"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ws@8.14.2_bufferutil@4.0.7";
exports.ids = ["vendor-chunks/ws@8.14.2_bufferutil@4.0.7"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/buffer-util.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/buffer-util.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */ function concat(list, totalLength) {\n    if (list.length === 0) return EMPTY_BUFFER;\n    if (list.length === 1) return list[0];\n    const target = Buffer.allocUnsafe(totalLength);\n    let offset = 0;\n    for(let i = 0; i < list.length; i++){\n        const buf = list[i];\n        target.set(buf, offset);\n        offset += buf.length;\n    }\n    if (offset < totalLength) {\n        return new FastBuffer(target.buffer, target.byteOffset, offset);\n    }\n    return target;\n}\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */ function _mask(source, mask, output, offset, length) {\n    for(let i = 0; i < length; i++){\n        output[offset + i] = source[i] ^ mask[i & 3];\n    }\n}\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */ function _unmask(buffer, mask) {\n    for(let i = 0; i < buffer.length; i++){\n        buffer[i] ^= mask[i & 3];\n    }\n}\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */ function toArrayBuffer(buf) {\n    if (buf.length === buf.buffer.byteLength) {\n        return buf.buffer;\n    }\n    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */ function toBuffer(data) {\n    toBuffer.readOnly = true;\n    if (Buffer.isBuffer(data)) return data;\n    let buf;\n    if (data instanceof ArrayBuffer) {\n        buf = new FastBuffer(data);\n    } else if (ArrayBuffer.isView(data)) {\n        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n    } else {\n        buf = Buffer.from(data);\n        toBuffer.readOnly = false;\n    }\n    return buf;\n}\nmodule.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n};\n/* istanbul ignore else  */ if (!process.env.WS_NO_BUFFER_UTIL) {\n    try {\n        const bufferUtil = __webpack_require__(/*! bufferutil */ \"(rsc)/../../node_modules/.pnpm/bufferutil@4.0.7/node_modules/bufferutil/index.js\");\n        module.exports.mask = function(source, mask, output, offset, length) {\n            if (length < 48) _mask(source, mask, output, offset, length);\n            else bufferUtil.mask(source, mask, output, offset, length);\n        };\n        module.exports.unmask = function(buffer, mask) {\n            if (buffer.length < 32) _unmask(buffer, mask);\n            else bufferUtil.unmask(buffer, mask);\n        };\n    } catch (e) {\n    // Continue regardless of the error.\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvYnVmZmVyLXV0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFlBQVksRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUVqQyxNQUFNQyxhQUFhQyxNQUFNLENBQUNDLE9BQU9DLE9BQU8sQ0FBQztBQUV6Qzs7Ozs7OztDQU9DLEdBQ0QsU0FBU0MsT0FBT0MsSUFBSSxFQUFFQyxXQUFXO0lBQy9CLElBQUlELEtBQUtFLE1BQU0sS0FBSyxHQUFHLE9BQU9UO0lBQzlCLElBQUlPLEtBQUtFLE1BQU0sS0FBSyxHQUFHLE9BQU9GLElBQUksQ0FBQyxFQUFFO0lBRXJDLE1BQU1HLFNBQVNQLE9BQU9RLFdBQVcsQ0FBQ0g7SUFDbEMsSUFBSUksU0FBUztJQUViLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixLQUFLRSxNQUFNLEVBQUVJLElBQUs7UUFDcEMsTUFBTUMsTUFBTVAsSUFBSSxDQUFDTSxFQUFFO1FBQ25CSCxPQUFPSyxHQUFHLENBQUNELEtBQUtGO1FBQ2hCQSxVQUFVRSxJQUFJTCxNQUFNO0lBQ3RCO0lBRUEsSUFBSUcsU0FBU0osYUFBYTtRQUN4QixPQUFPLElBQUlOLFdBQVdRLE9BQU9NLE1BQU0sRUFBRU4sT0FBT08sVUFBVSxFQUFFTDtJQUMxRDtJQUVBLE9BQU9GO0FBQ1Q7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTUSxNQUFNQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFVCxNQUFNLEVBQUVILE1BQU07SUFDakQsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlKLFFBQVFJLElBQUs7UUFDL0JRLE1BQU0sQ0FBQ1QsU0FBU0MsRUFBRSxHQUFHTSxNQUFNLENBQUNOLEVBQUUsR0FBR08sSUFBSSxDQUFDUCxJQUFJLEVBQUU7SUFDOUM7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNTLFFBQVFOLE1BQU0sRUFBRUksSUFBSTtJQUMzQixJQUFLLElBQUlQLElBQUksR0FBR0EsSUFBSUcsT0FBT1AsTUFBTSxFQUFFSSxJQUFLO1FBQ3RDRyxNQUFNLENBQUNILEVBQUUsSUFBSU8sSUFBSSxDQUFDUCxJQUFJLEVBQUU7SUFDMUI7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNVLGNBQWNULEdBQUc7SUFDeEIsSUFBSUEsSUFBSUwsTUFBTSxLQUFLSyxJQUFJRSxNQUFNLENBQUNRLFVBQVUsRUFBRTtRQUN4QyxPQUFPVixJQUFJRSxNQUFNO0lBQ25CO0lBRUEsT0FBT0YsSUFBSUUsTUFBTSxDQUFDUyxLQUFLLENBQUNYLElBQUlHLFVBQVUsRUFBRUgsSUFBSUcsVUFBVSxHQUFHSCxJQUFJTCxNQUFNO0FBQ3JFO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNpQixTQUFTQyxJQUFJO0lBQ3BCRCxTQUFTRSxRQUFRLEdBQUc7SUFFcEIsSUFBSXpCLE9BQU8wQixRQUFRLENBQUNGLE9BQU8sT0FBT0E7SUFFbEMsSUFBSWI7SUFFSixJQUFJYSxnQkFBZ0JHLGFBQWE7UUFDL0JoQixNQUFNLElBQUlaLFdBQVd5QjtJQUN2QixPQUFPLElBQUlHLFlBQVlDLE1BQU0sQ0FBQ0osT0FBTztRQUNuQ2IsTUFBTSxJQUFJWixXQUFXeUIsS0FBS1gsTUFBTSxFQUFFVyxLQUFLVixVQUFVLEVBQUVVLEtBQUtILFVBQVU7SUFDcEUsT0FBTztRQUNMVixNQUFNWCxPQUFPNkIsSUFBSSxDQUFDTDtRQUNsQkQsU0FBU0UsUUFBUSxHQUFHO0lBQ3RCO0lBRUEsT0FBT2Q7QUFDVDtBQUVBbUIsT0FBT0MsT0FBTyxHQUFHO0lBQ2Y1QjtJQUNBYyxNQUFNRjtJQUNOSztJQUNBRztJQUNBUyxRQUFRYjtBQUNWO0FBRUEseUJBQXlCLEdBQ3pCLElBQUksQ0FBQ2MsUUFBUUMsR0FBRyxDQUFDQyxpQkFBaUIsRUFBRTtJQUNsQyxJQUFJO1FBQ0YsTUFBTUMsYUFBYXRDLG1CQUFPQSxDQUFDO1FBRTNCZ0MsbUJBQW1CLEdBQUcsU0FBVWQsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRVQsTUFBTSxFQUFFSCxNQUFNO1lBQ2xFLElBQUlBLFNBQVMsSUFBSVMsTUFBTUMsUUFBUUMsTUFBTUMsUUFBUVQsUUFBUUg7aUJBQ2hEOEIsV0FBV25CLElBQUksQ0FBQ0QsUUFBUUMsTUFBTUMsUUFBUVQsUUFBUUg7UUFDckQ7UUFFQXdCLHFCQUFxQixHQUFHLFNBQVVqQixNQUFNLEVBQUVJLElBQUk7WUFDNUMsSUFBSUosT0FBT1AsTUFBTSxHQUFHLElBQUlhLFFBQVFOLFFBQVFJO2lCQUNuQ21CLFdBQVdKLE1BQU0sQ0FBQ25CLFFBQVFJO1FBQ2pDO0lBQ0YsRUFBRSxPQUFPb0IsR0FBRztJQUNWLG9DQUFvQztJQUN0QztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd3NAOC4xNC4yX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcz8zOGY2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcih0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgb2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSByZXR1cm4gZGF0YTtcblxuICBsZXQgYnVmO1xuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uY2F0LFxuICBtYXNrOiBfbWFzayxcbiAgdG9BcnJheUJ1ZmZlcixcbiAgdG9CdWZmZXIsXG4gIHVubWFzazogX3VubWFza1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG5pZiAoIXByb2Nlc3MuZW52LldTX05PX0JVRkZFUl9VVElMKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJ2J1ZmZlcnV0aWwnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLm1hc2sgPSBmdW5jdGlvbiAoc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cy51bm1hc2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGVycm9yLlxuICB9XG59XG4iXSwibmFtZXMiOlsiRU1QVFlfQlVGRkVSIiwicmVxdWlyZSIsIkZhc3RCdWZmZXIiLCJCdWZmZXIiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uY2F0IiwibGlzdCIsInRvdGFsTGVuZ3RoIiwibGVuZ3RoIiwidGFyZ2V0IiwiYWxsb2NVbnNhZmUiLCJvZmZzZXQiLCJpIiwiYnVmIiwic2V0IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsIl9tYXNrIiwic291cmNlIiwibWFzayIsIm91dHB1dCIsIl91bm1hc2siLCJ0b0FycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsInNsaWNlIiwidG9CdWZmZXIiLCJkYXRhIiwicmVhZE9ubHkiLCJpc0J1ZmZlciIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiZnJvbSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ1bm1hc2siLCJwcm9jZXNzIiwiZW52IiwiV1NfTk9fQlVGRkVSX1VUSUwiLCJidWZmZXJVdGlsIiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/constants.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/constants.js ***!
  \********************************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    BINARY_TYPES: [\n        \"nodebuffer\",\n        \"arraybuffer\",\n        \"fragments\"\n    ],\n    EMPTY_BUFFER: Buffer.alloc(0),\n    GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n    kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\n    kListener: Symbol(\"kListener\"),\n    kStatusCode: Symbol(\"status-code\"),\n    kWebSocket: Symbol(\"websocket\"),\n    NOOP: ()=>{}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxjQUFjO1FBQUM7UUFBYztRQUFlO0tBQVk7SUFDeERDLGNBQWNDLE9BQU9DLEtBQUssQ0FBQztJQUMzQkMsTUFBTTtJQUNOQyxzQkFBc0JDLE9BQU87SUFDN0JDLFdBQVdELE9BQU87SUFDbEJFLGFBQWFGLE9BQU87SUFDcEJHLFlBQVlILE9BQU87SUFDbkJJLE1BQU0sS0FBTztBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd3NAOC4xNC4yX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanM/Yzg2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVM6IFsnbm9kZWJ1ZmZlcicsICdhcnJheWJ1ZmZlcicsICdmcmFnbWVudHMnXSxcbiAgRU1QVFlfQlVGRkVSOiBCdWZmZXIuYWxsb2MoMCksXG4gIEdVSUQ6ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnLFxuICBrRm9yT25FdmVudEF0dHJpYnV0ZTogU3ltYm9sKCdrSXNGb3JPbkV2ZW50QXR0cmlidXRlJyksXG4gIGtMaXN0ZW5lcjogU3ltYm9sKCdrTGlzdGVuZXInKSxcbiAga1N0YXR1c0NvZGU6IFN5bWJvbCgnc3RhdHVzLWNvZGUnKSxcbiAga1dlYlNvY2tldDogU3ltYm9sKCd3ZWJzb2NrZXQnKSxcbiAgTk9PUDogKCkgPT4ge31cbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkJJTkFSWV9UWVBFUyIsIkVNUFRZX0JVRkZFUiIsIkJ1ZmZlciIsImFsbG9jIiwiR1VJRCIsImtGb3JPbkV2ZW50QXR0cmlidXRlIiwiU3ltYm9sIiwia0xpc3RlbmVyIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiTk9PUCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/event-target.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/event-target.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/constants.js\");\nconst kCode = Symbol(\"kCode\");\nconst kData = Symbol(\"kData\");\nconst kError = Symbol(\"kError\");\nconst kMessage = Symbol(\"kMessage\");\nconst kReason = Symbol(\"kReason\");\nconst kTarget = Symbol(\"kTarget\");\nconst kType = Symbol(\"kType\");\nconst kWasClean = Symbol(\"kWasClean\");\n/**\n * Class representing an event.\n */ class Event {\n    /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */ constructor(type){\n        this[kTarget] = null;\n        this[kType] = type;\n    }\n    /**\n   * @type {*}\n   */ get target() {\n        return this[kTarget];\n    }\n    /**\n   * @type {String}\n   */ get type() {\n        return this[kType];\n    }\n}\nObject.defineProperty(Event.prototype, \"target\", {\n    enumerable: true\n});\nObject.defineProperty(Event.prototype, \"type\", {\n    enumerable: true\n});\n/**\n * Class representing a close event.\n *\n * @extends Event\n */ class CloseEvent extends Event {\n    /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */ constructor(type, options = {}){\n        super(type);\n        this[kCode] = options.code === undefined ? 0 : options.code;\n        this[kReason] = options.reason === undefined ? \"\" : options.reason;\n        this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n    }\n    /**\n   * @type {Number}\n   */ get code() {\n        return this[kCode];\n    }\n    /**\n   * @type {String}\n   */ get reason() {\n        return this[kReason];\n    }\n    /**\n   * @type {Boolean}\n   */ get wasClean() {\n        return this[kWasClean];\n    }\n}\nObject.defineProperty(CloseEvent.prototype, \"code\", {\n    enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"reason\", {\n    enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"wasClean\", {\n    enumerable: true\n});\n/**\n * Class representing an error event.\n *\n * @extends Event\n */ class ErrorEvent extends Event {\n    /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */ constructor(type, options = {}){\n        super(type);\n        this[kError] = options.error === undefined ? null : options.error;\n        this[kMessage] = options.message === undefined ? \"\" : options.message;\n    }\n    /**\n   * @type {*}\n   */ get error() {\n        return this[kError];\n    }\n    /**\n   * @type {String}\n   */ get message() {\n        return this[kMessage];\n    }\n}\nObject.defineProperty(ErrorEvent.prototype, \"error\", {\n    enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, \"message\", {\n    enumerable: true\n});\n/**\n * Class representing a message event.\n *\n * @extends Event\n */ class MessageEvent extends Event {\n    /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */ constructor(type, options = {}){\n        super(type);\n        this[kData] = options.data === undefined ? null : options.data;\n    }\n    /**\n   * @type {*}\n   */ get data() {\n        return this[kData];\n    }\n}\nObject.defineProperty(MessageEvent.prototype, \"data\", {\n    enumerable: true\n});\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */ const EventTarget = {\n    /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */ addEventListener (type, handler, options = {}) {\n        for (const listener of this.listeners(type)){\n            if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n                return;\n            }\n        }\n        let wrapper;\n        if (type === \"message\") {\n            wrapper = function onMessage(data, isBinary) {\n                const event = new MessageEvent(\"message\", {\n                    data: isBinary ? data : data.toString()\n                });\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else if (type === \"close\") {\n            wrapper = function onClose(code, message) {\n                const event = new CloseEvent(\"close\", {\n                    code,\n                    reason: message.toString(),\n                    wasClean: this._closeFrameReceived && this._closeFrameSent\n                });\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else if (type === \"error\") {\n            wrapper = function onError(error) {\n                const event = new ErrorEvent(\"error\", {\n                    error,\n                    message: error.message\n                });\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else if (type === \"open\") {\n            wrapper = function onOpen() {\n                const event = new Event(\"open\");\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else {\n            return;\n        }\n        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n        wrapper[kListener] = handler;\n        if (options.once) {\n            this.once(type, wrapper);\n        } else {\n            this.on(type, wrapper);\n        }\n    },\n    /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */ removeEventListener (type, handler) {\n        for (const listener of this.listeners(type)){\n            if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n                this.removeListener(type, listener);\n                break;\n            }\n        }\n    }\n};\nmodule.exports = {\n    CloseEvent,\n    ErrorEvent,\n    Event,\n    EventTarget,\n    MessageEvent\n};\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */ function callListener(listener, thisArg, event) {\n    if (typeof listener === \"object\" && listener.handleEvent) {\n        listener.handleEvent.call(listener, event);\n    } else {\n        listener.call(thisArg, event);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxvQkFBb0IsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRXBELE1BQU1DLFFBQVFDLE9BQU87QUFDckIsTUFBTUMsUUFBUUQsT0FBTztBQUNyQixNQUFNRSxTQUFTRixPQUFPO0FBQ3RCLE1BQU1HLFdBQVdILE9BQU87QUFDeEIsTUFBTUksVUFBVUosT0FBTztBQUN2QixNQUFNSyxVQUFVTCxPQUFPO0FBQ3ZCLE1BQU1NLFFBQVFOLE9BQU87QUFDckIsTUFBTU8sWUFBWVAsT0FBTztBQUV6Qjs7Q0FFQyxHQUNELE1BQU1RO0lBQ0o7Ozs7O0dBS0MsR0FDREMsWUFBWUMsSUFBSSxDQUFFO1FBQ2hCLElBQUksQ0FBQ0wsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHSTtJQUNoQjtJQUVBOztHQUVDLEdBQ0QsSUFBSUMsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDTixRQUFRO0lBQ3RCO0lBRUE7O0dBRUMsR0FDRCxJQUFJSyxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUNKLE1BQU07SUFDcEI7QUFDRjtBQUVBTSxPQUFPQyxjQUFjLENBQUNMLE1BQU1NLFNBQVMsRUFBRSxVQUFVO0lBQUVDLFlBQVk7QUFBSztBQUNwRUgsT0FBT0MsY0FBYyxDQUFDTCxNQUFNTSxTQUFTLEVBQUUsUUFBUTtJQUFFQyxZQUFZO0FBQUs7QUFFbEU7Ozs7Q0FJQyxHQUNELE1BQU1DLG1CQUFtQlI7SUFDdkI7Ozs7Ozs7Ozs7OztHQVlDLEdBQ0RDLFlBQVlDLElBQUksRUFBRU8sVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUM5QixLQUFLLENBQUNQO1FBRU4sSUFBSSxDQUFDWCxNQUFNLEdBQUdrQixRQUFRQyxJQUFJLEtBQUtDLFlB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TUMsR0FDRGEscUJBQW9CbkMsSUFBSSxFQUFFbUIsT0FBTztRQUMvQixLQUFLLE1BQU1DLFlBQVksSUFBSSxDQUFDQyxTQUFTLENBQUNyQixNQUFPO1lBQzNDLElBQUlvQixRQUFRLENBQUNqQyxVQUFVLEtBQUtnQyxXQUFXLENBQUNDLFFBQVEsQ0FBQ2xDLHFCQUFxQixFQUFFO2dCQUN0RSxJQUFJLENBQUNrRCxjQUFjLENBQUNwQyxNQUFNb0I7Z0JBQzFCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQWlCLE9BQU9DLE9BQU8sR0FBRztJQUNmaEM7SUFDQU07SUFDQWQ7SUFDQW1CO0lBQ0FGO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1ksYUFBYVAsUUFBUSxFQUFFbUIsT0FBTyxFQUFFZCxLQUFLO0lBQzVDLElBQUksT0FBT0wsYUFBYSxZQUFZQSxTQUFTb0IsV0FBVyxFQUFFO1FBQ3hEcEIsU0FBU29CLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDckIsVUFBVUs7SUFDdEMsT0FBTztRQUNMTCxTQUFTcUIsSUFBSSxDQUFDRixTQUFTZDtJQUN6QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd3NAOC4xNC4yX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanM/YTY5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsga0Zvck9uRXZlbnRBdHRyaWJ1dGUsIGtMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga0NvZGUgPSBTeW1ib2woJ2tDb2RlJyk7XG5jb25zdCBrRGF0YSA9IFN5bWJvbCgna0RhdGEnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgna0Vycm9yJyk7XG5jb25zdCBrTWVzc2FnZSA9IFN5bWJvbCgna01lc3NhZ2UnKTtcbmNvbnN0IGtSZWFzb24gPSBTeW1ib2woJ2tSZWFzb24nKTtcbmNvbnN0IGtUYXJnZXQgPSBTeW1ib2woJ2tUYXJnZXQnKTtcbmNvbnN0IGtUeXBlID0gU3ltYm9sKCdrVHlwZScpO1xuY29uc3Qga1dhc0NsZWFuID0gU3ltYm9sKCdrV2FzQ2xlYW4nKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICB0aGlzW2tUYXJnZXRdID0gbnVsbDtcbiAgICB0aGlzW2tUeXBlXSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2tUYXJnZXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3RhcmdldCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0eXBlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2RlPTBdIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxuICAgKiAgICAgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndhc0NsZWFuPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tDb2RlXSA9IG9wdGlvbnMuY29kZSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuY29kZTtcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5yZWFzb247XG4gICAgdGhpc1trV2FzQ2xlYW5dID0gb3B0aW9ucy53YXNDbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLndhc0NsZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29kZV07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgd2FzQ2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXNba1dhc0NsZWFuXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdjb2RlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAncmVhc29uJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnd2FzQ2xlYW4nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2U9JyddIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0Vycm9yXSA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmVycm9yO1xuICAgIHRoaXNba01lc3NhZ2VdID0gb3B0aW9ucy5tZXNzYWdlID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMubWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpc1trRXJyb3JdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnZXJyb3InLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdtZXNzYWdlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZGF0YT1udWxsXSBUaGUgbWVzc2FnZSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXNba0RhdGFdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlRXZlbnQucHJvdG90eXBlLCAnZGF0YScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdICYmXG4gICAgICAgIGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiZcbiAgICAgICAgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScsIHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHJlYXNvbjogbWVzc2FnZS50b1N0cmluZygpLFxuICAgICAgICAgIHdhc0NsZWFuOiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGhpcy5fY2xvc2VGcmFtZVNlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3JhcHBlcltrRm9yT25FdmVudEF0dHJpYnV0ZV0gPSAhIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdO1xuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGhhbmRsZXI7XG5cbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnQsXG4gIEV2ZW50LFxuICBFdmVudFRhcmdldCxcbiAgTWVzc2FnZUV2ZW50XG59O1xuXG4vKipcbiAqIENhbGwgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbFxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgYCB3aGVuIGNhbGxpbmcgdGhlIGxpc3RlbmVyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc0FyZywgZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCcgJiYgbGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcbiAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKGxpc3RlbmVyLCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJnLCBldmVudCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJrRm9yT25FdmVudEF0dHJpYnV0ZSIsImtMaXN0ZW5lciIsInJlcXVpcmUiLCJrQ29kZSIsIlN5bWJvbCIsImtEYXRhIiwia0Vycm9yIiwia01lc3NhZ2UiLCJrUmVhc29uIiwia1RhcmdldCIsImtUeXBlIiwia1dhc0NsZWFuIiwiRXZlbnQiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJ0YXJnZXQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsImVudW1lcmFibGUiLCJDbG9zZUV2ZW50Iiwib3B0aW9ucyIsImNvZGUiLCJ1bmRlZmluZWQiLCJyZWFzb24iLCJ3YXNDbGVhbiIsIkVycm9yRXZlbnQiLCJlcnJvciIsIm1lc3NhZ2UiLCJNZXNzYWdlRXZlbnQiLCJkYXRhIiwiRXZlbnRUYXJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlciIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwid3JhcHBlciIsIm9uTWVzc2FnZSIsImlzQmluYXJ5IiwiZXZlbnQiLCJ0b1N0cmluZyIsImNhbGxMaXN0ZW5lciIsIm9uQ2xvc2UiLCJfY2xvc2VGcmFtZVJlY2VpdmVkIiwiX2Nsb3NlRnJhbWVTZW50Iiwib25FcnJvciIsIm9uT3BlbiIsIm9uY2UiLCJvbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0aGlzQXJnIiwiaGFuZGxlRXZlbnQiLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/extension.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/extension.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/validation.js\");\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */ function push(dest, name, elem) {\n    if (dest[name] === undefined) dest[name] = [\n        elem\n    ];\n    else dest[name].push(elem);\n}\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */ function parse(header) {\n    const offers = Object.create(null);\n    let params = Object.create(null);\n    let mustUnescape = false;\n    let isEscaping = false;\n    let inQuotes = false;\n    let extensionName;\n    let paramName;\n    let start = -1;\n    let code = -1;\n    let end = -1;\n    let i = 0;\n    for(; i < header.length; i++){\n        code = header.charCodeAt(i);\n        if (extensionName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b /* ';' */  || code === 0x2c /* ',' */ ) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                const name = header.slice(start, end);\n                if (code === 0x2c) {\n                    push(offers, name, params);\n                    params = Object.create(null);\n                } else {\n                    extensionName = name;\n                }\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        } else if (paramName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (code === 0x20 || code === 0x09) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                push(params, header.slice(start, end), true);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = Object.create(null);\n                    extensionName = undefined;\n                }\n                start = end = -1;\n            } else if (code === 0x3d /* '=' */  && start !== -1 && end === -1) {\n                paramName = header.slice(start, i);\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        } else {\n            //\n            // The value of a quoted-string after unescaping must conform to the\n            // token ABNF, so only token characters are valid.\n            // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n            //\n            if (isEscaping) {\n                if (tokenChars[code] !== 1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (start === -1) start = i;\n                else if (!mustUnescape) mustUnescape = true;\n                isEscaping = false;\n            } else if (inQuotes) {\n                if (tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (code === 0x22 /* '\"' */  && start !== -1) {\n                    inQuotes = false;\n                    end = i;\n                } else if (code === 0x5c /* '\\' */ ) {\n                    isEscaping = true;\n                } else {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n            } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n                inQuotes = true;\n            } else if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n                if (end === -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                let value = header.slice(start, end);\n                if (mustUnescape) {\n                    value = value.replace(/\\\\/g, \"\");\n                    mustUnescape = false;\n                }\n                push(params, paramName, value);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = Object.create(null);\n                    extensionName = undefined;\n                }\n                paramName = undefined;\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        }\n    }\n    if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    if (end === -1) end = i;\n    const token = header.slice(start, end);\n    if (extensionName === undefined) {\n        push(offers, token, params);\n    } else {\n        if (paramName === undefined) {\n            push(params, token, true);\n        } else if (mustUnescape) {\n            push(params, paramName, token.replace(/\\\\/g, \"\"));\n        } else {\n            push(params, paramName, token);\n        }\n        push(offers, extensionName, params);\n    }\n    return offers;\n}\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */ function format(extensions) {\n    return Object.keys(extensions).map((extension)=>{\n        let configurations = extensions[extension];\n        if (!Array.isArray(configurations)) configurations = [\n            configurations\n        ];\n        return configurations.map((params)=>{\n            return [\n                extension\n            ].concat(Object.keys(params).map((k)=>{\n                let values = params[k];\n                if (!Array.isArray(values)) values = [\n                    values\n                ];\n                return values.map((v)=>v === true ? k : `${k}=${v}`).join(\"; \");\n            })).join(\"; \");\n        }).join(\", \");\n    }).join(\", \");\n}\nmodule.exports = {\n    format,\n    parse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxVQUFVLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFL0I7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0MsS0FBS0MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFDNUIsSUFBSUYsSUFBSSxDQUFDQyxLQUFLLEtBQUtFLFdBQVdILElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQUNDO0tBQUs7U0FDNUNGLElBQUksQ0FBQ0MsS0FBSyxDQUFDRixJQUFJLENBQUNHO0FBQ3ZCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0UsTUFBTUMsTUFBTTtJQUNuQixNQUFNQyxTQUFTQyxPQUFPQyxNQUFNLENBQUM7SUFDN0IsSUFBSUMsU0FBU0YsT0FBT0MsTUFBTSxDQUFDO0lBQzNCLElBQUlFLGVBQWU7SUFDbkIsSUFBSUMsYUFBYTtJQUNqQixJQUFJQyxXQUFXO0lBQ2YsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDLFFBQVEsQ0FBQztJQUNiLElBQUlDLE9BQU8sQ0FBQztJQUNaLElBQUlDLE1BQU0sQ0FBQztJQUNYLElBQUlDLElBQUk7SUFFUixNQUFPQSxJQUFJYixPQUFPYyxNQUFNLEVBQUVELElBQUs7UUFDN0JGLE9BQU9YLE9BQU9lLFVBQVUsQ0FBQ0Y7UUFFekIsSUFBSUwsa0JBQWtCVixXQUFXO1lBQy9CLElBQUljLFFBQVEsQ0FBQyxLQUFLcEIsVUFBVSxDQUFDbUIsS0FBSyxLQUFLLEdBQUc7Z0JBQ3hDLElBQUlELFVBQVUsQ0FBQyxHQUFHQSxRQUFRRztZQUM1QixPQUFPLElBQ0xBLE1BQU0sS0FDTEYsQ0FBQUEsU0FBUyxLQUFLLE9BQU8sT0FBTUEsU0FBUyxJQUFHLEdBQ3hDO2dCQUNBLElBQUlDLFFBQVEsQ0FBQyxLQUFLRixVQUFV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ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzP2I5MDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIEFkZHMgYW4gb2ZmZXIgdG8gdGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIGEgcGFyYW1ldGVyIHRvIHRoZSBtYXAgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3QgVGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBleHRlbnNpb24gb3IgcGFyYW1ldGVyIG5hbWVcbiAqIEBwYXJhbSB7KE9iamVjdHxCb29sZWFufFN0cmluZyl9IGVsZW0gVGhlIGV4dGVuc2lvbiBwYXJhbWV0ZXJzIG9yIHRoZVxuICogICAgIHBhcmFtZXRlciB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVzaChkZXN0LCBuYW1lLCBlbGVtKSB7XG4gIGlmIChkZXN0W25hbWVdID09PSB1bmRlZmluZWQpIGRlc3RbbmFtZV0gPSBbZWxlbV07XG4gIGVsc2UgZGVzdFtuYW1lXS5wdXNoKGVsZW0pO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHBhcnNlZCBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IG9mZmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gIGxldCBpc0VzY2FwaW5nID0gZmFsc2U7XG4gIGxldCBpblF1b3RlcyA9IGZhbHNlO1xuICBsZXQgZXh0ZW5zaW9uTmFtZTtcbiAgbGV0IHBhcmFtTmFtZTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBjb2RlID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpICE9PSAwICYmXG4gICAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICAgKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiAvKiAnOycgKi8gfHwgY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBwdXNoKHBhcmFtcywgaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdmFsdWUgb2YgYSBxdW90ZWQtc3RyaW5nIGFmdGVyIHVuZXNjYXBpbmcgbXVzdCBjb25mb3JtIHRvIHRoZVxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICAgIC8vXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZSBpZiAoIW11c3RVbmVzY2FwZSkgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyIC8qICdcIicgKi8gJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NWMgLyogJ1xcJyAqLykge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgIT09IC0xICYmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgaW5RdW90ZXMgfHwgY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gIGNvbnN0IHRva2VuID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcHVzaChvZmZlcnMsIHRva2VuLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG9mZmVycztcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBmaWVsZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChleHRlbnNpb25zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhleHRlbnNpb25zKVxuICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgbGV0IGNvbmZpZ3VyYXRpb25zID0gZXh0ZW5zaW9uc1tleHRlbnNpb25dO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3VyYXRpb25zKSkgY29uZmlndXJhdGlvbnMgPSBbY29uZmlndXJhdGlvbnNdO1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIC5tYXAoKHBhcmFtcykgPT4ge1xuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXVxuICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gcGFyYW1zW2tdO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiAodiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkpXG4gICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICB9KVxuICAgIC5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZm9ybWF0LCBwYXJzZSB9O1xuIl0sIm5hbWVzIjpbInRva2VuQ2hhcnMiLCJyZXF1aXJlIiwicHVzaCIsImRlc3QiLCJuYW1lIiwiZWxlbSIsInVuZGVmaW5lZCIsInBhcnNlIiwiaGVhZGVyIiwib2ZmZXJzIiwiT2JqZWN0IiwiY3JlYXRlIiwicGFyYW1zIiwibXVzdFVuZXNjYXBlIiwiaXNFc2NhcGluZyIsImluUXVvdGVzIiwiZXh0ZW5zaW9uTmFtZSIsInBhcmFtTmFtZSIsInN0YXJ0IiwiY29kZSIsImVuZCIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiU3ludGF4RXJyb3IiLCJzbGljZSIsInZhbHVlIiwicmVwbGFjZSIsInRva2VuIiwiZm9ybWF0IiwiZXh0ZW5zaW9ucyIsImtleXMiLCJtYXAiLCJleHRlbnNpb24iLCJjb25maWd1cmF0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImNvbmNhdCIsImsiLCJ2YWx1ZXMiLCJ2Iiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/limiter.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/limiter.js ***!
  \******************************************************************************************/
/***/ ((module) => {

eval("\nconst kDone = Symbol(\"kDone\");\nconst kRun = Symbol(\"kRun\");\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */ class Limiter {\n    /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */ constructor(concurrency){\n        this[kDone] = ()=>{\n            this.pending--;\n            this[kRun]();\n        };\n        this.concurrency = concurrency || Infinity;\n        this.jobs = [];\n        this.pending = 0;\n    }\n    /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */ add(job) {\n        this.jobs.push(job);\n        this[kRun]();\n    }\n    /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */ [kRun]() {\n        if (this.pending === this.concurrency) return;\n        if (this.jobs.length) {\n            const job = this.jobs.shift();\n            this.pending++;\n            job(this[kDone]);\n        }\n    }\n}\nmodule.exports = Limiter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFFBQVFDLE9BQU87QUFDckIsTUFBTUMsT0FBT0QsT0FBTztBQUVwQjs7O0NBR0MsR0FDRCxNQUFNRTtJQUNKOzs7OztHQUtDLEdBQ0RDLFlBQVlDLFdBQVcsQ0FBRTtRQUN2QixJQUFJLENBQUNMLE1BQU0sR0FBRztZQUNaLElBQUksQ0FBQ00sT0FBTztZQUNaLElBQUksQ0FBQ0osS0FBSztRQUNaO1FBQ0EsSUFBSSxDQUFDRyxXQUFXLEdBQUdBLGVBQWVFO1FBQ2xDLElBQUksQ0FBQ0MsSUFBSSxHQUFHLEVBQUU7UUFDZCxJQUFJLENBQUNGLE9BQU8sR0FBRztJQUNqQjtJQUVBOzs7OztHQUtDLEdBQ0RHLElBQUlDLEdBQUcsRUFBRTtRQUNQLElBQUksQ0FBQ0YsSUFBSSxDQUFDRyxJQUFJLENBQUNEO1FBQ2YsSUFBSSxDQUFDUixLQUFLO0lBQ1o7SUFFQTs7OztHQUlDLEdBQ0QsQ0FBQ0EsS0FBSyxHQUFHO1FBQ1AsSUFBSSxJQUFJLENBQUNJLE9BQU8sS0FBSyxJQUFJLENBQUNELFdBQVcsRUFBRTtRQUV2QyxJQUFJLElBQUksQ0FBQ0csSUFBSSxDQUFDSSxNQUFNLEVBQUU7WUFDcEIsTUFBTUYsTUFBTSxJQUFJLENBQUNGLElBQUksQ0FBQ0ssS0FBSztZQUUzQixJQUFJLENBQUNQLE9BQU87WUFDWkksSUFBSSxJQUFJLENBQUNWLE1BQU07UUFDakI7SUFDRjtBQUNGO0FBRUFjLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93c0A4LjE0LjJfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanM/YTA0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xuXG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvYXN5bmMtbGltaXRlclxuICovXG5jbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygam9icyBhbGxvd2VkXG4gICAqICAgICB0byBydW4gY29uY3VycmVudGx5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeSkge1xuICAgIHRoaXNba0RvbmVdID0gKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nLS07XG4gICAgICB0aGlzW2tSdW5dKCk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XG4gICAgdGhpcy5qb2JzID0gW107XG4gICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgam9iIHRvIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gam9iIFRoZSBqb2IgdG8gcnVuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIHRoaXNba1J1bl0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcblxuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XG4iXSwibmFtZXMiOlsia0RvbmUiLCJTeW1ib2wiLCJrUnVuIiwiTGltaXRlciIsImNvbnN0cnVjdG9yIiwiY29uY3VycmVuY3kiLCJwZW5kaW5nIiwiSW5maW5pdHkiLCJqb2JzIiwiYWRkIiwiam9iIiwicHVzaCIsImxlbmd0aCIsInNoaWZ0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/permessage-deflate.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/permessage-deflate.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([\n    0x00,\n    0x00,\n    0xff,\n    0xff\n]);\nconst kPerMessageDeflate = Symbol(\"permessage-deflate\");\nconst kTotalLength = Symbol(\"total-length\");\nconst kCallback = Symbol(\"callback\");\nconst kBuffers = Symbol(\"buffers\");\nconst kError = Symbol(\"error\");\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n/**\n * permessage-deflate implementation.\n */ class PerMessageDeflate {\n    /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */ constructor(options, isServer, maxPayload){\n        this._maxPayload = maxPayload | 0;\n        this._options = options || {};\n        this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n        this._isServer = !!isServer;\n        this._deflate = null;\n        this._inflate = null;\n        this.params = null;\n        if (!zlibLimiter) {\n            const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n            zlibLimiter = new Limiter(concurrency);\n        }\n    }\n    /**\n   * @type {String}\n   */ static get extensionName() {\n        return \"permessage-deflate\";\n    }\n    /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */ offer() {\n        const params = {};\n        if (this._options.serverNoContextTakeover) {\n            params.server_no_context_takeover = true;\n        }\n        if (this._options.clientNoContextTakeover) {\n            params.client_no_context_takeover = true;\n        }\n        if (this._options.serverMaxWindowBits) {\n            params.server_max_window_bits = this._options.serverMaxWindowBits;\n        }\n        if (this._options.clientMaxWindowBits) {\n            params.client_max_window_bits = this._options.clientMaxWindowBits;\n        } else if (this._options.clientMaxWindowBits == null) {\n            params.client_max_window_bits = true;\n        }\n        return params;\n    }\n    /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */ accept(configurations) {\n        configurations = this.normalizeParams(configurations);\n        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n        return this.params;\n    }\n    /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */ cleanup() {\n        if (this._inflate) {\n            this._inflate.close();\n            this._inflate = null;\n        }\n        if (this._deflate) {\n            const callback = this._deflate[kCallback];\n            this._deflate.close();\n            this._deflate = null;\n            if (callback) {\n                callback(new Error(\"The deflate stream was closed while data was being processed\"));\n            }\n        }\n    }\n    /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsServer(offers) {\n        const opts = this._options;\n        const accepted = offers.find((params)=>{\n            if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n                return false;\n            }\n            return true;\n        });\n        if (!accepted) {\n            throw new Error(\"None of the extension offers can be accepted\");\n        }\n        if (opts.serverNoContextTakeover) {\n            accepted.server_no_context_takeover = true;\n        }\n        if (opts.clientNoContextTakeover) {\n            accepted.client_no_context_takeover = true;\n        }\n        if (typeof opts.serverMaxWindowBits === \"number\") {\n            accepted.server_max_window_bits = opts.serverMaxWindowBits;\n        }\n        if (typeof opts.clientMaxWindowBits === \"number\") {\n            accepted.client_max_window_bits = opts.clientMaxWindowBits;\n        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n            delete accepted.client_max_window_bits;\n        }\n        return accepted;\n    }\n    /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsClient(response) {\n        const params = response[0];\n        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n            throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n        }\n        if (!params.client_max_window_bits) {\n            if (typeof this._options.clientMaxWindowBits === \"number\") {\n                params.client_max_window_bits = this._options.clientMaxWindowBits;\n            }\n        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n            throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n        }\n        return params;\n    }\n    /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */ normalizeParams(configurations) {\n        configurations.forEach((params)=>{\n            Object.keys(params).forEach((key)=>{\n                let value = params[key];\n                if (value.length > 1) {\n                    throw new Error(`Parameter \"${key}\" must have only a single value`);\n                }\n                value = value[0];\n                if (key === \"client_max_window_bits\") {\n                    if (value !== true) {\n                        const num = +value;\n                        if (!Number.isInteger(num) || num < 8 || num > 15) {\n                            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                        }\n                        value = num;\n                    } else if (!this._isServer) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                } else if (key === \"server_max_window_bits\") {\n                    const num = +value;\n                    if (!Number.isInteger(num) || num < 8 || num > 15) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                    value = num;\n                } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n                    if (value !== true) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                } else {\n                    throw new Error(`Unknown parameter \"${key}\"`);\n                }\n                params[key] = value;\n            });\n        });\n        return configurations;\n    }\n    /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ decompress(data, fin, callback) {\n        zlibLimiter.add((done)=>{\n            this._decompress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ compress(data, fin, callback) {\n        zlibLimiter.add((done)=>{\n            this._compress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _decompress(data, fin, callback) {\n        const endpoint = this._isServer ? \"client\" : \"server\";\n        if (!this._inflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._inflate = zlib.createInflateRaw({\n                ...this._options.zlibInflateOptions,\n                windowBits\n            });\n            this._inflate[kPerMessageDeflate] = this;\n            this._inflate[kTotalLength] = 0;\n            this._inflate[kBuffers] = [];\n            this._inflate.on(\"error\", inflateOnError);\n            this._inflate.on(\"data\", inflateOnData);\n        }\n        this._inflate[kCallback] = callback;\n        this._inflate.write(data);\n        if (fin) this._inflate.write(TRAILER);\n        this._inflate.flush(()=>{\n            const err = this._inflate[kError];\n            if (err) {\n                this._inflate.close();\n                this._inflate = null;\n                callback(err);\n                return;\n            }\n            const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n            if (this._inflate._readableState.endEmitted) {\n                this._inflate.close();\n                this._inflate = null;\n            } else {\n                this._inflate[kTotalLength] = 0;\n                this._inflate[kBuffers] = [];\n                if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                    this._inflate.reset();\n                }\n            }\n            callback(null, data);\n        });\n    }\n    /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _compress(data, fin, callback) {\n        const endpoint = this._isServer ? \"server\" : \"client\";\n        if (!this._deflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._deflate = zlib.createDeflateRaw({\n                ...this._options.zlibDeflateOptions,\n                windowBits\n            });\n            this._deflate[kTotalLength] = 0;\n            this._deflate[kBuffers] = [];\n            this._deflate.on(\"data\", deflateOnData);\n        }\n        this._deflate[kCallback] = callback;\n        this._deflate.write(data);\n        this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{\n            if (!this._deflate) {\n                //\n                // The deflate stream was closed while data was being processed.\n                //\n                return;\n            }\n            let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n            if (fin) {\n                data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n            }\n            //\n            // Ensure that the callback will not be called again in\n            // `PerMessageDeflate#cleanup()`.\n            //\n            this._deflate[kCallback] = null;\n            this._deflate[kTotalLength] = 0;\n            this._deflate[kBuffers] = [];\n            if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                this._deflate.reset();\n            }\n            callback(null, data);\n        });\n    }\n}\nmodule.exports = PerMessageDeflate;\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function deflateOnData(chunk) {\n    this[kBuffers].push(chunk);\n    this[kTotalLength] += chunk.length;\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function inflateOnData(chunk) {\n    this[kTotalLength] += chunk.length;\n    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n        this[kBuffers].push(chunk);\n        return;\n    }\n    this[kError] = new RangeError(\"Max payload size exceeded\");\n    this[kError].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n    this[kError][kStatusCode] = 1009;\n    this.removeListener(\"data\", inflateOnData);\n    this.reset();\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */ function inflateOnError(err) {\n    //\n    // There is no need to call `Zlib#close()` as the handle is automatically\n    // closed when an error is emitted.\n    //\n    this[kPerMessageDeflate]._inflate = null;\n    err[kStatusCode] = 1007;\n    this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvcGVybWVzc2FnZS1kZWZsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFFckIsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUM7QUFDM0IsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUM7QUFDeEIsTUFBTSxFQUFFRyxXQUFXLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFFaEMsTUFBTUksYUFBYUMsTUFBTSxDQUFDQyxPQUFPQyxPQUFPLENBQUM7QUFDekMsTUFBTUMsVUFBVUgsT0FBT0ksSUFBSSxDQUFDO0lBQUM7SUFBTTtJQUFNO0lBQU07Q0FBSztBQUNwRCxNQUFNQyxxQkFBcUJKLE9BQU87QUFDbEMsTUFBTUssZUFBZUwsT0FBTztBQUM1QixNQUFNTSxZQUFZTixPQUFPO0FBQ3pCLE1BQU1PLFdBQVdQLE9BQU87QUFDeEIsTUFBTVEsU0FBU1IsT0FBTztBQUV0QixFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHFGQUFxRjtBQUNyRixtREFBbUQ7QUFDbkQsRUFBRTtBQUNGLHFFQUFxRTtBQUNyRSxFQUFFO0FBQ0YsSUFBSVM7QUFFSjs7Q0FFQyxHQUNELE1BQU1DO0lBQ0o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUJDLEdBQ0RDLFlBQVlDLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxVQUFVLENBQUU7UUFDekMsSUFBSSxDQUFDQyxXQUFXLEdBQUdELGFBQWE7UUFDaEMsSUFBSSxDQUFDRSxRQUFRLEdBQUdKLFdBQVcsQ0FBQztRQUM1QixJQUFJLENBQUNLLFVBQVUsR0FDYixJQUFJLENBQUNELFFBQVEsQ0FBQ0UsU0FBUyxLQUFLQyxZQUFZLElBQUksQ0FBQ0gsUUFBUSxDQUFDRSxTQUFTLEdBQUc7UUFDcEUsSUFBSSxDQUFDRSxTQUFTLEdBQUcsQ0FBQyxDQUFDUDtRQUNuQixJ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LENBQUNSLFNBQVMsQ0FBQ3NGLElBQUksQ0FBQ0Q7UUFDcEI7SUFDRjtJQUVBLElBQUksQ0FBQ3BGLE9BQU8sR0FBRyxJQUFJc0YsV0FBVztJQUM5QixJQUFJLENBQUN0RixPQUFPLENBQUN1RixJQUFJLEdBQUc7SUFDcEIsSUFBSSxDQUFDdkYsT0FBTyxDQUFDWCxZQUFZLEdBQUc7SUFDNUIsSUFBSSxDQUFDbUcsY0FBYyxDQUFDLFFBQVFuQjtJQUM1QixJQUFJLENBQUNNLEtBQUs7QUFDWjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU1AsZUFBZVYsR0FBRztJQUN6QixFQUFFO0lBQ0YseUVBQXlFO0lBQ3pFLG1DQUFtQztJQUNuQyxFQUFFO0lBQ0YsSUFBSSxDQUFDOUQsbUJBQW1CLENBQUNrQixRQUFRLEdBQUc7SUFDcEM0QyxHQUFHLENBQUNyRSxZQUFZLEdBQUc7SUFDbkIsSUFBSSxDQUFDUyxVQUFVLENBQUM0RDtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvcGVybWVzc2FnZS1kZWZsYXRlLmpzPzU3OTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5jb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgTGltaXRlciA9IHJlcXVpcmUoJy4vbGltaXRlcicpO1xuY29uc3QgeyBrU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcbmNvbnN0IGtQZXJNZXNzYWdlRGVmbGF0ZSA9IFN5bWJvbCgncGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woJ2J1ZmZlcnMnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcblxuLy9cbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG4vL1xuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXG4vL1xubGV0IHpsaWJMaW1pdGVyO1xuXG4vKipcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHNdIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXG4gICAqICAgICBhY2tub3dsZWRnZSBkaXNhYmxpbmcgb2YgY2xpZW50IGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbmN1cnJlbmN5TGltaXQ9MTBdIFRoZSBudW1iZXIgb2YgY29uY3VycmVudFxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHNdIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcbiAgICogICAgIGRpc2FibGluZyBvZiBzZXJ2ZXIgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTEwMjRdIFNpemUgKGluIGJ5dGVzKSBiZWxvdyB3aGljaFxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGRlZmxhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGluZmxhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTZXJ2ZXI9ZmFsc2VdIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvclxuICAgKiAgICAgY2xpZW50IG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxuICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgZXh0ZW5zaW9uIG9mZmVycyBjYW4gYmUgYWNjZXB0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIG9yIGludmFsaWQgcGFyYW1ldGVyIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdlcnJvcicsIGluZmxhdGVPbkVycm9yKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcblxuICAgIHRoaXMuX2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5faW5mbGF0ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xuXG4gICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdkYXRhJywgZGVmbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikge1xuICAgICAgICBkYXRhID0gbmV3IEZhc3RCdWZmZXIoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5sZW5ndGggLSA0KTtcbiAgICAgIH1cblxuICAgICAgLy9cbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW4gaW5cbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlck1lc3NhZ2VEZWZsYXRlO1xuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuRGVmbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xuXG4gIGlmIChcbiAgICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8XG4gICAgdGhpc1trVG90YWxMZW5ndGhdIDw9IHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZFxuICApIHtcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzW2tFcnJvcl0gPSBuZXcgUmFuZ2VFcnJvcignTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcpO1xuICB0aGlzW2tFcnJvcl0uY29kZSA9ICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnO1xuICB0aGlzW2tFcnJvcl1ba1N0YXR1c0NvZGVdID0gMTAwOTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IoZXJyKSB7XG4gIC8vXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcbiAgLy8gY2xvc2VkIHdoZW4gYW4gZXJyb3IgaXMgZW1pdHRlZC5cbiAgLy9cbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IDEwMDc7XG4gIHRoaXNba0NhbGxiYWNrXShlcnIpO1xufVxuIl0sIm5hbWVzIjpbInpsaWIiLCJyZXF1aXJlIiwiYnVmZmVyVXRpbCIsIkxpbWl0ZXIiLCJrU3RhdHVzQ29kZSIsIkZhc3RCdWZmZXIiLCJCdWZmZXIiLCJTeW1ib2wiLCJzcGVjaWVzIiwiVFJBSUxFUiIsImZyb20iLCJrUGVyTWVzc2FnZURlZmxhdGUiLCJrVG90YWxMZW5ndGgiLCJrQ2FsbGJhY2siLCJrQnVmZmVycyIsImtFcnJvciIsInpsaWJMaW1pdGVyIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJpc1NlcnZlciIsIm1heFBheWxvYWQiLCJfbWF4UGF5bG9hZCIsIl9vcHRpb25zIiwiX3RocmVzaG9sZCIsInRocmVzaG9sZCIsInVuZGVmaW5lZCIsIl9pc1NlcnZlciIsIl9kZWZsYXRlIiwiX2luZmxhdGUiLCJwYXJhbXMiLCJjb25jdXJyZW5jeSIsImNvbmN1cnJlbmN5TGltaXQiLCJleHRlbnNpb25OYW1lIiwib2ZmZXIiLCJzZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciIsInNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyIiwiY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIiLCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciIsInNlcnZlck1heFdpbmRvd0JpdHMiLCJzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzIiwiY2xpZW50TWF4V2luZG93Qml0cyIsImNsaWVudF9tYXhfd2luZG93X2JpdHMiLCJhY2NlcHQiLCJjb25maWd1cmF0aW9ucyIsIm5vcm1hbGl6ZVBhcmFtcyIsImFjY2VwdEFzU2VydmVyIiwiYWNjZXB0QXNDbGllbnQiLCJjbGVhbnVwIiwiY2xvc2UiLCJjYWxsYmFjayIsIkVycm9yIiwib2ZmZXJzIiwib3B0cyIsImFjY2VwdGVkIiwiZmluZCIsInJlc3BvbnNlIiwiZm9yRWFjaCIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJ2YWx1ZSIsImxlbmd0aCIsIm51bSIsIk51bWJlciIsImlzSW50ZWdlciIsIlR5cGVFcnJvciIsImRlY29tcHJlc3MiLCJkYXRhIiwiZmluIiwiYWRkIiwiZG9uZSIsIl9kZWNvbXByZXNzIiwiZXJyIiwicmVzdWx0IiwiY29tcHJlc3MiLCJfY29tcHJlc3MiLCJlbmRwb2ludCIsIndpbmRvd0JpdHMiLCJaX0RFRkFVTFRfV0lORE9XQklUUyIsImNyZWF0ZUluZmxhdGVSYXciLCJ6bGliSW5mbGF0ZU9wdGlvbnMiLCJvbiIsImluZmxhdGVPbkVycm9yIiwiaW5mbGF0ZU9uRGF0YSIsIndyaXRlIiwiZmx1c2giLCJjb25jYXQiLCJfcmVhZGFibGVTdGF0ZSIsImVuZEVtaXR0ZWQiLCJyZXNldCIsImNyZWF0ZURlZmxhdGVSYXciLCJ6bGliRGVmbGF0ZU9wdGlvbnMiLCJkZWZsYXRlT25EYXRhIiwiWl9TWU5DX0ZMVVNIIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsIm1vZHVsZSIsImV4cG9ydHMiLCJjaHVuayIsInB1c2giLCJSYW5nZUVycm9yIiwiY29kZSIsInJlbW92ZUxpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/receiver.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/receiver.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/permessage-deflate.js\");\nconst { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/validation.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst promise = Promise.resolve();\n//\n// `queueMicrotask()` is not available in Node.js < 11.\n//\nconst queueTask = typeof queueMicrotask === \"function\" ? queueMicrotask : queueMicrotaskShim;\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst WAIT_MICROTASK = 6;\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */ class Receiver extends Writable {\n    /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */ constructor(options = {}){\n        super();\n        this._binaryType = options.binaryType || BINARY_TYPES[0];\n        this._extensions = options.extensions || {};\n        this._isServer = !!options.isServer;\n        this._maxPayload = options.maxPayload | 0;\n        this._skipUTF8Validation = !!options.skipUTF8Validation;\n        this[kWebSocket] = undefined;\n        this._bufferedBytes = 0;\n        this._buffers = [];\n        this._compressed = false;\n        this._payloadLength = 0;\n        this._mask = undefined;\n        this._fragmented = 0;\n        this._masked = false;\n        this._fin = false;\n        this._opcode = 0;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragments = [];\n        this._state = GET_INFO;\n        this._loop = false;\n    }\n    /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */ _write(chunk, encoding, cb) {\n        if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n        this._bufferedBytes += chunk.length;\n        this._buffers.push(chunk);\n        this.startLoop(cb);\n    }\n    /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */ consume(n) {\n        this._bufferedBytes -= n;\n        if (n === this._buffers[0].length) return this._buffers.shift();\n        if (n < this._buffers[0].length) {\n            const buf = this._buffers[0];\n            this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n            return new FastBuffer(buf.buffer, buf.byteOffset, n);\n        }\n        const dst = Buffer.allocUnsafe(n);\n        do {\n            const buf = this._buffers[0];\n            const offset = dst.length - n;\n            if (n >= buf.length) {\n                dst.set(this._buffers.shift(), offset);\n            } else {\n                dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n                this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n            }\n            n -= buf.length;\n        }while (n > 0);\n        return dst;\n    }\n    /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ startLoop(cb) {\n        let err;\n        this._loop = true;\n        do {\n            switch(this._state){\n                case GET_INFO:\n                    err = this.getInfo();\n                    break;\n                case GET_PAYLOAD_LENGTH_16:\n                    err = this.getPayloadLength16();\n                    break;\n                case GET_PAYLOAD_LENGTH_64:\n                    err = this.getPayloadLength64();\n                    break;\n                case GET_MASK:\n                    this.getMask();\n                    break;\n                case GET_DATA:\n                    err = this.getData(cb);\n                    break;\n                case INFLATING:\n                    this._loop = false;\n                    return;\n                default:\n                    //\n                    // `WAIT_MICROTASK`.\n                    //\n                    this._loop = false;\n                    queueTask(()=>{\n                        this._state = GET_INFO;\n                        this.startLoop(cb);\n                    });\n                    return;\n            }\n        }while (this._loop);\n        cb(err);\n    }\n    /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ getInfo() {\n        if (this._bufferedBytes < 2) {\n            this._loop = false;\n            return;\n        }\n        const buf = this.consume(2);\n        if ((buf[0] & 0x30) !== 0x00) {\n            this._loop = false;\n            return error(RangeError, \"RSV2 and RSV3 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_2_3\");\n        }\n        const compressed = (buf[0] & 0x40) === 0x40;\n        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n            this._loop = false;\n            return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n        }\n        this._fin = (buf[0] & 0x80) === 0x80;\n        this._opcode = buf[0] & 0x0f;\n        this._payloadLength = buf[1] & 0x7f;\n        if (this._opcode === 0x00) {\n            if (compressed) {\n                this._loop = false;\n                return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n            }\n            if (!this._fragmented) {\n                this._loop = false;\n                return error(RangeError, \"invalid opcode 0\", true, 1002, \"WS_ERR_INVALID_OPCODE\");\n            }\n            this._opcode = this._fragmented;\n        } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n            if (this._fragmented) {\n                this._loop = false;\n                return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n            }\n            this._compressed = compressed;\n        } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n            if (!this._fin) {\n                this._loop = false;\n                return error(RangeError, \"FIN must be set\", true, 1002, \"WS_ERR_EXPECTED_FIN\");\n            }\n            if (compressed) {\n                this._loop = false;\n                return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n            }\n            if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {\n                this._loop = false;\n                return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\");\n            }\n        } else {\n            this._loop = false;\n            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n        }\n        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n        this._masked = (buf[1] & 0x80) === 0x80;\n        if (this._isServer) {\n            if (!this._masked) {\n                this._loop = false;\n                return error(RangeError, \"MASK must be set\", true, 1002, \"WS_ERR_EXPECTED_MASK\");\n            }\n        } else if (this._masked) {\n            this._loop = false;\n            return error(RangeError, \"MASK must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_MASK\");\n        }\n        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n        else return this.haveLength();\n    }\n    /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ getPayloadLength16() {\n        if (this._bufferedBytes < 2) {\n            this._loop = false;\n            return;\n        }\n        this._payloadLength = this.consume(2).readUInt16BE(0);\n        return this.haveLength();\n    }\n    /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ getPayloadLength64() {\n        if (this._bufferedBytes < 8) {\n            this._loop = false;\n            return;\n        }\n        const buf = this.consume(8);\n        const num = buf.readUInt32BE(0);\n        //\n        // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n        // if payload length is greater than this number.\n        //\n        if (num > Math.pow(2, 53 - 32) - 1) {\n            this._loop = false;\n            return error(RangeError, \"Unsupported WebSocket frame: payload length > 2^53 - 1\", false, 1009, \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\");\n        }\n        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n        return this.haveLength();\n    }\n    /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ haveLength() {\n        if (this._payloadLength && this._opcode < 0x08) {\n            this._totalPayloadLength += this._payloadLength;\n            if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n                this._loop = false;\n                return error(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\");\n            }\n        }\n        if (this._masked) this._state = GET_MASK;\n        else this._state = GET_DATA;\n    }\n    /**\n   * Reads mask bytes.\n   *\n   * @private\n   */ getMask() {\n        if (this._bufferedBytes < 4) {\n            this._loop = false;\n            return;\n        }\n        this._mask = this.consume(4);\n        this._state = GET_DATA;\n    }\n    /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */ getData(cb) {\n        let data = EMPTY_BUFFER;\n        if (this._payloadLength) {\n            if (this._bufferedBytes < this._payloadLength) {\n                this._loop = false;\n                return;\n            }\n            data = this.consume(this._payloadLength);\n            if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n                unmask(data, this._mask);\n            }\n        }\n        if (this._opcode > 0x07) return this.controlMessage(data);\n        if (this._compressed) {\n            this._state = INFLATING;\n            this.decompress(data, cb);\n            return;\n        }\n        if (data.length) {\n            //\n            // This message is not compressed so its length is the sum of the payload\n            // length of all fragments.\n            //\n            this._messageLength = this._totalPayloadLength;\n            this._fragments.push(data);\n        }\n        return this.dataMessage();\n    }\n    /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */ decompress(data, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        perMessageDeflate.decompress(data, this._fin, (err, buf)=>{\n            if (err) return cb(err);\n            if (buf.length) {\n                this._messageLength += buf.length;\n                if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n                    return cb(error(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"));\n                }\n                this._fragments.push(buf);\n            }\n            const er = this.dataMessage();\n            if (er) return cb(er);\n            this.startLoop(cb);\n        });\n    }\n    /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */ dataMessage() {\n        if (this._fin) {\n            const messageLength = this._messageLength;\n            const fragments = this._fragments;\n            this._totalPayloadLength = 0;\n            this._messageLength = 0;\n            this._fragmented = 0;\n            this._fragments = [];\n            if (this._opcode === 2) {\n                let data;\n                if (this._binaryType === \"nodebuffer\") {\n                    data = concat(fragments, messageLength);\n                } else if (this._binaryType === \"arraybuffer\") {\n                    data = toArrayBuffer(concat(fragments, messageLength));\n                } else {\n                    data = fragments;\n                }\n                this.emit(\"message\", data, true);\n            } else {\n                const buf = concat(fragments, messageLength);\n                if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                    this._loop = false;\n                    return error(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                }\n                this.emit(\"message\", buf, false);\n            }\n        }\n        this._state = WAIT_MICROTASK;\n    }\n    /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */ controlMessage(data) {\n        if (this._opcode === 0x08) {\n            this._loop = false;\n            if (data.length === 0) {\n                this.emit(\"conclude\", 1005, EMPTY_BUFFER);\n                this.end();\n                this._state = GET_INFO;\n            } else {\n                const code = data.readUInt16BE(0);\n                if (!isValidStatusCode(code)) {\n                    return error(RangeError, `invalid status code ${code}`, true, 1002, \"WS_ERR_INVALID_CLOSE_CODE\");\n                }\n                const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);\n                if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                    return error(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                }\n                this.emit(\"conclude\", code, buf);\n                this.end();\n                this._state = GET_INFO;\n            }\n        } else if (this._opcode === 0x09) {\n            this.emit(\"ping\", data);\n            this._state = WAIT_MICROTASK;\n        } else {\n            this.emit(\"pong\", data);\n            this._state = WAIT_MICROTASK;\n        }\n    }\n}\nmodule.exports = Receiver;\n/**\n * Builds an error object.\n *\n * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @param {String} errorCode The exposed error code\n * @return {(Error|RangeError)} The error\n * @private\n */ function error(ErrorCtor, message, prefix, statusCode, errorCode) {\n    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n    Error.captureStackTrace(err, error);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n}\n/**\n * A shim for `queueMicrotask()`.\n *\n * @param {Function} cb Callback\n */ function queueMicrotaskShim(cb) {\n    promise.then(cb).catch(throwErrorNextTick);\n}\n/**\n * Throws an error.\n *\n * @param {Error} err The error to throw\n * @private\n */ function throwError(err) {\n    throw err;\n}\n/**\n * Throws an error in the next tick.\n *\n * @param {Error} err The error to throw\n * @private\n */ function throwErrorNextTick(err) {\n    process.nextTick(throwError, err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvcmVjZWl2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFFBQVEsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUU3QixNQUFNQyxvQkFBb0JELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFDSkUsWUFBWSxFQUNaQyxZQUFZLEVBQ1pDLFdBQVcsRUFDWEMsVUFBVSxFQUNYLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTSxNQUFNLEVBQUVDLGFBQWEsRUFBRUMsTUFBTSxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBQ2xELE1BQU0sRUFBRVMsaUJBQWlCLEVBQUVDLFdBQVcsRUFBRSxHQUFHVixtQkFBT0EsQ0FBQztBQUVuRCxNQUFNVyxhQUFhQyxNQUFNLENBQUNDLE9BQU9DLE9BQU8sQ0FBQztBQUN6QyxNQUFNQyxVQUFVQyxRQUFRQyxPQUFPO0FBRS9CLEVBQUU7QUFDRix1REFBdUQ7QUFDdkQsRUFBRTtBQUNGLE1BQU1DLFlBQ0osT0FBT0MsbUJBQW1CLGFBQWFBLGlCQUFpQkM7QUFFMUQsTUFBTUMsV0FBVztBQUNqQixNQUFNQyx3QkFBd0I7QUFDOUIsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxZQUFZO0FBQ2xCLE1BQU1DLGlCQUFpQjtBQUV2Qjs7OztDQUlDLEdBQ0QsTUFBTUMsaUJBQWlCN0I7SUFDckI7Ozs7Ozs7Ozs7OztHQVlDLEdBQ0Q4QixZQUFZQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQ3hCLEtBQUs7UUFFTCxJQUFJLENBQUNDLFdBQVcsR0FBR0QsUUFBUUUsVUFBVSxJQUFJOUIsWUFBWSxDQUFDLEVBQUU7UUFDeEQsSUFBSSxDQUFDK0IsV0FBVyxHQUFHSCxRQUFRSSxVQUFVLElBQUksQ0FBQztRQUMxQyxJ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QUFNLEVBQUVDLFVBQVUsRUFBRUMsU0FBUztJQUM5RCxNQUFNbEMsTUFBTSxJQUFJOEIsVUFDZEUsU0FBUyxDQUFDLHlCQUF5QixFQUFFRCxRQUFRLENBQUMsR0FBR0E7SUFHbkROLE1BQU1VLGlCQUFpQixDQUFDbkMsS0FBS007SUFDN0JOLElBQUkyQixJQUFJLEdBQUdPO0lBQ1hsQyxHQUFHLENBQUN0RSxZQUFZLEdBQUd1RztJQUNuQixPQUFPakM7QUFDVDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTdEQsbUJBQW1CdUMsRUFBRTtJQUM1QjVDLFFBQVErRixJQUFJLENBQUNuRCxJQUFJb0QsS0FBSyxDQUFDQztBQUN6QjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0MsV0FBV3ZDLEdBQUc7SUFDckIsTUFBTUE7QUFDUjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU3NDLG1CQUFtQnRDLEdBQUc7SUFDN0J3QyxRQUFRQyxRQUFRLENBQUNGLFlBQVl2QztBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvcmVjZWl2ZXIuanM/NjNmMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBrU3RhdHVzQ29kZSxcbiAga1dlYlNvY2tldFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGNvbmNhdCwgdG9BcnJheUJ1ZmZlciwgdW5tYXNrIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlLCBpc1ZhbGlkVVRGOCB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4vL1xuLy8gYHF1ZXVlTWljcm90YXNrKClgIGlzIG5vdCBhdmFpbGFibGUgaW4gTm9kZS5qcyA8IDExLlxuLy9cbmNvbnN0IHF1ZXVlVGFzayA9XG4gIHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJyA/IHF1ZXVlTWljcm90YXNrIDogcXVldWVNaWNyb3Rhc2tTaGltO1xuXG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5jb25zdCBXQUlUX01JQ1JPVEFTSyA9IDY7XG5cbi8qKlxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBXcml0YWJsZVxuICovXG5jbGFzcyBSZWNlaXZlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG4gICAqICAgICBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cbiAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gb3B0aW9ucy5iaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyBgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIFRoZSBjaHVuayBvZiBkYXRhIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIGBjaHVua2BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9zdGF0ZSA9PSBHRVRfSU5GTykgcmV0dXJuIGNiKCk7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLl9idWZmZXJzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdW1lKG4pIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XG5cbiAgICBpZiAobiA9PT0gdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XG5cbiAgICBpZiAobiA8IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICBidWYuYnVmZmVyLFxuICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXG4gICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pO1xuICAgIH1cblxuICAgIGNvbnN0IGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICBjb25zdCBvZmZzZXQgPSBkc3QubGVuZ3RoIC0gbjtcblxuICAgICAgaWYgKG4gPj0gYnVmLmxlbmd0aCkge1xuICAgICAgICBkc3Quc2V0KHRoaXMuX2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRzdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJzWzBdID0gbmV3IEZhc3RCdWZmZXIoXG4gICAgICAgICAgYnVmLmJ1ZmZlcixcbiAgICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXG4gICAgICAgICAgYnVmLmxlbmd0aCAtIG5cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSBidWYubGVuZ3RoO1xuICAgIH0gd2hpbGUgKG4gPiAwKTtcblxuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBwYXJzaW5nIGxvb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydExvb3AoY2IpIHtcbiAgICBsZXQgZXJyO1xuICAgIHRoaXMuX2xvb3AgPSB0cnVlO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICBjYXNlIEdFVF9JTkZPOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0SW5mbygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF8xNjpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGgxNigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGg2NCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9NQVNLOlxuICAgICAgICAgIHRoaXMuZ2V0TWFzaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9EQVRBOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0RGF0YShjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSU5GTEFUSU5HOlxuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBgV0FJVF9NSUNST1RBU0tgLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuXG4gICAgICAgICAgcXVldWVUYXNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRoaXMuX2xvb3ApO1xuXG4gICAgY2IoZXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEluZm8oKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzMnXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXByZXNzZWQgPSAoYnVmWzBdICYgMHg0MCkgPT09IDB4NDA7XG5cbiAgICBpZiAoY29tcHJlc3NlZCAmJiAhdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9maW4gPSAoYnVmWzBdICYgMHg4MCkgPT09IDB4ODA7XG4gICAgdGhpcy5fb3Bjb2RlID0gYnVmWzBdICYgMHgwZjtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gYnVmWzFdICYgMHg3ZjtcblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDApIHtcbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgb3Bjb2RlIDAnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29tcHJlc3NlZCA9IGNvbXByZXNzZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3ICYmIHRoaXMuX29wY29kZSA8IDB4MGIpIHtcbiAgICAgIGlmICghdGhpcy5fZmluKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ0ZJTiBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfRklOJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QgfHxcbiAgICAgICAgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgcGF5bG9hZCBsZW5ndGggJHt0aGlzLl9wYXlsb2FkTGVuZ3RofWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DT05UUk9MX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcbiAgICB0aGlzLl9tYXNrZWQgPSAoYnVmWzFdICYgMHg4MCkgPT09IDB4ODA7XG5cbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ01BU0sgbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX01BU0snXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9tYXNrZWQpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ01BU0sgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9NQVNLJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrMTYpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoMTYoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrNjQpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDgpO1xuICAgIGNvbnN0IG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMCk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBtYXhpbXVtIHNhZmUgaW50ZWdlciBpbiBKYXZhU2NyaXB0IGlzIDJeNTMgLSAxLiBBbiBlcnJvciBpcyByZXR1cm5lZFxuICAgIC8vIGlmIHBheWxvYWQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIG51bWJlci5cbiAgICAvL1xuICAgIGlmIChudW0gPiBNYXRoLnBvdygyLCA1MyAtIDMyKSAtIDEpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIFdlYlNvY2tldCBmcmFtZTogcGF5bG9hZCBsZW5ndGggPiAyXjUzIC0gMScsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAxMDA5LFxuICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX0RBVEFfUEFZTE9BRF9MRU5HVEgnXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBudW0gKiBNYXRoLnBvdygyLCAzMikgKyBidWYucmVhZFVJbnQzMkJFKDQpO1xuICAgIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKCkge1xuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoICYmIHRoaXMuX29wY29kZSA8IDB4MDgpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgMTAwOSxcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrZWQpIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXREYXRhKGNiKSB7XG4gICAgbGV0IGRhdGEgPSBFTVBUWV9CVUZGRVI7XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCB0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gdGhpcy5jb25zdW1lKHRoaXMuX3BheWxvYWRMZW5ndGgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX21hc2tlZCAmJlxuICAgICAgICAodGhpcy5fbWFza1swXSB8IHRoaXMuX21hc2tbMV0gfCB0aGlzLl9tYXNrWzJdIHwgdGhpcy5fbWFza1szXSkgIT09IDBcbiAgICAgICkge1xuICAgICAgICB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHJldHVybiB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEpO1xuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKFxuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIDEwMDksXG4gICAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVyID0gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICAgICAgaWYgKGVyKSByZXR1cm4gY2IoZXIpO1xuXG4gICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHJldHVybiB7KEVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9maW4pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuXG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgICBkYXRhID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBidWYgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gV0FJVF9NSUNST1RBU0s7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNvbnRyb2wgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBoYW5kbGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCBFTVBUWV9CVUZGRVIpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuXG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICAgIGRhdGEuYnVmZmVyLFxuICAgICAgICAgIGRhdGEuYnl0ZU9mZnNldCArIDIsXG4gICAgICAgICAgZGF0YS5sZW5ndGggLSAyXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCBjb2RlLCBidWYpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuXG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDkpIHtcbiAgICAgIHRoaXMuZW1pdCgncGluZycsIGRhdGEpO1xuICAgICAgdGhpcy5fc3RhdGUgPSBXQUlUX01JQ1JPVEFTSztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdwb25nJywgZGF0YSk7XG4gICAgICB0aGlzLl9zdGF0ZSA9IFdBSVRfTUlDUk9UQVNLO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6RXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAqICAgICBgbWVzc2FnZWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUsIGVycm9yQ29kZSkge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICk7XG5cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBlcnJvcik7XG4gIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBBIHNoaW0gZm9yIGBxdWV1ZU1pY3JvdGFzaygpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICovXG5mdW5jdGlvbiBxdWV1ZU1pY3JvdGFza1NoaW0oY2IpIHtcbiAgcHJvbWlzZS50aGVuKGNiKS5jYXRjaCh0aHJvd0Vycm9yTmV4dFRpY2spO1xufVxuXG4vKipcbiAqIFRocm93cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yIHRvIHRocm93XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0aHJvd0Vycm9yKGVycikge1xuICB0aHJvdyBlcnI7XG59XG5cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIGluIHRoZSBuZXh0IHRpY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciB0byB0aHJvd1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGhyb3dFcnJvck5leHRUaWNrKGVycikge1xuICBwcm9jZXNzLm5leHRUaWNrKHRocm93RXJyb3IsIGVycik7XG59XG4iXSwibmFtZXMiOlsiV3JpdGFibGUiLCJyZXF1aXJlIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJCSU5BUllfVFlQRVMiLCJFTVBUWV9CVUZGRVIiLCJrU3RhdHVzQ29kZSIsImtXZWJTb2NrZXQiLCJjb25jYXQiLCJ0b0FycmF5QnVmZmVyIiwidW5tYXNrIiwiaXNWYWxpZFN0YXR1c0NvZGUiLCJpc1ZhbGlkVVRGOCIsIkZhc3RCdWZmZXIiLCJCdWZmZXIiLCJTeW1ib2wiLCJzcGVjaWVzIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicXVldWVUYXNrIiwicXVldWVNaWNyb3Rhc2siLCJxdWV1ZU1pY3JvdGFza1NoaW0iLCJHRVRfSU5GTyIsIkdFVF9QQVlMT0FEX0xFTkdUSF8xNiIsIkdFVF9QQVlMT0FEX0xFTkdUSF82NCIsIkdFVF9NQVNLIiwiR0VUX0RBVEEiLCJJTkZMQVRJTkciLCJXQUlUX01JQ1JPVEFTSyIsIlJlY2VpdmVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2JpbmFyeVR5cGUiLCJiaW5hcnlUeXBlIiwiX2V4dGVuc2lvbnMiLCJleHRlbnNpb25zIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXIiLCJfbWF4UGF5bG9hZCIsIm1heFBheWxvYWQiLCJfc2tpcFVURjhWYWxpZGF0aW9uIiwic2tpcFVURjhWYWxpZGF0aW9uIiwidW5kZWZpbmVkIiwiX2J1ZmZlcmVkQnl0ZXMiLCJfYnVmZmVycyIsIl9jb21wcmVzc2VkIiwiX3BheWxvYWRMZW5ndGgiLCJfbWFzayIsIl9mcmFnbWVudGVkIiwiX21hc2tlZCIsIl9maW4iLCJfb3Bjb2RlIiwiX3RvdGFsUGF5bG9hZExlbmd0aCIsIl9tZXNzYWdlTGVuZ3RoIiwiX2ZyYWdtZW50cyIsIl9zdGF0ZSIsIl9sb29wIiwiX3dyaXRlIiwiY2h1bmsiLCJlbmNvZGluZyIsImNiIiwibGVuZ3RoIiwicHVzaCIsInN0YXJ0TG9vcCIsImNvbnN1bWUiLCJuIiwic2hpZnQiLCJidWYiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiZHN0IiwiYWxsb2NVbnNhZmUiLCJvZmZzZXQiLCJzZXQiLCJVaW50OEFycmF5IiwiZXJyIiwiZ2V0SW5mbyIsImdldFBheWxvYWRMZW5ndGgxNiIsImdldFBheWxvYWRMZW5ndGg2NCIsImdldE1hc2siLCJnZXREYXRhIiwiZXJyb3IiLCJSYW5nZUVycm9yIiwiY29tcHJlc3NlZCIsImV4dGVuc2lvbk5hbWUiLCJoYXZlTGVuZ3RoIiwicmVhZFVJbnQxNkJFIiwibnVtIiwicmVhZFVJbnQzMkJFIiwiTWF0aCIsInBvdyIsImRhdGEiLCJjb250cm9sTWVzc2FnZSIsImRlY29tcHJlc3MiLCJkYXRhTWVzc2FnZSIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZXIiLCJtZXNzYWdlTGVuZ3RoIiwiZnJhZ21lbnRzIiwiZW1pdCIsIkVycm9yIiwiZW5kIiwiY29kZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJFcnJvckN0b3IiLCJtZXNzYWdlIiwicHJlZml4Iiwic3RhdHVzQ29kZSIsImVycm9yQ29kZSIsImNhcHR1cmVTdGFja1RyYWNlIiwidGhlbiIsImNhdGNoIiwidGhyb3dFcnJvck5leHRUaWNrIiwidGhyb3dFcnJvciIsInByb2Nlc3MiLCJuZXh0VGljayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/sender.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/sender.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ \nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\n/**\n * HyBi Sender implementation.\n */ class Sender {\n    /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._deflating = false;\n        this._queue = [];\n    }\n    /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                randomFillSync(mask, 0, 4);\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === \"string\") {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n            throw new TypeError(\"First argument must be a valid error code number\");\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError(\"The message must not be greater than 123 bytes\");\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === \"string\") {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._deflating) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (this._deflating) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (this._deflating) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        if (perMessageDeflate) {\n            const opts = {\n                [kByteLength]: byteLength,\n                fin: options.fin,\n                generateMask: this._generateMask,\n                mask: options.mask,\n                maskBuffer: this._maskBuffer,\n                opcode,\n                readOnly,\n                rsv1\n            };\n            if (this._deflating) {\n                this.enqueue([\n                    this.dispatch,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.dispatch(data, this._compress, opts, cb);\n            }\n        } else {\n            this.sendFrame(Sender.frame(data, {\n                [kByteLength]: byteLength,\n                fin: options.fin,\n                generateMask: this._generateMask,\n                mask: options.mask,\n                maskBuffer: this._maskBuffer,\n                opcode,\n                readOnly,\n                rsv1: false\n            }), cb);\n        }\n    }\n    /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._deflating = true;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while data was being compressed\");\n                if (typeof cb === \"function\") cb(err);\n                for(let i = 0; i < this._queue.length; i++){\n                    const params = this._queue[i];\n                    const callback = params[params.length - 1];\n                    if (typeof callback === \"function\") callback(err);\n                }\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._deflating = false;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\n   * Executes queued send operations.\n   *\n   * @private\n   */ dequeue() {\n        while(!this._deflating && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvc2VuZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLHdFQUF3RSxHQUV4RTtBQUVBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRUMsY0FBYyxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBRW5DLE1BQU1FLG9CQUFvQkYsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFRyxZQUFZLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDakMsTUFBTSxFQUFFSSxpQkFBaUIsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUN0QyxNQUFNLEVBQUVLLE1BQU1DLFNBQVMsRUFBRUMsUUFBUSxFQUFFLEdBQUdQLG1CQUFPQSxDQUFDO0FBRTlDLE1BQU1RLGNBQWNDLE9BQU87QUFDM0IsTUFBTUMsYUFBYUMsT0FBT0MsS0FBSyxDQUFDO0FBRWhDOztDQUVDLEdBQ0QsTUFBTUM7SUFDSjs7Ozs7OztHQU9DLEdBQ0RDLFlBQVlDLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxZQUFZLENBQUU7UUFDNUMsSUFBSSxDQUFDQyxXQUFXLEdBQUdGLGNBQWMsQ0FBQztRQUVsQyxJQUFJQyxjQUFjO1lBQ2hCLElBQUksQ0FBQ0UsYUFBYSxHQUFHRjtZQUNyQixJQUFJLENBQUNHLFdBQVcsR0FBR1QsT0FBT0MsS0FBSyxDQUFDO1FBQ2xDO1FBRUEsSUFBSSxDQUFDUyxPQUFPLEdBQUdOO1FBRWYsSUFBSSxDQUFDTyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFFakIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtJQUNsQjtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CQyxHQUNELE9BQU9D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SUFBSSxDQUFDcEQsY0FBYyxJQUFJeUMsTUFBTSxDQUFDLEVBQUUsQ0FBQ3pELFlBQVk7WUFDN0NxRSxRQUFRQyxLQUFLLENBQUNiLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFQSxPQUFPYyxLQUFLLENBQUM7UUFDOUM7SUFDRjtJQUVBOzs7OztHQUtDLEdBQ0R4QixRQUFRVSxNQUFNLEVBQUU7UUFDZCxJQUFJLENBQUN6QyxjQUFjLElBQUl5QyxNQUFNLENBQUMsRUFBRSxDQUFDekQsWUFBWTtRQUM3QyxJQUFJLENBQUNrQixNQUFNLENBQUNzRCxJQUFJLENBQUNmO0lBQ25CO0lBRUE7Ozs7OztHQU1DLEdBQ0RSLFVBQVV3QixJQUFJLEVBQUVqQyxFQUFFLEVBQUU7UUFDbEIsSUFBSWlDLEtBQUs3QyxNQUFNLEtBQUssR0FBRztZQUNyQixJQUFJLENBQUNmLE9BQU8sQ0FBQzZELElBQUk7WUFDakIsSUFBSSxDQUFDN0QsT0FBTyxDQUFDZ0MsS0FBSyxDQUFDNEIsSUFBSSxDQUFDLEVBQUU7WUFDMUIsSUFBSSxDQUFDNUQsT0FBTyxDQUFDZ0MsS0FBSyxDQUFDNEIsSUFBSSxDQUFDLEVBQUUsRUFBRWpDO1lBQzVCLElBQUksQ0FBQzNCLE9BQU8sQ0FBQzhELE1BQU07UUFDckIsT0FBTztZQUNMLElBQUksQ0FBQzlELE9BQU8sQ0FBQ2dDLEtBQUssQ0FBQzRCLElBQUksQ0FBQyxFQUFFLEVBQUVqQztRQUM5QjtJQUNGO0FBQ0Y7QUFFQW9DLE9BQU9DLE9BQU8sR0FBR3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd3NAOC4xNC4yX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanM/NTA2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXhcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IGtCeXRlTGVuZ3RoID0gU3ltYm9sKCdrQnl0ZUxlbmd0aCcpO1xuY29uc3QgbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcblxuLyoqXG4gKiBIeUJpIFNlbmRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgU2VuZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTZW5kZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGV4dGVuc2lvbnMsIGdlbmVyYXRlTWFzaykge1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xuXG4gICAgaWYgKGdlbmVyYXRlTWFzaykge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVNYXNrID0gZ2VuZXJhdGVNYXNrO1xuICAgICAgdGhpcy5fbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcmV0dXJuIHsoQnVmZmVyfFN0cmluZylbXX0gVGhlIGZyYW1lZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZShkYXRhLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hc2s7XG4gICAgbGV0IG1lcmdlID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IHNraXBNYXNraW5nID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5tYXNrKSB7XG4gICAgICBtYXNrID0gb3B0aW9ucy5tYXNrQnVmZmVyIHx8IG1hc2tCdWZmZXI7XG5cbiAgICAgIGlmIChvcHRpb25zLmdlbmVyYXRlTWFzaykge1xuICAgICAgICBvcHRpb25zLmdlbmVyYXRlTWFzayhtYXNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmRvbUZpbGxTeW5jKG1hc2ssIDAsIDQpO1xuICAgICAgfVxuXG4gICAgICBza2lwTWFza2luZyA9IChtYXNrWzBdIHwgbWFza1sxXSB8IG1hc2tbMl0gfCBtYXNrWzNdKSA9PT0gMDtcbiAgICAgIG9mZnNldCA9IDY7XG4gICAgfVxuXG4gICAgbGV0IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoXG4gICAgICAgICghb3B0aW9ucy5tYXNrIHx8IHNraXBNYXNraW5nKSAmJlxuICAgICAgICBvcHRpb25zW2tCeXRlTGVuZ3RoXSAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgZGF0YUxlbmd0aCA9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHkgJiYgIXNraXBNYXNraW5nO1xuICAgIH1cblxuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YUxlbmd0aDtcblxuICAgIGlmIChkYXRhTGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YUxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGFMZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXRbMl0gPSB0YXJnZXRbM10gPSAwO1xuICAgICAgdGFyZ2V0LndyaXRlVUludEJFKGRhdGFMZW5ndGgsIDQsIDYpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICB0YXJnZXRbMV0gfD0gMHg4MDtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gNF0gPSBtYXNrWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMV0gPSBtYXNrWzNdO1xuXG4gICAgaWYgKHNraXBNYXNraW5nKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YUxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGFMZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ1ZjtcblxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZiA9IEVNUFRZX0JVRkZFUjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgbWVzc2FnZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTIzIGJ5dGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5zZXQoZGF0YSwgMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ1Zi5sZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBidWYsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBpbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDksXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MGEsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnlcbiAgICogICAgIG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG4gICAgbGV0IG9wY29kZSA9IG9wdGlvbnMuYmluYXJ5ID8gMiA6IDE7XG4gICAgbGV0IHJzdjEgPSBvcHRpb25zLmNvbXByZXNzO1xuXG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmlyc3RGcmFnbWVudCkge1xuICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IGZhbHNlO1xuICAgICAgaWYgKFxuICAgICAgICByc3YxICYmXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLnBhcmFtc1tcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5faXNTZXJ2ZXJcbiAgICAgICAgICAgID8gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICAgICAgOiAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgIF1cbiAgICAgICkge1xuICAgICAgICByc3YxID0gYnl0ZUxlbmd0aCA+PSBwZXJNZXNzYWdlRGVmbGF0ZS5fdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3YxID0gZmFsc2U7XG4gICAgICBvcGNvZGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbikgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICAgIG9wY29kZSxcbiAgICAgICAgcmVhZE9ubHksXG4gICAgICAgIHJzdjFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgICAgIG9wY29kZSxcbiAgICAgICAgICByZWFkT25seSxcbiAgICAgICAgICByc3YxOiBmYWxzZVxuICAgICAgICB9KSxcbiAgICAgICAgY2JcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9kZWZsYXRpbmcgPSB0cnVlO1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmNvbXByZXNzKGRhdGEsIG9wdGlvbnMuZmluLCAoXywgYnVmKSA9PiB7XG4gICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RoZSBzb2NrZXQgd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBjb21wcmVzc2VkJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIGNiKGVycik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlW2ldO1xuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB0aGlzLl9kZWZsYXRpbmcgPSBmYWxzZTtcbiAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBxdWV1ZWQgc2VuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVxdWV1ZSgpIHtcbiAgICB3aGlsZSAoIXRoaXMuX2RlZmxhdGluZyAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuIl0sIm5hbWVzIjpbIkR1cGxleCIsInJlcXVpcmUiLCJyYW5kb21GaWxsU3luYyIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiRU1QVFlfQlVGRkVSIiwiaXNWYWxpZFN0YXR1c0NvZGUiLCJtYXNrIiwiYXBwbHlNYXNrIiwidG9CdWZmZXIiLCJrQnl0ZUxlbmd0aCIsIlN5bWJvbCIsIm1hc2tCdWZmZXIiLCJCdWZmZXIiLCJhbGxvYyIsIlNlbmRlciIsImNvbnN0cnVjdG9yIiwic29ja2V0IiwiZXh0ZW5zaW9ucyIsImdlbmVyYXRlTWFzayIsIl9leHRlbnNpb25zIiwiX2dlbmVyYXRlTWFzayIsIl9tYXNrQnVmZmVyIiwiX3NvY2tldCIsIl9maXJzdEZyYWdtZW50IiwiX2NvbXByZXNzIiwiX2J1ZmZlcmVkQnl0ZXMiLCJfZGVmbGF0aW5nIiwiX3F1ZXVlIiwiZnJhbWUiLCJkYXRhIiwib3B0aW9ucyIsIm1lcmdlIiwib2Zmc2V0Iiwic2tpcE1hc2tpbmciLCJkYXRhTGVuZ3RoIiwidW5kZWZpbmVkIiwiZnJvbSIsImxlbmd0aCIsInJlYWRPbmx5IiwicGF5bG9hZExlbmd0aCIsInRhcmdldCIsImFsbG9jVW5zYWZlIiwiZmluIiwib3Bjb2RlIiwicnN2MSIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVJbnRCRSIsImNsb3NlIiwiY29kZSIsImNiIiwiYnVmIiwiVHlwZUVycm9yIiwiYnl0ZUxlbmd0aCIsIlJhbmdlRXJyb3IiLCJ3cml0ZSIsInNldCIsImVucXVldWUiLCJkaXNwYXRjaCIsInNlbmRGcmFtZSIsInBpbmciLCJwb25nIiwic2VuZCIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZXh0ZW5zaW9uTmFtZSIsImJpbmFyeSIsImNvbXByZXNzIiwicGFyYW1zIiwiX2lzU2VydmVyIiwiX3RocmVzaG9sZCIsIm9wdHMiLCJfIiwiZGVzdHJveWVkIiwiZXJyIiwiRXJyb3IiLCJpIiwiY2FsbGJhY2siLCJkZXF1ZXVlIiwic2hpZnQiLCJSZWZsZWN0IiwiYXBwbHkiLCJzbGljZSIsInB1c2giLCJsaXN0IiwiY29yayIsInVuY29yayIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/stream.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/stream.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */ function emitClose(stream) {\n    stream.emit(\"close\");\n}\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */ function duplexOnEnd() {\n    if (!this.destroyed && this._writableState.finished) {\n        this.destroy();\n    }\n}\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */ function duplexOnError(err) {\n    this.removeListener(\"error\", duplexOnError);\n    this.destroy();\n    if (this.listenerCount(\"error\") === 0) {\n        // Do not suppress the throwing behavior.\n        this.emit(\"error\", err);\n    }\n}\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */ function createWebSocketStream(ws, options) {\n    let terminateOnDestroy = true;\n    const duplex = new Duplex({\n        ...options,\n        autoDestroy: false,\n        emitClose: false,\n        objectMode: false,\n        writableObjectMode: false\n    });\n    ws.on(\"message\", function message(msg, isBinary) {\n        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n        if (!duplex.push(data)) ws.pause();\n    });\n    ws.once(\"error\", function error(err) {\n        if (duplex.destroyed) return;\n        // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n        //\n        // - If the `'error'` event is emitted before the `'open'` event, then\n        //   `ws.terminate()` is a noop as no socket is assigned.\n        // - Otherwise, the error is re-emitted by the listener of the `'error'`\n        //   event of the `Receiver` object. The listener already closes the\n        //   connection by calling `ws.close()`. This allows a close frame to be\n        //   sent to the other peer. If `ws.terminate()` is called right after this,\n        //   then the close frame might not be sent.\n        terminateOnDestroy = false;\n        duplex.destroy(err);\n    });\n    ws.once(\"close\", function close() {\n        if (duplex.destroyed) return;\n        duplex.push(null);\n    });\n    duplex._destroy = function(err, callback) {\n        if (ws.readyState === ws.CLOSED) {\n            callback(err);\n            process.nextTick(emitClose, duplex);\n            return;\n        }\n        let called = false;\n        ws.once(\"error\", function error(err) {\n            called = true;\n            callback(err);\n        });\n        ws.once(\"close\", function close() {\n            if (!called) callback(err);\n            process.nextTick(emitClose, duplex);\n        });\n        if (terminateOnDestroy) ws.terminate();\n    };\n    duplex._final = function(callback) {\n        if (ws.readyState === ws.CONNECTING) {\n            ws.once(\"open\", function open() {\n                duplex._final(callback);\n            });\n            return;\n        }\n        // If the value of the `_socket` property is `null` it means that `ws` is a\n        // client websocket and the handshake failed. In fact, when this happens, a\n        // socket is never assigned to the websocket. Wait for the `'error'` event\n        // that will be emitted by the websocket.\n        if (ws._socket === null) return;\n        if (ws._socket._writableState.finished) {\n            callback();\n            if (duplex._readableState.endEmitted) duplex.destroy();\n        } else {\n            ws._socket.once(\"finish\", function finish() {\n                // `duplex` is not destroyed here because the `'end'` event will be\n                // emitted on `duplex` after this `'finish'` event. The EOF signaling\n                // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n                callback();\n            });\n            ws.close();\n        }\n    };\n    duplex._read = function() {\n        if (ws.isPaused) ws.resume();\n    };\n    duplex._write = function(chunk, encoding, callback) {\n        if (ws.readyState === ws.CONNECTING) {\n            ws.once(\"open\", function open() {\n                duplex._write(chunk, encoding, callback);\n            });\n            return;\n        }\n        ws.send(chunk, callback);\n    };\n    duplex.on(\"end\", duplexOnEnd);\n    duplex.on(\"error\", duplexOnError);\n    return duplex;\n}\nmodule.exports = createWebSocketStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFM0I7Ozs7O0NBS0MsR0FDRCxTQUFTQyxVQUFVQyxNQUFNO0lBQ3ZCQSxPQUFPQyxJQUFJLENBQUM7QUFDZDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTQztJQUNQLElBQUksQ0FBQyxJQUFJLENBQUNDLFNBQVMsSUFBSSxJQUFJLENBQUNDLGNBQWMsQ0FBQ0MsUUFBUSxFQUFFO1FBQ25ELElBQUksQ0FBQ0MsT0FBTztJQUNkO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLGNBQWNDLEdBQUc7SUFDeEIsSUFBSSxDQUFDQyxjQUFjLENBQUMsU0FBU0Y7SUFDN0IsSUFBSSxDQUFDRCxPQUFPO0lBQ1osSUFBSSxJQUFJLENBQUNJLGFBQWEsQ0FBQyxhQUFhLEdBQUc7UUFDckMseUNBQXlDO1FBQ3pDLElBQUksQ0FBQ1QsSUFBSSxDQUFDLFNBQVNPO0lBQ3JCO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0csc0JBQXNCQyxFQUFFLEVBQUVDLE9BQU87SUFDeEMsSUFBSUMscUJBQXFCO0lBRXpCLE1BQU1DLFNBQVMsSUFBSWxCLE9BQU87UUFDeEIsR0FBR2dCLE9BQU87UUFDVkcsYUFBYTtRQUNiakIsV0FBVztRQUNYa0IsWUFBWTtRQUNaQyxvQkFBb0I7SUFDdEI7SUFFQU4sR0FBR08sRUFBRSxDQUFDLFdBQVcsU0FBU0MsUUFBUUMsR0FBRyxFQUFFQyxRQUFRO1FBQzdDLE1BQU1DLE9BQ0osQ0FBQ0QsWUFBWVAsT0FBT1MsY0FBYyxDQUFDUCxVQUFVLEdBQUdJLElBQUlJLFFBQVEsS0FBS0o7UUFFbkUsSUFBSSxDQUFDTixPQUFPVyxJQUFJLENBQUNILE9BQU9YLEdBQUdlLEtBQUs7SUFDbEM7SUFFQWYsR0FBR2dCLElBQUksQ0FBQyxTQUFTLFNBQVNDLE1BQU1yQixHQUFHO1FBQ2pDLElBQUlPLE9BQU9aLFNBQVMsRUFBRTtRQUV0QixxRUFBcUU7UUFDckUsRUFBRTtRQUNGLHNFQUFzRTtRQUN0RSx5REFBeUQ7UUFDekQsd0VBQXdFO1FBQ3hFLG9FQUFvRTtRQUNwRSx3RUFBd0U7UUFDeEUsNEVBQTRFO1FBQzVFLDRDQUE0QztRQUM1Q1cscUJBQXFCO1FBQ3JCQyxPQUFPVCxPQUFPLENBQUNFO0lBQ2pCO0lBRUFJLEdBQUdnQixJQUFJLENBQUMsU0FBUyxTQUFTRTtRQUN4QixJQUFJZixPQUFPWixTQUFTLEVBQUU7UUFFdEJZLE9BQU9XLElBQUksQ0FBQztJQUNkO0lBRUFYLE9BQU9nQixRQUFRLEdBQUcsU0FBVXZCLEdBQUcsRUFBRXdCLFFBQVE7UUFDdkMsSUFBSXBCLEdBQUdxQixVQUFVLEtBQUtyQixHQUFHc0IsTUFBTSxFQUFFO1lBQy9CRixTQUFTeEI7WUFDVDJCLFFBQVFDLFFBQVEsQ0FBQ3JDLFdBQVdnQjtZQUM1QjtRQUNGO1FBRUEsSUFBSXNCLFNBQVM7UUFFYnpCLEdBQUdnQixJQUFJLENBQUMsU0FBUyxTQUFTQyxNQUFNckIsR0FBRztZQUNqQzZCLFNBQVM7WUFDVEwsU0FBU3hCO1FBQ1g7UUFFQUksR0FBR2dCLElBQUksQ0FBQyxTQUFTLFNBQVNFO1lBQ3hCLElBQUksQ0FBQ08sUUFBUUwsU0FBU3hCO1lBQ3RCMkIsUUFBUUMsUUFBUSxDQUFDckMsV0FBV2dCO1FBQzlCO1FBRUEsSUFBSUQsb0JBQW9CRixHQUFHMEIsU0FBUztJQUN0QztJQUVBdkIsT0FBT3dCLE1BQU0sR0FBRyxTQUFVUCxRQUFRO1FBQ2hDLElBQUlwQixHQUFHcUIsVUFBVSxLQUFLckIsR0FBRzRCLFVBQVUsRUFBRTtZQUNuQzVCLEdBQUdnQixJQUFJLENBQUMsUUFBUSxTQUFTYTtnQkFDdkIxQixPQUFPd0IsTUFBTSxDQUFDUDtZQUNoQjtZQUNBO1FBQ0Y7UUFFQSwyRUFBMkU7UUFDM0UsMkVBQTJFO1FBQzNFLDBFQUEwRTtRQUMxRSx5Q0FBeUM7UUFDekMsSUFBSXBCLEdBQUc4QixPQUFPLEtBQUssTUFBTTtRQUV6QixJQUFJOUIsR0FBRzhCLE9BQU8sQ0FBQ3RDLGNBQWMsQ0FBQ0MsUUFBUSxFQUFFO1lBQ3RDMkI7WUFDQSxJQUFJakIsT0FBT1MsY0FBYyxDQUFDbUIsVUFBVSxFQUFFNUIsT0FBT1QsT0FBTztRQUN0RCxPQUFPO1lBQ0xNLEdBQUc4QixPQUFPLENBQUNkLElBQUksQ0FBQyxVQUFVLFNBQVNnQjtnQkFDakMsbUVBQW1FO2dCQUNuRSxxRUFBcUU7Z0JBQ3JFLHVFQUF1RTtnQkFDdkVaO1lBQ0Y7WUFDQXBCLEdBQUdrQixLQUFLO1FBQ1Y7SUFDRjtJQUVBZixPQUFPOEIsS0FBSyxHQUFHO1FBQ2IsSUFBSWpDLEdBQUdrQyxRQUFRLEVBQUVsQyxHQUFHbUMsTUFBTTtJQUM1QjtJQUVBaEMsT0FBT2lDLE1BQU0sR0FBRyxTQUFVQyxLQUFLLEVBQUVDLFFBQVEsRUFBRWxCLFFBQVE7UUFDakQsSUFBSXBCLEdBQUdxQixVQUFVLEtBQUtyQixHQUFHNEIsVUFBVSxFQUFFO1lBQ25DNUIsR0FBR2dCLElBQUksQ0FBQyxRQUFRLFNBQVNhO2dCQUN2QjFCLE9BQU9pQyxNQUFNLENBQUNDLE9BQU9DLFVBQVVsQjtZQUNqQztZQUNBO1FBQ0Y7UUFFQXBCLEdBQUd1QyxJQUFJLENBQUNGLE9BQU9qQjtJQUNqQjtJQUVBakIsT0FBT0ksRUFBRSxDQUFDLE9BQU9qQjtJQUNqQmEsT0FBT0ksRUFBRSxDQUFDLFNBQVNaO0lBQ25CLE9BQU9RO0FBQ1Q7QUFFQXFDLE9BQU9DLE9BQU8sR0FBRzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd3NAOC4xNC4yX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL3dzL2xpYi9zdHJlYW0uanM/YzBhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyoqXG4gKiBFbWl0cyB0aGUgYCdjbG9zZSdgIGV2ZW50IG9uIGEgc3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7RHVwbGV4fSBzdHJlYW0gVGhlIHN0cmVhbS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRDbG9zZShzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2VuZCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGR1cGxleE9uRW5kKCkge1xuICBpZiAoIXRoaXMuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGR1cGxleE9uRXJyb3IoZXJyKSB7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHRoaXMuZGVzdHJveSgpO1xuICBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgLy8gRG8gbm90IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvci5cbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFdyYXBzIGEgYFdlYlNvY2tldGAgaW4gYSBkdXBsZXggc3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3cyBUaGUgYFdlYlNvY2tldGAgdG8gd3JhcFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhlIGBEdXBsZXhgIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJuIHtEdXBsZXh9IFRoZSBkdXBsZXggc3RyZWFtXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldFN0cmVhbSh3cywgb3B0aW9ucykge1xuICBsZXQgdGVybWluYXRlT25EZXN0cm95ID0gdHJ1ZTtcblxuICBjb25zdCBkdXBsZXggPSBuZXcgRHVwbGV4KHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGF1dG9EZXN0cm95OiBmYWxzZSxcbiAgICBlbWl0Q2xvc2U6IGZhbHNlLFxuICAgIG9iamVjdE1vZGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogZmFsc2VcbiAgfSk7XG5cbiAgd3Mub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiBtZXNzYWdlKG1zZywgaXNCaW5hcnkpIHtcbiAgICBjb25zdCBkYXRhID1cbiAgICAgICFpc0JpbmFyeSAmJiBkdXBsZXguX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSA/IG1zZy50b1N0cmluZygpIDogbXNnO1xuXG4gICAgaWYgKCFkdXBsZXgucHVzaChkYXRhKSkgd3MucGF1c2UoKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBgd3MudGVybWluYXRlKClgIGZyb20gYmVpbmcgY2FsbGVkIGJ5IGBkdXBsZXguX2Rlc3Ryb3koKWAuXG4gICAgLy9cbiAgICAvLyAtIElmIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBiZWZvcmUgdGhlIGAnb3BlbidgIGV2ZW50LCB0aGVuXG4gICAgLy8gICBgd3MudGVybWluYXRlKClgIGlzIGEgbm9vcCBhcyBubyBzb2NrZXQgaXMgYXNzaWduZWQuXG4gICAgLy8gLSBPdGhlcndpc2UsIHRoZSBlcnJvciBpcyByZS1lbWl0dGVkIGJ5IHRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlcnJvcidgXG4gICAgLy8gICBldmVudCBvZiB0aGUgYFJlY2VpdmVyYCBvYmplY3QuIFRoZSBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlcyB0aGVcbiAgICAvLyAgIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBgd3MuY2xvc2UoKWAuIFRoaXMgYWxsb3dzIGEgY2xvc2UgZnJhbWUgdG8gYmVcbiAgICAvLyAgIHNlbnQgdG8gdGhlIG90aGVyIHBlZXIuIElmIGB3cy50ZXJtaW5hdGUoKWAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHRoaXMsXG4gICAgLy8gICB0aGVuIHRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgYmUgc2VudC5cbiAgICB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSBmYWxzZTtcbiAgICBkdXBsZXguZGVzdHJveShlcnIpO1xuICB9KTtcblxuICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBkdXBsZXgucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgZHVwbGV4Ll9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ0xPU0VEKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuXG4gICAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICghY2FsbGVkKSBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGVybWluYXRlT25EZXN0cm95KSB3cy50ZXJtaW5hdGUoKTtcbiAgfTtcblxuICBkdXBsZXguX2ZpbmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX2ZpbmFsKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgYF9zb2NrZXRgIHByb3BlcnR5IGlzIGBudWxsYCBpdCBtZWFucyB0aGF0IGB3c2AgaXMgYVxuICAgIC8vIGNsaWVudCB3ZWJzb2NrZXQgYW5kIHRoZSBoYW5kc2hha2UgZmFpbGVkLiBJbiBmYWN0LCB3aGVuIHRoaXMgaGFwcGVucywgYVxuICAgIC8vIHNvY2tldCBpcyBuZXZlciBhc3NpZ25lZCB0byB0aGUgd2Vic29ja2V0LiBXYWl0IGZvciB0aGUgYCdlcnJvcidgIGV2ZW50XG4gICAgLy8gdGhhdCB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhlIHdlYnNvY2tldC5cbiAgICBpZiAod3MuX3NvY2tldCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKHdzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICBpZiAoZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIGR1cGxleC5kZXN0cm95KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdzLl9zb2NrZXQub25jZSgnZmluaXNoJywgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICAvLyBgZHVwbGV4YCBpcyBub3QgZGVzdHJveWVkIGhlcmUgYmVjYXVzZSB0aGUgYCdlbmQnYCBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGVtaXR0ZWQgb24gYGR1cGxleGAgYWZ0ZXIgdGhpcyBgJ2ZpbmlzaCdgIGV2ZW50LiBUaGUgRU9GIHNpZ25hbGluZ1xuICAgICAgICAvLyBgbnVsbGAgY2h1bmsgaXMsIGluIGZhY3QsIHB1c2hlZCB3aGVuIHRoZSB3ZWJzb2NrZXQgZW1pdHMgYCdjbG9zZSdgLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgICB3cy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICBkdXBsZXguX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdzLmlzUGF1c2VkKSB3cy5yZXN1bWUoKTtcbiAgfTtcblxuICBkdXBsZXguX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cy5zZW5kKGNodW5rLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgZHVwbGV4Lm9uKCdlbmQnLCBkdXBsZXhPbkVuZCk7XG4gIGR1cGxleC5vbignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgcmV0dXJuIGR1cGxleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXZWJTb2NrZXRTdHJlYW07XG4iXSwibmFtZXMiOlsiRHVwbGV4IiwicmVxdWlyZSIsImVtaXRDbG9zZSIsInN0cmVhbSIsImVtaXQiLCJkdXBsZXhPbkVuZCIsImRlc3Ryb3llZCIsIl93cml0YWJsZVN0YXRlIiwiZmluaXNoZWQiLCJkZXN0cm95IiwiZHVwbGV4T25FcnJvciIsImVyciIsInJlbW92ZUxpc3RlbmVyIiwibGlzdGVuZXJDb3VudCIsImNyZWF0ZVdlYlNvY2tldFN0cmVhbSIsIndzIiwib3B0aW9ucyIsInRlcm1pbmF0ZU9uRGVzdHJveSIsImR1cGxleCIsImF1dG9EZXN0cm95Iiwib2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsIm9uIiwibWVzc2FnZSIsIm1zZyIsImlzQmluYXJ5IiwiZGF0YSIsIl9yZWFkYWJsZVN0YXRlIiwidG9TdHJpbmciLCJwdXNoIiwicGF1c2UiLCJvbmNlIiwiZXJyb3IiLCJjbG9zZSIsIl9kZXN0cm95IiwiY2FsbGJhY2siLCJyZWFkeVN0YXRlIiwiQ0xPU0VEIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2FsbGVkIiwidGVybWluYXRlIiwiX2ZpbmFsIiwiQ09OTkVDVElORyIsIm9wZW4iLCJfc29ja2V0IiwiZW5kRW1pdHRlZCIsImZpbmlzaCIsIl9yZWFkIiwiaXNQYXVzZWQiLCJyZXN1bWUiLCJfd3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwic2VuZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/subprotocol.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/subprotocol.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/validation.js\");\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */ function parse(header) {\n    const protocols = new Set();\n    let start = -1;\n    let end = -1;\n    let i = 0;\n    for(i; i < header.length; i++){\n        const code = header.charCodeAt(i);\n        if (end === -1 && tokenChars[code] === 1) {\n            if (start === -1) start = i;\n        } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n            if (end === -1 && start !== -1) end = i;\n        } else if (code === 0x2c /* ',' */ ) {\n            if (start === -1) {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (end === -1) end = i;\n            const protocol = header.slice(start, end);\n            if (protocols.has(protocol)) {\n                throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n            }\n            protocols.add(protocol);\n            start = end = -1;\n        } else {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n    }\n    if (start === -1 || end !== -1) {\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    const protocol = header.slice(start, i);\n    if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n    }\n    protocols.add(protocol);\n    return protocols;\n}\nmodule.exports = {\n    parse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvc3VicHJvdG9jb2wuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUUvQjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxNQUFNQyxNQUFNO0lBQ25CLE1BQU1DLFlBQVksSUFBSUM7SUFDdEIsSUFBSUMsUUFBUSxDQUFDO0lBQ2IsSUFBSUMsTUFBTSxDQUFDO0lBQ1gsSUFBSUMsSUFBSTtJQUVSLElBQUtBLEdBQUdBLElBQUlMLE9BQU9NLE1BQU0sRUFBRUQsSUFBSztRQUM5QixNQUFNRSxPQUFPUCxPQUFPUSxVQUFVLENBQUNIO1FBRS9CLElBQUlELFFBQVEsQ0FBQyxLQUFLUCxVQUFVLENBQUNVLEtBQUssS0FBSyxHQUFHO1lBQ3hDLElBQUlKLFVBQVUsQ0FBQyxHQUFHQSxRQUFRRTtRQUM1QixPQUFPLElBQ0xBLE1BQU0sS0FDTEUsQ0FBQUEsU0FBUyxLQUFLLE9BQU8sT0FBTUEsU0FBUyxJQUFHLEdBQ3hDO1lBQ0EsSUFBSUgsUUFBUSxDQUFDLEtBQUtELFVBQVUsQ0FBQyxHQUFHQyxNQUFNQztRQUN4QyxPQUFPLElBQUlFLFNBQVMsS0FBSyxPQUFPLEtBQUk7WUFDbEMsSUFBSUosVUFBVSxDQUFDLEdBQUc7Z0JBQ2hCLE1BQU0sSUFBSU0sWUFBWSxDQUFDLDhCQUE4QixFQUFFSixFQUFFLENBQUM7WUFDNUQ7WUFFQSxJQUFJRCxRQUFRLENBQUMsR0FBR0EsTUFBTUM7WUFFdEIsTUFBTUssV0FBV1YsT0FBT1csS0FBSyxDQUFDUixPQUFPQztZQUVyQyxJQUFJSCxVQUFVVyxHQUFHLENBQUNGLFdBQVc7Z0JBQzNCLE1BQU0sSUFBSUQsWUFBWSxDQUFDLEtBQUssRUFBRUMsU0FBUywyQkFBMkIsQ0FBQztZQUNyRTtZQUVBVCxVQUFVWSxHQUFHLENBQUNIO1lBQ2RQLFFBQVFDLE1BQU0sQ0FBQztRQUNqQixPQUFPO1lBQ0wsTUFBTSxJQUFJSyxZQUFZLENBQUMsOEJBQThCLEVBQUVKLEVBQUUsQ0FBQztRQUM1RDtJQUNGO0lBRUEsSUFBSUYsVUFBVSxDQUFDLEtBQUtDLFFBQVEsQ0FBQyxHQUFHO1FBQzlCLE1BQU0sSUFBSUssWUFBWTtJQUN4QjtJQUVBLE1BQU1DLFdBQVdWLE9BQU9XLEtBQUssQ0FBQ1IsT0FBT0U7SUFFckMsSUFBSUosVUFBVVcsR0FBRyxDQUFDRixXQUFXO1FBQzNCLE1BQU0sSUFBSUQsWUFBWSxDQUFDLEtBQUssRUFBRUMsU0FBUywyQkFBMkIsQ0FBQztJQUNyRTtJQUVBVCxVQUFVWSxHQUFHLENBQUNIO0lBQ2QsT0FBT1Q7QUFDVDtBQUVBYSxPQUFPQyxPQUFPLEdBQUc7SUFBRWhCO0FBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93c0A4LjE0LjJfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzP2M2NWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGkgIT09IDAgJiZcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cblxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhcnNlIH07XG4iXSwibmFtZXMiOlsidG9rZW5DaGFycyIsInJlcXVpcmUiLCJwYXJzZSIsImhlYWRlciIsInByb3RvY29scyIsIlNldCIsInN0YXJ0IiwiZW5kIiwiaSIsImxlbmd0aCIsImNvZGUiLCJjaGFyQ29kZUF0IiwiU3ludGF4RXJyb3IiLCJwcm90b2NvbCIsInNsaWNlIiwiaGFzIiwiYWRkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/validation.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/validation.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { isUtf8 } = __webpack_require__(/*! buffer */ \"buffer\");\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0 // 112 - 127\n];\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */ function isValidStatusCode(code) {\n    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n}\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */ function _isValidUTF8(buf) {\n    const len = buf.length;\n    let i = 0;\n    while(i < len){\n        if ((buf[i] & 0x80) === 0) {\n            // 0xxxxxxx\n            i++;\n        } else if ((buf[i] & 0xe0) === 0xc0) {\n            // 110xxxxx 10xxxxxx\n            if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n            ) {\n                return false;\n            }\n            i += 2;\n        } else if ((buf[i] & 0xf0) === 0xe0) {\n            // 1110xxxx 10xxxxxx 10xxxxxx\n            if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong\n            buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n            ) {\n                return false;\n            }\n            i += 3;\n        } else if ((buf[i] & 0xf8) === 0xf0) {\n            // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n            if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong\n            buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n            ) {\n                return false;\n            }\n            i += 4;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\nmodule.exports = {\n    isValidStatusCode,\n    isValidUTF8: _isValidUTF8,\n    tokenChars\n};\nif (isUtf8) {\n    module.exports.isValidUTF8 = function(buf) {\n        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n    };\n} else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n    try {\n        const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"(rsc)/../../node_modules/.pnpm/utf-8-validate@6.0.3/node_modules/utf-8-validate/index.js\");\n        module.exports.isValidUTF8 = function(buf) {\n            return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n        };\n    } catch (e) {\n    // Continue regardless of the error.\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvdmFsaWRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTNCLEVBQUU7QUFDRiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLCtDQUErQztBQUMvQyw4Q0FBOEM7QUFDOUMsRUFBRTtBQUNGLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLE1BQU07QUFDTixFQUFFO0FBQ0Ysa0JBQWtCO0FBQ2xCLE1BQU1DLGFBQWE7SUFDakI7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7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T0EsSUFBSUUsTUFBTSxHQUFHLEtBQUtILGFBQWFDLE9BQU9NLFlBQVlOO1FBQzNEO0lBQ0YsRUFBRSxPQUFPVSxHQUFHO0lBQ1Ysb0NBQW9DO0lBQ3RDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93c0A4LjE0LjJfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanM/ZDJhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgaXNVdGY4IH0gPSByZXF1aXJlKCdidWZmZXInKTtcblxuLy9cbi8vIEFsbG93ZWQgdG9rZW4gY2hhcmFjdGVyczpcbi8vXG4vLyAnIScsICcjJywgJyQnLCAnJScsICcmJywgJycnLCAnKicsICcrJywgJy0nLFxuLy8gJy4nLCAwLTksIEEtWiwgJ14nLCAnXycsICdgJywgYS16LCAnfCcsICd+J1xuLy9cbi8vIHRva2VuQ2hhcnNbMzJdID09PSAwIC8vICcgJ1xuLy8gdG9rZW5DaGFyc1szM10gPT09IDEgLy8gJyEnXG4vLyB0b2tlbkNoYXJzWzM0XSA9PT0gMCAvLyAnXCInXG4vLyAuLi5cbi8vXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHRva2VuQ2hhcnMgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDAsIC8vIDMyIC0gNDdcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNDggLSA2M1xuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIC8vIDgwIC0gOTVcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcbl07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhdHVzIGNvZGUgaXMgYWxsb3dlZCBpbiBhIGNsb3NlIGZyYW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzdGF0dXMgY29kZSBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICAoY29kZSA+PSAxMDAwICYmXG4gICAgICBjb2RlIDw9IDEwMTQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDUgJiZcbiAgICAgIGNvZGUgIT09IDEwMDYpIHx8XG4gICAgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpXG4gICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYnVmZmVyIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOC5cbiAqIFBvcnRlZCBmcm9tIGh0dHBzOi8vd3d3LmNsLmNhbS5hYy51ay8lN0VtZ2syNS91Y3MvdXRmOF9jaGVjay5jIGJ5XG4gKiBNYXJrdXMgS3Vobi5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgYnVmYCBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTgsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfaXNWYWxpZFVURjgoYnVmKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmICgoYnVmW2ldICYgMHg4MCkgPT09IDApIHtcbiAgICAgIC8vIDB4eHh4eHh4XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAxID09PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldICYgMHhmZSkgPT09IDB4YzAgLy8gT3ZlcmxvbmdcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDIgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGUwICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZWQgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHhhMCkgLy8gU3Vycm9nYXRlIChVK0Q4MDAgLSBVK0RGRkYpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDM7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgIC8vIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAzID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgM10gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGYwICYmIChidWZbaSArIDFdICYgMHhmMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZjQgJiYgYnVmW2kgKyAxXSA+IDB4OGYpIHx8XG4gICAgICAgIGJ1ZltpXSA+IDB4ZjQgLy8gPiBVKzEwRkZGRlxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcbiAgdG9rZW5DaGFyc1xufTtcblxuaWYgKGlzVXRmOCkge1xuICBtb2R1bGUuZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDI0ID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1V0ZjgoYnVmKTtcbiAgfTtcbn0gLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovIGVsc2UgaWYgKCFwcm9jZXNzLmVudi5XU19OT19VVEZfOF9WQUxJREFURSkge1xuICB0cnkge1xuICAgIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAzMiA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpc1V0ZjgiLCJyZXF1aXJlIiwidG9rZW5DaGFycyIsImlzVmFsaWRTdGF0dXNDb2RlIiwiY29kZSIsIl9pc1ZhbGlkVVRGOCIsImJ1ZiIsImxlbiIsImxlbmd0aCIsImkiLCJtb2R1bGUiLCJleHBvcnRzIiwiaXNWYWxpZFVURjgiLCJwcm9jZXNzIiwiZW52IiwiV1NfTk9fVVRGXzhfVkFMSURBVEUiLCJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/websocket-server.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/websocket-server.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\" }] */ \nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst extension = __webpack_require__(/*! ./extension */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/websocket.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/constants.js\");\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */ class WebSocketServer extends EventEmitter {\n    /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */ constructor(options, callback){\n        super();\n        options = {\n            maxPayload: 100 * 1024 * 1024,\n            skipUTF8Validation: false,\n            perMessageDeflate: false,\n            handleProtocols: null,\n            clientTracking: true,\n            verifyClient: null,\n            noServer: false,\n            backlog: null,\n            server: null,\n            host: null,\n            path: null,\n            port: null,\n            WebSocket,\n            ...options\n        };\n        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n            throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + \"must be specified\");\n        }\n        if (options.port != null) {\n            this._server = http.createServer((req, res)=>{\n                const body = http.STATUS_CODES[426];\n                res.writeHead(426, {\n                    \"Content-Length\": body.length,\n                    \"Content-Type\": \"text/plain\"\n                });\n                res.end(body);\n            });\n            this._server.listen(options.port, options.host, options.backlog, callback);\n        } else if (options.server) {\n            this._server = options.server;\n        }\n        if (this._server) {\n            const emitConnection = this.emit.bind(this, \"connection\");\n            this._removeListeners = addListeners(this._server, {\n                listening: this.emit.bind(this, \"listening\"),\n                error: this.emit.bind(this, \"error\"),\n                upgrade: (req, socket, head)=>{\n                    this.handleUpgrade(req, socket, head, emitConnection);\n                }\n            });\n        }\n        if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n        if (options.clientTracking) {\n            this.clients = new Set();\n            this._shouldEmitClose = false;\n        }\n        this.options = options;\n        this._state = RUNNING;\n    }\n    /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */ address() {\n        if (this.options.noServer) {\n            throw new Error('The server is operating in \"noServer\" mode');\n        }\n        if (!this._server) return null;\n        return this._server.address();\n    }\n    /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */ close(cb) {\n        if (this._state === CLOSED) {\n            if (cb) {\n                this.once(\"close\", ()=>{\n                    cb(new Error(\"The server is not running\"));\n                });\n            }\n            process.nextTick(emitClose, this);\n            return;\n        }\n        if (cb) this.once(\"close\", cb);\n        if (this._state === CLOSING) return;\n        this._state = CLOSING;\n        if (this.options.noServer || this.options.server) {\n            if (this._server) {\n                this._removeListeners();\n                this._removeListeners = this._server = null;\n            }\n            if (this.clients) {\n                if (!this.clients.size) {\n                    process.nextTick(emitClose, this);\n                } else {\n                    this._shouldEmitClose = true;\n                }\n            } else {\n                process.nextTick(emitClose, this);\n            }\n        } else {\n            const server = this._server;\n            this._removeListeners();\n            this._removeListeners = this._server = null;\n            //\n            // The HTTP/S server was created internally. Close it, and rely on its\n            // `'close'` event.\n            //\n            server.close(()=>{\n                emitClose(this);\n            });\n        }\n    }\n    /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */ shouldHandle(req) {\n        if (this.options.path) {\n            const index = req.url.indexOf(\"?\");\n            const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n            if (pathname !== this.options.path) return false;\n        }\n        return true;\n    }\n    /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */ handleUpgrade(req, socket, head, cb) {\n        socket.on(\"error\", socketOnError);\n        const key = req.headers[\"sec-websocket-key\"];\n        const version = +req.headers[\"sec-websocket-version\"];\n        if (req.method !== \"GET\") {\n            const message = \"Invalid HTTP method\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n            return;\n        }\n        if (req.headers.upgrade.toLowerCase() !== \"websocket\") {\n            const message = \"Invalid Upgrade header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n        }\n        if (!key || !keyRegex.test(key)) {\n            const message = \"Missing or invalid Sec-WebSocket-Key header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n        }\n        if (version !== 8 && version !== 13) {\n            const message = \"Missing or invalid Sec-WebSocket-Version header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n        }\n        if (!this.shouldHandle(req)) {\n            abortHandshake(socket, 400);\n            return;\n        }\n        const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n        let protocols = new Set();\n        if (secWebSocketProtocol !== undefined) {\n            try {\n                protocols = subprotocol.parse(secWebSocketProtocol);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Protocol header\";\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n        }\n        const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n        const extensions = {};\n        if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n            const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n            try {\n                const offers = extension.parse(secWebSocketExtensions);\n                if (offers[PerMessageDeflate.extensionName]) {\n                    perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n                    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n                }\n            } catch (err) {\n                const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n        }\n        //\n        // Optionally call external client verification handler.\n        //\n        if (this.options.verifyClient) {\n            const info = {\n                origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n                secure: !!(req.socket.authorized || req.socket.encrypted),\n                req\n            };\n            if (this.options.verifyClient.length === 2) {\n                this.options.verifyClient(info, (verified, code, message, headers)=>{\n                    if (!verified) {\n                        return abortHandshake(socket, code || 401, message, headers);\n                    }\n                    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n                });\n                return;\n            }\n            if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n        }\n        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n    }\n    /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */ completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n        //\n        // Destroy the socket if the client has already sent a FIN packet.\n        //\n        if (!socket.readable || !socket.writable) return socket.destroy();\n        if (socket[kWebSocket]) {\n            throw new Error(\"server.handleUpgrade() was called more than once with the same \" + \"socket, possibly due to a misconfiguration\");\n        }\n        if (this._state > RUNNING) return abortHandshake(socket, 503);\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        const headers = [\n            \"HTTP/1.1 101 Switching Protocols\",\n            \"Upgrade: websocket\",\n            \"Connection: Upgrade\",\n            `Sec-WebSocket-Accept: ${digest}`\n        ];\n        const ws = new this.options.WebSocket(null);\n        if (protocols.size) {\n            //\n            // Optionally call external protocol selection handler.\n            //\n            const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n            if (protocol) {\n                headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n                ws._protocol = protocol;\n            }\n        }\n        if (extensions[PerMessageDeflate.extensionName]) {\n            const params = extensions[PerMessageDeflate.extensionName].params;\n            const value = extension.format({\n                [PerMessageDeflate.extensionName]: [\n                    params\n                ]\n            });\n            headers.push(`Sec-WebSocket-Extensions: ${value}`);\n            ws._extensions = extensions;\n        }\n        //\n        // Allow external modification/inspection of handshake headers.\n        //\n        this.emit(\"headers\", headers, req);\n        socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n        socket.removeListener(\"error\", socketOnError);\n        ws.setSocket(socket, head, {\n            maxPayload: this.options.maxPayload,\n            skipUTF8Validation: this.options.skipUTF8Validation\n        });\n        if (this.clients) {\n            this.clients.add(ws);\n            ws.on(\"close\", ()=>{\n                this.clients.delete(ws);\n                if (this._shouldEmitClose && !this.clients.size) {\n                    process.nextTick(emitClose, this);\n                }\n            });\n        }\n        cb(ws, req);\n    }\n}\nmodule.exports = WebSocketServer;\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */ function addListeners(server, map) {\n    for (const event of Object.keys(map))server.on(event, map[event]);\n    return function removeListeners() {\n        for (const event of Object.keys(map)){\n            server.removeListener(event, map[event]);\n        }\n    };\n}\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */ function emitClose(server) {\n    server._state = CLOSED;\n    server.emit(\"close\");\n}\n/**\n * Handle socket errors.\n *\n * @private\n */ function socketOnError() {\n    this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */ function abortHandshake(socket, code, message, headers) {\n    //\n    // The socket is writable unless the user destroyed or ended it before calling\n    // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n    // error. Handling this does not make much sense as the worst that can happen\n    // is that some of the data written by the user might be discarded due to the\n    // call to `socket.end()` below, which triggers an `'error'` event that in\n    // turn causes the socket to be destroyed.\n    //\n    message = message || http.STATUS_CODES[code];\n    headers = {\n        Connection: \"close\",\n        \"Content-Type\": \"text/html\",\n        \"Content-Length\": Buffer.byteLength(message),\n        ...headers\n    };\n    socket.once(\"finish\", socket.destroy);\n    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map((h)=>`${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message);\n}\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */ function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n    if (server.listenerCount(\"wsClientError\")) {\n        const err = new Error(message);\n        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n        server.emit(\"wsClientError\", err, socket, req);\n    } else {\n        abortHandshake(socket, code, message);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5RUFBeUUsR0FFekU7QUFFQSxNQUFNQSxlQUFlQyxtQkFBT0EsQ0FBQztBQUM3QixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVFLE1BQU0sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVHLFVBQVUsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUUvQixNQUFNSSxZQUFZSixtQkFBT0EsQ0FBQztBQUMxQixNQUFNSyxvQkFBb0JMLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1NLGNBQWNOLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1PLFlBQVlQLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU0sRUFBRVEsSUFBSSxFQUFFQyxVQUFVLEVBQUUsR0FBR1QsbUJBQU9BLENBQUM7QUFFckMsTUFBTVUsV0FBVztBQUVqQixNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsU0FBUztBQUVmOzs7O0NBSUMsR0FDRCxNQUFNQyx3QkFBd0JmO0lBQzVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeUJDLEdBQ0RnQixZQUFZQyxPQUFPLEVBQUVDLFFBQVEsQ0FBRTtRQUM3QixLQUFLO1FBRUxELFVBQVU7WUFDUkUsWUFBWSxNQUFNLE9BQU87WUFDekJDLG9CQUFvQjtZQUNwQkMsbUJBQW1CO1lBQ25CQyxpQkFBaUI7WUFDakJDLGdCQUFnQjtZQUNoQkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLFNBQVM7WUFDVEMsUUFBUTtZQUNSQyxNQUFNO1lBQ05DLE1BQU07WUFDTkMsTUFBTTtZQUNOdEI7WUFDQSxHQUFHUyxPQUFPO1FBQ1o7UUFFQSxJQUNFLFFBQVNhLElBQUksSUFBSSxRQUFRLENBQUNiLFFBQVFVLE1BQU0s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LGdCQUFnQjtRQUNoQixrQkFBa0JDLE9BQU9DLFVBQVUsQ0FBQ3REO1FBQ3BDLEdBQUdILE9BQU87SUFDWjtJQUVBekIsT0FBT1csSUFBSSxDQUFDLFVBQVVYLE9BQU9xRCxPQUFPO0lBRXBDckQsT0FBT1YsR0FBRyxDQUNSLENBQUMsU0FBUyxFQUFFMkQsS0FBSyxDQUFDLEVBQUVqRyxLQUFLbUMsWUFBWSxDQUFDOEQsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUMvQzRCLE9BQU9DLElBQUksQ0FBQ3JELFNBQ1RrRCxHQUFHLENBQUMsQ0FBQ1EsSUFBTSxDQUFDLEVBQUVBLEVBQUUsRUFBRSxFQUFFMUQsT0FBTyxDQUFDMEQsRUFBRSxDQUFDLENBQUMsRUFDaENmLElBQUksQ0FBQyxVQUNSLGFBQ0F4QztBQUVOO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVNDLGtDQUFrQ3BELE1BQU0sRUFBRU8sR0FBRyxFQUFFZ0IsTUFBTSxFQUFFaUQsSUFBSSxFQUFFckIsT0FBTztJQUMzRSxJQUFJbkQsT0FBTzJHLGFBQWEsQ0FBQyxrQkFBa0I7UUFDekMsTUFBTS9DLE1BQU0sSUFBSTdCLE1BQU1vQjtRQUN0QnBCLE1BQU02RSxpQkFBaUIsQ0FBQ2hELEtBQUtSO1FBRTdCcEQsT0FBT2dCLElBQUksQ0FBQyxpQkFBaUI0QyxLQUFLckMsUUFBUWhCO0lBQzVDLE9BQU87UUFDTGdELGVBQWVoQyxRQUFRaUQsTUFBTXJCO0lBQy9CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93c0A4LjE0LjJfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanM/ZjQwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXgkXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBleHRlbnNpb24gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qgc3VicHJvdG9jb2wgPSByZXF1aXJlKCcuL3N1YnByb3RvY29sJyk7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuY29uc3QgeyBHVUlELCBrV2ViU29ja2V0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrZXlSZWdleCA9IC9eWysvMC05QS1aYS16XXsyMn09PSQvO1xuXG5jb25zdCBSVU5OSU5HID0gMDtcbmNvbnN0IENMT1NJTkcgPSAxO1xuY29uc3QgQ0xPU0VEID0gMjtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQgc2VydmVyLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXRTZXJ2ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYFdlYlNvY2tldFNlcnZlcmAgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmFja2xvZz01MTFdIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgcXVldWUgb2ZcbiAgICogICAgIHBlbmRpbmcgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnRUcmFja2luZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIHRyYWNrIGNsaWVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXSBBIGhvb2sgdG8gaGFuZGxlIHByb3RvY29sc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaG9zdF0gVGhlIGhvc3RuYW1lIHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxuICAgKiAgICAgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vU2VydmVyPWZhbHNlXSBFbmFibGUgbm8gc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhdGhdIEFjY2VwdCBvbmx5IGNvbm5lY3Rpb25zIG1hdGNoaW5nIHRoaXMgcGF0aFxuICAgKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPWZhbHNlXSBFbmFibGUvZGlzYWJsZVxuICAgKiAgICAgcGVybWVzc2FnZS1kZWZsYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3J0XSBUaGUgcG9ydCB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHsoaHR0cC5TZXJ2ZXJ8aHR0cHMuU2VydmVyKX0gW29wdGlvbnMuc2VydmVyXSBBIHByZS1jcmVhdGVkIEhUVFAvU1xuICAgKiAgICAgc2VydmVyIHRvIHVzZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZlcmlmeUNsaWVudF0gQSBob29rIHRvIHJlamVjdCBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5XZWJTb2NrZXQ9V2ViU29ja2V0XSBTcGVjaWZpZXMgdGhlIGBXZWJTb2NrZXRgXG4gICAqICAgICBjbGFzcyB0byB1c2UuIEl0IG11c3QgYmUgdGhlIGBXZWJTb2NrZXRgIGNsYXNzIG9yIGNsYXNzIHRoYXQgZXh0ZW5kcyBpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIEEgbGlzdGVuZXIgZm9yIHRoZSBgbGlzdGVuaW5nYCBldmVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBmYWxzZSxcbiAgICAgIGhhbmRsZVByb3RvY29sczogbnVsbCxcbiAgICAgIGNsaWVudFRyYWNraW5nOiB0cnVlLFxuICAgICAgdmVyaWZ5Q2xpZW50OiBudWxsLFxuICAgICAgbm9TZXJ2ZXI6IGZhbHNlLFxuICAgICAgYmFja2xvZzogbnVsbCwgLy8gdXNlIGRlZmF1bHQgKDUxMSBhcyBpbXBsZW1lbnRlZCBpbiBuZXQuanMpXG4gICAgICBzZXJ2ZXI6IG51bGwsXG4gICAgICBob3N0OiBudWxsLFxuICAgICAgcGF0aDogbnVsbCxcbiAgICAgIHBvcnQ6IG51bGwsXG4gICAgICBXZWJTb2NrZXQsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmIChcbiAgICAgIChvcHRpb25zLnBvcnQgPT0gbnVsbCAmJiAhb3B0aW9ucy5zZXJ2ZXIgJiYgIW9wdGlvbnMubm9TZXJ2ZXIpIHx8XG4gICAgICAob3B0aW9ucy5wb3J0ICE9IG51bGwgJiYgKG9wdGlvbnMuc2VydmVyIHx8IG9wdGlvbnMubm9TZXJ2ZXIpKSB8fFxuICAgICAgKG9wdGlvbnMuc2VydmVyICYmIG9wdGlvbnMubm9TZXJ2ZXIpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnT25lIGFuZCBvbmx5IG9uZSBvZiB0aGUgXCJwb3J0XCIsIFwic2VydmVyXCIsIG9yIFwibm9TZXJ2ZXJcIiBvcHRpb25zICcgK1xuICAgICAgICAgICdtdXN0IGJlIHNwZWNpZmllZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucG9ydCAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9zZXJ2ZXIgPSBodHRwLmNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IGh0dHAuU1RBVFVTX0NPREVTWzQyNl07XG5cbiAgICAgICAgcmVzLndyaXRlSGVhZCg0MjYsIHtcbiAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBib2R5Lmxlbmd0aCxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nXG4gICAgICAgIH0pO1xuICAgICAgICByZXMuZW5kKGJvZHkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXJ2ZXIubGlzdGVuKFxuICAgICAgICBvcHRpb25zLnBvcnQsXG4gICAgICAgIG9wdGlvbnMuaG9zdCxcbiAgICAgICAgb3B0aW9ucy5iYWNrbG9nLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VydmVyKSB7XG4gICAgICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2VydmVyKSB7XG4gICAgICBjb25zdCBlbWl0Q29ubmVjdGlvbiA9IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdjb25uZWN0aW9uJyk7XG5cbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IGFkZExpc3RlbmVycyh0aGlzLl9zZXJ2ZXIsIHtcbiAgICAgICAgbGlzdGVuaW5nOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAnbGlzdGVuaW5nJyksXG4gICAgICAgIGVycm9yOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAnZXJyb3InKSxcbiAgICAgICAgdXBncmFkZTogKHJlcSwgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBlbWl0Q29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID09PSB0cnVlKSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50VHJhY2tpbmcpIHtcbiAgICAgIHRoaXMuY2xpZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fc3RhdGUgPSBSVU5OSU5HO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kIGFkZHJlc3MsIHRoZSBhZGRyZXNzIGZhbWlseSBuYW1lLCBhbmQgcG9ydCBvZiB0aGUgc2VydmVyXG4gICAqIGFzIHJlcG9ydGVkIGJ5IHRoZSBvcGVyYXRpbmcgc3lzdGVtIGlmIGxpc3RlbmluZyBvbiBhbiBJUCBzb2NrZXQuXG4gICAqIElmIHRoZSBzZXJ2ZXIgaXMgbGlzdGVuaW5nIG9uIGEgcGlwZSBvciBVTklYIGRvbWFpbiBzb2NrZXQsIHRoZSBuYW1lIGlzXG4gICAqIHJldHVybmVkIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoT2JqZWN0fFN0cmluZ3xudWxsKX0gVGhlIGFkZHJlc3Mgb2YgdGhlIHNlcnZlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRyZXNzKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBvcGVyYXRpbmcgaW4gXCJub1NlcnZlclwiIG1vZGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3NlcnZlcikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX3NlcnZlci5hZGRyZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgc2VydmVyIGZyb20gYWNjZXB0aW5nIG5ldyBjb25uZWN0aW9ucyBhbmQgZW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIHdoZW4gYWxsIGV4aXN0aW5nIGNvbm5lY3Rpb25zIGFyZSBjbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgdGhlIGAnY2xvc2UnYCBldmVudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjYikge1xuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0VEKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdGhpcy5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICBjYihuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgbm90IHJ1bm5pbmcnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNiKSB0aGlzLm9uY2UoJ2Nsb3NlJywgY2IpO1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TSU5HKSByZXR1cm47XG4gICAgdGhpcy5fc3RhdGUgPSBDTE9TSU5HO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlciB8fCB0aGlzLm9wdGlvbnMuc2VydmVyKSB7XG4gICAgICBpZiAodGhpcy5fc2VydmVyKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzZXJ2ZXIgPSB0aGlzLl9zZXJ2ZXI7XG5cbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcblxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBIVFRQL1Mgc2VydmVyIHdhcyBjcmVhdGVkIGludGVybmFsbHkuIENsb3NlIGl0LCBhbmQgcmVseSBvbiBpdHNcbiAgICAgIC8vIGAnY2xvc2UnYCBldmVudC5cbiAgICAgIC8vXG4gICAgICBzZXJ2ZXIuY2xvc2UoKCkgPT4ge1xuICAgICAgICBlbWl0Q2xvc2UodGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VlIGlmIGEgZ2l2ZW4gcmVxdWVzdCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGlzIHNlcnZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFJlcXVlc3Qgb2JqZWN0IHRvIGluc3BlY3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSByZXF1ZXN0IGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2hvdWxkSGFuZGxlKHJlcSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGF0aCkge1xuICAgICAgY29uc3QgaW5kZXggPSByZXEudXJsLmluZGV4T2YoJz8nKTtcbiAgICAgIGNvbnN0IHBhdGhuYW1lID0gaW5kZXggIT09IC0xID8gcmVxLnVybC5zbGljZSgwLCBpbmRleCkgOiByZXEudXJsO1xuXG4gICAgICBpZiAocGF0aG5hbWUgIT09IHRoaXMub3B0aW9ucy5wYXRoKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgSFRUUCBVcGdyYWRlIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGNiKSB7XG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgY29uc3Qga2V5ID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J107XG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG5cbiAgICBpZiAocmVxLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBIVFRQIG1ldGhvZCc7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwNSwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlcS5oZWFkZXJzLnVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFrZXkgfHwgIWtleVJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1LZXkgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAhPT0gOCAmJiB2ZXJzaW9uICE9PSAxMykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1WZXJzaW9uIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNob3VsZEhhbmRsZShyZXEpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0UHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdG9jb2xzID0gc3VicHJvdG9jb2wucGFyc2Uoc2VjV2ViU29ja2V0UHJvdG9jb2wpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICBzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZlcnMgPSBleHRlbnNpb24ucGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdJbnZhbGlkIG9yIHVuYWNjZXB0YWJsZSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXG4gICAgICAgIHJlcVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbywgKHZlcmlmaWVkLCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKFxuICAgICAgICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBjYlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvKSkgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShleHRlbnNpb25zLCBrZXksIHByb3RvY29scywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXG4gICAqIEBwYXJhbSB7U2V0fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDUwMyk7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtkaWdlc3R9YFxuICAgIF07XG5cbiAgICBjb25zdCB3cyA9IG5ldyB0aGlzLm9wdGlvbnMuV2ViU29ja2V0KG51bGwpO1xuXG4gICAgaWYgKHByb3RvY29scy5zaXplKSB7XG4gICAgICAvL1xuICAgICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIHByb3RvY29sIHNlbGVjdGlvbiBoYW5kbGVyLlxuICAgICAgLy9cbiAgICAgIGNvbnN0IHByb3RvY29sID0gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29sc1xuICAgICAgICA/IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2xzLCByZXEpXG4gICAgICAgIDogcHJvdG9jb2xzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAgICAgaWYgKHByb3RvY29sKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJHtwcm90b2NvbH1gKTtcbiAgICAgICAgd3MuX3Byb3RvY29sID0gcHJvdG9jb2w7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0ucGFyYW1zO1xuICAgICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uZm9ybWF0KHtcbiAgICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBbcGFyYW1zXVxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcbiAgICAgIHdzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxuICAgIC8vXG4gICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgaGVhZGVycywgcmVxKTtcblxuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdCgnXFxyXFxuJykuam9pbignXFxyXFxuJykpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHdzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiB0aGlzLm9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEVtaXRDbG9zZSAmJiAhdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuICogICAgIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBzb2NrZXQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIC8vXG4gIC8vIFRoZSBzb2NrZXQgaXMgd3JpdGFibGUgdW5sZXNzIHRoZSB1c2VyIGRlc3Ryb3llZCBvciBlbmRlZCBpdCBiZWZvcmUgY2FsbGluZ1xuICAvLyBgc2VydmVyLmhhbmRsZVVwZ3JhZGUoKWAgb3IgaW4gdGhlIGB2ZXJpZnlDbGllbnRgIGZ1bmN0aW9uLCB3aGljaCBpcyBhIHVzZXJcbiAgLy8gZXJyb3IuIEhhbmRsaW5nIHRoaXMgZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIGFzIHRoZSB3b3JzdCB0aGF0IGNhbiBoYXBwZW5cbiAgLy8gaXMgdGhhdCBzb21lIG9mIHRoZSBkYXRhIHdyaXR0ZW4gYnkgdGhlIHVzZXIgbWlnaHQgYmUgZGlzY2FyZGVkIGR1ZSB0byB0aGVcbiAgLy8gY2FsbCB0byBgc29ja2V0LmVuZCgpYCBiZWxvdywgd2hpY2ggdHJpZ2dlcnMgYW4gYCdlcnJvcidgIGV2ZW50IHRoYXQgaW5cbiAgLy8gdHVybiBjYXVzZXMgdGhlIHNvY2tldCB0byBiZSBkZXN0cm95ZWQuXG4gIC8vXG4gIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGh0dHAuU1RBVFVTX0NPREVTW2NvZGVdO1xuICBoZWFkZXJzID0ge1xuICAgIENvbm5lY3Rpb246ICdjbG9zZScsXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgIC4uLmhlYWRlcnNcbiAgfTtcblxuICBzb2NrZXQub25jZSgnZmluaXNoJywgc29ja2V0LmRlc3Ryb3kpO1xuXG4gIHNvY2tldC5lbmQoXG4gICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICdcXHJcXG5cXHJcXG4nICtcbiAgICAgIG1lc3NhZ2VcbiAgKTtcbn1cblxuLyoqXG4gKiBFbWl0IGEgYCd3c0NsaWVudEVycm9yJ2AgZXZlbnQgb24gYSBgV2ViU29ja2V0U2VydmVyYCBpZiB0aGVyZSBpcyBhdCBsZWFzdFxuICogb25lIGxpc3RlbmVyIGZvciBpdCwgb3RoZXJ3aXNlIGNhbGwgYGFib3J0SGFuZHNoYWtlKClgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0U2VydmVyfSBzZXJ2ZXIgVGhlIFdlYlNvY2tldCBzZXJ2ZXJcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHNlcnZlciwgcmVxLCBzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHNlcnZlci5saXN0ZW5lckNvdW50KCd3c0NsaWVudEVycm9yJykpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IpO1xuXG4gICAgc2VydmVyLmVtaXQoJ3dzQ2xpZW50RXJyb3InLCBlcnIsIHNvY2tldCwgcmVxKTtcbiAgfSBlbHNlIHtcbiAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsImh0dHAiLCJEdXBsZXgiLCJjcmVhdGVIYXNoIiwiZXh0ZW5zaW9uIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJzdWJwcm90b2NvbCIsIldlYlNvY2tldCIsIkdVSUQiLCJrV2ViU29ja2V0Iiwia2V5UmVnZXgiLCJSVU5OSU5HIiwiQ0xPU0lORyIsIkNMT1NFRCIsIldlYlNvY2tldFNlcnZlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNhbGxiYWNrIiwibWF4UGF5bG9hZCIsInNraXBVVEY4VmFsaWRhdGlvbiIsInBlck1lc3NhZ2VEZWZsYXRlIiwiaGFuZGxlUHJvdG9jb2xzIiwiY2xpZW50VHJhY2tpbmciLCJ2ZXJpZnlDbGllbnQiLCJub1NlcnZlciIsImJhY2tsb2ciLCJzZXJ2ZXIiLCJob3N0IiwicGF0aCIsInBvcnQiLCJUeXBlRXJyb3IiLCJfc2VydmVyIiwiY3JlYXRlU2VydmVyIiwicmVxIiwicmVzIiwiYm9keSIsIlNUQVRVU19DT0RFUyIsIndyaXRlSGVhZCIsImxlbmd0aCIsImVuZCIsImxpc3RlbiIsImVtaXRDb25uZWN0aW9uIiwiZW1pdCIsImJpbmQiLCJfcmVtb3ZlTGlzdGVuZXJzIiwiYWRkTGlzdGVuZXJzIiwibGlzdGVuaW5nIiwiZXJyb3IiLCJ1cGdyYWRlIiwic29ja2V0IiwiaGVhZCIsImhhbmRsZVVwZ3JhZGUiLCJjbGllbnRzIiwiU2V0IiwiX3Nob3VsZEVtaXRDbG9zZSIsIl9zdGF0ZSIsImFkZHJlc3MiLCJFcnJvciIsImNsb3NlIiwiY2IiLCJvbmNlIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiZW1pdENsb3NlIiwic2l6ZSIsInNob3VsZEhhbmRsZSIsImluZGV4IiwidXJsIiwiaW5kZXhPZiIsInBhdGhuYW1lIiwic2xpY2UiLCJvbiIsInNvY2tldE9uRXJyb3IiLCJrZXkiLCJoZWFkZXJzIiwidmVyc2lvbiIsIm1ldGhvZCIsIm1lc3NhZ2UiLCJhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IiLCJ0b0xvd2VyQ2FzZSIsInRlc3QiLCJhYm9ydEhhbmRzaGFrZSIsInNlY1dlYlNvY2tldFByb3RvY29sIiwicHJvdG9jb2xzIiwidW5kZWZpbmVkIiwicGFyc2UiLCJlcnIiLCJzZWNXZWJTb2NrZXRFeHRlbnNpb25zIiwiZXh0ZW5zaW9ucyIsIm9mZmVycyIsImV4dGVuc2lvbk5hbWUiLCJhY2NlcHQiLCJpbmZvIiwib3JpZ2luIiwic2VjdXJlIiwiYXV0aG9yaXplZCIsImVuY3J5cHRlZCIsInZlcmlmaWVkIiwiY29kZSIsImNvbXBsZXRlVXBncmFkZSIsInJlYWRhYmxlIiwid3JpdGFibGUiLCJkZXN0cm95IiwiZGlnZXN0IiwidXBkYXRlIiwid3MiLCJwcm90b2NvbCIsInZhbHVlcyIsIm5leHQiLCJ2YWx1ZSIsInB1c2giLCJfcHJvdG9jb2wiLCJwYXJhbXMiLCJmb3JtYXQiLCJfZXh0ZW5zaW9ucyIsIndyaXRlIiwiY29uY2F0Iiwiam9pbiIsInJlbW92ZUxpc3RlbmVyIiwic2V0U29ja2V0IiwiYWRkIiwiZGVsZXRlIiwibW9kdWxlIiwiZXhwb3J0cyIsIm1hcCIsImV2ZW50IiwiT2JqZWN0Iiwia2V5cyIsInJlbW92ZUxpc3RlbmVycyIsIkNvbm5lY3Rpb24iLCJCdWZmZXIiLCJieXRlTGVuZ3RoIiwiaCIsImxpc3RlbmVyQ291bnQiLCJjYXB0dXJlU3RhY2tUcmFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/websocket.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/websocket.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\" }] */ \nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Duplex, Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/sender.js\");\nconst { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/constants.js\");\nconst { EventTarget: { addEventListener, removeEventListener } } = __webpack_require__(/*! ./event-target */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/buffer-util.js\");\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol(\"kAborted\");\nconst protocolVersions = [\n    8,\n    13\n];\nconst readyStates = [\n    \"CONNECTING\",\n    \"OPEN\",\n    \"CLOSING\",\n    \"CLOSED\"\n];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */ class WebSocket extends EventEmitter {\n    /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */ constructor(address, protocols, options){\n        super();\n        this._binaryType = BINARY_TYPES[0];\n        this._closeCode = 1006;\n        this._closeFrameReceived = false;\n        this._closeFrameSent = false;\n        this._closeMessage = EMPTY_BUFFER;\n        this._closeTimer = null;\n        this._extensions = {};\n        this._paused = false;\n        this._protocol = \"\";\n        this._readyState = WebSocket.CONNECTING;\n        this._receiver = null;\n        this._sender = null;\n        this._socket = null;\n        if (address !== null) {\n            this._bufferedAmount = 0;\n            this._isServer = false;\n            this._redirects = 0;\n            if (protocols === undefined) {\n                protocols = [];\n            } else if (!Array.isArray(protocols)) {\n                if (typeof protocols === \"object\" && protocols !== null) {\n                    options = protocols;\n                    protocols = [];\n                } else {\n                    protocols = [\n                        protocols\n                    ];\n                }\n            }\n            initAsClient(this, address, protocols, options);\n        } else {\n            this._isServer = true;\n        }\n    }\n    /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */ get binaryType() {\n        return this._binaryType;\n    }\n    set binaryType(type) {\n        if (!BINARY_TYPES.includes(type)) return;\n        this._binaryType = type;\n        //\n        // Allow to change `binaryType` on the fly.\n        //\n        if (this._receiver) this._receiver._binaryType = type;\n    }\n    /**\n   * @type {Number}\n   */ get bufferedAmount() {\n        if (!this._socket) return this._bufferedAmount;\n        return this._socket._writableState.length + this._sender._bufferedBytes;\n    }\n    /**\n   * @type {String}\n   */ get extensions() {\n        return Object.keys(this._extensions).join();\n    }\n    /**\n   * @type {Boolean}\n   */ get isPaused() {\n        return this._paused;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onclose() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onerror() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onopen() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onmessage() {\n        return null;\n    }\n    /**\n   * @type {String}\n   */ get protocol() {\n        return this._protocol;\n    }\n    /**\n   * @type {Number}\n   */ get readyState() {\n        return this._readyState;\n    }\n    /**\n   * @type {String}\n   */ get url() {\n        return this._url;\n    }\n    /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */ setSocket(socket, head, options) {\n        const receiver = new Receiver({\n            binaryType: this.binaryType,\n            extensions: this._extensions,\n            isServer: this._isServer,\n            maxPayload: options.maxPayload,\n            skipUTF8Validation: options.skipUTF8Validation\n        });\n        this._sender = new Sender(socket, this._extensions, options.generateMask);\n        this._receiver = receiver;\n        this._socket = socket;\n        receiver[kWebSocket] = this;\n        socket[kWebSocket] = this;\n        receiver.on(\"conclude\", receiverOnConclude);\n        receiver.on(\"drain\", receiverOnDrain);\n        receiver.on(\"error\", receiverOnError);\n        receiver.on(\"message\", receiverOnMessage);\n        receiver.on(\"ping\", receiverOnPing);\n        receiver.on(\"pong\", receiverOnPong);\n        //\n        // These methods may not be available if `socket` is just a `Duplex`.\n        //\n        if (socket.setTimeout) socket.setTimeout(0);\n        if (socket.setNoDelay) socket.setNoDelay();\n        if (head.length > 0) socket.unshift(head);\n        socket.on(\"close\", socketOnClose);\n        socket.on(\"data\", socketOnData);\n        socket.on(\"end\", socketOnEnd);\n        socket.on(\"error\", socketOnError);\n        this._readyState = WebSocket.OPEN;\n        this.emit(\"open\");\n    }\n    /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */ emitClose() {\n        if (!this._socket) {\n            this._readyState = WebSocket.CLOSED;\n            this.emit(\"close\", this._closeCode, this._closeMessage);\n            return;\n        }\n        if (this._extensions[PerMessageDeflate.extensionName]) {\n            this._extensions[PerMessageDeflate.extensionName].cleanup();\n        }\n        this._receiver.removeAllListeners();\n        this._readyState = WebSocket.CLOSED;\n        this.emit(\"close\", this._closeCode, this._closeMessage);\n    }\n    /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */ close(code, data) {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            const msg = \"WebSocket was closed before the connection was established\";\n            abortHandshake(this, this._req, msg);\n            return;\n        }\n        if (this.readyState === WebSocket.CLOSING) {\n            if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n                this._socket.end();\n            }\n            return;\n        }\n        this._readyState = WebSocket.CLOSING;\n        this._sender.close(code, data, !this._isServer, (err)=>{\n            //\n            // This error is handled by the `'error'` listener on the socket. We only\n            // want to know if the close frame has been sent here.\n            //\n            if (err) return;\n            this._closeFrameSent = true;\n            if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n                this._socket.end();\n            }\n        });\n        //\n        // Specify a timeout for the closing handshake to complete.\n        //\n        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n    }\n    /**\n   * Pause the socket.\n   *\n   * @public\n   */ pause() {\n        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n            return;\n        }\n        this._paused = true;\n        this._socket.pause();\n    }\n    /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */ ping(data, mask, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n            cb = data;\n            data = mask = undefined;\n        } else if (typeof mask === \"function\") {\n            cb = mask;\n            mask = undefined;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */ pong(data, mask, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n            cb = data;\n            data = mask = undefined;\n        } else if (typeof mask === \"function\") {\n            cb = mask;\n            mask = undefined;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n   * Resume the socket.\n   *\n   * @public\n   */ resume() {\n        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n            return;\n        }\n        this._paused = false;\n        if (!this._receiver._writableState.needDrain) this._socket.resume();\n    }\n    /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */ send(data, options, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof options === \"function\") {\n            cb = options;\n            options = {};\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        const opts = {\n            binary: typeof data !== \"string\",\n            mask: !this._isServer,\n            compress: true,\n            fin: true,\n            ...options\n        };\n        if (!this._extensions[PerMessageDeflate.extensionName]) {\n            opts.compress = false;\n        }\n        this._sender.send(data || EMPTY_BUFFER, opts, cb);\n    }\n    /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */ terminate() {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            const msg = \"WebSocket was closed before the connection was established\";\n            abortHandshake(this, this._req, msg);\n            return;\n        }\n        if (this._socket) {\n            this._readyState = WebSocket.CLOSING;\n            this._socket.destroy();\n        }\n    }\n}\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CONNECTING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CONNECTING\")\n});\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CONNECTING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CONNECTING\")\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"OPEN\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"OPEN\")\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"OPEN\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"OPEN\")\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CLOSING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSING\")\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CLOSING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSING\")\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CLOSED\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSED\")\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CLOSED\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSED\")\n});\n[\n    \"binaryType\",\n    \"bufferedAmount\",\n    \"extensions\",\n    \"isPaused\",\n    \"protocol\",\n    \"readyState\",\n    \"url\"\n].forEach((property)=>{\n    Object.defineProperty(WebSocket.prototype, property, {\n        enumerable: true\n    });\n});\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n[\n    \"open\",\n    \"error\",\n    \"close\",\n    \"message\"\n].forEach((method)=>{\n    Object.defineProperty(WebSocket.prototype, `on${method}`, {\n        enumerable: true,\n        get () {\n            for (const listener of this.listeners(method)){\n                if (listener[kForOnEventAttribute]) return listener[kListener];\n            }\n            return null;\n        },\n        set (handler) {\n            for (const listener of this.listeners(method)){\n                if (listener[kForOnEventAttribute]) {\n                    this.removeListener(method, listener);\n                    break;\n                }\n            }\n            if (typeof handler !== \"function\") return;\n            this.addEventListener(method, handler, {\n                [kForOnEventAttribute]: true\n            });\n        }\n    });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */ function initAsClient(websocket, address, protocols, options) {\n    const opts = {\n        protocolVersion: protocolVersions[1],\n        maxPayload: 100 * 1024 * 1024,\n        skipUTF8Validation: false,\n        perMessageDeflate: true,\n        followRedirects: false,\n        maxRedirects: 10,\n        ...options,\n        createConnection: undefined,\n        socketPath: undefined,\n        hostname: undefined,\n        protocol: undefined,\n        timeout: undefined,\n        method: \"GET\",\n        host: undefined,\n        path: undefined,\n        port: undefined\n    };\n    if (!protocolVersions.includes(opts.protocolVersion)) {\n        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(\", \")})`);\n    }\n    let parsedUrl;\n    if (address instanceof URL) {\n        parsedUrl = address;\n    } else {\n        try {\n            parsedUrl = new URL(address);\n        } catch (e) {\n            throw new SyntaxError(`Invalid URL: ${address}`);\n        }\n    }\n    if (parsedUrl.protocol === \"http:\") {\n        parsedUrl.protocol = \"ws:\";\n    } else if (parsedUrl.protocol === \"https:\") {\n        parsedUrl.protocol = \"wss:\";\n    }\n    websocket._url = parsedUrl.href;\n    const isSecure = parsedUrl.protocol === \"wss:\";\n    const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\n    let invalidUrlMessage;\n    if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\n        invalidUrlMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' + '\"http:\", \"https\", or \"ws+unix:\"';\n    } else if (isIpcUrl && !parsedUrl.pathname) {\n        invalidUrlMessage = \"The URL's pathname is empty\";\n    } else if (parsedUrl.hash) {\n        invalidUrlMessage = \"The URL contains a fragment identifier\";\n    }\n    if (invalidUrlMessage) {\n        const err = new SyntaxError(invalidUrlMessage);\n        if (websocket._redirects === 0) {\n            throw err;\n        } else {\n            emitErrorAndClose(websocket, err);\n            return;\n        }\n    }\n    const defaultPort = isSecure ? 443 : 80;\n    const key = randomBytes(16).toString(\"base64\");\n    const request = isSecure ? https.request : http.request;\n    const protocolSet = new Set();\n    let perMessageDeflate;\n    opts.createConnection = isSecure ? tlsConnect : netConnect;\n    opts.defaultPort = opts.defaultPort || defaultPort;\n    opts.port = parsedUrl.port || defaultPort;\n    opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n    opts.headers = {\n        ...opts.headers,\n        \"Sec-WebSocket-Version\": opts.protocolVersion,\n        \"Sec-WebSocket-Key\": key,\n        Connection: \"Upgrade\",\n        Upgrade: \"websocket\"\n    };\n    opts.path = parsedUrl.pathname + parsedUrl.search;\n    opts.timeout = opts.handshakeTimeout;\n    if (opts.perMessageDeflate) {\n        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n        opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n            [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n        });\n    }\n    if (protocols.length) {\n        for (const protocol of protocols){\n            if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n                throw new SyntaxError(\"An invalid or duplicated subprotocol was specified\");\n            }\n            protocolSet.add(protocol);\n        }\n        opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n    }\n    if (opts.origin) {\n        if (opts.protocolVersion < 13) {\n            opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n        } else {\n            opts.headers.Origin = opts.origin;\n        }\n    }\n    if (parsedUrl.username || parsedUrl.password) {\n        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n    }\n    if (isIpcUrl) {\n        const parts = opts.path.split(\":\");\n        opts.socketPath = parts[0];\n        opts.path = parts[1];\n    }\n    let req;\n    if (opts.followRedirects) {\n        if (websocket._redirects === 0) {\n            websocket._originalIpc = isIpcUrl;\n            websocket._originalSecure = isSecure;\n            websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n            const headers = options && options.headers;\n            //\n            // Shallow copy the user provided options so that headers can be changed\n            // without mutating the original object.\n            //\n            options = {\n                ...options,\n                headers: {}\n            };\n            if (headers) {\n                for (const [key, value] of Object.entries(headers)){\n                    options.headers[key.toLowerCase()] = value;\n                }\n            }\n        } else if (websocket.listenerCount(\"redirect\") === 0) {\n            const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n            if (!isSameHost || websocket._originalSecure && !isSecure) {\n                //\n                // Match curl 7.77.0 behavior and drop the following headers. These\n                // headers are also dropped when following a redirect to a subdomain.\n                //\n                delete opts.headers.authorization;\n                delete opts.headers.cookie;\n                if (!isSameHost) delete opts.headers.host;\n                opts.auth = undefined;\n            }\n        }\n        //\n        // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n        // If the `Authorization` header is set, then there is nothing to do as it\n        // will take precedence.\n        //\n        if (opts.auth && !options.headers.authorization) {\n            options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n        }\n        req = websocket._req = request(opts);\n        if (websocket._redirects) {\n            //\n            // Unlike what is done for the `'upgrade'` event, no early exit is\n            // triggered here if the user calls `websocket.close()` or\n            // `websocket.terminate()` from a listener of the `'redirect'` event. This\n            // is because the user can also call `request.destroy()` with an error\n            // before calling `websocket.close()` or `websocket.terminate()` and this\n            // would result in an error being emitted on the `request` object with no\n            // `'error'` event listeners attached.\n            //\n            websocket.emit(\"redirect\", websocket.url, req);\n        }\n    } else {\n        req = websocket._req = request(opts);\n    }\n    if (opts.timeout) {\n        req.on(\"timeout\", ()=>{\n            abortHandshake(websocket, req, \"Opening handshake has timed out\");\n        });\n    }\n    req.on(\"error\", (err)=>{\n        if (req === null || req[kAborted]) return;\n        req = websocket._req = null;\n        emitErrorAndClose(websocket, err);\n    });\n    req.on(\"response\", (res)=>{\n        const location = res.headers.location;\n        const statusCode = res.statusCode;\n        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n            if (++websocket._redirects > opts.maxRedirects) {\n                abortHandshake(websocket, req, \"Maximum redirects exceeded\");\n                return;\n            }\n            req.abort();\n            let addr;\n            try {\n                addr = new URL(location, address);\n            } catch (e) {\n                const err = new SyntaxError(`Invalid URL: ${location}`);\n                emitErrorAndClose(websocket, err);\n                return;\n            }\n            initAsClient(websocket, addr, protocols, options);\n        } else if (!websocket.emit(\"unexpected-response\", req, res)) {\n            abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n        }\n    });\n    req.on(\"upgrade\", (res, socket, head)=>{\n        websocket.emit(\"upgrade\", res);\n        //\n        // The user may have closed the connection from a listener of the\n        // `'upgrade'` event.\n        //\n        if (websocket.readyState !== WebSocket.CONNECTING) return;\n        req = websocket._req = null;\n        if (res.headers.upgrade.toLowerCase() !== \"websocket\") {\n            abortHandshake(websocket, socket, \"Invalid Upgrade header\");\n            return;\n        }\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        if (res.headers[\"sec-websocket-accept\"] !== digest) {\n            abortHandshake(websocket, socket, \"Invalid Sec-WebSocket-Accept header\");\n            return;\n        }\n        const serverProt = res.headers[\"sec-websocket-protocol\"];\n        let protError;\n        if (serverProt !== undefined) {\n            if (!protocolSet.size) {\n                protError = \"Server sent a subprotocol but none was requested\";\n            } else if (!protocolSet.has(serverProt)) {\n                protError = \"Server sent an invalid subprotocol\";\n            }\n        } else if (protocolSet.size) {\n            protError = \"Server sent no subprotocol\";\n        }\n        if (protError) {\n            abortHandshake(websocket, socket, protError);\n            return;\n        }\n        if (serverProt) websocket._protocol = serverProt;\n        const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n        if (secWebSocketExtensions !== undefined) {\n            if (!perMessageDeflate) {\n                const message = \"Server sent a Sec-WebSocket-Extensions header but no extension \" + \"was requested\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            let extensions;\n            try {\n                extensions = parse(secWebSocketExtensions);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Extensions header\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            const extensionNames = Object.keys(extensions);\n            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n                const message = \"Server indicated an extension that was not requested\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            try {\n                perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Extensions header\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n        websocket.setSocket(socket, head, {\n            generateMask: opts.generateMask,\n            maxPayload: opts.maxPayload,\n            skipUTF8Validation: opts.skipUTF8Validation\n        });\n    });\n    if (opts.finishRequest) {\n        opts.finishRequest(req, websocket);\n    } else {\n        req.end();\n    }\n}\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */ function emitErrorAndClose(websocket, err) {\n    websocket._readyState = WebSocket.CLOSING;\n    websocket.emit(\"error\", err);\n    websocket.emitClose();\n}\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */ function netConnect(options) {\n    options.path = options.socketPath;\n    return net.connect(options);\n}\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */ function tlsConnect(options) {\n    options.path = undefined;\n    if (!options.servername && options.servername !== \"\") {\n        options.servername = net.isIP(options.host) ? \"\" : options.host;\n    }\n    return tls.connect(options);\n}\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */ function abortHandshake(websocket, stream, message) {\n    websocket._readyState = WebSocket.CLOSING;\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshake);\n    if (stream.setHeader) {\n        stream[kAborted] = true;\n        stream.abort();\n        if (stream.socket && !stream.socket.destroyed) {\n            //\n            // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n            // called after the request completed. See\n            // https://github.com/websockets/ws/issues/1869.\n            //\n            stream.socket.destroy();\n        }\n        process.nextTick(emitErrorAndClose, websocket, err);\n    } else {\n        stream.destroy(err);\n        stream.once(\"error\", websocket.emit.bind(websocket, \"error\"));\n        stream.once(\"close\", websocket.emitClose.bind(websocket));\n    }\n}\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */ function sendAfterClose(websocket, data, cb) {\n    if (data) {\n        const length = toBuffer(data).length;\n        //\n        // The `_bufferedAmount` property is used only when the peer is a client and\n        // the opening handshake fails. Under these circumstances, in fact, the\n        // `setSocket()` method is not called, so the `_socket` and `_sender`\n        // properties are set to `null`.\n        //\n        if (websocket._socket) websocket._sender._bufferedBytes += length;\n        else websocket._bufferedAmount += length;\n    }\n    if (cb) {\n        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n        process.nextTick(cb, err);\n    }\n}\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */ function receiverOnConclude(code, reason) {\n    const websocket = this[kWebSocket];\n    websocket._closeFrameReceived = true;\n    websocket._closeMessage = reason;\n    websocket._closeCode = code;\n    if (websocket._socket[kWebSocket] === undefined) return;\n    websocket._socket.removeListener(\"data\", socketOnData);\n    process.nextTick(resume, websocket._socket);\n    if (code === 1005) websocket.close();\n    else websocket.close(code, reason);\n}\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */ function receiverOnDrain() {\n    const websocket = this[kWebSocket];\n    if (!websocket.isPaused) websocket._socket.resume();\n}\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */ function receiverOnError(err) {\n    const websocket = this[kWebSocket];\n    if (websocket._socket[kWebSocket] !== undefined) {\n        websocket._socket.removeListener(\"data\", socketOnData);\n        //\n        // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n        // https://github.com/websockets/ws/issues/1940.\n        //\n        process.nextTick(resume, websocket._socket);\n        websocket.close(err[kStatusCode]);\n    }\n    websocket.emit(\"error\", err);\n}\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */ function receiverOnFinish() {\n    this[kWebSocket].emitClose();\n}\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */ function receiverOnMessage(data, isBinary) {\n    this[kWebSocket].emit(\"message\", data, isBinary);\n}\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */ function receiverOnPing(data) {\n    const websocket = this[kWebSocket];\n    websocket.pong(data, !websocket._isServer, NOOP);\n    websocket.emit(\"ping\", data);\n}\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */ function receiverOnPong(data) {\n    this[kWebSocket].emit(\"pong\", data);\n}\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */ function resume(stream) {\n    stream.resume();\n}\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */ function socketOnClose() {\n    const websocket = this[kWebSocket];\n    this.removeListener(\"close\", socketOnClose);\n    this.removeListener(\"data\", socketOnData);\n    this.removeListener(\"end\", socketOnEnd);\n    websocket._readyState = WebSocket.CLOSING;\n    let chunk;\n    //\n    // The close frame might not have been received or the `'end'` event emitted,\n    // for example, if the socket was destroyed due to an error. Ensure that the\n    // `receiver` stream is closed after writing any remaining buffered data to\n    // it. If the readable side of the socket is in flowing mode then there is no\n    // buffered data as everything has been already written and `readable.read()`\n    // will return `null`. If instead, the socket is paused, any possible buffered\n    // data will be read as a single chunk.\n    //\n    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n        websocket._receiver.write(chunk);\n    }\n    websocket._receiver.end();\n    this[kWebSocket] = undefined;\n    clearTimeout(websocket._closeTimer);\n    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n        websocket.emitClose();\n    } else {\n        websocket._receiver.on(\"error\", receiverOnFinish);\n        websocket._receiver.on(\"finish\", receiverOnFinish);\n    }\n}\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function socketOnData(chunk) {\n    if (!this[kWebSocket]._receiver.write(chunk)) {\n        this.pause();\n    }\n}\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */ function socketOnEnd() {\n    const websocket = this[kWebSocket];\n    websocket._readyState = WebSocket.CLOSING;\n    websocket._receiver.end();\n    this.end();\n}\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */ function socketOnError() {\n    const websocket = this[kWebSocket];\n    this.removeListener(\"error\", socketOnError);\n    this.on(\"error\", NOOP);\n    if (websocket) {\n        websocket._readyState = WebSocket.CLOSING;\n        this.destroy();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBLGtGQUFrRixHQUVsRjtBQUVBLE1BQU1BLGVBQWVDLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1HLE1BQU1ILG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1JLE1BQU1KLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU0sRUFBRUssV0FBVyxFQUFFQyxVQUFVLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDNUMsTUFBTSxFQUFFTyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUNyQyxNQUFNLEVBQUVTLEdBQUcsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQztBQUV4QixNQUFNVSxvQkFBb0JWLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1XLFdBQVdYLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1ZLFNBQVNaLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFDSmEsWUFBWSxFQUNaQyxZQUFZLEVBQ1pDLElBQUksRUFDSkMsb0JBQW9CLEVBQ3BCQyxTQUFTLEVBQ1RDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxJQUFJLEVBQ0wsR0FBR3BCLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUNKcUIsYUFBYSxFQUFFQyxnQkFBZ0IsRUFBRUMsbUJBQW1CLEVBQUUsRUFDdkQsR0FBR3ZCLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFd0IsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR3pCLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRTBCLFFBQVEsRUFBRSxHQUFHMUIsbUJBQU9BLENBQUM7QUFFN0IsTUFBTTJCLGVBQWUsS0FBSztBQUMxQixNQUFNQyxXQUFXQyxPQUFPO0FBQ3hC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ekYsVUFBVXZHLFNBQVMsQ0FBQ21FLEdBQUc7SUFFdkIsSUFBSSxDQUFDakcsV0FBVyxHQUFHb0M7SUFFbkIrTCxhQUFhOUYsVUFBVTdHLFdBQVc7SUFFbEMsSUFDRTZHLFVBQVV2RyxTQUFTLENBQUNjLGNBQWMsQ0FBQ3dMLFFBQVEsSUFDM0MvRixVQUFVdkcsU0FBUyxDQUFDYyxjQUFjLENBQUNvRCxZQUFZLEVBQy9DO1FBQ0FxQyxVQUFVakQsU0FBUztJQUNyQixPQUFPO1FBQ0xpRCxVQUFVdkcsU0FBUyxDQUFDc0MsRUFBRSxDQUFDLFNBQVN3SjtRQUNoQ3ZGLFVBQVV2RyxTQUFTLENBQUNzQyxFQUFFLENBQUMsVUFBVXdKO0lBQ25DO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVM3SSxhQUFhK0ksS0FBSztJQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDOU4sV0FBVyxDQUFDOEIsU0FBUyxDQUFDb00sS0FBSyxDQUFDSixRQUFRO1FBQzVDLElBQUksQ0FBQ3pILEtBQUs7SUFDWjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNyQjtJQUNQLE1BQU1xRCxZQUFZLElBQUksQ0FBQ3JJLFdBQVc7SUFFbENxSSxVQUFVekcsV0FBVyxHQUFHZCxVQUFVaUYsT0FBTztJQUN6Q3NDLFVBQVV2RyxTQUFTLENBQUNtRSxHQUFHO0lBQ3ZCLElBQUksQ0FBQ0EsR0FBRztBQUNWO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNoQjtJQUNQLE1BQU1vRCxZQUFZLElBQUksQ0FBQ3JJLFdBQVc7SUFFbEMsSUFBSSxDQUFDa0ksY0FBYyxDQUFDLFNBQVNqRDtJQUM3QixJQUFJLENBQUNiLEVBQUUsQ0FBQyxTQUFTbkU7SUFFakIsSUFBSW9JLFdBQVc7UUFDYkEsVUFBVXpHLFdBQVcsR0FBR2QsVUFBVWlGLE9BQU87UUFDekMsSUFBSSxDQUFDSSxPQUFPO0lBQ2Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LmpzPzA4NjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4fFJlYWRhYmxlJFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgcmFuZG9tQnl0ZXMsIGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBEdXBsZXgsIFJlYWRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyJyk7XG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5jb25zdCBrQWJvcnRlZCA9IFN5bWJvbCgna0Fib3J0ZWQnKTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAocHJvdG9jb2xzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdvYmplY3QnICYmIHByb3RvY29scyAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBkZXZpYXRlcyBmcm9tIHRoZSBXSEFUV0cgaW50ZXJmYWNlIHNpbmNlIHdzIGRvZXNuJ3Qgc3VwcG9ydCB0aGVcbiAgICogcmVxdWlyZWQgZGVmYXVsdCBcImJsb2JcIiB0eXBlIChpbnN0ZWFkIHdlIGRlZmluZSBhIGN1c3RvbSBcIm5vZGVidWZmZXJcIlxuICAgKiB0eXBlKS5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5sZW5ndGggKyB0aGlzLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBleHRlbnNpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25jbG9zZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25lcnJvcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25vcGVuKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKHtcbiAgICAgIGJpbmFyeVR5cGU6IHRoaXMuYmluYXJ5VHlwZSxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuX2V4dGVuc2lvbnMsXG4gICAgICBpc1NlcnZlcjogdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBtYXhQYXlsb2FkOiBvcHRpb25zLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZW5kZXIgPSBuZXcgU2VuZGVyKHNvY2tldCwgdGhpcy5fZXh0ZW5zaW9ucywgb3B0aW9ucy5nZW5lcmF0ZU1hc2spO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIC8vXG4gICAgLy8gVGhlc2UgbWV0aG9kcyBtYXkgbm90IGJlIGF2YWlsYWJsZSBpZiBgc29ja2V0YCBpcyBqdXN0IGEgYER1cGxleGAuXG4gICAgLy9cbiAgICBpZiAoc29ja2V0LnNldFRpbWVvdXQpIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIGlmIChzb2NrZXQuc2V0Tm9EZWxheSkgc29ja2V0LnNldE5vRGVsYXkoKTtcblxuICAgIGlmIChoZWFkLmxlbmd0aCA+IDApIHNvY2tldC51bnNoaWZ0KGhlYWQpO1xuXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICAgIHNvY2tldC5vbignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gICAgc29ja2V0Lm9uKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgdGhlIGAnY2xvc2UnYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRDbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgY2xvc2luZyBoYW5kc2hha2UuXG4gICAqXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLStcbiAgICogICAgIC0gLSAtfHdzLmNsb3NlKCl8LS0+fGNsb3NlIGZyYW1lfC0tPnx3cy5jbG9zZSgpfC0gLSAtXG4gICAqICAgIHwgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLSsgICAgIHxcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcbiAgICogQ0xPU0lORyAgfHdzLmNsb3NlKCl8PC0tfGNsb3NlIGZyYW1lfDwtLSstLS0tLSsgICAgICAgQ0xPU0lOR1xuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgfFxuICAgKiAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0+fGZpbnwgLSAtIC0gLVxuICAgKiAgICB8ICAgICAgICAgKy0tLSsgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rXG4gICAqICAgICAtIC0gLSAtIC18ZmlufDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAqICAgICAgICAgICAgICArLS0tK1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgcmVhc29uIHdoeSB0aGUgY29ubmVjdGlvbiBpc1xuICAgKiAgICAgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgJiZcbiAgICAgICAgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fCB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuX3NlbmRlci5jbG9zZShjb2RlLCBkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIChlcnIpID0+IHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgYnkgdGhlIGAnZXJyb3InYCBsaXN0ZW5lciBvbiB0aGUgc29ja2V0LiBXZSBvbmx5XG4gICAgICAvLyB3YW50IHRvIGtub3cgaWYgdGhlIGNsb3NlIGZyYW1lIGhhcyBiZWVuIHNlbnQgaGVyZS5cbiAgICAgIC8vXG4gICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHxcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy9cbiAgICAvLyBTcGVjaWZ5IGEgdGltZW91dCBmb3IgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIHRvIGNvbXBsZXRlLlxuICAgIC8vXG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveS5iaW5kKHRoaXMuX3NvY2tldCksXG4gICAgICBjbG9zZVRpbWVvdXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fc29ja2V0LnBhdXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSB0aGlzLl9zb2NrZXQucmVzdW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxuICAgKiAgICAgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj10cnVlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gZGF0YSBpcyB3cml0dGVuIG91dFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxuICAgICAgbWFzazogIXRoaXMuX2lzU2VydmVyLFxuICAgICAgY29tcHJlc3M6IHRydWUsXG4gICAgICBmaW46IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuW1xuICAnYmluYXJ5VHlwZScsXG4gICdidWZmZXJlZEFtb3VudCcsXG4gICdleHRlbnNpb25zJyxcbiAgJ2lzUGF1c2VkJyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3JlYWR5U3RhdGUnLFxuICAndXJsJ1xuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHJldHVybiBsaXN0ZW5lcltrTGlzdGVuZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGhhbmRsZXIsIHtcbiAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvbGxvd1JlZGlyZWN0cz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gZm9sbG93XG4gKiAgICAgcmVkaXJlY3RzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICogICAgIG1hc2tpbmcga2V5XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGFuZHNoYWtlVGltZW91dF0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxuICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxuICogICAgIHNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSZWRpcmVjdHM9MTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHNcbiAqICAgICBhbGxvd2VkXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3JpZ2luXSBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcbiAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxuICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT10cnVlXSBFbmFibGUvZGlzYWJsZVxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByb3RvY29sVmVyc2lvbj0xM10gVmFsdWUgb2YgdGhlXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmAgaGVhZGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxuICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXG4gICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcbiAgICBtYXhSZWRpcmVjdHM6IDEwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY3JlYXRlQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgaG9zdDogdW5kZWZpbmVkLFxuICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICBwb3J0OiB1bmRlZmluZWRcbiAgfTtcblxuICBpZiAoIXByb3RvY29sVmVyc2lvbnMuaW5jbHVkZXMob3B0cy5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRzLnByb3RvY29sVmVyc2lvbn0gYCArXG4gICAgICAgIGAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbignLCAnKX0pYFxuICAgICk7XG4gIH1cblxuICBsZXQgcGFyc2VkVXJsO1xuXG4gIGlmIChhZGRyZXNzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcGFyc2VkVXJsID0gYWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9ICd3czonO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3NzOic7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3VybCA9IHBhcnNlZFVybC5ocmVmO1xuXG4gIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG4gIGNvbnN0IGlzSXBjVXJsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuICBsZXQgaW52YWxpZFVybE1lc3NhZ2U7XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID1cbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgJyArXG4gICAgICAnXCJodHRwOlwiLCBcImh0dHBzXCIsIG9yIFwid3MrdW5peDpcIic7XG4gIH0gZWxzZSBpZiAoaXNJcGNVcmwgJiYgIXBhcnNlZFVybC5wYXRobmFtZSkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gXCJUaGUgVVJMJ3MgcGF0aG5hbWUgaXMgZW1wdHlcIjtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJztcbiAgfVxuXG4gIGlmIChpbnZhbGlkVXJsTWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihpbnZhbGlkVXJsTWVzc2FnZSk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgcmVxdWVzdCA9IGlzU2VjdXJlID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdDtcbiAgY29uc3QgcHJvdG9jb2xTZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBwZXJNZXNzYWdlRGVmbGF0ZTtcblxuICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gPSBpc1NlY3VyZSA/IHRsc0Nvbm5lY3QgOiBuZXRDb25uZWN0O1xuICBvcHRzLmRlZmF1bHRQb3J0ID0gb3B0cy5kZWZhdWx0UG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZS5zdGFydHNXaXRoKCdbJylcbiAgICA/IHBhcnNlZFVybC5ob3N0bmFtZS5zbGljZSgxLCAtMSlcbiAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgb3B0cy5oZWFkZXJzID0ge1xuICAgIC4uLm9wdHMuaGVhZGVycyxcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0J1xuICB9O1xuICBvcHRzLnBhdGggPSBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XG5cbiAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxuICAgICk7XG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnXSA9IGZvcm1hdCh7XG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvdG9jb2xzLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBwcm90b2NvbCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIXN1YnByb3RvY29sUmVnZXgudGVzdChwcm90b2NvbCkgfHxcbiAgICAgICAgcHJvdG9jb2xTZXQuaGFzKHByb3RvY29sKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAnQW4gaW52YWxpZCBvciBkdXBsaWNhdGVkIHN1YnByb3RvY29sIHdhcyBzcGVjaWZpZWQnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29sU2V0LmFkZChwcm90b2NvbCk7XG4gICAgfVxuXG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHMuam9pbignLCcpO1xuICB9XG4gIGlmIChvcHRzLm9yaWdpbikge1xuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuXG4gIGlmIChpc0lwY1VybCkge1xuICAgIGNvbnN0IHBhcnRzID0gb3B0cy5wYXRoLnNwbGl0KCc6Jyk7XG5cbiAgICBvcHRzLnNvY2tldFBhdGggPSBwYXJ0c1swXTtcbiAgICBvcHRzLnBhdGggPSBwYXJ0c1sxXTtcbiAgfVxuXG4gIGxldCByZXE7XG5cbiAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzKSB7XG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjID0gaXNJcGNVcmw7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlID0gaXNTZWN1cmU7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aCA9IGlzSXBjVXJsXG4gICAgICAgID8gb3B0cy5zb2NrZXRQYXRoXG4gICAgICAgIDogcGFyc2VkVXJsLmhvc3Q7XG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcblxuICAgICAgLy9cbiAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxuICAgICAgLy8gd2l0aG91dCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgLy9cbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XG5cbiAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3ZWJzb2NrZXQubGlzdGVuZXJDb3VudCgncmVkaXJlY3QnKSA9PT0gMCkge1xuICAgICAgY29uc3QgaXNTYW1lSG9zdCA9IGlzSXBjVXJsXG4gICAgICAgID8gd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xuICAgICAgICAgID8gb3B0cy5zb2NrZXRQYXRoID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aFxuICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgOiB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXG4gICAgICAgID8gZmFsc2VcbiAgICAgICAgOiBwYXJzZWRVcmwuaG9zdCA9PT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGg7XG5cbiAgICAgIGlmICghaXNTYW1lSG9zdCB8fCAod2Vic29ja2V0Ll9vcmlnaW5hbFNlY3VyZSAmJiAhaXNTZWN1cmUpKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBkcm9wIHRoZSBmb2xsb3dpbmcgaGVhZGVycy4gVGhlc2VcbiAgICAgICAgLy8gaGVhZGVycyBhcmUgYWxzbyBkcm9wcGVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBzdWJkb21haW4uXG4gICAgICAgIC8vXG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5jb29raWU7XG5cbiAgICAgICAgaWYgKCFpc1NhbWVIb3N0KSBkZWxldGUgb3B0cy5oZWFkZXJzLmhvc3Q7XG5cbiAgICAgICAgb3B0cy5hdXRoID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIG1ha2UgdGhlIGZpcnN0IGBBdXRob3JpemF0aW9uYCBoZWFkZXIgd2luLlxuICAgIC8vIElmIHRoZSBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlzIHNldCwgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvIGFzIGl0XG4gICAgLy8gd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gICAgLy9cbiAgICBpZiAob3B0cy5hdXRoICYmICFvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPVxuICAgICAgICAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcblxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cykge1xuICAgICAgLy9cbiAgICAgIC8vIFVubGlrZSB3aGF0IGlzIGRvbmUgZm9yIHRoZSBgJ3VwZ3JhZGUnYCBldmVudCwgbm8gZWFybHkgZXhpdCBpc1xuICAgICAgLy8gdHJpZ2dlcmVkIGhlcmUgaWYgdGhlIHVzZXIgY2FsbHMgYHdlYnNvY2tldC5jbG9zZSgpYCBvclxuICAgICAgLy8gYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgJ3JlZGlyZWN0J2AgZXZlbnQuIFRoaXNcbiAgICAgIC8vIGlzIGJlY2F1c2UgdGhlIHVzZXIgY2FuIGFsc28gY2FsbCBgcmVxdWVzdC5kZXN0cm95KClgIHdpdGggYW4gZXJyb3JcbiAgICAgIC8vIGJlZm9yZSBjYWxsaW5nIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3IgYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgYW5kIHRoaXNcbiAgICAgIC8vIHdvdWxkIHJlc3VsdCBpbiBhbiBlcnJvciBiZWluZyBlbWl0dGVkIG9uIHRoZSBgcmVxdWVzdGAgb2JqZWN0IHdpdGggbm9cbiAgICAgIC8vIGAnZXJyb3InYCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQuXG4gICAgICAvL1xuICAgICAgd2Vic29ja2V0LmVtaXQoJ3JlZGlyZWN0Jywgd2Vic29ja2V0LnVybCwgcmVxKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSByZXF1ZXN0KG9wdHMpO1xuICB9XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcVtrQWJvcnRlZF0pIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcbiAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgbGV0IGFkZHI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHtsb2NhdGlvbn1gKTtcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0LmVtaXQoJ3VuZXhwZWN0ZWQtcmVzcG9uc2UnLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlXG4gICAgLy8gYCd1cGdyYWRlJ2AgZXZlbnQuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG5cbiAgICBpZiAocmVzLmhlYWRlcnMudXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RFcnJvcjtcblxuICAgIGlmIChzZXJ2ZXJQcm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcbiAgICAgIH0gZWxzZSBpZiAoIXByb3RvY29sU2V0LmhhcyhzZXJ2ZXJQcm90KSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xuICAgIH1cblxuICAgIGlmIChwcm90RXJyb3IpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBwcm90RXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJQcm90KSB3ZWJzb2NrZXQuX3Byb3RvY29sID0gc2VydmVyUHJvdDtcblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdTZXJ2ZXIgc2VudCBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgYnV0IG5vIGV4dGVuc2lvbiAnICtcbiAgICAgICAgICAnd2FzIHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXh0ZW5zaW9ucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWVzID0gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgIGV4dGVuc2lvbk5hbWVzWzBdICE9PSBQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdTZXJ2ZXIgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiB0aGF0IHdhcyBub3QgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3ZWJzb2NrZXQuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPVxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgZ2VuZXJhdGVNYXNrOiBvcHRzLmdlbmVyYXRlTWFzayxcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKG9wdHMuZmluaXNoUmVxdWVzdCkge1xuICAgIG9wdHMuZmluaXNoUmVxdWVzdChyZXEsIHdlYnNvY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgcmVxLmVuZCgpO1xuICB9XG59XG5cbi8qKlxuICogRW1pdCB0aGUgYCdlcnJvcidgIGFuZCBgJ2Nsb3NlJ2AgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yIHRvIGVtaXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyAnJyA6IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xuICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW1ba0Fib3J0ZWRdID0gdHJ1ZTtcbiAgICBzdHJlYW0uYWJvcnQoKTtcblxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgLy9cbiAgICAgIC8vIE9uIE5vZGUuanMgPj0gMTQuMy4wIGByZXF1ZXN0LmFib3J0KClgIGRvZXMgbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBpZlxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cbiAgICAgIC8vXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlLCB3ZWJzb2NrZXQsIGVycik7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKTtcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCB3ZWJzb2NrZXQuZW1pdC5iaW5kKHdlYnNvY2tldCwgJ2Vycm9yJykpO1xuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgYHBpbmcoKWAsIGBwb25nKClgLCBvciBgc2VuZCgpYCBtZXRob2RzIGFyZSBjYWxsZWRcbiAqIHdoZW4gdGhlIGByZWFkeVN0YXRlYCBhdHRyaWJ1dGUgaXMgYENMT1NJTkdgIG9yIGBDTE9TRURgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZEFmdGVyQ2xvc2Uod2Vic29ja2V0LCBkYXRhLCBjYikge1xuICBpZiAoZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRvQnVmZmVyKGRhdGEpLmxlbmd0aDtcblxuICAgIC8vXG4gICAgLy8gVGhlIGBfYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5IGlzIHVzZWQgb25seSB3aGVuIHRoZSBwZWVyIGlzIGEgY2xpZW50IGFuZFxuICAgIC8vIHRoZSBvcGVuaW5nIGhhbmRzaGFrZSBmYWlscy4gVW5kZXIgdGhlc2UgY2lyY3Vtc3RhbmNlcywgaW4gZmFjdCwgdGhlXG4gICAgLy8gYHNldFNvY2tldCgpYCBtZXRob2QgaXMgbm90IGNhbGxlZCwgc28gdGhlIGBfc29ja2V0YCBhbmQgYF9zZW5kZXJgXG4gICAgLy8gcHJvcGVydGllcyBhcmUgc2V0IHRvIGBudWxsYC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQuX3NvY2tldCkgd2Vic29ja2V0Ll9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xuICAgIGVsc2Ugd2Vic29ja2V0Ll9idWZmZXJlZEFtb3VudCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAoY2IpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0LnJlYWR5U3RhdGV9IGAgK1xuICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbd2Vic29ja2V0LnJlYWR5U3RhdGVdfSlgXG4gICAgKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnY29uY2x1ZGUnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSByZWFzb24gVGhlIHJlYXNvbiBmb3IgY2xvc2luZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkNvbmNsdWRlKGNvZGUsIHJlYXNvbikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XG4gIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuICBpZiAoY29kZSA9PT0gMTAwNSkgd2Vic29ja2V0LmNsb3NlKCk7XG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZHJhaW4nYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKCF3ZWJzb2NrZXQuaXNQYXVzZWQpIHdlYnNvY2tldC5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuXG4gICAgLy9cbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTk0MC5cbiAgICAvL1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgICB3ZWJzb2NrZXQuY2xvc2UoZXJyW2tTdGF0dXNDb2RlXSk7XG4gIH1cblxuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2ZpbmlzaCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnbWVzc2FnZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgbWVzc2FnZVxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSBTcGVjaWZpZXMgd2hldGhlciB0aGUgbWVzc2FnZSBpcyBiaW5hcnkgb3Igbm90XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCBpc0JpbmFyeSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncGluZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXdlYnNvY2tldC5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQuZW1pdCgncGluZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcG9uZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBSZXN1bWUgYSByZWFkYWJsZSBzdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gVGhlIHJlYWRhYmxlIHN0cmVhbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSkge1xuICBzdHJlYW0ucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdjbG9zZSdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uQ2xvc2UoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHNvY2tldE9uRW5kKTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBsZXQgY2h1bms7XG5cbiAgLy9cbiAgLy8gVGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGAnZW5kJ2AgZXZlbnQgZW1pdHRlZCxcbiAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZSBzb2NrZXQgd2FzIGRlc3Ryb3llZCBkdWUgdG8gYW4gZXJyb3IuIEVuc3VyZSB0aGF0IHRoZVxuICAvLyBgcmVjZWl2ZXJgIHN0cmVhbSBpcyBjbG9zZWQgYWZ0ZXIgd3JpdGluZyBhbnkgcmVtYWluaW5nIGJ1ZmZlcmVkIGRhdGEgdG9cbiAgLy8gaXQuIElmIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBzb2NrZXQgaXMgaW4gZmxvd2luZyBtb2RlIHRoZW4gdGhlcmUgaXMgbm9cbiAgLy8gYnVmZmVyZWQgZGF0YSBhcyBldmVyeXRoaW5nIGhhcyBiZWVuIGFscmVhZHkgd3JpdHRlbiBhbmQgYHJlYWRhYmxlLnJlYWQoKWBcbiAgLy8gd2lsbCByZXR1cm4gYG51bGxgLiBJZiBpbnN0ZWFkLCB0aGUgc29ja2V0IGlzIHBhdXNlZCwgYW55IHBvc3NpYmxlIGJ1ZmZlcmVkXG4gIC8vIGRhdGEgd2lsbCBiZSByZWFkIGFzIGEgc2luZ2xlIGNodW5rLlxuICAvL1xuICBpZiAoXG4gICAgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJlxuICAgICF3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJlxuICAgICF3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCAmJlxuICAgIChjaHVuayA9IHdlYnNvY2tldC5fc29ja2V0LnJlYWQoKSkgIT09IG51bGxcbiAgKSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci53cml0ZShjaHVuayk7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwiaHR0cHMiLCJodHRwIiwibmV0IiwidGxzIiwicmFuZG9tQnl0ZXMiLCJjcmVhdGVIYXNoIiwiRHVwbGV4IiwiUmVhZGFibGUiLCJVUkwiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsIlJlY2VpdmVyIiwiU2VuZGVyIiwiQklOQVJZX1RZUEVTIiwiRU1QVFlfQlVGRkVSIiwiR1VJRCIsImtGb3JPbkV2ZW50QXR0cmlidXRlIiwia0xpc3RlbmVyIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiTk9PUCIsIkV2ZW50VGFyZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmb3JtYXQiLCJwYXJzZSIsInRvQnVmZmVyIiwiY2xvc2VUaW1lb3V0Iiwia0Fib3J0ZWQiLCJTeW1ib2wiLCJwcm90b2NvbFZlcnNpb25zIiwicmVhZHlTdGF0ZXMiLCJzdWJwcm90b2NvbFJlZ2V4IiwiV2ViU29ja2V0IiwiY29uc3RydWN0b3IiLCJhZGRyZXNzIiwicHJvdG9jb2xzIiwib3B0aW9ucyIsIl9iaW5hcnlUeXBlIiwiX2Nsb3NlQ29kZSIsIl9jbG9zZUZyYW1lUmVjZWl2ZWQiLCJfY2xvc2VGcmFtZVNlbnQiLCJfY2xvc2VNZXNzYWdlIiwiX2Nsb3NlVGltZXIiLCJfZXh0ZW5zaW9ucyIsIl9wYXVzZWQiLCJfcHJvdG9jb2wiLCJfcmVhZHlTdGF0ZSIsIkNPTk5FQ1RJTkciLCJfcmVjZWl2ZXIiLCJfc2VuZGVyIiwiX3NvY2tldCIsIl9idWZmZXJlZEFtb3VudCIsIl9pc1NlcnZlciIsIl9yZWRpcmVjdHMiLCJ1bmRlZmluZWQiLCJBcnJheSIsImlzQXJyYXkiLCJpbml0QXNDbGllbnQiLCJiaW5hcnlUeXBlIiwidHlwZSIsImluY2x1ZGVzIiwiYnVmZmVyZWRBbW91bnQiLCJfd3JpdGFibGVTdGF0ZSIsImxlbmd0aCIsIl9idWZmZXJlZEJ5dGVzIiwiZXh0ZW5zaW9ucyIsIk9iamVjdCIsImtleXMiLCJqb2luIiwiaXNQYXVzZWQiLCJvbmNsb3NlIiwib25lcnJvciIsIm9ub3BlbiIsIm9ubWVzc2FnZSIsInByb3RvY29sIiwicmVhZHlTdGF0ZSIsInVybCIsIl91cmwiLCJzZXRTb2NrZXQiLCJzb2NrZXQiLCJoZWFkIiwicmVjZWl2ZXIiLCJpc1NlcnZlciIsIm1heFBheWxvYWQiLCJza2lwVVRGOFZhbGlkYXRpb24iLCJnZW5lcmF0ZU1hc2siLCJvbiIsInJlY2VpdmVyT25Db25jbHVkZSIsInJlY2VpdmVyT25EcmFpbiIsInJlY2VpdmVyT25FcnJvciIsInJlY2VpdmVyT25NZXNzYWdlIiwicmVjZWl2ZXJPblBpbmciLCJyZWNlaXZlck9uUG9uZyIsInNldFRpbWVvdXQiLCJzZXROb0RlbGF5IiwidW5zaGlmdCIsInNvY2tldE9uQ2xvc2UiLCJzb2NrZXRPbkRhdGEiLCJzb2NrZXRPbkVuZCIsInNvY2tldE9uRXJyb3IiLCJPUEVOIiwiZW1pdCIsImVtaXRDbG9zZSIsIkNMT1NFRCIsImV4dGVuc2lvbk5hbWUiLCJjbGVhbnVwIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiY2xvc2UiLCJjb2RlIiwiZGF0YSIsIm1zZyIsImFib3J0SGFuZHNoYWtlIiwiX3JlcSIsIkNMT1NJTkciLCJlcnJvckVtaXR0ZWQiLCJlbmQiLCJlcnIiLCJkZXN0cm95IiwiYmluZCIsInBhdXNlIiwicGluZyIsIm1hc2siLCJjYiIsIkVycm9yIiwidG9TdHJpbmciLCJzZW5kQWZ0ZXJDbG9zZSIsInBvbmciLCJyZXN1bWUiLCJuZWVkRHJhaW4iLCJzZW5kIiwib3B0cyIsImJpbmFyeSIsImNvbXByZXNzIiwiZmluIiwidGVybWluYXRlIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwidmFsdWUiLCJpbmRleE9mIiwicHJvdG90eXBlIiwiZm9yRWFjaCIsInByb3BlcnR5IiwibWV0aG9kIiwiZ2V0IiwibGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJzZXQiLCJoYW5kbGVyIiwicmVtb3ZlTGlzdGVuZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwid2Vic29ja2V0IiwicHJvdG9jb2xWZXJzaW9uIiwicGVyTWVzc2FnZURlZmxhdGUiLCJmb2xsb3dSZWRpcmVjdHMiLCJtYXhSZWRpcmVjdHMiLCJjcmVhdGVDb25uZWN0aW9uIiwic29ja2V0UGF0aCIsImhvc3RuYW1lIiwidGltZW91dCIsImhvc3QiLCJwYXRoIiwicG9ydCIsIlJhbmdlRXJyb3IiLCJwYXJzZWRVcmwiLCJlIiwiU3ludGF4RXJyb3IiLCJocmVmIiwiaXNTZWN1cmUiLCJpc0lwY1VybCIsImludmFsaWRVcmxNZXNzYWdlIiwicGF0aG5hbWUiLCJoYXNoIiwiZW1pdEVycm9yQW5kQ2xvc2UiLCJkZWZhdWx0UG9ydCIsImtleSIsInJlcXVlc3QiLCJwcm90b2NvbFNldCIsIlNldCIsInRsc0Nvbm5lY3QiLCJuZXRDb25uZWN0Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwiaGVhZGVycyIsIkNvbm5lY3Rpb24iLCJVcGdyYWRlIiwic2VhcmNoIiwiaGFuZHNoYWtlVGltZW91dCIsIm9mZmVyIiwidGVzdCIsImhhcyIsImFkZCIsIm9yaWdpbiIsIk9yaWdpbiIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJhdXRoIiwicGFydHMiLCJzcGxpdCIsInJlcSIsIl9vcmlnaW5hbElwYyIsIl9vcmlnaW5hbFNlY3VyZSIsIl9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGgiLCJlbnRyaWVzIiwidG9Mb3dlckNhc2UiLCJsaXN0ZW5lckNvdW50IiwiaXNTYW1lSG9zdCIsImF1dGhvcml6YXRpb24iLCJjb29raWUiLCJCdWZmZXIiLCJmcm9tIiwicmVzIiwibG9jYXRpb24iLCJzdGF0dXNDb2RlIiwiYWJvcnQiLCJhZGRyIiwidXBncmFkZSIsImRpZ2VzdCIsInVwZGF0ZSIsInNlcnZlclByb3QiLCJwcm90RXJyb3IiLCJzaXplIiwic2VjV2ViU29ja2V0RXh0ZW5zaW9ucyIsIm1lc3NhZ2UiLCJleHRlbnNpb25OYW1lcyIsImFjY2VwdCIsImZpbmlzaFJlcXVlc3QiLCJjb25uZWN0Iiwic2VydmVybmFtZSIsImlzSVAiLCJzdHJlYW0iLCJjYXB0dXJlU3RhY2tUcmFjZSIsInNldEhlYWRlciIsImRlc3Ryb3llZCIsInByb2Nlc3MiLCJuZXh0VGljayIsIm9uY2UiLCJyZWFzb24iLCJyZWNlaXZlck9uRmluaXNoIiwiaXNCaW5hcnkiLCJjaHVuayIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kRW1pdHRlZCIsInJlYWQiLCJ3cml0ZSIsImNsZWFyVGltZW91dCIsImZpbmlzaGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/wrapper.mjs":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/wrapper.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/stream.js\");\n/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/receiver.js\");\n/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/sender.js\");\n/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/websocket.js\");\n/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ \"(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/lib/websocket-server.js\");\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy93cmFwcGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNYO0FBQ0o7QUFDTTtBQUNhO0FBRXVCO0FBQy9FLGlFQUFlRyw4Q0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dzQDguMTQuMl9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy93cy93cmFwcGVyLm1qcz8wZmEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVXZWJTb2NrZXRTdHJlYW0gZnJvbSAnLi9saWIvc3RyZWFtLmpzJztcbmltcG9ydCBSZWNlaXZlciBmcm9tICcuL2xpYi9yZWNlaXZlci5qcyc7XG5pbXBvcnQgU2VuZGVyIGZyb20gJy4vbGliL3NlbmRlci5qcyc7XG5pbXBvcnQgV2ViU29ja2V0IGZyb20gJy4vbGliL3dlYnNvY2tldC5qcyc7XG5pbXBvcnQgV2ViU29ja2V0U2VydmVyIGZyb20gJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMnO1xuXG5leHBvcnQgeyBjcmVhdGVXZWJTb2NrZXRTdHJlYW0sIFJlY2VpdmVyLCBTZW5kZXIsIFdlYlNvY2tldCwgV2ViU29ja2V0U2VydmVyIH07XG5leHBvcnQgZGVmYXVsdCBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOlsiY3JlYXRlV2ViU29ja2V0U3RyZWFtIiwiUmVjZWl2ZXIiLCJTZW5kZXIiLCJXZWJTb2NrZXQiLCJXZWJTb2NrZXRTZXJ2ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ws@8.14.2_bufferutil@4.0.7/node_modules/ws/wrapper.mjs\n");

/***/ })

};
;