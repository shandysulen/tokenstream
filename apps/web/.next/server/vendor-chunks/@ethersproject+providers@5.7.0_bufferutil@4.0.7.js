"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ethersproject+providers@5.7.0_bufferutil@4.0.7";
exports.ids = ["vendor-chunks/@ethersproject+providers@5.7.0_bufferutil@4.0.7"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js":
/*!**************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"providers/5.7.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi9fdmVyc2lvbi5qcz8xM2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuZXhwb3J0cy52ZXJzaW9uID0gXCJwcm92aWRlcnMvNS43LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/alchemy-provider.js":
/*!**********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/alchemy-provider.js ***!
  \**********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlchemyProvider = exports.AlchemyWebSocketProvider = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/formatter.js\");\nvar websocket_provider_1 = __webpack_require__(/*! ./websocket-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/websocket-provider.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\nvar defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nvar AlchemyWebSocketProvider = /** @class */ (function (_super) {\n    __extends(AlchemyWebSocketProvider, _super);\n    function AlchemyWebSocketProvider(network, apiKey) {\n        var _this = this;\n        var provider = new AlchemyProvider(network, apiKey);\n        var url = provider.connection.url.replace(/^http/i, \"ws\")\n            .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n        _this = _super.call(this, url, provider.network) || this;\n        (0, properties_1.defineReadOnly)(_this, \"apiKey\", provider.apiKey);\n        return _this;\n    }\n    AlchemyWebSocketProvider.prototype.isCommunityResource = function () {\n        return (this.apiKey === defaultApiKey);\n    };\n    return AlchemyWebSocketProvider;\n}(websocket_provider_1.WebSocketProvider));\nexports.AlchemyWebSocketProvider = AlchemyWebSocketProvider;\nvar AlchemyProvider = /** @class */ (function (_super) {\n    __extends(AlchemyProvider, _super);\n    function AlchemyProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AlchemyProvider.getWebSocketProvider = function (network, apiKey) {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    };\n    AlchemyProvider.getApiKey = function (apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    };\n    AlchemyProvider.getUrl = function (network, apiKey) {\n        var host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-goerli\":\n                host = \"arb-goerli.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-goerli\":\n                host = \"opt-goerli.g.alchemy.com/v2/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: function (attempt, url) {\n                if (apiKey === defaultApiKey) {\n                    (0, formatter_1.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    };\n    AlchemyProvider.prototype.isCommunityResource = function () {\n        return (this.apiKey === defaultApiKey);\n    };\n    return AlchemyProvider;\n}(url_json_rpc_provider_1.UrlJsonRpcProvider));\nexports.AlchemyProvider = AlchemyProvider;\n//# sourceMappingURL=alchemy-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2FsY2hlbXktcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsZ0NBQWdDO0FBQzFELG1CQUFtQixtQkFBTyxDQUFDLHFKQUEyQjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQywwSkFBYTtBQUN2QywyQkFBMkIsbUJBQU8sQ0FBQyw0S0FBc0I7QUFDekQsZUFBZSxtQkFBTyxDQUFDLHlJQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyx3SkFBWTtBQUNyQztBQUNBLDhCQUE4QixtQkFBTyxDQUFDLGtMQUF5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2FsY2hlbXktcHJvdmlkZXIuanM/M2MxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFsY2hlbXlQcm92aWRlciA9IGV4cG9ydHMuQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xudmFyIHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCIpO1xudmFyIGZvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vZm9ybWF0dGVyXCIpO1xudmFyIHdlYnNvY2tldF9wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vd2Vic29ja2V0LXByb3ZpZGVyXCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xudmFyIHVybF9qc29uX3JwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vdXJsLWpzb24tcnBjLXByb3ZpZGVyXCIpO1xuLy8gVGhpcyBrZXkgd2FzIHByb3ZpZGVkIHRvIGV0aGVycy5qcyBieSBBbGNoZW15IHRvIGJlIHVzZWQgYnkgdGhlXG4vLyBkZWZhdWx0IHByb3ZpZGVyLCBidXQgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCBmb3IgeW91ciBvd25cbi8vIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLCB0aGF0IHlvdSBhY3F1aXJlIHlvdXIgb3duIEFQSSBrZXkgYXQ6XG4vLyAgIGh0dHBzOi8vZGFzaGJvYXJkLmFsY2hlbXlhcGkuaW9cbnZhciBkZWZhdWx0QXBpS2V5ID0gXCJfZ2c3d1NTaTBLTUJzZEtuR1ZmSER1ZXE2eE1COUVrQ1wiO1xudmFyIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IEFsY2hlbXlQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpO1xuICAgICAgICB2YXIgdXJsID0gcHJvdmlkZXIuY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoXCIuYWxjaGVteWFwaS5cIiwgXCIud3MuYWxjaGVteWFwaS5cIik7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdXJsLCBwcm92aWRlci5uZXR3b3JrKSB8fCB0aGlzO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJhcGlLZXlcIiwgcHJvdmlkZXIuYXBpS2V5KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmlzQ29tbXVuaXR5UmVzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpO1xuICAgIH07XG4gICAgcmV0dXJuIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcjtcbn0od2Vic29ja2V0X3Byb3ZpZGVyXzEuV2ViU29ja2V0UHJvdmlkZXIpKTtcbmV4cG9ydHMuQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyID0gQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyO1xudmFyIEFsY2hlbXlQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWxjaGVteVByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFsY2hlbXlQcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBbGNoZW15UHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSk7XG4gICAgfTtcbiAgICBBbGNoZW15UHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QXBpS2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIChhcGlLZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcGlLZXlcIiwgXCJhcGlLZXlcIiwgYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBpS2V5O1xuICAgIH07XG4gICAgQWxjaGVteVByb3ZpZGVyLmdldFVybCA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1tYWlubmV0LmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1yb3BzdGVuLmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1yaW5rZWJ5LmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLWdvZXJsaS5hbGNoZW15YXBpLmlvL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLWtvdmFuLmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtYXRpY211bVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvbHlnb24tbXVtYmFpLmcuYWxjaGVteS5jb20vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJhcmItbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtLXJpbmtlYnlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJhcmItcmlua2VieS5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtLWdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYi1nb2VybGkuZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm9wdC1tYWlubmV0LmcuYWxjaGVteS5jb20vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3B0aW1pc20ta292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJvcHQta292YW4uZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJvcHQtZ29lcmxpLmcuYWxjaGVteS5jb20vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBhcmd1bWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxvd0d6aXA6IHRydWUsXG4gICAgICAgICAgICB1cmw6IChcImh0dHBzOi9cIiArIFwiL1wiICsgaG9zdCArIGFwaUtleSksXG4gICAgICAgICAgICB0aHJvdHRsZUNhbGxiYWNrOiBmdW5jdGlvbiAoYXR0ZW1wdCwgdXJsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgZm9ybWF0dGVyXzEuc2hvd1Rocm90dGxlTWVzc2FnZSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEFsY2hlbXlQcm92aWRlci5wcm90b3R5cGUuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSk7XG4gICAgfTtcbiAgICByZXR1cm4gQWxjaGVteVByb3ZpZGVyO1xufSh1cmxfanNvbl9ycGNfcHJvdmlkZXJfMS5VcmxKc29uUnBjUHJvdmlkZXIpKTtcbmV4cG9ydHMuQWxjaGVteVByb3ZpZGVyID0gQWxjaGVteVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxjaGVteS1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/alchemy-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ankr-provider.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ankr-provider.js ***!
  \*******************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AnkrProvider = void 0;\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/formatter.js\");\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\nfunction getHost(name) {\n    switch (name) {\n        case \"homestead\":\n            return \"rpc.ankr.com/eth/\";\n        case \"ropsten\":\n            return \"rpc.ankr.com/eth_ropsten/\";\n        case \"rinkeby\":\n            return \"rpc.ankr.com/eth_rinkeby/\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli/\";\n        case \"matic\":\n            return \"rpc.ankr.com/polygon/\";\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum/\";\n    }\n    return logger.throwArgumentError(\"unsupported network\", \"name\", name);\n}\nvar AnkrProvider = /** @class */ (function (_super) {\n    __extends(AnkrProvider, _super);\n    function AnkrProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AnkrProvider.prototype.isCommunityResource = function () {\n        return (this.apiKey === defaultApiKey);\n    };\n    AnkrProvider.getApiKey = function (apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        return apiKey;\n    };\n    AnkrProvider.getUrl = function (network, apiKey) {\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        var connection = {\n            allowGzip: true,\n            url: (\"https:/\\/\" + getHost(network.name) + apiKey),\n            throttleCallback: function (attempt, url) {\n                if (apiKey.apiKey === defaultApiKey) {\n                    (0, formatter_1.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    };\n    return AnkrProvider;\n}(url_json_rpc_provider_1.UrlJsonRpcProvider));\nexports.AnkrProvider = AnkrProvider;\n//# sourceMappingURL=ankr-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2Fua3ItcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLGtCQUFrQixtQkFBTyxDQUFDLDBKQUFhO0FBQ3ZDLDhCQUE4QixtQkFBTyxDQUFDLGtMQUF5QjtBQUMvRCxlQUFlLG1CQUFPLENBQUMseUlBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHdKQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi9hbmtyLXByb3ZpZGVyLmpzP2ZkN2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbmtyUHJvdmlkZXIgPSB2b2lkIDA7XG52YXIgZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi9mb3JtYXR0ZXJcIik7XG52YXIgdXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi91cmwtanNvbi1ycGMtcHJvdmlkZXJcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCIpO1xudmFyIF92ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9fdmVyc2lvblwiKTtcbnZhciBsb2dnZXIgPSBuZXcgbG9nZ2VyXzEuTG9nZ2VyKF92ZXJzaW9uXzEudmVyc2lvbik7XG52YXIgZGVmYXVsdEFwaUtleSA9IFwiOWY3ZDkyOWIwMThjZGZmYjMzODUxN2VmYTA2ZjU4MzU5ZTg2ZmYxZmZkMzUwYmM4ODk3Mzg1MjM2NTllNzk3MlwiO1xuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGgvXCI7XG4gICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vZXRoX3JvcHN0ZW4vXCI7XG4gICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vZXRoX3JpbmtlYnkvXCI7XG4gICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGhfZ29lcmxpL1wiO1xuICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9wb2x5Z29uL1wiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9hcmJpdHJ1bS9cIjtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmFtZVwiLCBuYW1lKTtcbn1cbnZhciBBbmtyUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFua3JQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbmtyUHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQW5rclByb3ZpZGVyLnByb3RvdHlwZS5pc0NvbW11bml0eVJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KTtcbiAgICB9O1xuICAgIEFua3JQcm92aWRlci5nZXRBcGlLZXkgPSBmdW5jdGlvbiAoYXBpS2V5KSB7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRBcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwaUtleTtcbiAgICB9O1xuICAgIEFua3JQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIGFsbG93R3ppcDogdHJ1ZSxcbiAgICAgICAgICAgIHVybDogKFwiaHR0cHM6L1xcL1wiICsgZ2V0SG9zdChuZXR3b3JrLm5hbWUpICsgYXBpS2V5KSxcbiAgICAgICAgICAgIHRocm90dGxlQ2FsbGJhY2s6IGZ1bmN0aW9uIChhdHRlbXB0LCB1cmwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBpS2V5LmFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgZm9ybWF0dGVyXzEuc2hvd1Rocm90dGxlTWVzc2FnZSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFwaUtleS5wcm9qZWN0U2VjcmV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24udXNlciA9IFwiXCI7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnBhc3N3b3JkID0gYXBpS2V5LnByb2plY3RTZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfTtcbiAgICByZXR1cm4gQW5rclByb3ZpZGVyO1xufSh1cmxfanNvbl9ycGNfcHJvdmlkZXJfMS5VcmxKc29uUnBjUHJvdmlkZXIpKTtcbmV4cG9ydHMuQW5rclByb3ZpZGVyID0gQW5rclByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5rci1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ankr-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/base-provider.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/base-provider.js ***!
  \*******************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseProvider = exports.Resolver = exports.Event = void 0;\nvar abstract_provider_1 = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+abstract-provider@5.7.0/node_modules/@ethersproject/abstract-provider/lib/index.js\");\nvar base64_1 = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+base64@5.7.0/node_modules/@ethersproject/base64/lib/index.js\");\nvar basex_1 = __webpack_require__(/*! @ethersproject/basex */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+basex@5.7.0/node_modules/@ethersproject/basex/lib/index.js\");\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib/index.js\");\nvar constants_1 = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib/index.js\");\nvar hash_1 = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib/index.js\");\nvar networks_1 = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+networks@5.7.0/node_modules/@ethersproject/networks/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar sha2_1 = __webpack_require__(/*! @ethersproject/sha2 */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+sha2@5.7.0/node_modules/@ethersproject/sha2/lib/index.js\");\nvar strings_1 = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib/index.js\");\nvar web_1 = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+web@5.7.0/node_modules/@ethersproject/web/lib/index.js\");\nvar bech32_1 = __importDefault(__webpack_require__(/*! bech32 */ \"(ssr)/../../node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js\"));\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/formatter.js\");\nvar MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if ((0, bytes_1.hexDataLength)(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map(function (topic) {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            var unique_1 = {};\n            topic.forEach(function (topic) {\n                unique_1[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            var sorted = Object.keys(unique_1);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map(function (topic) {\n        if (topic === \"\") {\n            return [];\n        }\n        var comps = topic.split(\"|\").map(function (topic) {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if ((0, bytes_1.hexDataLength)(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (abstract_provider_1.ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nvar PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nvar Event = /** @class */ (function () {\n    function Event(tag, listener, once) {\n        (0, properties_1.defineReadOnly)(this, \"tag\", tag);\n        (0, properties_1.defineReadOnly)(this, \"listener\", listener);\n        (0, properties_1.defineReadOnly)(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    Object.defineProperty(Event.prototype, \"event\", {\n        get: function () {\n            switch (this.type) {\n                case \"tx\":\n                    return this.hash;\n                case \"filter\":\n                    return this.filter;\n            }\n            return this.tag;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Event.prototype, \"type\", {\n        get: function () {\n            return this.tag.split(\":\")[0];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Event.prototype, \"hash\", {\n        get: function () {\n            var comps = this.tag.split(\":\");\n            if (comps[0] !== \"tx\") {\n                return null;\n            }\n            return comps[1];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Event.prototype, \"filter\", {\n        get: function () {\n            var comps = this.tag.split(\":\");\n            if (comps[0] !== \"filter\") {\n                return null;\n            }\n            var address = comps[1];\n            var topics = deserializeTopics(comps[2]);\n            var filter = {};\n            if (topics.length > 0) {\n                filter.topics = topics;\n            }\n            if (address && address !== \"*\") {\n                filter.address = address;\n            }\n            return filter;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Event.prototype.pollable = function () {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    };\n    return Event;\n}());\nexports.Event = Event;\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nvar coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return (0, bytes_1.hexZeroPad)(bignumber_1.BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return basex_1.Base58.encode((0, bytes_1.concat)([data, (0, bytes_1.hexDataSlice)((0, sha2_1.sha256)((0, sha2_1.sha256)(data)), 0, 4)]));\n}\nvar matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nvar matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result, start) {\n    try {\n        return (0, strings_1.toUtf8String)(_parseBytes(result, start));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    var offset = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(result, start, start + 32)).toNumber();\n    var length = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(result, offset, offset + 32)).toNumber();\n    return (0, bytes_1.hexDataSlice)(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return \"https://gateway.ipfs.io/ipfs/\" + link;\n}\nfunction numPad(value) {\n    var result = (0, bytes_1.arrayify)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    var padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    var result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    var result = [];\n    var byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (var i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n    for (var i = 0; i < datas.length; i++) {\n        var data = (0, bytes_1.arrayify)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0, bytes_1.hexConcat)(result);\n}\nvar Resolver = /** @class */ (function () {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    function Resolver(provider, address, name, resolvedAddress) {\n        (0, properties_1.defineReadOnly)(this, \"provider\", provider);\n        (0, properties_1.defineReadOnly)(this, \"name\", name);\n        (0, properties_1.defineReadOnly)(this, \"address\", provider.formatter.address(address));\n        (0, properties_1.defineReadOnly)(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    Resolver.prototype.supportsWildcard = function () {\n        var _this = this;\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then(function (result) {\n                return bignumber_1.BigNumber.from(result).eq(1);\n            }).catch(function (error) {\n                if (error.code === logger_1.Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                _this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    };\n    Resolver.prototype._fetch = function (selector, parameters) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tx, parseBytes, result, error_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        tx = {\n                            to: this.address,\n                            ccipReadEnabled: true,\n                            data: (0, bytes_1.hexConcat)([selector, (0, hash_1.namehash)(this.name), (parameters || \"0x\")])\n                        };\n                        parseBytes = false;\n                        return [4 /*yield*/, this.supportsWildcard()];\n                    case 1:\n                        if (_a.sent()) {\n                            parseBytes = true;\n                            // selector(\"resolve(bytes,bytes)\")\n                            tx.data = (0, bytes_1.hexConcat)([\"0x9061b923\", encodeBytes([(0, hash_1.dnsEncode)(this.name), tx.data])]);\n                        }\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.provider.call(tx)];\n                    case 3:\n                        result = _a.sent();\n                        if (((0, bytes_1.arrayify)(result).length % 32) === 4) {\n                            logger.throwError(\"resolver threw error\", logger_1.Logger.errors.CALL_EXCEPTION, {\n                                transaction: tx, data: result\n                            });\n                        }\n                        if (parseBytes) {\n                            result = _parseBytes(result, 0);\n                        }\n                        return [2 /*return*/, result];\n                    case 4:\n                        error_1 = _a.sent();\n                        if (error_1.code === logger_1.Logger.errors.CALL_EXCEPTION) {\n                            return [2 /*return*/, null];\n                        }\n                        throw error_1;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Resolver.prototype._fetchBytes = function (selector, parameters) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._fetch(selector, parameters)];\n                    case 1:\n                        result = _a.sent();\n                        if (result != null) {\n                            return [2 /*return*/, _parseBytes(result, 0)];\n                        }\n                        return [2 /*return*/, null];\n                }\n            });\n        });\n    };\n    Resolver.prototype._getAddress = function (coinType, hexBytes) {\n        var coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(\"unsupported coin type: \" + coinType, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getAddress(\" + coinType + \")\"\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        var bytes = (0, bytes_1.arrayify)(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            var p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                var length_1 = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length_1 * 2 && length_1 >= 1 && length_1 <= 75) {\n                    return base58Encode((0, bytes_1.concat)([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            var p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                var length_2 = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length_2 * 2 && length_2 >= 1 && length_2 <= 75) {\n                    return base58Encode((0, bytes_1.concat)([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            var length_3 = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            var version_1 = bytes[0];\n            if (version_1 === 0x00) {\n                if (length_3 !== 20 && length_3 !== 32) {\n                    version_1 = -1;\n                }\n            }\n            else {\n                version_1 = -1;\n            }\n            if (version_1 >= 0 && bytes.length === 2 + length_3 && length_3 >= 1 && length_3 <= 75) {\n                var words = bech32_1.default.toWords(bytes.slice(2));\n                words.unshift(version_1);\n                return bech32_1.default.encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    };\n    Resolver.prototype.getAddress = function (coinType) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, error_2, hexBytes, address;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (coinType == null) {\n                            coinType = 60;\n                        }\n                        if (!(coinType === 60)) return [3 /*break*/, 4];\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._fetch(\"0x3b3b57de\")];\n                    case 2:\n                        result = _a.sent();\n                        // No address\n                        if (result === \"0x\" || result === constants_1.HashZero) {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, this.provider.formatter.callAddress(result)];\n                    case 3:\n                        error_2 = _a.sent();\n                        if (error_2.code === logger_1.Logger.errors.CALL_EXCEPTION) {\n                            return [2 /*return*/, null];\n                        }\n                        throw error_2;\n                    case 4: return [4 /*yield*/, this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType))];\n                    case 5:\n                        hexBytes = _a.sent();\n                        // No address\n                        if (hexBytes == null || hexBytes === \"0x\") {\n                            return [2 /*return*/, null];\n                        }\n                        address = this._getAddress(coinType, hexBytes);\n                        if (address == null) {\n                            logger.throwError(\"invalid or unsupported coin data\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"getAddress(\" + coinType + \")\",\n                                coinType: coinType,\n                                data: hexBytes\n                            });\n                        }\n                        return [2 /*return*/, address];\n                }\n            });\n        });\n    };\n    Resolver.prototype.getAvatar = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var linkage, avatar, i, match, scheme, _a, selector, owner, _b, comps, addr, tokenId, tokenOwner, _c, _d, balance, _e, _f, tx, metadataUrl, _g, metadata, imageUrl, ipfs, error_3;\n            return __generator(this, function (_h) {\n                switch (_h.label) {\n                    case 0:\n                        linkage = [{ type: \"name\", content: this.name }];\n                        _h.label = 1;\n                    case 1:\n                        _h.trys.push([1, 19, , 20]);\n                        return [4 /*yield*/, this.getText(\"avatar\")];\n                    case 2:\n                        avatar = _h.sent();\n                        if (avatar == null) {\n                            return [2 /*return*/, null];\n                        }\n                        i = 0;\n                        _h.label = 3;\n                    case 3:\n                        if (!(i < matchers.length)) return [3 /*break*/, 18];\n                        match = avatar.match(matchers[i]);\n                        if (match == null) {\n                            return [3 /*break*/, 17];\n                        }\n                        scheme = match[1].toLowerCase();\n                        _a = scheme;\n                        switch (_a) {\n                            case \"https\": return [3 /*break*/, 4];\n                            case \"data\": return [3 /*break*/, 5];\n                            case \"ipfs\": return [3 /*break*/, 6];\n                            case \"erc721\": return [3 /*break*/, 7];\n                            case \"erc1155\": return [3 /*break*/, 7];\n                        }\n                        return [3 /*break*/, 17];\n                    case 4:\n                        linkage.push({ type: \"url\", content: avatar });\n                        return [2 /*return*/, { linkage: linkage, url: avatar }];\n                    case 5:\n                        linkage.push({ type: \"data\", content: avatar });\n                        return [2 /*return*/, { linkage: linkage, url: avatar }];\n                    case 6:\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return [2 /*return*/, { linkage: linkage, url: getIpfsLink(avatar) }];\n                    case 7:\n                        selector = (scheme === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                        linkage.push({ type: scheme, content: avatar });\n                        _b = this._resolvedAddress;\n                        if (_b) return [3 /*break*/, 9];\n                        return [4 /*yield*/, this.getAddress()];\n                    case 8:\n                        _b = (_h.sent());\n                        _h.label = 9;\n                    case 9:\n                        owner = (_b);\n                        comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) {\n                            return [2 /*return*/, null];\n                        }\n                        return [4 /*yield*/, this.provider.formatter.address(comps[0])];\n                    case 10:\n                        addr = _h.sent();\n                        tokenId = (0, bytes_1.hexZeroPad)(bignumber_1.BigNumber.from(comps[1]).toHexString(), 32);\n                        if (!(scheme === \"erc721\")) return [3 /*break*/, 12];\n                        _d = (_c = this.provider.formatter).callAddress;\n                        return [4 /*yield*/, this.provider.call({\n                                to: addr, data: (0, bytes_1.hexConcat)([\"0x6352211e\", tokenId])\n                            })];\n                    case 11:\n                        tokenOwner = _d.apply(_c, [_h.sent()]);\n                        if (owner !== tokenOwner) {\n                            return [2 /*return*/, null];\n                        }\n                        linkage.push({ type: \"owner\", content: tokenOwner });\n                        return [3 /*break*/, 14];\n                    case 12:\n                        if (!(scheme === \"erc1155\")) return [3 /*break*/, 14];\n                        _f = (_e = bignumber_1.BigNumber).from;\n                        return [4 /*yield*/, this.provider.call({\n                                to: addr, data: (0, bytes_1.hexConcat)([\"0x00fdd58e\", (0, bytes_1.hexZeroPad)(owner, 32), tokenId])\n                            })];\n                    case 13:\n                        balance = _f.apply(_e, [_h.sent()]);\n                        if (balance.isZero()) {\n                            return [2 /*return*/, null];\n                        }\n                        linkage.push({ type: \"balance\", content: balance.toString() });\n                        _h.label = 14;\n                    case 14:\n                        tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: (0, bytes_1.hexConcat)([selector, tokenId])\n                        };\n                        _g = _parseString;\n                        return [4 /*yield*/, this.provider.call(tx)];\n                    case 15:\n                        metadataUrl = _g.apply(void 0, [_h.sent(), 0]);\n                        if (metadataUrl == null) {\n                            return [2 /*return*/, null];\n                        }\n                        linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                        }\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                        return [4 /*yield*/, (0, web_1.fetchJson)(metadataUrl)];\n                    case 16:\n                        metadata = _h.sent();\n                        if (!metadata) {\n                            return [2 /*return*/, null];\n                        }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                        imageUrl = metadata.image;\n                        if (typeof (imageUrl) !== \"string\") {\n                            return [2 /*return*/, null];\n                        }\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        }\n                        else {\n                            ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) {\n                                return [2 /*return*/, null];\n                            }\n                            linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n                        linkage.push({ type: \"url\", content: imageUrl });\n                        return [2 /*return*/, { linkage: linkage, url: imageUrl }];\n                    case 17:\n                        i++;\n                        return [3 /*break*/, 3];\n                    case 18: return [3 /*break*/, 20];\n                    case 19:\n                        error_3 = _h.sent();\n                        return [3 /*break*/, 20];\n                    case 20: return [2 /*return*/, null];\n                }\n            });\n        });\n    };\n    Resolver.prototype.getContentHash = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var hexBytes, ipfs, length_4, ipns, length_5, swarm, skynet, urlSafe_1, hash;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._fetchBytes(\"0xbc1c58d1\")];\n                    case 1:\n                        hexBytes = _a.sent();\n                        // No contenthash\n                        if (hexBytes == null || hexBytes === \"0x\") {\n                            return [2 /*return*/, null];\n                        }\n                        ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n                        if (ipfs) {\n                            length_4 = parseInt(ipfs[3], 16);\n                            if (ipfs[4].length === length_4 * 2) {\n                                return [2 /*return*/, \"ipfs:/\\/\" + basex_1.Base58.encode(\"0x\" + ipfs[1])];\n                            }\n                        }\n                        ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n                        if (ipns) {\n                            length_5 = parseInt(ipns[3], 16);\n                            if (ipns[4].length === length_5 * 2) {\n                                return [2 /*return*/, \"ipns:/\\/\" + basex_1.Base58.encode(\"0x\" + ipns[1])];\n                            }\n                        }\n                        swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n                        if (swarm) {\n                            if (swarm[1].length === (32 * 2)) {\n                                return [2 /*return*/, \"bzz:/\\/\" + swarm[1]];\n                            }\n                        }\n                        skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n                        if (skynet) {\n                            if (skynet[1].length === (34 * 2)) {\n                                urlSafe_1 = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                                hash = (0, base64_1.encode)(\"0x\" + skynet[1]).replace(/[=+\\/]/g, function (a) { return (urlSafe_1[a]); });\n                                return [2 /*return*/, \"sia:/\\/\" + hash];\n                            }\n                        }\n                        return [2 /*return*/, logger.throwError(\"invalid or unsupported content hash data\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"getContentHash()\",\n                                data: hexBytes\n                            })];\n                }\n            });\n        });\n    };\n    Resolver.prototype.getText = function (key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var keyBytes, hexBytes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        keyBytes = (0, strings_1.toUtf8Bytes)(key);\n                        // The nodehash consumes the first slot, so the string pointer targets\n                        // offset 64, with the length at offset 64 and data starting at offset 96\n                        keyBytes = (0, bytes_1.concat)([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n                        // Pad to word-size (32 bytes)\n                        if ((keyBytes.length % 32) !== 0) {\n                            keyBytes = (0, bytes_1.concat)([keyBytes, (0, bytes_1.hexZeroPad)(\"0x\", 32 - (key.length % 32))]);\n                        }\n                        return [4 /*yield*/, this._fetchBytes(\"0x59d1d43c\", (0, bytes_1.hexlify)(keyBytes))];\n                    case 1:\n                        hexBytes = _a.sent();\n                        if (hexBytes == null || hexBytes === \"0x\") {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, (0, strings_1.toUtf8String)(hexBytes)];\n                }\n            });\n        });\n    };\n    return Resolver;\n}());\nexports.Resolver = Resolver;\nvar defaultFormatter = null;\nvar nextPollId = 1;\nvar BaseProvider = /** @class */ (function (_super) {\n    __extends(BaseProvider, _super);\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    function BaseProvider(network) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this) || this;\n        // Events being listened to\n        _this._events = [];\n        _this._emitted = { block: -2 };\n        _this.disableCcipRead = false;\n        _this.formatter = _newTarget.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        (0, properties_1.defineReadOnly)(_this, \"anyNetwork\", (network === \"any\"));\n        if (_this.anyNetwork) {\n            network = _this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            _this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch(function (error) { });\n            // Trigger initial network setting (async)\n            _this._ready().catch(function (error) { });\n        }\n        else {\n            var knownNetwork = (0, properties_1.getStatic)(_newTarget, \"getNetwork\")(network);\n            if (knownNetwork) {\n                (0, properties_1.defineReadOnly)(_this, \"_network\", knownNetwork);\n                _this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        _this._maxInternalBlockNumber = -1024;\n        _this._lastBlockNumber = -2;\n        _this._maxFilterBlockRange = 10;\n        _this._pollingInterval = 4000;\n        _this._fastQueryDate = 0;\n        return _this;\n    }\n    BaseProvider.prototype._ready = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var network, error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this._network == null)) return [3 /*break*/, 7];\n                        network = null;\n                        if (!this._networkPromise) return [3 /*break*/, 4];\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._networkPromise];\n                    case 2:\n                        network = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        error_4 = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 4:\n                        if (!(network == null)) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this.detectNetwork()];\n                    case 5:\n                        network = _a.sent();\n                        _a.label = 6;\n                    case 6:\n                        // This should never happen; every Provider sub-class should have\n                        // suggested a network by here (or have thrown).\n                        if (!network) {\n                            logger.throwError(\"no network detected\", logger_1.Logger.errors.UNKNOWN_ERROR, {});\n                        }\n                        // Possible this call stacked so do not call defineReadOnly again\n                        if (this._network == null) {\n                            if (this.anyNetwork) {\n                                this._network = network;\n                            }\n                            else {\n                                (0, properties_1.defineReadOnly)(this, \"_network\", network);\n                            }\n                            this.emit(\"network\", network, null);\n                        }\n                        _a.label = 7;\n                    case 7: return [2 /*return*/, this._network];\n                }\n            });\n        });\n    };\n    Object.defineProperty(BaseProvider.prototype, \"ready\", {\n        // This will always return the most recently established network.\n        // For \"any\", this can change (a \"network\" event is emitted before\n        // any change is reflected); otherwise this cannot change\n        get: function () {\n            var _this = this;\n            return (0, web_1.poll)(function () {\n                return _this._ready().then(function (network) {\n                    return network;\n                }, function (error) {\n                    // If the network isn't running yet, we will wait\n                    if (error.code === logger_1.Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                        return undefined;\n                    }\n                    throw error;\n                });\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // @TODO: Remove this and just create a singleton formatter\n    BaseProvider.getFormatter = function () {\n        if (defaultFormatter == null) {\n            defaultFormatter = new formatter_1.Formatter();\n        }\n        return defaultFormatter;\n    };\n    // @TODO: Remove this and just use getNetwork\n    BaseProvider.getNetwork = function (network) {\n        return (0, networks_1.getNetwork)((network == null) ? \"homestead\" : network);\n    };\n    BaseProvider.prototype.ccipReadFetch = function (tx, calldata, urls) {\n        return __awaiter(this, void 0, void 0, function () {\n            var sender, data, errorMessages, i, url, href, json, result, errorMessage;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.disableCcipRead || urls.length === 0) {\n                            return [2 /*return*/, null];\n                        }\n                        sender = tx.to.toLowerCase();\n                        data = calldata.toLowerCase();\n                        errorMessages = [];\n                        i = 0;\n                        _a.label = 1;\n                    case 1:\n                        if (!(i < urls.length)) return [3 /*break*/, 4];\n                        url = urls[i];\n                        href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                        json = (url.indexOf(\"{data}\") >= 0) ? null : JSON.stringify({ data: data, sender: sender });\n                        return [4 /*yield*/, (0, web_1.fetchJson)({ url: href, errorPassThrough: true }, json, function (value, response) {\n                                value.status = response.statusCode;\n                                return value;\n                            })];\n                    case 2:\n                        result = _a.sent();\n                        if (result.data) {\n                            return [2 /*return*/, result.data];\n                        }\n                        errorMessage = (result.message || \"unknown error\");\n                        // 4xx indicates the result is not present; stop\n                        if (result.status >= 400 && result.status < 500) {\n                            return [2 /*return*/, logger.throwError(\"response not found during CCIP fetch: \" + errorMessage, logger_1.Logger.errors.SERVER_ERROR, { url: url, errorMessage: errorMessage })];\n                        }\n                        // 5xx indicates server issue; try the next url\n                        errorMessages.push(errorMessage);\n                        _a.label = 3;\n                    case 3:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/, logger.throwError(\"error encountered during CCIP fetch: \" + errorMessages.map(function (m) { return JSON.stringify(m); }).join(\", \"), logger_1.Logger.errors.SERVER_ERROR, {\n                            urls: urls,\n                            errorMessages: errorMessages\n                        })];\n                }\n            });\n        });\n    };\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    BaseProvider.prototype._getInternalBlockNumber = function (maxAge) {\n        return __awaiter(this, void 0, void 0, function () {\n            var internalBlockNumber, result, error_5, reqTime, checkInternalBlockNumber;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._ready()];\n                    case 1:\n                        _a.sent();\n                        if (!(maxAge > 0)) return [3 /*break*/, 7];\n                        _a.label = 2;\n                    case 2:\n                        if (!this._internalBlockNumber) return [3 /*break*/, 7];\n                        internalBlockNumber = this._internalBlockNumber;\n                        _a.label = 3;\n                    case 3:\n                        _a.trys.push([3, 5, , 6]);\n                        return [4 /*yield*/, internalBlockNumber];\n                    case 4:\n                        result = _a.sent();\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return [2 /*return*/, result.blockNumber];\n                        }\n                        // Too old; fetch a new value\n                        return [3 /*break*/, 7];\n                    case 5:\n                        error_5 = _a.sent();\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            return [3 /*break*/, 7];\n                        }\n                        return [3 /*break*/, 6];\n                    case 6: return [3 /*break*/, 2];\n                    case 7:\n                        reqTime = getTime();\n                        checkInternalBlockNumber = (0, properties_1.resolveProperties)({\n                            blockNumber: this.perform(\"getBlockNumber\", {}),\n                            networkError: this.getNetwork().then(function (network) { return (null); }, function (error) { return (error); })\n                        }).then(function (_a) {\n                            var blockNumber = _a.blockNumber, networkError = _a.networkError;\n                            if (networkError) {\n                                // Unremember this bad internal block number\n                                if (_this._internalBlockNumber === checkInternalBlockNumber) {\n                                    _this._internalBlockNumber = null;\n                                }\n                                throw networkError;\n                            }\n                            var respTime = getTime();\n                            blockNumber = bignumber_1.BigNumber.from(blockNumber).toNumber();\n                            if (blockNumber < _this._maxInternalBlockNumber) {\n                                blockNumber = _this._maxInternalBlockNumber;\n                            }\n                            _this._maxInternalBlockNumber = blockNumber;\n                            _this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                            return { blockNumber: blockNumber, reqTime: reqTime, respTime: respTime };\n                        });\n                        this._internalBlockNumber = checkInternalBlockNumber;\n                        // Swallow unhandled exceptions; if needed they are handled else where\n                        checkInternalBlockNumber.catch(function (error) {\n                            // Don't null the dead (rejected) fetch, if it has already been updated\n                            if (_this._internalBlockNumber === checkInternalBlockNumber) {\n                                _this._internalBlockNumber = null;\n                            }\n                        });\n                        return [4 /*yield*/, checkInternalBlockNumber];\n                    case 8: return [2 /*return*/, (_a.sent()).blockNumber];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.poll = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var pollId, runners, blockNumber, error_6, i;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        pollId = nextPollId++;\n                        runners = [];\n                        blockNumber = null;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._getInternalBlockNumber(100 + this.pollingInterval / 2)];\n                    case 2:\n                        blockNumber = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        error_6 = _a.sent();\n                        this.emit(\"error\", error_6);\n                        return [2 /*return*/];\n                    case 4:\n                        this._setFastBlockNumber(blockNumber);\n                        // Emit a poll event after we have the latest (fast) block number\n                        this.emit(\"poll\", pollId, blockNumber);\n                        // If the block has not changed, meh.\n                        if (blockNumber === this._lastBlockNumber) {\n                            this.emit(\"didPoll\", pollId);\n                            return [2 /*return*/];\n                        }\n                        // First polling cycle, trigger a \"block\" events\n                        if (this._emitted.block === -2) {\n                            this._emitted.block = blockNumber - 1;\n                        }\n                        if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                            logger.warn(\"network block skew detected; skipping block events (emitted=\" + this._emitted.block + \" blockNumber\" + blockNumber + \")\");\n                            this.emit(\"error\", logger.makeError(\"network block skew detected\", logger_1.Logger.errors.NETWORK_ERROR, {\n                                blockNumber: blockNumber,\n                                event: \"blockSkew\",\n                                previousBlockNumber: this._emitted.block\n                            }));\n                            this.emit(\"block\", blockNumber);\n                        }\n                        else {\n                            // Notify all listener for each block that has passed\n                            for (i = this._emitted.block + 1; i <= blockNumber; i++) {\n                                this.emit(\"block\", i);\n                            }\n                        }\n                        // The emitted block was updated, check for obsolete events\n                        if (this._emitted.block !== blockNumber) {\n                            this._emitted.block = blockNumber;\n                            Object.keys(this._emitted).forEach(function (key) {\n                                // The block event does not expire\n                                if (key === \"block\") {\n                                    return;\n                                }\n                                // The block we were at when we emitted this event\n                                var eventBlockNumber = _this._emitted[key];\n                                // We cannot garbage collect pending transactions or blocks here\n                                // They should be garbage collected by the Provider when setting\n                                // \"pending\" events\n                                if (eventBlockNumber === \"pending\") {\n                                    return;\n                                }\n                                // Evict any transaction hashes or block hashes over 12 blocks\n                                // old, since they should not return null anyways\n                                if (blockNumber - eventBlockNumber > 12) {\n                                    delete _this._emitted[key];\n                                }\n                            });\n                        }\n                        // First polling cycle\n                        if (this._lastBlockNumber === -2) {\n                            this._lastBlockNumber = blockNumber - 1;\n                        }\n                        // Find all transaction hashes we are waiting on\n                        this._events.forEach(function (event) {\n                            switch (event.type) {\n                                case \"tx\": {\n                                    var hash_2 = event.hash;\n                                    var runner = _this.getTransactionReceipt(hash_2).then(function (receipt) {\n                                        if (!receipt || receipt.blockNumber == null) {\n                                            return null;\n                                        }\n                                        _this._emitted[\"t:\" + hash_2] = receipt.blockNumber;\n                                        _this.emit(hash_2, receipt);\n                                        return null;\n                                    }).catch(function (error) { _this.emit(\"error\", error); });\n                                    runners.push(runner);\n                                    break;\n                                }\n                                case \"filter\": {\n                                    // We only allow a single getLogs to be in-flight at a time\n                                    if (!event._inflight) {\n                                        event._inflight = true;\n                                        // This is the first filter for this event, so we want to\n                                        // restrict events to events that happened no earlier than now\n                                        if (event._lastBlockNumber === -2) {\n                                            event._lastBlockNumber = blockNumber - 1;\n                                        }\n                                        // Filter from the last *known* event; due to load-balancing\n                                        // and some nodes returning updated block numbers before\n                                        // indexing events, a logs result with 0 entries cannot be\n                                        // trusted and we must retry a range which includes it again\n                                        var filter_1 = event.filter;\n                                        filter_1.fromBlock = event._lastBlockNumber + 1;\n                                        filter_1.toBlock = blockNumber;\n                                        // Prevent fitler ranges from growing too wild, since it is quite\n                                        // likely there just haven't been any events to move the lastBlockNumber.\n                                        var minFromBlock = filter_1.toBlock - _this._maxFilterBlockRange;\n                                        if (minFromBlock > filter_1.fromBlock) {\n                                            filter_1.fromBlock = minFromBlock;\n                                        }\n                                        if (filter_1.fromBlock < 0) {\n                                            filter_1.fromBlock = 0;\n                                        }\n                                        var runner = _this.getLogs(filter_1).then(function (logs) {\n                                            // Allow the next getLogs\n                                            event._inflight = false;\n                                            if (logs.length === 0) {\n                                                return;\n                                            }\n                                            logs.forEach(function (log) {\n                                                // Only when we get an event for a given block number\n                                                // can we trust the events are indexed\n                                                if (log.blockNumber > event._lastBlockNumber) {\n                                                    event._lastBlockNumber = log.blockNumber;\n                                                }\n                                                // Make sure we stall requests to fetch blocks and txs\n                                                _this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                                _this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                                _this.emit(filter_1, log);\n                                            });\n                                        }).catch(function (error) {\n                                            _this.emit(\"error\", error);\n                                            // Allow another getLogs (the range was not updated)\n                                            event._inflight = false;\n                                        });\n                                        runners.push(runner);\n                                    }\n                                    break;\n                                }\n                            }\n                        });\n                        this._lastBlockNumber = blockNumber;\n                        // Once all events for this loop have been processed, emit \"didPoll\"\n                        Promise.all(runners).then(function () {\n                            _this.emit(\"didPoll\", pollId);\n                        }).catch(function (error) { _this.emit(\"error\", error); });\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // Deprecated; do not use this\n    BaseProvider.prototype.resetEventsBlock = function (blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    };\n    Object.defineProperty(BaseProvider.prototype, \"network\", {\n        get: function () {\n            return this._network;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    BaseProvider.prototype.detectNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, logger.throwError(\"provider does not support network detection\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"provider.detectNetwork\"\n                    })];\n            });\n        });\n    };\n    BaseProvider.prototype.getNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var network, currentNetwork, error;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._ready()];\n                    case 1:\n                        network = _a.sent();\n                        return [4 /*yield*/, this.detectNetwork()];\n                    case 2:\n                        currentNetwork = _a.sent();\n                        if (!(network.chainId !== currentNetwork.chainId)) return [3 /*break*/, 5];\n                        if (!this.anyNetwork) return [3 /*break*/, 4];\n                        this._network = currentNetwork;\n                        // Reset all internal block number guards and caches\n                        this._lastBlockNumber = -2;\n                        this._fastBlockNumber = null;\n                        this._fastBlockNumberPromise = null;\n                        this._fastQueryDate = 0;\n                        this._emitted.block = -2;\n                        this._maxInternalBlockNumber = -1024;\n                        this._internalBlockNumber = null;\n                        // The \"network\" event MUST happen before this method resolves\n                        // so any events have a chance to unregister, so we stall an\n                        // additional event loop before returning from /this/ call\n                        this.emit(\"network\", currentNetwork, network);\n                        return [4 /*yield*/, stall(0)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, this._network];\n                    case 4:\n                        error = logger.makeError(\"underlying network changed\", logger_1.Logger.errors.NETWORK_ERROR, {\n                            event: \"changed\",\n                            network: network,\n                            detectedNetwork: currentNetwork\n                        });\n                        this.emit(\"error\", error);\n                        throw error;\n                    case 5: return [2 /*return*/, network];\n                }\n            });\n        });\n    };\n    Object.defineProperty(BaseProvider.prototype, \"blockNumber\", {\n        get: function () {\n            var _this = this;\n            this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(function (blockNumber) {\n                _this._setFastBlockNumber(blockNumber);\n            }, function (error) { });\n            return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseProvider.prototype, \"polling\", {\n        get: function () {\n            return (this._poller != null);\n        },\n        set: function (value) {\n            var _this = this;\n            if (value && !this._poller) {\n                this._poller = setInterval(function () { _this.poll(); }, this.pollingInterval);\n                if (!this._bootstrapPoll) {\n                    this._bootstrapPoll = setTimeout(function () {\n                        _this.poll();\n                        // We block additional polls until the polling interval\n                        // is done, to prevent overwhelming the poll function\n                        _this._bootstrapPoll = setTimeout(function () {\n                            // If polling was disabled, something may require a poke\n                            // since starting the bootstrap poll and it was disabled\n                            if (!_this._poller) {\n                                _this.poll();\n                            }\n                            // Clear out the bootstrap so we can do another\n                            _this._bootstrapPoll = null;\n                        }, _this.pollingInterval);\n                    }, 0);\n                }\n            }\n            else if (!value && this._poller) {\n                clearInterval(this._poller);\n                this._poller = null;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseProvider.prototype, \"pollingInterval\", {\n        get: function () {\n            return this._pollingInterval;\n        },\n        set: function (value) {\n            var _this = this;\n            if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n                throw new Error(\"invalid polling interval\");\n            }\n            this._pollingInterval = value;\n            if (this._poller) {\n                clearInterval(this._poller);\n                this._poller = setInterval(function () { _this.poll(); }, this._pollingInterval);\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BaseProvider.prototype._getFastBlockNumber = function () {\n        var _this = this;\n        var now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then(function (blockNumber) {\n                if (_this._fastBlockNumber == null || blockNumber > _this._fastBlockNumber) {\n                    _this._fastBlockNumber = blockNumber;\n                }\n                return _this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    };\n    BaseProvider.prototype._setFastBlockNumber = function (blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    };\n    BaseProvider.prototype.waitForTransaction = function (transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null)];\n            });\n        });\n    };\n    BaseProvider.prototype._waitForTransaction = function (transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function () {\n            var receipt;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getTransactionReceipt(transactionHash)];\n                    case 1:\n                        receipt = _a.sent();\n                        // Receipt is already good\n                        if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                            return [2 /*return*/, receipt];\n                        }\n                        // Poll until the receipt is good...\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\n                                var cancelFuncs = [];\n                                var done = false;\n                                var alreadyDone = function () {\n                                    if (done) {\n                                        return true;\n                                    }\n                                    done = true;\n                                    cancelFuncs.forEach(function (func) { func(); });\n                                    return false;\n                                };\n                                var minedHandler = function (receipt) {\n                                    if (receipt.confirmations < confirmations) {\n                                        return;\n                                    }\n                                    if (alreadyDone()) {\n                                        return;\n                                    }\n                                    resolve(receipt);\n                                };\n                                _this.on(transactionHash, minedHandler);\n                                cancelFuncs.push(function () { _this.removeListener(transactionHash, minedHandler); });\n                                if (replaceable) {\n                                    var lastBlockNumber_1 = replaceable.startBlock;\n                                    var scannedBlock_1 = null;\n                                    var replaceHandler_1 = function (blockNumber) { return __awaiter(_this, void 0, void 0, function () {\n                                        var _this = this;\n                                        return __generator(this, function (_a) {\n                                            switch (_a.label) {\n                                                case 0:\n                                                    if (done) {\n                                                        return [2 /*return*/];\n                                                    }\n                                                    // Wait 1 second; this is only used in the case of a fault, so\n                                                    // we will trade off a little bit of latency for more consistent\n                                                    // results and fewer JSON-RPC calls\n                                                    return [4 /*yield*/, stall(1000)];\n                                                case 1:\n                                                    // Wait 1 second; this is only used in the case of a fault, so\n                                                    // we will trade off a little bit of latency for more consistent\n                                                    // results and fewer JSON-RPC calls\n                                                    _a.sent();\n                                                    this.getTransactionCount(replaceable.from).then(function (nonce) { return __awaiter(_this, void 0, void 0, function () {\n                                                        var mined, block, ti, tx, receipt_1, reason;\n                                                        return __generator(this, function (_a) {\n                                                            switch (_a.label) {\n                                                                case 0:\n                                                                    if (done) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    if (!(nonce <= replaceable.nonce)) return [3 /*break*/, 1];\n                                                                    lastBlockNumber_1 = blockNumber;\n                                                                    return [3 /*break*/, 9];\n                                                                case 1: return [4 /*yield*/, this.getTransaction(transactionHash)];\n                                                                case 2:\n                                                                    mined = _a.sent();\n                                                                    if (mined && mined.blockNumber != null) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    // First time scanning. We start a little earlier for some\n                                                                    // wiggle room here to handle the eventually consistent nature\n                                                                    // of blockchain (e.g. the getTransactionCount was for a\n                                                                    // different block)\n                                                                    if (scannedBlock_1 == null) {\n                                                                        scannedBlock_1 = lastBlockNumber_1 - 3;\n                                                                        if (scannedBlock_1 < replaceable.startBlock) {\n                                                                            scannedBlock_1 = replaceable.startBlock;\n                                                                        }\n                                                                    }\n                                                                    _a.label = 3;\n                                                                case 3:\n                                                                    if (!(scannedBlock_1 <= blockNumber)) return [3 /*break*/, 9];\n                                                                    if (done) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    return [4 /*yield*/, this.getBlockWithTransactions(scannedBlock_1)];\n                                                                case 4:\n                                                                    block = _a.sent();\n                                                                    ti = 0;\n                                                                    _a.label = 5;\n                                                                case 5:\n                                                                    if (!(ti < block.transactions.length)) return [3 /*break*/, 8];\n                                                                    tx = block.transactions[ti];\n                                                                    // Successfully mined!\n                                                                    if (tx.hash === transactionHash) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    if (!(tx.from === replaceable.from && tx.nonce === replaceable.nonce)) return [3 /*break*/, 7];\n                                                                    if (done) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    return [4 /*yield*/, this.waitForTransaction(tx.hash, confirmations)];\n                                                                case 6:\n                                                                    receipt_1 = _a.sent();\n                                                                    // Already resolved or rejected (prolly a timeout)\n                                                                    if (alreadyDone()) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    reason = \"replaced\";\n                                                                    if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                                        reason = \"repriced\";\n                                                                    }\n                                                                    else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                                        reason = \"cancelled\";\n                                                                    }\n                                                                    // Explain why we were replaced\n                                                                    reject(logger.makeError(\"transaction was replaced\", logger_1.Logger.errors.TRANSACTION_REPLACED, {\n                                                                        cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                                        reason: reason,\n                                                                        replacement: this._wrapTransaction(tx),\n                                                                        hash: transactionHash,\n                                                                        receipt: receipt_1\n                                                                    }));\n                                                                    return [2 /*return*/];\n                                                                case 7:\n                                                                    ti++;\n                                                                    return [3 /*break*/, 5];\n                                                                case 8:\n                                                                    scannedBlock_1++;\n                                                                    return [3 /*break*/, 3];\n                                                                case 9:\n                                                                    if (done) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    this.once(\"block\", replaceHandler_1);\n                                                                    return [2 /*return*/];\n                                                            }\n                                                        });\n                                                    }); }, function (error) {\n                                                        if (done) {\n                                                            return;\n                                                        }\n                                                        _this.once(\"block\", replaceHandler_1);\n                                                    });\n                                                    return [2 /*return*/];\n                                            }\n                                        });\n                                    }); };\n                                    if (done) {\n                                        return;\n                                    }\n                                    _this.once(\"block\", replaceHandler_1);\n                                    cancelFuncs.push(function () {\n                                        _this.removeListener(\"block\", replaceHandler_1);\n                                    });\n                                }\n                                if (typeof (timeout) === \"number\" && timeout > 0) {\n                                    var timer_1 = setTimeout(function () {\n                                        if (alreadyDone()) {\n                                            return;\n                                        }\n                                        reject(logger.makeError(\"timeout exceeded\", logger_1.Logger.errors.TIMEOUT, { timeout: timeout }));\n                                    }, timeout);\n                                    if (timer_1.unref) {\n                                        timer_1.unref();\n                                    }\n                                    cancelFuncs.push(function () { clearTimeout(timer_1); });\n                                }\n                            })];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getBlockNumber = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this._getInternalBlockNumber(0)];\n            });\n        });\n    };\n    BaseProvider.prototype.getGasPrice = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this.perform(\"getGasPrice\", {})];\n                    case 2:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, bignumber_1.BigNumber.from(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"getGasPrice\",\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getBalance = function (addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                address: this._getAddress(addressOrName),\n                                blockTag: this._getBlockTag(blockTag)\n                            })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"getBalance\", params)];\n                    case 3:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, bignumber_1.BigNumber.from(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"getBalance\",\n                                    params: params,\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getTransactionCount = function (addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                address: this._getAddress(addressOrName),\n                                blockTag: this._getBlockTag(blockTag)\n                            })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"getTransactionCount\", params)];\n                    case 3:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, bignumber_1.BigNumber.from(result).toNumber()];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"getTransactionCount\",\n                                    params: params,\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getCode = function (addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                address: this._getAddress(addressOrName),\n                                blockTag: this._getBlockTag(blockTag)\n                            })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"getCode\", params)];\n                    case 3:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, (0, bytes_1.hexlify)(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"getCode\",\n                                    params: params,\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getStorageAt = function (addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                address: this._getAddress(addressOrName),\n                                blockTag: this._getBlockTag(blockTag),\n                                position: Promise.resolve(position).then(function (p) { return (0, bytes_1.hexValue)(p); })\n                            })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"getStorageAt\", params)];\n                    case 3:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, (0, bytes_1.hexlify)(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"getStorageAt\",\n                                    params: params,\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // This should be called by any subclass wrapping a TransactionResponse\n    BaseProvider.prototype._wrapTransaction = function (tx, hash, startBlock) {\n        var _this = this;\n        if (hash != null && (0, bytes_1.hexDataLength)(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        var result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", logger_1.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = function (confirms, timeout) { return __awaiter(_this, void 0, void 0, function () {\n            var replacement, receipt;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (confirms == null) {\n                            confirms = 1;\n                        }\n                        if (timeout == null) {\n                            timeout = 0;\n                        }\n                        replacement = undefined;\n                        if (confirms !== 0 && startBlock != null) {\n                            replacement = {\n                                data: tx.data,\n                                from: tx.from,\n                                nonce: tx.nonce,\n                                to: tx.to,\n                                value: tx.value,\n                                startBlock: startBlock\n                            };\n                        }\n                        return [4 /*yield*/, this._waitForTransaction(tx.hash, confirms, timeout, replacement)];\n                    case 1:\n                        receipt = _a.sent();\n                        if (receipt == null && confirms === 0) {\n                            return [2 /*return*/, null];\n                        }\n                        // No longer pending, allow the polling loop to garbage collect this\n                        this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n                        if (receipt.status === 0) {\n                            logger.throwError(\"transaction failed\", logger_1.Logger.errors.CALL_EXCEPTION, {\n                                transactionHash: tx.hash,\n                                transaction: tx,\n                                receipt: receipt\n                            });\n                        }\n                        return [2 /*return*/, receipt];\n                }\n            });\n        }); };\n        return result;\n    };\n    BaseProvider.prototype.sendTransaction = function (signedTransaction) {\n        return __awaiter(this, void 0, void 0, function () {\n            var hexTx, tx, blockNumber, hash, error_7;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, Promise.resolve(signedTransaction).then(function (t) { return (0, bytes_1.hexlify)(t); })];\n                    case 2:\n                        hexTx = _a.sent();\n                        tx = this.formatter.transaction(signedTransaction);\n                        if (tx.confirmations == null) {\n                            tx.confirmations = 0;\n                        }\n                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n                    case 3:\n                        blockNumber = _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        _a.trys.push([4, 6, , 7]);\n                        return [4 /*yield*/, this.perform(\"sendTransaction\", { signedTransaction: hexTx })];\n                    case 5:\n                        hash = _a.sent();\n                        return [2 /*return*/, this._wrapTransaction(tx, hash, blockNumber)];\n                    case 6:\n                        error_7 = _a.sent();\n                        error_7.transaction = tx;\n                        error_7.transactionHash = tx.hash;\n                        throw error_7;\n                    case 7: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getTransactionRequest = function (transaction) {\n        return __awaiter(this, void 0, void 0, function () {\n            var values, tx, _a, _b;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, transaction];\n                    case 1:\n                        values = _c.sent();\n                        tx = {};\n                        [\"from\", \"to\"].forEach(function (key) {\n                            if (values[key] == null) {\n                                return;\n                            }\n                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? _this._getAddress(v) : null); });\n                        });\n                        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach(function (key) {\n                            if (values[key] == null) {\n                                return;\n                            }\n                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? bignumber_1.BigNumber.from(v) : null); });\n                        });\n                        [\"type\"].forEach(function (key) {\n                            if (values[key] == null) {\n                                return;\n                            }\n                            tx[key] = Promise.resolve(values[key]).then(function (v) { return ((v != null) ? v : null); });\n                        });\n                        if (values.accessList) {\n                            tx.accessList = this.formatter.accessList(values.accessList);\n                        }\n                        [\"data\"].forEach(function (key) {\n                            if (values[key] == null) {\n                                return;\n                            }\n                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? (0, bytes_1.hexlify)(v) : null); });\n                        });\n                        _b = (_a = this.formatter).transactionRequest;\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)(tx)];\n                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getFilter = function (filter) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, _a, _b;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, filter];\n                    case 1:\n                        filter = _c.sent();\n                        result = {};\n                        if (filter.address != null) {\n                            result.address = this._getAddress(filter.address);\n                        }\n                        [\"blockHash\", \"topics\"].forEach(function (key) {\n                            if (filter[key] == null) {\n                                return;\n                            }\n                            result[key] = filter[key];\n                        });\n                        [\"fromBlock\", \"toBlock\"].forEach(function (key) {\n                            if (filter[key] == null) {\n                                return;\n                            }\n                            result[key] = _this._getBlockTag(filter[key]);\n                        });\n                        _b = (_a = this.formatter).filter;\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)(result)];\n                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._call = function (transaction, blockTag, attempt) {\n        return __awaiter(this, void 0, void 0, function () {\n            var txSender, result, data, sender, urls, urlsOffset, urlsLength, urlsData, u, url, calldata, callbackSelector, extraData, ccipResult, tx, error_8;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (attempt >= MAX_CCIP_REDIRECTS) {\n                            logger.throwError(\"CCIP read exceeded maximum redirections\", logger_1.Logger.errors.SERVER_ERROR, {\n                                redirects: attempt,\n                                transaction: transaction\n                            });\n                        }\n                        txSender = transaction.to;\n                        return [4 /*yield*/, this.perform(\"call\", { transaction: transaction, blockTag: blockTag })];\n                    case 1:\n                        result = _a.sent();\n                        if (!(attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && ((0, bytes_1.hexDataLength)(result) % 32 === 4))) return [3 /*break*/, 5];\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        data = (0, bytes_1.hexDataSlice)(result, 4);\n                        sender = (0, bytes_1.hexDataSlice)(data, 0, 32);\n                        if (!bignumber_1.BigNumber.from(sender).eq(txSender)) {\n                            logger.throwError(\"CCIP Read sender did not match\", logger_1.Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction: transaction,\n                                data: result\n                            });\n                        }\n                        urls = [];\n                        urlsOffset = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, 32, 64)).toNumber();\n                        urlsLength = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();\n                        urlsData = (0, bytes_1.hexDataSlice)(data, urlsOffset + 32);\n                        for (u = 0; u < urlsLength; u++) {\n                            url = _parseString(urlsData, u * 32);\n                            if (url == null) {\n                                logger.throwError(\"CCIP Read contained corrupt URL string\", logger_1.Logger.errors.CALL_EXCEPTION, {\n                                    name: \"OffchainLookup\",\n                                    signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                    transaction: transaction,\n                                    data: result\n                                });\n                            }\n                            urls.push(url);\n                        }\n                        calldata = _parseBytes(data, 64);\n                        // Get the callbackSelector (bytes4)\n                        if (!bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, 100, 128)).isZero()) {\n                            logger.throwError(\"CCIP Read callback selector included junk\", logger_1.Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction: transaction,\n                                data: result\n                            });\n                        }\n                        callbackSelector = (0, bytes_1.hexDataSlice)(data, 96, 100);\n                        extraData = _parseBytes(data, 128);\n                        return [4 /*yield*/, this.ccipReadFetch(transaction, calldata, urls)];\n                    case 3:\n                        ccipResult = _a.sent();\n                        if (ccipResult == null) {\n                            logger.throwError(\"CCIP Read disabled or provided no URLs\", logger_1.Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction: transaction,\n                                data: result\n                            });\n                        }\n                        tx = {\n                            to: txSender,\n                            data: (0, bytes_1.hexConcat)([callbackSelector, encodeBytes([ccipResult, extraData])])\n                        };\n                        return [2 /*return*/, this._call(tx, blockTag, attempt + 1)];\n                    case 4:\n                        error_8 = _a.sent();\n                        if (error_8.code === logger_1.Logger.errors.SERVER_ERROR) {\n                            throw error_8;\n                        }\n                        return [3 /*break*/, 5];\n                    case 5:\n                        try {\n                            return [2 /*return*/, (0, bytes_1.hexlify)(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"call\",\n                                    params: { transaction: transaction, blockTag: blockTag },\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.call = function (transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var resolved;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                transaction: this._getTransactionRequest(transaction),\n                                blockTag: this._getBlockTag(blockTag),\n                                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n                            })];\n                    case 2:\n                        resolved = _a.sent();\n                        return [2 /*return*/, this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1)];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.estimateGas = function (transaction) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                transaction: this._getTransactionRequest(transaction)\n                            })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"estimateGas\", params)];\n                    case 3:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, bignumber_1.BigNumber.from(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"estimateGas\",\n                                    params: params,\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getAddress = function (addressOrName) {\n        return __awaiter(this, void 0, void 0, function () {\n            var address;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, addressOrName];\n                    case 1:\n                        addressOrName = _a.sent();\n                        if (typeof (addressOrName) !== \"string\") {\n                            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n                        }\n                        return [4 /*yield*/, this.resolveName(addressOrName)];\n                    case 2:\n                        address = _a.sent();\n                        if (address == null) {\n                            logger.throwError(\"ENS name not configured\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"resolveName(\" + JSON.stringify(addressOrName) + \")\"\n                            });\n                        }\n                        return [2 /*return*/, address];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getBlock = function (blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockNumber, params, _a, error_9;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _b.sent();\n                        return [4 /*yield*/, blockHashOrBlockTag];\n                    case 2:\n                        blockHashOrBlockTag = _b.sent();\n                        blockNumber = -128;\n                        params = {\n                            includeTransactions: !!includeTransactions\n                        };\n                        if (!(0, bytes_1.isHexString)(blockHashOrBlockTag, 32)) return [3 /*break*/, 3];\n                        params.blockHash = blockHashOrBlockTag;\n                        return [3 /*break*/, 6];\n                    case 3:\n                        _b.trys.push([3, 5, , 6]);\n                        _a = params;\n                        return [4 /*yield*/, this._getBlockTag(blockHashOrBlockTag)];\n                    case 4:\n                        _a.blockTag = _b.sent();\n                        if ((0, bytes_1.isHexString)(params.blockTag)) {\n                            blockNumber = parseInt(params.blockTag.substring(2), 16);\n                        }\n                        return [3 /*break*/, 6];\n                    case 5:\n                        error_9 = _b.sent();\n                        logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                        return [3 /*break*/, 6];\n                    case 6: return [2 /*return*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n                            var block, blockNumber_1, i, tx, confirmations, blockWithTxs;\n                            var _this = this;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0: return [4 /*yield*/, this.perform(\"getBlock\", params)];\n                                    case 1:\n                                        block = _a.sent();\n                                        // Block was not found\n                                        if (block == null) {\n                                            // For blockhashes, if we didn't say it existed, that blockhash may\n                                            // not exist. If we did see it though, perhaps from a log, we know\n                                            // it exists, and this node is just not caught up yet.\n                                            if (params.blockHash != null) {\n                                                if (this._emitted[\"b:\" + params.blockHash] == null) {\n                                                    return [2 /*return*/, null];\n                                                }\n                                            }\n                                            // For block tags, if we are asking for a future block, we return null\n                                            if (params.blockTag != null) {\n                                                if (blockNumber > this._emitted.block) {\n                                                    return [2 /*return*/, null];\n                                                }\n                                            }\n                                            // Retry on the next block\n                                            return [2 /*return*/, undefined];\n                                        }\n                                        if (!includeTransactions) return [3 /*break*/, 8];\n                                        blockNumber_1 = null;\n                                        i = 0;\n                                        _a.label = 2;\n                                    case 2:\n                                        if (!(i < block.transactions.length)) return [3 /*break*/, 7];\n                                        tx = block.transactions[i];\n                                        if (!(tx.blockNumber == null)) return [3 /*break*/, 3];\n                                        tx.confirmations = 0;\n                                        return [3 /*break*/, 6];\n                                    case 3:\n                                        if (!(tx.confirmations == null)) return [3 /*break*/, 6];\n                                        if (!(blockNumber_1 == null)) return [3 /*break*/, 5];\n                                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n                                    case 4:\n                                        blockNumber_1 = _a.sent();\n                                        _a.label = 5;\n                                    case 5:\n                                        confirmations = (blockNumber_1 - tx.blockNumber) + 1;\n                                        if (confirmations <= 0) {\n                                            confirmations = 1;\n                                        }\n                                        tx.confirmations = confirmations;\n                                        _a.label = 6;\n                                    case 6:\n                                        i++;\n                                        return [3 /*break*/, 2];\n                                    case 7:\n                                        blockWithTxs = this.formatter.blockWithTransactions(block);\n                                        blockWithTxs.transactions = blockWithTxs.transactions.map(function (tx) { return _this._wrapTransaction(tx); });\n                                        return [2 /*return*/, blockWithTxs];\n                                    case 8: return [2 /*return*/, this.formatter.block(block)];\n                                }\n                            });\n                        }); }, { oncePoll: this })];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getBlock = function (blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    };\n    BaseProvider.prototype.getBlockWithTransactions = function (blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    };\n    BaseProvider.prototype.getTransaction = function (transactionHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, transactionHash];\n                    case 2:\n                        transactionHash = _a.sent();\n                        params = { transactionHash: this.formatter.hash(transactionHash, true) };\n                        return [2 /*return*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n                                var result, tx, blockNumber, confirmations;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, this.perform(\"getTransaction\", params)];\n                                        case 1:\n                                            result = _a.sent();\n                                            if (result == null) {\n                                                if (this._emitted[\"t:\" + transactionHash] == null) {\n                                                    return [2 /*return*/, null];\n                                                }\n                                                return [2 /*return*/, undefined];\n                                            }\n                                            tx = this.formatter.transactionResponse(result);\n                                            if (!(tx.blockNumber == null)) return [3 /*break*/, 2];\n                                            tx.confirmations = 0;\n                                            return [3 /*break*/, 4];\n                                        case 2:\n                                            if (!(tx.confirmations == null)) return [3 /*break*/, 4];\n                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n                                        case 3:\n                                            blockNumber = _a.sent();\n                                            confirmations = (blockNumber - tx.blockNumber) + 1;\n                                            if (confirmations <= 0) {\n                                                confirmations = 1;\n                                            }\n                                            tx.confirmations = confirmations;\n                                            _a.label = 4;\n                                        case 4: return [2 /*return*/, this._wrapTransaction(tx)];\n                                    }\n                                });\n                            }); }, { oncePoll: this })];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getTransactionReceipt = function (transactionHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, transactionHash];\n                    case 2:\n                        transactionHash = _a.sent();\n                        params = { transactionHash: this.formatter.hash(transactionHash, true) };\n                        return [2 /*return*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n                                var result, receipt, blockNumber, confirmations;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, this.perform(\"getTransactionReceipt\", params)];\n                                        case 1:\n                                            result = _a.sent();\n                                            if (result == null) {\n                                                if (this._emitted[\"t:\" + transactionHash] == null) {\n                                                    return [2 /*return*/, null];\n                                                }\n                                                return [2 /*return*/, undefined];\n                                            }\n                                            // \"geth-etc\" returns receipts before they are ready\n                                            if (result.blockHash == null) {\n                                                return [2 /*return*/, undefined];\n                                            }\n                                            receipt = this.formatter.receipt(result);\n                                            if (!(receipt.blockNumber == null)) return [3 /*break*/, 2];\n                                            receipt.confirmations = 0;\n                                            return [3 /*break*/, 4];\n                                        case 2:\n                                            if (!(receipt.confirmations == null)) return [3 /*break*/, 4];\n                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n                                        case 3:\n                                            blockNumber = _a.sent();\n                                            confirmations = (blockNumber - receipt.blockNumber) + 1;\n                                            if (confirmations <= 0) {\n                                                confirmations = 1;\n                                            }\n                                            receipt.confirmations = confirmations;\n                                            _a.label = 4;\n                                        case 4: return [2 /*return*/, receipt];\n                                    }\n                                });\n                            }); }, { oncePoll: this })];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getLogs = function (filter) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, logs;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({ filter: this._getFilter(filter) })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"getLogs\", params)];\n                    case 3:\n                        logs = _a.sent();\n                        logs.forEach(function (log) {\n                            if (log.removed == null) {\n                                log.removed = false;\n                            }\n                        });\n                        return [2 /*return*/, formatter_1.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs)];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getEtherPrice = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, this.perform(\"getEtherPrice\", {})];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getBlockTag = function (blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, blockTag];\n                    case 1:\n                        blockTag = _a.sent();\n                        if (!(typeof (blockTag) === \"number\" && blockTag < 0)) return [3 /*break*/, 3];\n                        if (blockTag % 1) {\n                            logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                        }\n                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n                    case 2:\n                        blockNumber = _a.sent();\n                        blockNumber += blockTag;\n                        if (blockNumber < 0) {\n                            blockNumber = 0;\n                        }\n                        return [2 /*return*/, this.formatter.blockTag(blockNumber)];\n                    case 3: return [2 /*return*/, this.formatter.blockTag(blockTag)];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getResolver = function (name) {\n        return __awaiter(this, void 0, void 0, function () {\n            var currentName, addr, resolver, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        currentName = name;\n                        _b.label = 1;\n                    case 1:\n                        if (false) {}\n                        if (currentName === \"\" || currentName === \".\") {\n                            return [2 /*return*/, null];\n                        }\n                        // Optimization since the eth node cannot change and does\n                        // not have a wildcard resolver\n                        if (name !== \"eth\" && currentName === \"eth\") {\n                            return [2 /*return*/, null];\n                        }\n                        return [4 /*yield*/, this._getResolver(currentName, \"getResolver\")];\n                    case 2:\n                        addr = _b.sent();\n                        if (!(addr != null)) return [3 /*break*/, 5];\n                        resolver = new Resolver(this, addr, name);\n                        _a = currentName !== name;\n                        if (!_a) return [3 /*break*/, 4];\n                        return [4 /*yield*/, resolver.supportsWildcard()];\n                    case 3:\n                        _a = !(_b.sent());\n                        _b.label = 4;\n                    case 4:\n                        // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                        if (_a) {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, resolver];\n                    case 5:\n                        // Get the parent node\n                        currentName = currentName.split(\".\").slice(1).join(\".\");\n                        return [3 /*break*/, 1];\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getResolver = function (name, operation) {\n        return __awaiter(this, void 0, void 0, function () {\n            var network, addrData, error_10;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (operation == null) {\n                            operation = \"ENS\";\n                        }\n                        return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        network = _a.sent();\n                        // No ENS...\n                        if (!network.ensAddress) {\n                            logger.throwError(\"network does not support ENS\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: operation, network: network.name });\n                        }\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.call({\n                                to: network.ensAddress,\n                                data: (\"0x0178b8bf\" + (0, hash_1.namehash)(name).substring(2))\n                            })];\n                    case 3:\n                        addrData = _a.sent();\n                        return [2 /*return*/, this.formatter.callAddress(addrData)];\n                    case 4:\n                        error_10 = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/, null];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.resolveName = function (name) {\n        return __awaiter(this, void 0, void 0, function () {\n            var resolver;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, name];\n                    case 1:\n                        name = _a.sent();\n                        // If it is already an address, nothing to resolve\n                        try {\n                            return [2 /*return*/, Promise.resolve(this.formatter.address(name))];\n                        }\n                        catch (error) {\n                            // If is is a hexstring, the address is bad (See #694)\n                            if ((0, bytes_1.isHexString)(name)) {\n                                throw error;\n                            }\n                        }\n                        if (typeof (name) !== \"string\") {\n                            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n                        }\n                        return [4 /*yield*/, this.getResolver(name)];\n                    case 2:\n                        resolver = _a.sent();\n                        if (!resolver) {\n                            return [2 /*return*/, null];\n                        }\n                        return [4 /*yield*/, resolver.getAddress()];\n                    case 3: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.lookupAddress = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var node, resolverAddr, name, _a, addr;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, address];\n                    case 1:\n                        address = _b.sent();\n                        address = this.formatter.address(address);\n                        node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                        return [4 /*yield*/, this._getResolver(node, \"lookupAddress\")];\n                    case 2:\n                        resolverAddr = _b.sent();\n                        if (resolverAddr == null) {\n                            return [2 /*return*/, null];\n                        }\n                        _a = _parseString;\n                        return [4 /*yield*/, this.call({\n                                to: resolverAddr,\n                                data: (\"0x691f3431\" + (0, hash_1.namehash)(node).substring(2))\n                            })];\n                    case 3:\n                        name = _a.apply(void 0, [_b.sent(), 0]);\n                        return [4 /*yield*/, this.resolveName(name)];\n                    case 4:\n                        addr = _b.sent();\n                        if (addr != address) {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, name];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getAvatar = function (nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function () {\n            var resolver, address, node, resolverAddress, avatar_1, error_11, name_1, _a, error_12, avatar;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        resolver = null;\n                        if (!(0, bytes_1.isHexString)(nameOrAddress)) return [3 /*break*/, 10];\n                        address = this.formatter.address(nameOrAddress);\n                        node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                        return [4 /*yield*/, this._getResolver(node, \"getAvatar\")];\n                    case 1:\n                        resolverAddress = _b.sent();\n                        if (!resolverAddress) {\n                            return [2 /*return*/, null];\n                        }\n                        // Try resolving the avatar against the addr.reverse resolver\n                        resolver = new Resolver(this, resolverAddress, node);\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, resolver.getAvatar()];\n                    case 3:\n                        avatar_1 = _b.sent();\n                        if (avatar_1) {\n                            return [2 /*return*/, avatar_1.url];\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_11 = _b.sent();\n                        if (error_11.code !== logger_1.Logger.errors.CALL_EXCEPTION) {\n                            throw error_11;\n                        }\n                        return [3 /*break*/, 5];\n                    case 5:\n                        _b.trys.push([5, 8, , 9]);\n                        _a = _parseString;\n                        return [4 /*yield*/, this.call({\n                                to: resolverAddress,\n                                data: (\"0x691f3431\" + (0, hash_1.namehash)(node).substring(2))\n                            })];\n                    case 6:\n                        name_1 = _a.apply(void 0, [_b.sent(), 0]);\n                        return [4 /*yield*/, this.getResolver(name_1)];\n                    case 7:\n                        resolver = _b.sent();\n                        return [3 /*break*/, 9];\n                    case 8:\n                        error_12 = _b.sent();\n                        if (error_12.code !== logger_1.Logger.errors.CALL_EXCEPTION) {\n                            throw error_12;\n                        }\n                        return [2 /*return*/, null];\n                    case 9: return [3 /*break*/, 12];\n                    case 10: return [4 /*yield*/, this.getResolver(nameOrAddress)];\n                    case 11:\n                        // ENS name; forward lookup with wildcard\n                        resolver = _b.sent();\n                        if (!resolver) {\n                            return [2 /*return*/, null];\n                        }\n                        _b.label = 12;\n                    case 12: return [4 /*yield*/, resolver.getAvatar()];\n                    case 13:\n                        avatar = _b.sent();\n                        if (avatar == null) {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, avatar.url];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.perform = function (method, params) {\n        return logger.throwError(method + \" not implemented\", logger_1.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    };\n    BaseProvider.prototype._startEvent = function (event) {\n        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);\n    };\n    BaseProvider.prototype._stopEvent = function (event) {\n        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);\n    };\n    BaseProvider.prototype._addEventListener = function (eventName, listener, once) {\n        var event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    };\n    BaseProvider.prototype.on = function (eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    };\n    BaseProvider.prototype.once = function (eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    };\n    BaseProvider.prototype.emit = function (eventName) {\n        var _this = this;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var result = false;\n        var stopped = [];\n        var eventTag = getEventTag(eventName);\n        this._events = this._events.filter(function (event) {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(function () {\n                event.listener.apply(_this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach(function (event) { _this._stopEvent(event); });\n        return result;\n    };\n    BaseProvider.prototype.listenerCount = function (eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        var eventTag = getEventTag(eventName);\n        return this._events.filter(function (event) {\n            return (event.tag === eventTag);\n        }).length;\n    };\n    BaseProvider.prototype.listeners = function (eventName) {\n        if (eventName == null) {\n            return this._events.map(function (event) { return event.listener; });\n        }\n        var eventTag = getEventTag(eventName);\n        return this._events\n            .filter(function (event) { return (event.tag === eventTag); })\n            .map(function (event) { return event.listener; });\n    };\n    BaseProvider.prototype.off = function (eventName, listener) {\n        var _this = this;\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        var stopped = [];\n        var found = false;\n        var eventTag = getEventTag(eventName);\n        this._events = this._events.filter(function (event) {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach(function (event) { _this._stopEvent(event); });\n        return this;\n    };\n    BaseProvider.prototype.removeAllListeners = function (eventName) {\n        var _this = this;\n        var stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            var eventTag_1 = getEventTag(eventName);\n            this._events = this._events.filter(function (event) {\n                if (event.tag !== eventTag_1) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach(function (event) { _this._stopEvent(event); });\n        return this;\n    };\n    return BaseProvider;\n}(abstract_provider_1.Provider));\nexports.BaseProvider = BaseProvider;\n//# sourceMappingURL=base-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2Jhc2UtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsZ0JBQWdCLEdBQUcsYUFBYTtBQUN2RCwwQkFBMEIsbUJBQU8sQ0FBQywwS0FBa0M7QUFDcEUsZUFBZSxtQkFBTyxDQUFDLHlJQUF1QjtBQUM5QyxjQUFjLG1CQUFPLENBQUMsc0lBQXNCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGtKQUEwQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsc0lBQXNCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGtKQUEwQjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsbUlBQXFCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLCtJQUF5QjtBQUNsRCxtQkFBbUIsbUJBQU8sQ0FBQyxxSkFBMkI7QUFDdEQsYUFBYSxtQkFBTyxDQUFDLG1JQUFxQjtBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0SUFBd0I7QUFDaEQsWUFBWSxtQkFBTyxDQUFDLGdJQUFvQjtBQUN4QywrQkFBK0IsbUJBQU8sQ0FBQyx3RkFBUTtBQUMvQyxlQUFlLG1CQUFPLENBQUMseUlBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHdKQUFZO0FBQ3JDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsMEpBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzREFBc0Q7QUFDakUsV0FBVyx1REFBdUQ7QUFDbEUsV0FBVyx5Q0FBeUM7QUFDcEQsWUFBWSwyQkFBMkI7QUFDdkMsWUFBWSwyQkFBMkI7QUFDdkMsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUssRUFBRSxFQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEhBQThILDZDQUE2QztBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdHQUF3RyxtQkFBbUI7QUFDM0g7QUFDQTtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQTtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx3QkFBd0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RSxvQ0FBb0Msd0JBQXdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2Jhc2UtcHJvdmlkZXIuanM/YjBjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlUHJvdmlkZXIgPSBleHBvcnRzLlJlc29sdmVyID0gZXhwb3J0cy5FdmVudCA9IHZvaWQgMDtcbnZhciBhYnN0cmFjdF9wcm92aWRlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCIpO1xudmFyIGJhc2U2NF8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2Jhc2U2NFwiKTtcbnZhciBiYXNleF8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2Jhc2V4XCIpO1xudmFyIGJpZ251bWJlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiKTtcbnZhciBoYXNoXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiKTtcbnZhciBuZXR3b3Jrc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L25ldHdvcmtzXCIpO1xudmFyIHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCIpO1xudmFyIHNoYTJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9zaGEyXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCIpO1xudmFyIHdlYl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3dlYlwiKTtcbnZhciBiZWNoMzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmVjaDMyXCIpKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBmb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdHRlclwiKTtcbnZhciBNQVhfQ0NJUF9SRURJUkVDVFMgPSAxMDtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRXZlbnQgU2VyaWFsaXplaW5nXG5mdW5jdGlvbiBjaGVja1RvcGljKHRvcGljKSB7XG4gICAgaWYgKHRvcGljID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZiAoKDAsIGJ5dGVzXzEuaGV4RGF0YUxlbmd0aCkodG9waWMpICE9PSAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0b3BpY1wiLCBcInRvcGljXCIsIHRvcGljKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcGljLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUb3BpY3ModG9waWNzKSB7XG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIG51bGwgQU5ELXRvcGljczsgdGhleSBhcmUgcmVkdW5kYW50XG4gICAgdG9waWNzID0gdG9waWNzLnNsaWNlKCk7XG4gICAgd2hpbGUgKHRvcGljcy5sZW5ndGggPiAwICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT0gbnVsbCkge1xuICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiB0b3BpY3MubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b3BpYykpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdHJhY2sgdW5pcXVlIE9SLXRvcGljc1xuICAgICAgICAgICAgdmFyIHVuaXF1ZV8xID0ge307XG4gICAgICAgICAgICB0b3BpYy5mb3JFYWNoKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgICAgICAgICAgIHVuaXF1ZV8xW2NoZWNrVG9waWModG9waWMpXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRoZSBvcmRlciBvZiBPUi10b3BpY3MgZG9lcyBub3QgbWF0dGVyXG4gICAgICAgICAgICB2YXIgc29ydGVkID0gT2JqZWN0LmtleXModW5pcXVlXzEpO1xuICAgICAgICAgICAgc29ydGVkLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWQuam9pbihcInxcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tUb3BpYyh0b3BpYyk7XG4gICAgICAgIH1cbiAgICB9KS5qb2luKFwiJlwiKTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9waWNzKGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBkYXRhLnNwbGl0KC8mL2cpLm1hcChmdW5jdGlvbiAodG9waWMpIHtcbiAgICAgICAgaWYgKHRvcGljID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBzID0gdG9waWMuc3BsaXQoXCJ8XCIpLm1hcChmdW5jdGlvbiAodG9waWMpIHtcbiAgICAgICAgICAgIHJldHVybiAoKHRvcGljID09PSBcIm51bGxcIikgPyBudWxsIDogdG9waWMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgoY29tcHMubGVuZ3RoID09PSAxKSA/IGNvbXBzWzBdIDogY29tcHMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCgwLCBieXRlc18xLmhleERhdGFMZW5ndGgpKGV2ZW50TmFtZSkgPT09IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ0eDpcIiArIGV2ZW50TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiZmlsdGVyOio6XCIgKyBzZXJpYWxpemVUb3BpY3MoZXZlbnROYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWJzdHJhY3RfcHJvdmlkZXJfMS5Gb3JrRXZlbnQuaXNGb3JrRXZlbnQoZXZlbnROYW1lKSkge1xuICAgICAgICBsb2dnZXIud2FybihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudE5hbWUgJiYgdHlwZW9mIChldmVudE5hbWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBcImZpbHRlcjpcIiArIChldmVudE5hbWUuYWRkcmVzcyB8fCBcIipcIikgKyBcIjpcIiArIHNlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUudG9waWNzIHx8IFtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudCAtIFwiICsgZXZlbnROYW1lKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIE9iamVjdFxuZnVuY3Rpb24gZ2V0VGltZSgpIHtcbiAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuICAgIH0pO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBQcm92aWRlciBPYmplY3Rcbi8qKlxuICogIEV2ZW50VHlwZVxuICogICAtIFwiYmxvY2tcIlxuICogICAtIFwicG9sbFwiXG4gKiAgIC0gXCJkaWRQb2xsXCJcbiAqICAgLSBcInBlbmRpbmdcIlxuICogICAtIFwiZXJyb3JcIlxuICogICAtIFwibmV0d29ya1wiXG4gKiAgIC0gZmlsdGVyXG4gKiAgIC0gdG9waWNzIGFycmF5XG4gKiAgIC0gdHJhbnNhY3Rpb24gaGFzaFxuICovXG52YXIgUG9sbGFibGVFdmVudHMgPSBbXCJibG9ja1wiLCBcIm5ldHdvcmtcIiwgXCJwZW5kaW5nXCIsIFwicG9sbFwiXTtcbnZhciBFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudCh0YWcsIGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwidGFnXCIsIHRhZyk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwibGlzdGVuZXJcIiwgbGlzdGVuZXIpO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIm9uY2VcIiwgb25jZSk7XG4gICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuICAgICAgICB0aGlzLl9pbmZsaWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImV2ZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0eFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNoO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWcuc3BsaXQoXCI6XCIpWzBdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJoYXNoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29tcHMgPSB0aGlzLnRhZy5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICBpZiAoY29tcHNbMF0gIT09IFwidHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBzWzFdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21wcyA9IHRoaXMudGFnLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgIGlmIChjb21wc1swXSAhPT0gXCJmaWx0ZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFkZHJlc3MgPSBjb21wc1sxXTtcbiAgICAgICAgICAgIHZhciB0b3BpY3MgPSBkZXNlcmlhbGl6ZVRvcGljcyhjb21wc1syXSk7XG4gICAgICAgICAgICB2YXIgZmlsdGVyID0ge307XG4gICAgICAgICAgICBpZiAodG9waWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZHJlc3MgJiYgYWRkcmVzcyAhPT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRXZlbnQucHJvdG90eXBlLnBvbGxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudGFnLmluZGV4T2YoXCI6XCIpID49IDAgfHwgUG9sbGFibGVFdmVudHMuaW5kZXhPZih0aGlzLnRhZykgPj0gMCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnQ7XG59KCkpO1xuZXhwb3J0cy5FdmVudCA9IEV2ZW50O1xuO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NhdG9zaGlsYWJzL3NsaXBzL2Jsb2IvbWFzdGVyL3NsaXAtMDA0NC5tZFxudmFyIGNvaW5JbmZvcyA9IHtcbiAgICBcIjBcIjogeyBzeW1ib2w6IFwiYnRjXCIsIHAycGtoOiAweDAwLCBwMnNoOiAweDA1LCBwcmVmaXg6IFwiYmNcIiB9LFxuICAgIFwiMlwiOiB7IHN5bWJvbDogXCJsdGNcIiwgcDJwa2g6IDB4MzAsIHAyc2g6IDB4MzIsIHByZWZpeDogXCJsdGNcIiB9LFxuICAgIFwiM1wiOiB7IHN5bWJvbDogXCJkb2dlXCIsIHAycGtoOiAweDFlLCBwMnNoOiAweDE2IH0sXG4gICAgXCI2MFwiOiB7IHN5bWJvbDogXCJldGhcIiwgaWxrOiBcImV0aFwiIH0sXG4gICAgXCI2MVwiOiB7IHN5bWJvbDogXCJldGNcIiwgaWxrOiBcImV0aFwiIH0sXG4gICAgXCI3MDBcIjogeyBzeW1ib2w6IFwieGRhaVwiLCBpbGs6IFwiZXRoXCIgfSxcbn07XG5mdW5jdGlvbiBieXRlczMyaWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmhleFplcm9QYWQpKGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpLCAzMik7XG59XG4vLyBDb21wdXRlIHRoZSBCYXNlNThDaGVjayBlbmNvZGVkIGRhdGEgKGNoZWNrc3VtIGlzIGZpcnN0IDQgYnl0ZXMgb2Ygc2hhMjU2ZClcbmZ1bmN0aW9uIGJhc2U1OEVuY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIGJhc2V4XzEuQmFzZTU4LmVuY29kZSgoMCwgYnl0ZXNfMS5jb25jYXQpKFtkYXRhLCAoMCwgYnl0ZXNfMS5oZXhEYXRhU2xpY2UpKCgwLCBzaGEyXzEuc2hhMjU2KSgoMCwgc2hhMl8xLnNoYTI1NikoZGF0YSkpLCAwLCA0KV0pKTtcbn1cbnZhciBtYXRjaGVySXBmcyA9IG5ldyBSZWdFeHAoXCJeKGlwZnMpOi9cXC8oLiopJFwiLCBcImlcIik7XG52YXIgbWF0Y2hlcnMgPSBbXG4gICAgbmV3IFJlZ0V4cChcIl4oaHR0cHMpOi9cXC8oLiopJFwiLCBcImlcIiksXG4gICAgbmV3IFJlZ0V4cChcIl4oZGF0YSk6KC4qKSRcIiwgXCJpXCIpLFxuICAgIG1hdGNoZXJJcGZzLFxuICAgIG5ldyBSZWdFeHAoXCJeZWlwMTU1OlswLTldKy8oZXJjWzAtOV0rKTooLiopJFwiLCBcImlcIiksXG5dO1xuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCwgc3RhcnQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN0cmluZ3NfMS50b1V0ZjhTdHJpbmcpKF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpIHtcbiAgICBpZiAocmVzdWx0ID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSgoMCwgYnl0ZXNfMS5oZXhEYXRhU2xpY2UpKHJlc3VsdCwgc3RhcnQsIHN0YXJ0ICsgMzIpKS50b051bWJlcigpO1xuICAgIHZhciBsZW5ndGggPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSgoMCwgYnl0ZXNfMS5oZXhEYXRhU2xpY2UpKHJlc3VsdCwgb2Zmc2V0LCBvZmZzZXQgKyAzMikpLnRvTnVtYmVyKCk7XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmhleERhdGFTbGljZSkocmVzdWx0LCBvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBsZW5ndGgpO1xufVxuLy8gVHJpbSBvZmYgdGhlIGlwZnM6Ly8gcHJlZml4IGFuZCByZXR1cm4gdGhlIGRlZmF1bHQgZ2F0ZXdheSBVUkxcbmZ1bmN0aW9uIGdldElwZnNMaW5rKGxpbmspIHtcbiAgICBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvaXBmc1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoMTIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIElQRlMgZm9ybWF0XCIsIFwibGlua1wiLCBsaW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiaHR0cHM6Ly9nYXRld2F5LmlwZnMuaW8vaXBmcy9cIiArIGxpbms7XG59XG5mdW5jdGlvbiBudW1QYWQodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgdmFyIHBhZGRlZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICBwYWRkZWQuc2V0KHJlc3VsdCwgMzIgLSByZXN1bHQubGVuZ3RoKTtcbiAgICByZXR1cm4gcGFkZGVkO1xufVxuZnVuY3Rpb24gYnl0ZXNQYWQodmFsdWUpIHtcbiAgICBpZiAoKHZhbHVlLmxlbmd0aCAlIDMyKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwodmFsdWUubGVuZ3RoIC8gMzIpICogMzIpO1xuICAgIHJlc3VsdC5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBBQkkgRW5jb2RlcyBhIHNlcmllcyBvZiAoYnl0ZXMsIGJ5dGVzLCAuLi4pXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYnl0ZUNvdW50ID0gMDtcbiAgICAvLyBBZGQgcGxhY2UtaG9sZGVycyBmb3IgcG9pbnRlcnMgYXMgd2UgYWRkIGl0ZW1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkYXRhID0gKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKGRhdGFzW2ldKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBieXRlcyBvZmZzZXRcbiAgICAgICAgcmVzdWx0W2ldID0gbnVtUGFkKGJ5dGVDb3VudCk7XG4gICAgICAgIC8vIFRoZSBsZW5ndGggYW5kIHBhZGRlZCB2YWx1ZSBvZiBkYXRhXG4gICAgICAgIHJlc3VsdC5wdXNoKG51bVBhZChkYXRhLmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQucHVzaChieXRlc1BhZChkYXRhKSk7XG4gICAgICAgIGJ5dGVDb3VudCArPSAzMiArIE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDMyKSAqIDMyO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4Q29uY2F0KShyZXN1bHQpO1xufVxudmFyIFJlc29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoZSByZXNvbHZlZEFkZHJlc3MgaXMgb25seSBmb3IgY3JlYXRpbmcgYSBSZXZlcnNlTG9va3VwIHJlc29sdmVyXG4gICAgZnVuY3Rpb24gUmVzb2x2ZXIocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUsIHJlc29sdmVkQWRkcmVzcykge1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImFkZHJlc3NcIiwgcHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzcykpO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIl9yZXNvbHZlZEFkZHJlc3NcIiwgcmVzb2x2ZWRBZGRyZXNzKTtcbiAgICB9XG4gICAgUmVzb2x2ZXIucHJvdG90eXBlLnN1cHBvcnRzV2lsZGNhcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fc3VwcG9ydHNFaXAyNTQ0KSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0c0ludGVyZmFjZShieXRlczQgPSBzZWxlY3RvcihcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCIpKVxuICAgICAgICAgICAgdGhpcy5fc3VwcG9ydHNFaXAyNTQ0ID0gdGhpcy5wcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiMHgwMWZmYzlhNzkwNjFiOTIzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIlxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHJlc3VsdCkuZXEoMSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldGhyb3cgdGhlIGVycm9yOiBsaW5rIGlzIGRvd24sIGV0Yy4gTGV0IGZ1dHVyZSBhdHRlbXB0cyByZXRyeS5cbiAgICAgICAgICAgICAgICBfdGhpcy5fc3VwcG9ydHNFaXAyNTQ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBwb3J0c0VpcDI1NDQ7XG4gICAgfTtcbiAgICBSZXNvbHZlci5wcm90b3R5cGUuX2ZldGNoID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eCwgcGFyc2VCeXRlcywgcmVzdWx0LCBlcnJvcl8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjY2lwUmVhZEVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKDAsIGJ5dGVzXzEuaGV4Q29uY2F0KShbc2VsZWN0b3IsICgwLCBoYXNoXzEubmFtZWhhc2gpKHRoaXMubmFtZSksIChwYXJhbWV0ZXJzIHx8IFwiMHhcIildKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQnl0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc3VwcG9ydHNXaWxkY2FyZCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9hLnNlbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQnl0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yKFwicmVzb2x2ZShieXRlcyxieXRlcylcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5kYXRhID0gKDAsIGJ5dGVzXzEuaGV4Q29uY2F0KShbXCIweDkwNjFiOTIzXCIsIGVuY29kZUJ5dGVzKFsoMCwgaGFzaF8xLmRuc0VuY29kZSkodGhpcy5uYW1lKSwgdHguZGF0YV0pXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMiwgNCwgLCA1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmNhbGwodHgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoMCwgYnl0ZXNfMS5hcnJheWlmeSkocmVzdWx0KS5sZW5ndGggJSAzMikgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlc29sdmVyIHRocmV3IGVycm9yXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX3BhcnNlQnl0ZXMocmVzdWx0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yXzEuY29kZSA9PT0gbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXzE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc29sdmVyLnByb3RvdHlwZS5fZmV0Y2hCeXRlcyA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9mZXRjaChzZWxlY3RvciwgcGFyYW1ldGVycyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX3BhcnNlQnl0ZXMocmVzdWx0LCAwKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRBZGRyZXNzID0gZnVuY3Rpb24gKGNvaW5UeXBlLCBoZXhCeXRlcykge1xuICAgICAgICB2YXIgY29pbkluZm8gPSBjb2luSW5mb3NbU3RyaW5nKGNvaW5UeXBlKV07XG4gICAgICAgIGlmIChjb2luSW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIGNvaW4gdHlwZTogXCIgKyBjb2luVHlwZSwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzcyhcIiArIGNvaW5UeXBlICsgXCIpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luSW5mby5pbGsgPT09IFwiZXRoXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGhleEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZXMgPSAoMCwgYnl0ZXNfMS5hcnJheWlmeSkoaGV4Qnl0ZXMpO1xuICAgICAgICAvLyBQMlBLSDogT1BfRFVQIE9QX0hBU0gxNjAgPHB1YktleUhhc2g+IE9QX0VRVUFMVkVSSUZZIE9QX0NIRUNLU0lHXG4gICAgICAgIGlmIChjb2luSW5mby5wMnBraCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcDJwa2ggPSBoZXhCeXRlcy5tYXRjaCgvXjB4NzZhOShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopODhhYyQvKTtcbiAgICAgICAgICAgIGlmIChwMnBraCkge1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IHBhcnNlSW50KHAycGtoWzFdLCAxNik7XG4gICAgICAgICAgICAgICAgaWYgKHAycGtoWzJdLmxlbmd0aCA9PT0gbGVuZ3RoXzEgKiAyICYmIGxlbmd0aF8xID49IDEgJiYgbGVuZ3RoXzEgPD0gNzUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U1OEVuY29kZSgoMCwgYnl0ZXNfMS5jb25jYXQpKFtbY29pbkluZm8ucDJwa2hdLCAoXCIweFwiICsgcDJwa2hbMl0pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQMlNIOiBPUF9IQVNIMTYwIDxzY3JpcHRIYXNoPiBPUF9FUVVBTFxuICAgICAgICBpZiAoY29pbkluZm8ucDJzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcDJzaCA9IGhleEJ5dGVzLm1hdGNoKC9eMHhhOShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopODckLyk7XG4gICAgICAgICAgICBpZiAocDJzaCkge1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMiA9IHBhcnNlSW50KHAyc2hbMV0sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAocDJzaFsyXS5sZW5ndGggPT09IGxlbmd0aF8yICogMiAmJiBsZW5ndGhfMiA+PSAxICYmIGxlbmd0aF8yIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNThFbmNvZGUoKDAsIGJ5dGVzXzEuY29uY2F0KShbW2NvaW5JbmZvLnAyc2hdLCAoXCIweFwiICsgcDJzaFsyXSldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJlY2gzMlxuICAgICAgICBpZiAoY29pbkluZm8ucHJlZml4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGhfMyA9IGJ5dGVzWzFdO1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDE0MS5tZWRpYXdpa2kjd2l0bmVzcy1wcm9ncmFtXG4gICAgICAgICAgICB2YXIgdmVyc2lvbl8xID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBpZiAodmVyc2lvbl8xID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aF8zICE9PSAyMCAmJiBsZW5ndGhfMyAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbl8xID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbl8xID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmVyc2lvbl8xID49IDAgJiYgYnl0ZXMubGVuZ3RoID09PSAyICsgbGVuZ3RoXzMgJiYgbGVuZ3RoXzMgPj0gMSAmJiBsZW5ndGhfMyA8PSA3NSkge1xuICAgICAgICAgICAgICAgIHZhciB3b3JkcyA9IGJlY2gzMl8xLmRlZmF1bHQudG9Xb3JkcyhieXRlcy5zbGljZSgyKSk7XG4gICAgICAgICAgICAgICAgd29yZHMudW5zaGlmdCh2ZXJzaW9uXzEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBiZWNoMzJfMS5kZWZhdWx0LmVuY29kZShjb2luSW5mby5wcmVmaXgsIHdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFJlc29sdmVyLnByb3RvdHlwZS5nZXRBZGRyZXNzID0gZnVuY3Rpb24gKGNvaW5UeXBlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGVycm9yXzIsIGhleEJ5dGVzLCBhZGRyZXNzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29pblR5cGUgPT09IDYwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9mZXRjaChcIjB4M2IzYjU3ZGVcIildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBcIjB4XCIgfHwgcmVzdWx0ID09PSBjb25zdGFudHNfMS5IYXNoWmVybykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5jYWxsQWRkcmVzcyhyZXN1bHQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcl8yLmNvZGUgPT09IGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl8yO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2ZldGNoQnl0ZXMoXCIweGYxY2I3ZTA2XCIsIGJ5dGVzMzJpZnkoY29pblR5cGUpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleEJ5dGVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhleEJ5dGVzID09IG51bGwgfHwgaGV4Qnl0ZXMgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLl9nZXRBZGRyZXNzKGNvaW5UeXBlLCBoZXhCeXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvaW4gZGF0YVwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzcyhcIiArIGNvaW5UeXBlICsgXCIpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvaW5UeXBlOiBjb2luVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4Qnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBhZGRyZXNzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXNvbHZlci5wcm90b3R5cGUuZ2V0QXZhdGFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGlua2FnZSwgYXZhdGFyLCBpLCBtYXRjaCwgc2NoZW1lLCBfYSwgc2VsZWN0b3IsIG93bmVyLCBfYiwgY29tcHMsIGFkZHIsIHRva2VuSWQsIHRva2VuT3duZXIsIF9jLCBfZCwgYmFsYW5jZSwgX2UsIF9mLCB0eCwgbWV0YWRhdGFVcmwsIF9nLCBtZXRhZGF0YSwgaW1hZ2VVcmwsIGlwZnMsIGVycm9yXzM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9oKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfaC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlID0gW3sgdHlwZTogXCJuYW1lXCIsIGNvbnRlbnQ6IHRoaXMubmFtZSB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2gudHJ5cy5wdXNoKFsxLCAxOSwgLCAyMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRUZXh0KFwiYXZhdGFyXCIpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXZhdGFyID0gX2guc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaC5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBtYXRjaGVycy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGF2YXRhci5tYXRjaChtYXRjaGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtZSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHNjaGVtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHNcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlwZnNcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOiByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjMTE1NVwiOiByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgbGlua2FnZTogbGlua2FnZSwgdXJsOiBhdmF0YXIgfV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiZGF0YVwiLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyBsaW5rYWdlOiBsaW5rYWdlLCB1cmw6IGF2YXRhciB9XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpcGZzXCIsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IGxpbmthZ2U6IGxpbmthZ2UsIHVybDogZ2V0SXBmc0xpbmsoYXZhdGFyKSB9XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAoc2NoZW1lID09PSBcImVyYzcyMVwiKSA/IFwiMHhjODdiNTZkZFwiIDogXCIweDBlODkzNDFjXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBzY2hlbWUsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gdGhpcy5fcmVzb2x2ZWRBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9iKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QWRkcmVzcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2guc2VudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXIgPSAoX2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHMgPSAobWF0Y2hbMl0gfHwgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoY29tcHNbMF0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHIgPSBfaC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbklkID0gKDAsIGJ5dGVzXzEuaGV4WmVyb1BhZCkoYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oY29tcHNbMV0pLnRvSGV4U3RyaW5nKCksIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gKF9jID0gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIpLmNhbGxBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGFkZHIsIGRhdGE6ICgwLCBieXRlc18xLmhleENvbmNhdCkoW1wiMHg2MzUyMjExZVwiLCB0b2tlbklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbk93bmVyID0gX2QuYXBwbHkoX2MsIFtfaC5zZW50KCldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwib3duZXJcIiwgY29udGVudDogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpKSByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfZiA9IChfZSA9IGJpZ251bWJlcl8xLkJpZ051bWJlcikuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBhZGRyLCBkYXRhOiAoMCwgYnl0ZXNfMS5oZXhDb25jYXQpKFtcIjB4MDBmZGQ1OGVcIiwgKDAsIGJ5dGVzXzEuaGV4WmVyb1BhZCkob3duZXIsIDMyKSwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZSA9IF9mLmFwcGx5KF9lLCBbX2guc2VudCgpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFsYW5jZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYmFsYW5jZVwiLCBjb250ZW50OiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaC5sYWJlbCA9IDE0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoY29tcHNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6ICgwLCBieXRlc18xLmhleENvbmNhdCkoW3NlbGVjdG9yLCB0b2tlbklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBfZyA9IF9wYXJzZVN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuY2FsbCh0eCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBfZy5hcHBseSh2b2lkIDAsIFtfaC5zZW50KCksIDBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtYmFzZVwiLCBjb250ZW50OiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy0xMTU1IGFsbG93cyBhIGdlbmVyaWMge2lkfSBpbiB0aGUgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gbWV0YWRhdGFVcmwucmVwbGFjZShcIntpZH1cIiwgdG9rZW5JZC5zdWJzdHJpbmcoMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWV4cGFuZGVkXCIsIGNvbnRlbnQ6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbWV0YWRhdGEgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybC5tYXRjaCgvXmlwZnM6L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBnZXRJcGZzTGluayhtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybFwiLCBjb250ZW50OiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCB3ZWJfMS5mZXRjaEpzb24pKG1ldGFkYXRhVXJsKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IF9oLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsID0gbWV0YWRhdGEuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChpbWFnZVVybCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VVcmwubWF0Y2goL14oaHR0cHM6XFwvXFwvfGRhdGE6KS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcGZzID0gaW1hZ2VVcmwubWF0Y2gobWF0Y2hlcklwZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybC1pcGZzXCIsIGNvbnRlbnQ6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsID0gZ2V0SXBmc0xpbmsoaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgY29udGVudDogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyBsaW5rYWdlOiBsaW5rYWdlLCB1cmw6IGltYWdlVXJsIH1dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDIwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzMgPSBfaC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6IHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXNvbHZlci5wcm90b3R5cGUuZ2V0Q29udGVudEhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZXhCeXRlcywgaXBmcywgbGVuZ3RoXzQsIGlwbnMsIGxlbmd0aF81LCBzd2FybSwgc2t5bmV0LCB1cmxTYWZlXzEsIGhhc2g7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2ZldGNoQnl0ZXMoXCIweGJjMWM1OGQxXCIpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaGV4Qnl0ZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBjb250ZW50aGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhleEJ5dGVzID09IG51bGwgfHwgaGV4Qnl0ZXMgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlwZnMgPSBoZXhCeXRlcy5tYXRjaCgvXjB4ZTMwMTAxNzAoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlwZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhfNCA9IHBhcnNlSW50KGlwZnNbM10sIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmc1s0XS5sZW5ndGggPT09IGxlbmd0aF80ICogMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgXCJpcGZzOi9cXC9cIiArIGJhc2V4XzEuQmFzZTU4LmVuY29kZShcIjB4XCIgKyBpcGZzWzFdKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXBucyA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlNTAxMDE3MigoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aF81ID0gcGFyc2VJbnQoaXBuc1szXSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcG5zWzRdLmxlbmd0aCA9PT0gbGVuZ3RoXzUgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBcImlwbnM6L1xcL1wiICsgYmFzZXhfMS5CYXNlNTguZW5jb2RlKFwiMHhcIiArIGlwbnNbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FybSA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YXJtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YXJtWzFdLmxlbmd0aCA9PT0gKDMyICogMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFwiYnp6Oi9cXC9cIiArIHN3YXJtWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBza3luZXQgPSBoZXhCeXRlcy5tYXRjaCgvXjB4OTBiMmM2MDUoWzAtOWEtZl0qKSQvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza3luZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2t5bmV0WzFdLmxlbmd0aCA9PT0gKDM0ICogMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsU2FmZV8xID0geyBcIj1cIjogXCJcIiwgXCIrXCI6IFwiLVwiLCBcIi9cIjogXCJfXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCA9ICgwLCBiYXNlNjRfMS5lbmNvZGUpKFwiMHhcIiArIHNreW5ldFsxXSkucmVwbGFjZSgvWz0rXFwvXS9nLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKHVybFNhZmVfMVthXSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgXCJzaWE6L1xcL1wiICsgaGFzaF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb250ZW50IGhhc2ggZGF0YVwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0Q29udGVudEhhc2goKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhCeXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXNvbHZlci5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGtleUJ5dGVzLCBoZXhCeXRlcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleUJ5dGVzID0gKDAsIHN0cmluZ3NfMS50b1V0ZjhCeXRlcykoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBub2RlaGFzaCBjb25zdW1lcyB0aGUgZmlyc3Qgc2xvdCwgc28gdGhlIHN0cmluZyBwb2ludGVyIHRhcmdldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldCA2NCwgd2l0aCB0aGUgbGVuZ3RoIGF0IG9mZnNldCA2NCBhbmQgZGF0YSBzdGFydGluZyBhdCBvZmZzZXQgOTZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleUJ5dGVzID0gKDAsIGJ5dGVzXzEuY29uY2F0KShbYnl0ZXMzMmlmeSg2NCksIGJ5dGVzMzJpZnkoa2V5Qnl0ZXMubGVuZ3RoKSwga2V5Qnl0ZXNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZCB0byB3b3JkLXNpemUgKDMyIGJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChrZXlCeXRlcy5sZW5ndGggJSAzMikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlCeXRlcyA9ICgwLCBieXRlc18xLmNvbmNhdCkoW2tleUJ5dGVzLCAoMCwgYnl0ZXNfMS5oZXhaZXJvUGFkKShcIjB4XCIsIDMyIC0gKGtleS5sZW5ndGggJSAzMikpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHg1OWQxZDQzY1wiLCAoMCwgYnl0ZXNfMS5oZXhsaWZ5KShrZXlCeXRlcykpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaGV4Qnl0ZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGV4Qnl0ZXMgPT0gbnVsbCB8fCBoZXhCeXRlcyA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCBzdHJpbmdzXzEudG9VdGY4U3RyaW5nKShoZXhCeXRlcyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNvbHZlcjtcbn0oKSk7XG5leHBvcnRzLlJlc29sdmVyID0gUmVzb2x2ZXI7XG52YXIgZGVmYXVsdEZvcm1hdHRlciA9IG51bGw7XG52YXIgbmV4dFBvbGxJZCA9IDE7XG52YXIgQmFzZVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXNlUHJvdmlkZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogIHJlYWR5XG4gICAgICpcbiAgICAgKiAgQSBQcm9taXNlPE5ldHdvcms+IHRoYXQgcmVzb2x2ZXMgb25seSBvbmNlIHRoZSBwcm92aWRlciBpcyByZWFkeS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyB0aGF0IGNhbGwgdGhlIHN1cGVyIHdpdGggYSBuZXR3b3JrIHdpdGhvdXQgYSBjaGFpbklkXG4gICAgICogIE1VU1Qgc2V0IHRoaXMuIFN0YW5kYXJkIG5hbWVkIG5ldHdvcmtzIGhhdmUgYSBrbm93biBjaGFpbklkLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gQmFzZVByb3ZpZGVyKG5ldHdvcmspIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyBFdmVudHMgYmVpbmcgbGlzdGVuZWQgdG9cbiAgICAgICAgX3RoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICBfdGhpcy5fZW1pdHRlZCA9IHsgYmxvY2s6IC0yIH07XG4gICAgICAgIF90aGlzLmRpc2FibGVDY2lwUmVhZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5mb3JtYXR0ZXIgPSBfbmV3VGFyZ2V0LmdldEZvcm1hdHRlcigpO1xuICAgICAgICAvLyBJZiBuZXR3b3JrIGlzIGFueSwgdGhpcyBQcm92aWRlciBhbGxvd3MgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgLy8gbmV0d29yayB0byBjaGFuZ2UgZHluYW1pY2FsbHksIGFuZCB3ZSBhdXRvLWRldGVjdCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBuZXR3b3JrXG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImFueU5ldHdvcmtcIiwgKG5ldHdvcmsgPT09IFwiYW55XCIpKTtcbiAgICAgICAgaWYgKF90aGlzLmFueU5ldHdvcmspIHtcbiAgICAgICAgICAgIG5ldHdvcmsgPSBfdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ldHdvcmsgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBfdGhpcy5fbmV0d29ya1Byb21pc2UgPSBuZXR3b3JrO1xuICAgICAgICAgICAgLy8gU3F1YXNoIGFueSBcInVuaGFuZGxlZCBwcm9taXNlXCIgZXJyb3JzOyB0aGF0IGRvIG5vdCBuZWVkIHRvIGJlIGhhbmRsZWRcbiAgICAgICAgICAgIG5ldHdvcmsuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IH0pO1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBpbml0aWFsIG5ldHdvcmsgc2V0dGluZyAoYXN5bmMpXG4gICAgICAgICAgICBfdGhpcy5fcmVhZHkoKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIga25vd25OZXR3b3JrID0gKDAsIHByb3BlcnRpZXNfMS5nZXRTdGF0aWMpKF9uZXdUYXJnZXQsIFwiZ2V0TmV0d29ya1wiKShuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChrbm93bk5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJfbmV0d29ya1wiLCBrbm93bk5ldHdvcmspO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGtub3duTmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IC0xMDI0O1xuICAgICAgICBfdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIF90aGlzLl9tYXhGaWx0ZXJCbG9ja1JhbmdlID0gMTA7XG4gICAgICAgIF90aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSA0MDAwO1xuICAgICAgICBfdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fcmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXR3b3JrLCBlcnJvcl80O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5fbmV0d29yayA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbmV0d29ya1Byb21pc2UpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fbmV0d29ya1Byb21pc2VdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobmV0d29yayA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRldGVjdE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDY7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbjsgZXZlcnkgUHJvdmlkZXIgc3ViLWNsYXNzIHNob3VsZCBoYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWdnZXN0ZWQgYSBuZXR3b3JrIGJ5IGhlcmUgKG9yIGhhdmUgdGhyb3duKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm8gbmV0d29yayBkZXRlY3RlZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1IsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIHRoaXMgY2FsbCBzdGFja2VkIHNvIGRvIG5vdCBjYWxsIGRlZmluZVJlYWRPbmx5IGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX25ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX25ldHdvcmtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcInJlYWR5XCIsIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgZXN0YWJsaXNoZWQgbmV0d29yay5cbiAgICAgICAgLy8gRm9yIFwiYW55XCIsIHRoaXMgY2FuIGNoYW5nZSAoYSBcIm5ldHdvcmtcIiBldmVudCBpcyBlbWl0dGVkIGJlZm9yZVxuICAgICAgICAvLyBhbnkgY2hhbmdlIGlzIHJlZmxlY3RlZCk7IG90aGVyd2lzZSB0aGlzIGNhbm5vdCBjaGFuZ2VcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuICgwLCB3ZWJfMS5wb2xsKShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKG5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXR3b3JrIGlzbid0IHJ1bm5pbmcgeWV0LCB3ZSB3aWxsIHdhaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiAmJiBlcnJvci5ldmVudCA9PT0gXCJub05ldHdvcmtcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIGFuZCBqdXN0IGNyZWF0ZSBhIHNpbmdsZXRvbiBmb3JtYXR0ZXJcbiAgICBCYXNlUHJvdmlkZXIuZ2V0Rm9ybWF0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGVmYXVsdEZvcm1hdHRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Rm9ybWF0dGVyID0gbmV3IGZvcm1hdHRlcl8xLkZvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyO1xuICAgIH07XG4gICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIGFuZCBqdXN0IHVzZSBnZXROZXR3b3JrXG4gICAgQmFzZVByb3ZpZGVyLmdldE5ldHdvcmsgPSBmdW5jdGlvbiAobmV0d29yaykge1xuICAgICAgICByZXR1cm4gKDAsIG5ldHdvcmtzXzEuZ2V0TmV0d29yaykoKG5ldHdvcmsgPT0gbnVsbCkgPyBcImhvbWVzdGVhZFwiIDogbmV0d29yayk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmNjaXBSZWFkRmV0Y2ggPSBmdW5jdGlvbiAodHgsIGNhbGxkYXRhLCB1cmxzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZW5kZXIsIGRhdGEsIGVycm9yTWVzc2FnZXMsIGksIHVybCwgaHJlZiwganNvbiwgcmVzdWx0LCBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ2NpcFJlYWQgfHwgdXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXIgPSB0eC50by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGNhbGxkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IHVybHMubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmxzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZiA9IHVybC5yZXBsYWNlKFwie3NlbmRlcn1cIiwgc2VuZGVyKS5yZXBsYWNlKFwie2RhdGF9XCIsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9ICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA+PSAwKSA/IG51bGwgOiBKU09OLnN0cmluZ2lmeSh7IGRhdGE6IGRhdGEsIHNlbmRlcjogc2VuZGVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHdlYl8xLmZldGNoSnNvbikoeyB1cmw6IGhyZWYsIGVycm9yUGFzc1Rocm91Z2g6IHRydWUgfSwganNvbiwgZnVuY3Rpb24gKHZhbHVlLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0LmRhdGFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gKHJlc3VsdC5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDR4eCBpbmRpY2F0ZXMgdGhlIHJlc3VsdCBpcyBub3QgcHJlc2VudDsgc3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPj0gNDAwICYmIHJlc3VsdC5zdGF0dXMgPCA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJyZXNwb25zZSBub3QgZm91bmQgZHVyaW5nIENDSVAgZmV0Y2g6IFwiICsgZXJyb3JNZXNzYWdlLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwgeyB1cmw6IHVybCwgZXJyb3JNZXNzYWdlOiBlcnJvck1lc3NhZ2UgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNXh4IGluZGljYXRlcyBzZXJ2ZXIgaXNzdWU7IHRyeSB0aGUgbmV4dCB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZXMucHVzaChlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgQ0NJUCBmZXRjaDogXCIgKyBlcnJvck1lc3NhZ2VzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkobSk7IH0pLmpvaW4oXCIsIFwiKSwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxzOiB1cmxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZXM6IGVycm9yTWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBGZXRjaGVzIHRoZSBibG9ja051bWJlciwgYnV0IHdpbGwgcmV1c2UgYW55IHJlc3VsdCB0aGF0IGlzIGxlc3NcbiAgICAvLyB0aGFuIG1heEFnZSBvbGQgb3IgaGFzIGJlZW4gcmVxdWVzdGVkIHNpbmNlIHRoZSBsYXN0IHJlcXVlc3RcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKG1heEFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJuYWxCbG9ja051bWJlciwgcmVzdWx0LCBlcnJvcl81LCByZXFUaW1lLCBjaGVja0ludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9yZWFkeSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWF4QWdlID4gMCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxCbG9ja051bWJlciA9IHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMywgNSwgLCA2XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBpbnRlcm5hbEJsb2NrTnVtYmVyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChnZXRUaW1lKCkgLSByZXN1bHQucmVzcFRpbWUpIDw9IG1heEFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQuYmxvY2tOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9vIG9sZDsgZmV0Y2ggYSBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl81ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZldGNoIHJlamVjdGVkOyBpZiB3ZSBhcmUgdGhlIGZpcnN0IHRvIGdldCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGlvbiwgZHJvcCB0aHJvdWdoIHNvIHdlIHJlcGxhY2UgaXQgd2l0aCBhIG5ld1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmV0Y2g7IGFsbCBvdGhlcnMgYmxvY2tlZCB3aWxsIHRoZW4gZ2V0IHRoYXQgZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdvbid0IG1hdGNoIHRoZSBvbmUgdGhleSBcInJlbWVtYmVyZWRcIiBhbmQgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXFUaW1lID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyID0gKDAsIHByb3BlcnRpZXNfMS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnBlcmZvcm0oXCJnZXRCbG9ja051bWJlclwiLCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya0Vycm9yOiB0aGlzLmdldE5ldHdvcmsoKS50aGVuKGZ1bmN0aW9uIChuZXR3b3JrKSB7IHJldHVybiAobnVsbCk7IH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gKGVycm9yKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyID0gX2EuYmxvY2tOdW1iZXIsIG5ldHdvcmtFcnJvciA9IF9hLm5ldHdvcmtFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVucmVtZW1iZXIgdGhpcyBiYWQgaW50ZXJuYWwgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV0d29ya0Vycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcFRpbWUgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShibG9ja051bWJlcikudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPCBfdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpOyAvLyBAVE9ETzogU3RpbGwgbmVlZCB0aGlzP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGJsb2NrTnVtYmVyOiBibG9ja051bWJlciwgcmVxVGltZTogcmVxVGltZSwgcmVzcFRpbWU6IHJlc3BUaW1lIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBjaGVja0ludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2FsbG93IHVuaGFuZGxlZCBleGNlcHRpb25zOyBpZiBuZWVkZWQgdGhleSBhcmUgaGFuZGxlZCBlbHNlIHdoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgbnVsbCB0aGUgZGVhZCAocmVqZWN0ZWQpIGZldGNoLCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjaGVja0ludGVybmFsQmxvY2tOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKS5ibG9ja051bWJlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9sbElkLCBydW5uZXJzLCBibG9ja051bWJlciwgZXJyb3JfNiwgaTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2xsSWQgPSBuZXh0UG9sbElkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl82ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3JfNik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbWl0IGEgcG9sbCBldmVudCBhZnRlciB3ZSBoYXZlIHRoZSBsYXRlc3QgKGZhc3QpIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicG9sbFwiLCBwb2xsSWQsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBibG9jayBoYXMgbm90IGNoYW5nZWQsIG1laC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PT0gdGhpcy5fbGFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGlkUG9sbFwiLCBwb2xsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHBvbGxpbmcgY3ljbGUsIHRyaWdnZXIgYSBcImJsb2NrXCIgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKCh0aGlzLl9lbWl0dGVkLmJsb2NrKSAtIGJsb2NrTnVtYmVyKSA+IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIm5ldHdvcmsgYmxvY2sgc2tldyBkZXRlY3RlZDsgc2tpcHBpbmcgYmxvY2sgZXZlbnRzIChlbWl0dGVkPVwiICsgdGhpcy5fZW1pdHRlZC5ibG9jayArIFwiIGJsb2NrTnVtYmVyXCIgKyBibG9ja051bWJlciArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBsb2dnZXIubWFrZUVycm9yKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcjogYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImJsb2NrU2tld1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0Jsb2NrTnVtYmVyOiB0aGlzLl9lbWl0dGVkLmJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImJsb2NrXCIsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbGwgbGlzdGVuZXIgZm9yIGVhY2ggYmxvY2sgdGhhdCBoYXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gdGhpcy5fZW1pdHRlZC5ibG9jayArIDE7IGkgPD0gYmxvY2tOdW1iZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW1pdHRlZCBibG9jayB3YXMgdXBkYXRlZCwgY2hlY2sgZm9yIG9ic29sZXRlIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWQuYmxvY2sgIT09IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2VtaXR0ZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmxvY2sgZXZlbnQgZG9lcyBub3QgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiYmxvY2tcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayB3ZSB3ZXJlIGF0IHdoZW4gd2UgZW1pdHRlZCB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudEJsb2NrTnVtYmVyID0gX3RoaXMuX2VtaXR0ZWRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2Fubm90IGdhcmJhZ2UgY29sbGVjdCBwZW5kaW5nIHRyYW5zYWN0aW9ucyBvciBibG9ja3MgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHNob3VsZCBiZSBnYXJiYWdlIGNvbGxlY3RlZCBieSB0aGUgUHJvdmlkZXIgd2hlbiBzZXR0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwicGVuZGluZ1wiIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRCbG9ja051bWJlciA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmljdCBhbnkgdHJhbnNhY3Rpb24gaGFzaGVzIG9yIGJsb2NrIGhhc2hlcyBvdmVyIDEyIGJsb2Nrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbGQsIHNpbmNlIHRoZXkgc2hvdWxkIG5vdCByZXR1cm4gbnVsbCBhbnl3YXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIGV2ZW50QmxvY2tOdW1iZXIgPiAxMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLl9lbWl0dGVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHBvbGxpbmcgY3ljbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBhbGwgdHJhbnNhY3Rpb24gaGFzaGVzIHdlIGFyZSB3YWl0aW5nIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoXzIgPSBldmVudC5oYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bm5lciA9IF90aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoXzIpLnRoZW4oZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQgfHwgcmVjZWlwdC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoXzJdID0gcmVjZWlwdC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGhhc2hfMiwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgX3RoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzLnB1c2gocnVubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBhbGxvdyBhIHNpbmdsZSBnZXRMb2dzIHRvIGJlIGluLWZsaWdodCBhdCBhIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnQuX2luZmxpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2luZmxpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBmaWx0ZXIgZm9yIHRoaXMgZXZlbnQsIHNvIHdlIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN0cmljdCBldmVudHMgdG8gZXZlbnRzIHRoYXQgaGFwcGVuZWQgbm8gZWFybGllciB0aGFuIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5fbGFzdEJsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZnJvbSB0aGUgbGFzdCAqa25vd24qIGV2ZW50OyBkdWUgdG8gbG9hZC1iYWxhbmNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgc29tZSBub2RlcyByZXR1cm5pbmcgdXBkYXRlZCBibG9jayBudW1iZXJzIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4aW5nIGV2ZW50cywgYSBsb2dzIHJlc3VsdCB3aXRoIDAgZW50cmllcyBjYW5ub3QgYmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVzdGVkIGFuZCB3ZSBtdXN0IHJldHJ5IGEgcmFuZ2Ugd2hpY2ggaW5jbHVkZXMgaXQgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyXzEgPSBldmVudC5maWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyXzEuZnJvbUJsb2NrID0gZXZlbnQuX2xhc3RCbG9ja051bWJlciArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyXzEudG9CbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZml0bGVyIHJhbmdlcyBmcm9tIGdyb3dpbmcgdG9vIHdpbGQsIHNpbmNlIGl0IGlzIHF1aXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlrZWx5IHRoZXJlIGp1c3QgaGF2ZW4ndCBiZWVuIGFueSBldmVudHMgdG8gbW92ZSB0aGUgbGFzdEJsb2NrTnVtYmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5Gcm9tQmxvY2sgPSBmaWx0ZXJfMS50b0Jsb2NrIC0gX3RoaXMuX21heEZpbHRlckJsb2NrUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkZyb21CbG9jayA+IGZpbHRlcl8xLmZyb21CbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJfMS5mcm9tQmxvY2sgPSBtaW5Gcm9tQmxvY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJfMS5mcm9tQmxvY2sgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcl8xLmZyb21CbG9jayA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydW5uZXIgPSBfdGhpcy5nZXRMb2dzKGZpbHRlcl8xKS50aGVuKGZ1bmN0aW9uIChsb2dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBuZXh0IGdldExvZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2luZmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3MuZm9yRWFjaChmdW5jdGlvbiAobG9nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHdoZW4gd2UgZ2V0IGFuIGV2ZW50IGZvciBhIGdpdmVuIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHdlIHRydXN0IHRoZSBldmVudHMgYXJlIGluZGV4ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cuYmxvY2tOdW1iZXIgPiBldmVudC5fbGFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2xhc3RCbG9ja051bWJlciA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzdGFsbCByZXF1ZXN0cyB0byBmZXRjaCBibG9ja3MgYW5kIHR4c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VtaXR0ZWRbXCJiOlwiICsgbG9nLmJsb2NrSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyBsb2cudHJhbnNhY3Rpb25IYXNoXSA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoZmlsdGVyXzEsIGxvZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbm90aGVyIGdldExvZ3MgKHRoZSByYW5nZSB3YXMgbm90IHVwZGF0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9pbmZsaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBhbGwgZXZlbnRzIGZvciB0aGlzIGxvb3AgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgZW1pdCBcImRpZFBvbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocnVubmVycykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRpZFBvbGxcIiwgcG9sbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyBfdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBEZXByZWNhdGVkOyBkbyBub3QgdXNlIHRoaXNcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnJlc2V0RXZlbnRzQmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VQcm92aWRlci5wcm90b3R5cGUsIFwibmV0d29ya1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgcXVlcnkgdGhlIG5ldHdvcmsgaWYgdGhlIHVuZGVybHlpbmcgbmV0d29ya1xuICAgIC8vIGNhbiBjaGFuZ2UsIHN1Y2ggYXMgd2hlbiBjb25uZWN0ZWQgdG8gYSBKU09OLVJQQyBiYWNrZW5kXG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBuZXR3b3JrIGRldGVjdGlvblwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInByb3ZpZGVyLmRldGVjdE5ldHdvcmtcIlxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXR3b3JrLCBjdXJyZW50TmV0d29yaywgZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3JlYWR5KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZXRlY3ROZXR3b3JrKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TmV0d29yayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG5ldHdvcmsuY2hhaW5JZCAhPT0gY3VycmVudE5ldHdvcmsuY2hhaW5JZCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFueU5ldHdvcmspIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0d29yayA9IGN1cnJlbnROZXR3b3JrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgYWxsIGludGVybmFsIGJsb2NrIG51bWJlciBndWFyZHMgYW5kIGNhY2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIgPSAtMTAyNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFwibmV0d29ya1wiIGV2ZW50IE1VU1QgaGFwcGVuIGJlZm9yZSB0aGlzIG1ldGhvZCByZXNvbHZlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gYW55IGV2ZW50cyBoYXZlIGEgY2hhbmNlIHRvIHVucmVnaXN0ZXIsIHNvIHdlIHN0YWxsIGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbmFsIGV2ZW50IGxvb3AgYmVmb3JlIHJldHVybmluZyBmcm9tIC90aGlzLyBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGN1cnJlbnROZXR3b3JrLCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWxsKDApXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX25ldHdvcmtdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGxvZ2dlci5tYWtlRXJyb3IoXCJ1bmRlcmx5aW5nIG5ldHdvcmsgY2hhbmdlZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yazogbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZE5ldHdvcms6IGN1cnJlbnROZXR3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovLCBuZXR3b3JrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVByb3ZpZGVyLnByb3RvdHlwZSwgXCJibG9ja051bWJlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgdGhpcy5wb2xsaW5nSW50ZXJ2YWwgLyAyKS50aGVuKGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7IH0pO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCkgPyB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgOiAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcInBvbGxpbmdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fcG9sbGVyICE9IG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyBfdGhpcy5wb2xsKCk7IH0sIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2Jvb3RzdHJhcFBvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucG9sbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYmxvY2sgYWRkaXRpb25hbCBwb2xscyB1bnRpbCB0aGUgcG9sbGluZyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgZG9uZSwgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHBvbGwgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ib290c3RyYXBQb2xsID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcG9sbGluZyB3YXMgZGlzYWJsZWQsIHNvbWV0aGluZyBtYXkgcmVxdWlyZSBhIHBva2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBzdGFydGluZyB0aGUgYm9vdHN0cmFwIHBvbGwgYW5kIGl0IHdhcyBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIG91dCB0aGUgYm9vdHN0cmFwIHNvIHdlIGNhbiBkbyBhbm90aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jvb3RzdHJhcFBvbGwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcG9sbGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VQcm92aWRlci5wcm90b3R5cGUsIFwicG9sbGluZ0ludGVydmFsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9sbGluZ0ludGVydmFsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8PSAwIHx8IHBhcnNlSW50KFN0cmluZyh2YWx1ZSkpICE9IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2xsaW5nIGludGVydmFsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgX3RoaXMucG9sbCgpOyB9LCB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0RmFzdEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBTdGFsZSBibG9jayBudW1iZXIsIHJlcXVlc3QgYSBuZXdlciB2YWx1ZVxuICAgICAgICBpZiAoKG5vdyAtIHRoaXMuX2Zhc3RRdWVyeURhdGUpID4gMiAqIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IG5vdztcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSB0aGlzLmdldEJsb2NrTnVtYmVyKCkudGhlbihmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gX3RoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZmFzdEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2U7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9zZXRGYXN0QmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgLy8gT2xkZXIgYmxvY2ssIG1heWJlIGEgc3RhbGUgcmVxdWVzdFxuICAgICAgICBpZiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyICE9IG51bGwgJiYgYmxvY2tOdW1iZXIgPCB0aGlzLl9mYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIHRpbWUgd2UgdXBkYXRlZCB0aGUgYmxvY2tudW1iZXJcbiAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IGdldFRpbWUoKTtcbiAgICAgICAgLy8gTmV3ZXIgYmxvY2sgbnVtYmVyLCB1c2UgIGl0XG4gICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPT0gbnVsbCB8fCBibG9ja051bWJlciA+IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS53YWl0Rm9yVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgKGNvbmZpcm1hdGlvbnMgPT0gbnVsbCkgPyAxIDogY29uZmlybWF0aW9ucywgdGltZW91dCB8fCAwLCBudWxsKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl93YWl0Rm9yVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0LCByZXBsYWNlYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVjZWlwdDtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVjZWlwdCBpcyBhbHJlYWR5IGdvb2RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVjZWlwdCA/IHJlY2VpcHQuY29uZmlybWF0aW9ucyA6IDApID49IGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVjZWlwdF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb2xsIHVudGlsIHRoZSByZWNlaXB0IGlzIGdvb2QuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5jZWxGdW5jcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxyZWFkeURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jKSB7IGZ1bmMoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5lZEhhbmRsZXIgPSBmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuY29uZmlybWF0aW9ucyA8IGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uKHRyYW5zYWN0aW9uSGFzaCwgbWluZWRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsRnVuY3MucHVzaChmdW5jdGlvbiAoKSB7IF90aGlzLnJlbW92ZUxpc3RlbmVyKHRyYW5zYWN0aW9uSGFzaCwgbWluZWRIYW5kbGVyKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RCbG9ja051bWJlcl8xID0gcmVwbGFjZWFibGUuc3RhcnRCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FubmVkQmxvY2tfMSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZUhhbmRsZXJfMSA9IGZ1bmN0aW9uIChibG9ja051bWJlcikgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IDEgc2Vjb25kOyB0aGlzIGlzIG9ubHkgdXNlZCBpbiB0aGUgY2FzZSBvZiBhIGZhdWx0LCBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgdHJhZGUgb2ZmIGEgbGl0dGxlIGJpdCBvZiBsYXRlbmN5IGZvciBtb3JlIGNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGFuZCBmZXdlciBKU09OLVJQQyBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWxsKDEwMDApXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IDEgc2Vjb25kOyB0aGlzIGlzIG9ubHkgdXNlZCBpbiB0aGUgY2FzZSBvZiBhIGZhdWx0LCBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgdHJhZGUgb2ZmIGEgbGl0dGxlIGJpdCBvZiBsYXRlbmN5IGZvciBtb3JlIGNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGFuZCBmZXdlciBKU09OLVJQQyBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFRyYW5zYWN0aW9uQ291bnQocmVwbGFjZWFibGUuZnJvbSkudGhlbihmdW5jdGlvbiAobm9uY2UpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbmVkLCBibG9jaywgdGksIHR4LCByZWNlaXB0XzEsIHJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShub25jZSA8PSByZXBsYWNlYWJsZS5ub25jZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QmxvY2tOdW1iZXJfMSA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5lZCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmVkICYmIG1pbmVkLmJsb2NrTnVtYmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCB0aW1lIHNjYW5uaW5nLiBXZSBzdGFydCBhIGxpdHRsZSBlYXJsaWVyIGZvciBzb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpZ2dsZSByb29tIGhlcmUgdG8gaGFuZGxlIHRoZSBldmVudHVhbGx5IGNvbnNpc3RlbnQgbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGJsb2NrY2hhaW4gKGUuZy4gdGhlIGdldFRyYW5zYWN0aW9uQ291bnQgd2FzIGZvciBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCBibG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYW5uZWRCbG9ja18xID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5uZWRCbG9ja18xID0gbGFzdEJsb2NrTnVtYmVyXzEgLSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYW5uZWRCbG9ja18xIDwgcmVwbGFjZWFibGUuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5uZWRCbG9ja18xID0gcmVwbGFjZWFibGUuc3RhcnRCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzY2FubmVkQmxvY2tfMSA8PSBibG9ja051bWJlcikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zKHNjYW5uZWRCbG9ja18xKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aSA8IGJsb2NrLnRyYW5zYWN0aW9ucy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBibG9jay50cmFuc2FjdGlvbnNbdGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzZnVsbHkgbWluZWQhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSB0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eC5mcm9tID09PSByZXBsYWNlYWJsZS5mcm9tICYmIHR4Lm5vbmNlID09PSByZXBsYWNlYWJsZS5ub25jZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKHR4Lmhhc2gsIGNvbmZpcm1hdGlvbnMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSByZXNvbHZlZCBvciByZWplY3RlZCAocHJvbGx5IGEgdGltZW91dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcGxhY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhID09PSByZXBsYWNlYWJsZS5kYXRhICYmIHR4LnRvID09PSByZXBsYWNlYWJsZS50byAmJiB0eC52YWx1ZS5lcShyZXBsYWNlYWJsZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwicmVwcmljZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5kYXRhID09PSBcIjB4XCIgJiYgdHguZnJvbSA9PT0gdHgudG8gJiYgdHgudmFsdWUuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGFpbiB3aHkgd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlRSQU5TQUNUSU9OX1JFUExBQ0VELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IHRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQ6IHJlY2VpcHRfMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbm5lZEJsb2NrXzErKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25jZShcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsRnVuY3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlTGlzdGVuZXIoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRpbWVvdXQpID09PSBcIm51bWJlclwiICYmIHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZXJfMSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5RG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0aW1lb3V0IGV4Y2VlZGVkXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVElNRU9VVCwgeyB0aW1lb3V0OiB0aW1lb3V0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyXzEudW5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lcl8xLnVucmVmKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKGZ1bmN0aW9uICgpIHsgY2xlYXJUaW1lb3V0KHRpbWVyXzEpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRHYXNQcmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRHYXNQcmljZVwiLCB7fSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShyZXN1bHQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0R2FzUHJpY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJhbGFuY2UgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcywgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm9wZXJ0aWVzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZ2V0QmFsYW5jZVwiLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20ocmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJhbGFuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0VHJhbnNhY3Rpb25Db3VudCA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zLCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3BlcnRpZXNfMS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsIHBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShyZXN1bHQpLnRvTnVtYmVyKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldENvZGUgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcywgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm9wZXJ0aWVzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZ2V0Q29kZVwiLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGJ5dGVzXzEuaGV4bGlmeSkocmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0U3RvcmFnZUF0ID0gZnVuY3Rpb24gKGFkZHJlc3NPck5hbWUsIHBvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zLCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3BlcnRpZXNfMS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogUHJvbWlzZS5yZXNvbHZlKHBvc2l0aW9uKS50aGVuKGZ1bmN0aW9uIChwKSB7IHJldHVybiAoMCwgYnl0ZXNfMS5oZXhWYWx1ZSkocCk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRTdG9yYWdlQXRcIiwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCBieXRlc18xLmhleGxpZnkpKHJlc3VsdCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRTdG9yYWdlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBieSBhbnkgc3ViY2xhc3Mgd3JhcHBpbmcgYSBUcmFuc2FjdGlvblJlc3BvbnNlXG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fd3JhcFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHR4LCBoYXNoLCBzdGFydEJsb2NrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChoYXNoICE9IG51bGwgJiYgKDAsIGJ5dGVzXzEuaGV4RGF0YUxlbmd0aCkoaGFzaCkgIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIC0gc2VuZFRyYW5zYWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB0eDtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGhhc2ggd2UgZXhwZWN0IGlzIHRoZSBzYW1lIGFzIHRoZSBoYXNoIHRoZSBzZXJ2ZXIgcmVwb3J0ZWRcbiAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiB0eC5oYXNoICE9PSBoYXNoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIlRyYW5zYWN0aW9uIGhhc2ggbWlzbWF0Y2ggZnJvbSBQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24uXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwgeyBleHBlY3RlZEhhc2g6IHR4Lmhhc2gsIHJldHVybmVkSGFzaDogaGFzaCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQud2FpdCA9IGZ1bmN0aW9uIChjb25maXJtcywgdGltZW91dCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50LCByZWNlaXB0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtcyAhPT0gMCAmJiBzdGFydEJsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHR4Lm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdHgudG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRCbG9jazogc3RhcnRCbG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl93YWl0Rm9yVHJhbnNhY3Rpb24odHguaGFzaCwgY29uZmlybXMsIHRpbWVvdXQsIHJlcGxhY2VtZW50KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsICYmIGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gbG9uZ2VyIHBlbmRpbmcsIGFsbG93IHRoZSBwb2xsaW5nIGxvb3AgdG8gZ2FyYmFnZSBjb2xsZWN0IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHguaGFzaF0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0cmFuc2FjdGlvbiBmYWlsZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdDogcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlY2VpcHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHNpZ25lZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZXhUeCwgdHgsIGJsb2NrTnVtYmVyLCBoYXNoLCBlcnJvcl83O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZShzaWduZWRUcmFuc2FjdGlvbikudGhlbihmdW5jdGlvbiAodCkgeyByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4bGlmeSkodCk7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaGV4VHggPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5jb25maXJtYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzQsIDYsICwgN10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwic2VuZFRyYW5zYWN0aW9uXCIsIHsgc2lnbmVkVHJhbnNhY3Rpb246IGhleFR4IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgsIGhhc2gsIGJsb2NrTnVtYmVyKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzcgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl83LnRyYW5zYWN0aW9uID0gdHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl83LnRyYW5zYWN0aW9uSGFzaCA9IHR4Lmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl83O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QgPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcywgdHgsIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRyYW5zYWN0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcImZyb21cIiwgXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2ID8gX3RoaXMuX2dldEFkZHJlc3ModikgOiBudWxsKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInZhbHVlXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgPyBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSh2KSA6IG51bGwpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgW1widHlwZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oZnVuY3Rpb24gKHYpIHsgcmV0dXJuICgodiAhPSBudWxsKSA/IHYgOiBudWxsKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmFjY2Vzc0xpc3QgPSB0aGlzLmZvcm1hdHRlci5hY2Nlc3NMaXN0KHZhbHVlcy5hY2Nlc3NMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhdGFcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodiA/ICgwLCBieXRlc18xLmhleGxpZnkpKHYpIDogbnVsbCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IHRoaXMuZm9ybWF0dGVyKS50cmFuc2FjdGlvblJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvcGVydGllc18xLnJlc29sdmVQcm9wZXJ0aWVzKSh0eCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGZpbHRlcl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgW1wiYmxvY2tIYXNoXCIsIFwidG9waWNzXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBmaWx0ZXJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgW1wiZnJvbUJsb2NrXCIsIFwidG9CbG9ja1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gX3RoaXMuX2dldEJsb2NrVGFnKGZpbHRlcltrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSB0aGlzLmZvcm1hdHRlcikuZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3BlcnRpZXNfMS5yZXNvbHZlUHJvcGVydGllcykocmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2NhbGwgPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGJsb2NrVGFnLCBhdHRlbXB0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eFNlbmRlciwgcmVzdWx0LCBkYXRhLCBzZW5kZXIsIHVybHMsIHVybHNPZmZzZXQsIHVybHNMZW5ndGgsIHVybHNEYXRhLCB1LCB1cmwsIGNhbGxkYXRhLCBjYWxsYmFja1NlbGVjdG9yLCBleHRyYURhdGEsIGNjaXBSZXN1bHQsIHR4LCBlcnJvcl84O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPj0gTUFYX0NDSVBfUkVESVJFQ1RTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIHJlYWQgZXhjZWVkZWQgbWF4aW11bSByZWRpcmVjdGlvbnNcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RzOiBhdHRlbXB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHR4U2VuZGVyID0gdHJhbnNhY3Rpb24udG87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJjYWxsXCIsIHsgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLCBibG9ja1RhZzogYmxvY2tUYWcgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhdHRlbXB0ID49IDAgJiYgYmxvY2tUYWcgPT09IFwibGF0ZXN0XCIgJiYgdHhTZW5kZXIgIT0gbnVsbCAmJiByZXN1bHQuc3Vic3RyaW5nKDAsIDEwKSA9PT0gXCIweDU1NmYxODMwXCIgJiYgKCgwLCBieXRlc18xLmhleERhdGFMZW5ndGgpKHJlc3VsdCkgJSAzMiA9PT0gNCkpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsyLCA0LCAsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAoMCwgYnl0ZXNfMS5oZXhEYXRhU2xpY2UpKHJlc3VsdCwgNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXIgPSAoMCwgYnl0ZXNfMS5oZXhEYXRhU2xpY2UpKGRhdGEsIDAsIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oc2VuZGVyKS5lcSh0eFNlbmRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBzZW5kZXIgZGlkIG5vdCBtYXRjaFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiT2ZmY2hhaW5Mb29rdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdXJscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsc09mZnNldCA9IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKCgwLCBieXRlc18xLmhleERhdGFTbGljZSkoZGF0YSwgMzIsIDY0KSkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybHNMZW5ndGggPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSgoMCwgYnl0ZXNfMS5oZXhEYXRhU2xpY2UpKGRhdGEsIHVybHNPZmZzZXQsIHVybHNPZmZzZXQgKyAzMikpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmxzRGF0YSA9ICgwLCBieXRlc18xLmhleERhdGFTbGljZSkoZGF0YSwgdXJsc09mZnNldCArIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodSA9IDA7IHUgPCB1cmxzTGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBfcGFyc2VTdHJpbmcodXJsc0RhdGEsIHUgKiAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCBSZWFkIGNvbnRhaW5lZCBjb3JydXB0IFVSTCBzdHJpbmdcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxzLnB1c2godXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxkYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjYWxsYmFja1NlbGVjdG9yIChieXRlczQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKCgwLCBieXRlc18xLmhleERhdGFTbGljZSkoZGF0YSwgMTAwLCAxMjgpKS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCBSZWFkIGNhbGxiYWNrIHNlbGVjdG9yIGluY2x1ZGVkIGp1bmtcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrU2VsZWN0b3IgPSAoMCwgYnl0ZXNfMS5oZXhEYXRhU2xpY2UpKGRhdGEsIDk2LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFEYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgMTI4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2NpcFJlYWRGZXRjaCh0cmFuc2FjdGlvbiwgY2FsbGRhdGEsIHVybHMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2NpcFJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjY2lwUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBkaXNhYmxlZCBvciBwcm92aWRlZCBubyBVUkxzXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdHhTZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKDAsIGJ5dGVzXzEuaGV4Q29uY2F0KShbY2FsbGJhY2tTZWxlY3RvciwgZW5jb2RlQnl0ZXMoW2NjaXBSZXN1bHQsIGV4dHJhRGF0YV0pXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQgKyAxKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzggPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JfOC5jb2RlID09PSBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXzg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGJ5dGVzXzEuaGV4bGlmeSkocmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogeyB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sIGJsb2NrVGFnOiBibG9ja1RhZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm9wZXJ0aWVzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjaXBSZWFkRW5hYmxlZDogUHJvbWlzZS5yZXNvbHZlKHRyYW5zYWN0aW9uLmNjaXBSZWFkRW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2NhbGwocmVzb2x2ZWQudHJhbnNhY3Rpb24sIHJlc29sdmVkLmJsb2NrVGFnLCByZXNvbHZlZC5jY2lwUmVhZEVuYWJsZWQgPyAwIDogLTEpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmVzdGltYXRlR2FzID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMsIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvcGVydGllc18xLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJlc3RpbWF0ZUdhc1wiLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20ocmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImVzdGltYXRlR2FzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3NPck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3M7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGFkZHJlc3NPck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzT3JOYW1lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzc09yTmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIEVOUyBuYW1lXCIsIFwibmFtZVwiLCBhZGRyZXNzT3JOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiRU5TIG5hbWUgbm90IGNvbmZpZ3VyZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lKFwiICsgSlNPTi5zdHJpbmdpZnkoYWRkcmVzc09yTmFtZSkgKyBcIilcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGFkZHJlc3NdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEJsb2NrID0gZnVuY3Rpb24gKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyLCBwYXJhbXMsIF9hLCBlcnJvcl85O1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBibG9ja0hhc2hPckJsb2NrVGFnXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tIYXNoT3JCbG9ja1RhZyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gLTEyODtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlVHJhbnNhY3Rpb25zOiAhIWluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBieXRlc18xLmlzSGV4U3RyaW5nKShibG9ja0hhc2hPckJsb2NrVGFnLCAzMikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmJsb2NrSGFzaCA9IGJsb2NrSGFzaE9yQmxvY2tUYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFszLCA1LCAsIDZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tIYXNoT3JCbG9ja1RhZyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5ibG9ja1RhZyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykocGFyYW1zLmJsb2NrVGFnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gcGFyc2VJbnQocGFyYW1zLmJsb2NrVGFnLnN1YnN0cmluZygyKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzkgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9jayBoYXNoIG9yIGJsb2NrIHRhZ1wiLCBcImJsb2NrSGFzaE9yQmxvY2tUYWdcIiwgYmxvY2tIYXNoT3JCbG9ja1RhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIHdlYl8xLnBvbGwpKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2ssIGJsb2NrTnVtYmVyXzEsIGksIHR4LCBjb25maXJtYXRpb25zLCBibG9ja1dpdGhUeHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZ2V0QmxvY2tcIiwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxvY2sgd2FzIG5vdCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBibG9ja2hhc2hlcywgaWYgd2UgZGlkbid0IHNheSBpdCBleGlzdGVkLCB0aGF0IGJsb2NraGFzaCBtYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGV4aXN0LiBJZiB3ZSBkaWQgc2VlIGl0IHRob3VnaCwgcGVyaGFwcyBmcm9tIGEgbG9nLCB3ZSBrbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGV4aXN0cywgYW5kIHRoaXMgbm9kZSBpcyBqdXN0IG5vdCBjYXVnaHQgdXAgeWV0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrSGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZFtcImI6XCIgKyBwYXJhbXMuYmxvY2tIYXNoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBibG9jayB0YWdzLCBpZiB3ZSBhcmUgYXNraW5nIGZvciBhIGZ1dHVyZSBibG9jaywgd2UgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPiB0aGlzLl9lbWl0dGVkLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHJ5IG9uIHRoZSBuZXh0IGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVUcmFuc2FjdGlvbnMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyXzEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgYmxvY2sudHJhbnNhY3Rpb25zLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gYmxvY2sudHJhbnNhY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR4LmJsb2NrTnVtYmVyID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eC5jb25maXJtYXRpb25zID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShibG9ja051bWJlcl8xID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXJfMSAtIHR4LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IGNvbmZpcm1hdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1dpdGhUeHMgPSB0aGlzLmZvcm1hdHRlci5ibG9ja1dpdGhUcmFuc2FjdGlvbnMoYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrV2l0aFR4cy50cmFuc2FjdGlvbnMgPSBibG9ja1dpdGhUeHMudHJhbnNhY3Rpb25zLm1hcChmdW5jdGlvbiAodHgpIHsgcmV0dXJuIF90aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYmxvY2tXaXRoVHhzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZm9ybWF0dGVyLmJsb2NrKGJsb2NrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9LCB7IG9uY2VQb2xsOiB0aGlzIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJsb2NrID0gZnVuY3Rpb24gKGJsb2NrSGFzaE9yQmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCBmYWxzZSkpO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMgPSBmdW5jdGlvbiAoYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsIHRydWUpKTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXM7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRyYW5zYWN0aW9uSGFzaF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHsgdHJhbnNhY3Rpb25IYXNoOiB0aGlzLmZvcm1hdHRlci5oYXNoKHRyYW5zYWN0aW9uSGFzaCwgdHJ1ZSkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgd2ViXzEucG9sbCkoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0LCB0eCwgYmxvY2tOdW1iZXIsIGNvbmZpcm1hdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uXCIsIHBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXNwb25zZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eC5ibG9ja051bWJlciA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSB0eC5ibG9ja051bWJlcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSwgeyBvbmNlUG9sbDogdGhpcyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvblJlY2VpcHQgPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXM7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRyYW5zYWN0aW9uSGFzaF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHsgdHJhbnNhY3Rpb25IYXNoOiB0aGlzLmZvcm1hdHRlci5oYXNoKHRyYW5zYWN0aW9uSGFzaCwgdHJ1ZSkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgd2ViXzEucG9sbCkoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0LCByZWNlaXB0LCBibG9ja051bWJlciwgY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiZ2V0aC1ldGNcIiByZXR1cm5zIHJlY2VpcHRzIGJlZm9yZSB0aGV5IGFyZSByZWFkeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0ID0gdGhpcy5mb3JtYXR0ZXIucmVjZWlwdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWNlaXB0LmJsb2NrTnVtYmVyID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWNlaXB0LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuY29uZmlybWF0aW9ucyA9IGNvbmZpcm1hdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCByZWNlaXB0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIHsgb25jZVBvbGw6IHRoaXMgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0TG9ncyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcywgbG9ncztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvcGVydGllc18xLnJlc29sdmVQcm9wZXJ0aWVzKSh7IGZpbHRlcjogdGhpcy5fZ2V0RmlsdGVyKGZpbHRlcikgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRMb2dzXCIsIHBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9ncy5mb3JFYWNoKGZ1bmN0aW9uIChsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9nLnJlbW92ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cucmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZvcm1hdHRlcl8xLkZvcm1hdHRlci5hcnJheU9mKHRoaXMuZm9ybWF0dGVyLmZpbHRlckxvZy5iaW5kKHRoaXMuZm9ybWF0dGVyKSkobG9ncyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0RXRoZXJQcmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnBlcmZvcm0oXCJnZXRFdGhlclByaWNlXCIsIHt9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0QmxvY2tUYWcgPSBmdW5jdGlvbiAoYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBibG9ja1RhZ107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgJiYgYmxvY2tUYWcgPCAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tUYWcgJSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmxvY2tUYWdcIiwgXCJibG9ja1RhZ1wiLCBibG9ja1RhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyICs9IGJsb2NrVGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja051bWJlcildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja1RhZyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0UmVzb2x2ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudE5hbWUsIGFkZHIsIHJlc29sdmVyLCBfYTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnVlKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gXCJcIiB8fCBjdXJyZW50TmFtZSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gc2luY2UgdGhlIGV0aCBub2RlIGNhbm5vdCBjaGFuZ2UgYW5kIGRvZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBoYXZlIGEgd2lsZGNhcmQgcmVzb2x2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lICE9PSBcImV0aFwiICYmIGN1cnJlbnROYW1lID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0UmVzb2x2ZXIoY3VycmVudE5hbWUsIFwiZ2V0UmVzb2x2ZXJcIildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYWRkciAhPSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IG5ldyBSZXNvbHZlcih0aGlzLCBhZGRyLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gY3VycmVudE5hbWUgIT09IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9hKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc29sdmVyLnN1cHBvcnRzV2lsZGNhcmQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gIShfYi5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgcmVzb2x2ZXIgZm91bmQsIHVzaW5nIEVJUC0yNTQ0IHNvIGl0IGlzbid0IHNhZmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzb2x2ZXJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TmFtZSA9IGN1cnJlbnROYW1lLnNwbGl0KFwiLlwiKS5zbGljZSgxKS5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRSZXNvbHZlciA9IGZ1bmN0aW9uIChuYW1lLCBvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ldHdvcmssIGFkZHJEYXRhLCBlcnJvcl8xMDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IFwiRU5TXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBFTlMuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV0d29yay5lbnNBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogb3BlcmF0aW9uLCBuZXR3b3JrOiBuZXR3b3JrLm5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMiwgNCwgLCA1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogbmV0d29yay5lbnNBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDAxNzhiOGJmXCIgKyAoMCwgaGFzaF8xLm5hbWVoYXNoKShuYW1lKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyRGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZvcm1hdHRlci5jYWxsQWRkcmVzcyhhZGRyRGF0YSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xMCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnJlc29sdmVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGFscmVhZHkgYW4gYWRkcmVzcywgbm90aGluZyB0byByZXNvbHZlXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlc29sdmUodGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXMgaXMgYSBoZXhzdHJpbmcsIHRoZSBhZGRyZXNzIGlzIGJhZCAoU2VlICM2OTQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBieXRlc18xLmlzSGV4U3RyaW5nKShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNvbHZlci5nZXRBZGRyZXNzKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUubG9va3VwQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlLCByZXNvbHZlckFkZHIsIG5hbWUsIF9hLCBhZGRyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBhZGRyZXNzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldFJlc29sdmVyKG5vZGUsIFwibG9va3VwQWRkcmVzc1wiKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyQWRkciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlckFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX3BhcnNlU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHg2OTFmMzQzMVwiICsgKDAsIGhhc2hfMS5uYW1laGFzaCkobm9kZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKSwgMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXNvbHZlTmFtZShuYW1lKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkciAhPSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QXZhdGFyID0gZnVuY3Rpb24gKG5hbWVPckFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVyLCBhZGRyZXNzLCBub2RlLCByZXNvbHZlckFkZHJlc3MsIGF2YXRhcl8xLCBlcnJvcl8xMSwgbmFtZV8xLCBfYSwgZXJyb3JfMTIsIGF2YXRhcjtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKG5hbWVPckFkZHJlc3MpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lT3JBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRSZXNvbHZlcihub2RlLCBcImdldEF2YXRhclwiKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyQWRkcmVzcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXJBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHJlc29sdmluZyB0aGUgYXZhdGFyIGFnYWluc3QgdGhlIGFkZHIucmV2ZXJzZSByZXNvbHZlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIodGhpcywgcmVzb2x2ZXJBZGRyZXNzLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsyLCA0LCAsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc29sdmVyLmdldEF2YXRhcigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXZhdGFyXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXZhdGFyXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYXZhdGFyXzEudXJsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcl8xMS5jb2RlICE9PSBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JfMTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs1LCA4LCAsIDldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX3BhcnNlU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHg2OTFmMzQzMVwiICsgKDAsIGhhc2hfMS5uYW1laGFzaCkobm9kZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZV8xID0gX2EuYXBwbHkodm9pZCAwLCBbX2Iuc2VudCgpLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFJlc29sdmVyKG5hbWVfMSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xMiA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcl8xMi5jb2RlICE9PSBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JfMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFJlc29sdmVyKG5hbWVPckFkZHJlc3MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVOUyBuYW1lOyBmb3J3YXJkIGxvb2t1cCB3aXRoIHdpbGRjYXJkXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDEyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNvbHZlci5nZXRBdmF0YXIoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmF0YXIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYXZhdGFyLnVybF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihtZXRob2QgKyBcIiBub3QgaW1wbGVtZW50ZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9zdGFydEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnBvbGxhYmxlKCk7IH0pLmxlbmd0aCA+IDApO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fc3RvcEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnBvbGxhYmxlKCk7IH0pLmxlbmd0aCA+IDApO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudChnZXRFdmVudFRhZyhldmVudE5hbWUpLCBsaXN0ZW5lciwgb25jZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgdGhpcy5fc3RhcnRFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIHZhciBzdG9wcGVkID0gW107XG4gICAgICAgIHZhciBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQubGlzdGVuZXIuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGV2ZW50Lm9uY2UpIHtcbiAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkgeyBfdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAoZXZlbnQudGFnID09PSBldmVudFRhZyk7XG4gICAgICAgIH0pLmxlbmd0aDtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubWFwKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQubGlzdGVuZXI7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiAoZXZlbnQudGFnID09PSBldmVudFRhZyk7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQubGlzdGVuZXI7IH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0b3BwZWQgPSBbXTtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIHZhciBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZyB8fCBldmVudC5saXN0ZW5lciAhPSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkgeyBfdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdG9wcGVkID0gW107XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV2ZW50VGFnXzEgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZ18xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHsgX3RoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBCYXNlUHJvdmlkZXI7XG59KGFic3RyYWN0X3Byb3ZpZGVyXzEuUHJvdmlkZXIpKTtcbmV4cG9ydHMuQmFzZVByb3ZpZGVyID0gQmFzZVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/base-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/cloudflare-provider.js":
/*!*************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/cloudflare-provider.js ***!
  \*************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CloudflareProvider = void 0;\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar CloudflareProvider = /** @class */ (function (_super) {\n    __extends(CloudflareProvider, _super);\n    function CloudflareProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CloudflareProvider.getApiKey = function (apiKey) {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    };\n    CloudflareProvider.getUrl = function (network, apiKey) {\n        var host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return host;\n    };\n    CloudflareProvider.prototype.perform = function (method, params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var block;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(method === \"getBlockNumber\")) return [3 /*break*/, 2];\n                        return [4 /*yield*/, _super.prototype.perform.call(this, \"getBlock\", { blockTag: \"latest\" })];\n                    case 1:\n                        block = _a.sent();\n                        return [2 /*return*/, block.number];\n                    case 2: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];\n                }\n            });\n        });\n    };\n    return CloudflareProvider;\n}(url_json_rpc_provider_1.UrlJsonRpcProvider));\nexports.CloudflareProvider = CloudflareProvider;\n//# sourceMappingURL=cloudflare-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2Nsb3VkZmxhcmUtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQiw4QkFBOEIsbUJBQU8sQ0FBQyxrTEFBeUI7QUFDL0QsZUFBZSxtQkFBTyxDQUFDLHlJQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyx3SkFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Ysb0JBQW9CO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuNy4wX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIvY2xvdWRmbGFyZS1wcm92aWRlci5qcz8wZGI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsb3VkZmxhcmVQcm92aWRlciA9IHZvaWQgMDtcbnZhciB1cmxfanNvbl9ycGNfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBDbG91ZGZsYXJlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsb3VkZmxhcmVQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDbG91ZGZsYXJlUHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ2xvdWRmbGFyZVByb3ZpZGVyLmdldEFwaUtleSA9IGZ1bmN0aW9uIChhcGlLZXkpIHtcbiAgICAgICAgaWYgKGFwaUtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYXBpS2V5IG5vdCBzdXBwb3J0ZWQgZm9yIGNsb3VkZmxhcmVcIiwgXCJhcGlLZXlcIiwgYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENsb3VkZmxhcmVQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIHZhciBob3N0ID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChuZXR3b3JrLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2Nsb3VkZmxhcmUtZXRoLmNvbS9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfTtcbiAgICBDbG91ZGZsYXJlUHJvdmlkZXIucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJsb2NrO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWV0aG9kID09PSBcImdldEJsb2NrTnVtYmVyXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9zdXBlci5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsIFwiZ2V0QmxvY2tcIiwgeyBibG9ja1RhZzogXCJsYXRlc3RcIiB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJsb2NrLm51bWJlcl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9zdXBlci5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsIG1ldGhvZCwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENsb3VkZmxhcmVQcm92aWRlcjtcbn0odXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLkNsb3VkZmxhcmVQcm92aWRlciA9IENsb3VkZmxhcmVQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb3VkZmxhcmUtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/cloudflare-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/etherscan-provider.js":
/*!************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/etherscan-provider.js ***!
  \************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EtherscanProvider = void 0;\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar transactions_1 = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib/index.js\");\nvar web_1 = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+web@5.7.0/node_modules/@ethersproject/web/lib/index.js\");\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/formatter.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar base_provider_1 = __webpack_require__(/*! ./base-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/base-provider.js\");\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction) {\n    var result = {};\n    for (var key in transaction) {\n        if (transaction[key] == null) {\n            continue;\n        }\n        var value = transaction[key];\n        if (key === \"type\" && value === 0) {\n            continue;\n        }\n        // Quantity-types require no leading zero, unless 0\n        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n            value = (0, bytes_1.hexValue)((0, bytes_1.hexlify)(value));\n        }\n        else if (key === \"accessList\") {\n            value = \"[\" + (0, transactions_1.accessListify)(value).map(function (set) {\n                return \"{address:\\\"\" + set.address + \"\\\",storageKeys:[\\\"\" + set.storageKeys.join('\",\"') + \"\\\"]}\";\n            }).join(\",\") + \"]\";\n        }\n        else {\n            value = (0, bytes_1.hexlify)(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\nfunction getResult(result) {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n    if (result.status != 1 || typeof (result.message) !== \"string\" || !result.message.match(/^OK/)) {\n        var error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n    return result.result;\n}\nfunction getJsonResult(result) {\n    // This response indicates we are being throttled\n    if (result && result.status == 0 && result.message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        var error = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        var error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    if (result.error) {\n        // @TODO: not any\n        var error = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) {\n            error.code = result.error.code;\n        }\n        if (result.error.data) {\n            error.data = result.error.data;\n        }\n        throw error;\n    }\n    return result.result;\n}\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag) {\n    if (blockTag === \"pending\") {\n        throw new Error(\"pending not supported\");\n    }\n    if (blockTag === \"latest\") {\n        return blockTag;\n    }\n    return parseInt(blockTag.substring(2), 16);\n}\nfunction checkError(method, error, transaction) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === logger_1.Logger.errors.SERVER_ERROR) {\n        var e = error.error;\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            var data = e.data;\n            if (data) {\n                data = \"0x\" + data.replace(/^.*0x/i, \"\");\n            }\n            if ((0, bytes_1.isHexString)(data)) {\n                return data;\n            }\n            logger.throwError(\"missing revert data in call exception\", logger_1.Logger.errors.CALL_EXCEPTION, {\n                error: error,\n                data: \"0x\"\n            });\n        }\n    }\n    // Get the message from any nested error structure\n    var message = error.message;\n    if (error.code === logger_1.Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof (error.error.message) === \"string\") {\n            message = error.error.message;\n        }\n        else if (typeof (error.body) === \"string\") {\n            message = error.body;\n        }\n        else if (typeof (error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", logger_1.Logger.errors.INSUFFICIENT_FUNDS, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", logger_1.Logger.errors.NONCE_EXPIRED, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n        logger.throwError(\"replacement fee too low\", logger_1.Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    throw error;\n}\nvar EtherscanProvider = /** @class */ (function (_super) {\n    __extends(EtherscanProvider, _super);\n    function EtherscanProvider(network, apiKey) {\n        var _this = _super.call(this, network) || this;\n        (0, properties_1.defineReadOnly)(_this, \"baseUrl\", _this.getBaseUrl());\n        (0, properties_1.defineReadOnly)(_this, \"apiKey\", apiKey || null);\n        return _this;\n    }\n    EtherscanProvider.prototype.getBaseUrl = function () {\n        switch (this.network ? this.network.name : \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            case \"optimism-kovan\":\n                return \"https:/\\/api-kovan-optimistic.etherscan.io\";\n            default:\n        }\n        return logger.throwArgumentError(\"unsupported network\", \"network\", this.network.name);\n    };\n    EtherscanProvider.prototype.getUrl = function (module, params) {\n        var query = Object.keys(params).reduce(function (accum, key) {\n            var value = params[key];\n            if (value != null) {\n                accum += \"&\" + key + \"=\" + value;\n            }\n            return accum;\n        }, \"\");\n        var apiKey = ((this.apiKey) ? \"&apikey=\" + this.apiKey : \"\");\n        return this.baseUrl + \"/api?module=\" + module + query + apiKey;\n    };\n    EtherscanProvider.prototype.getPostUrl = function () {\n        return this.baseUrl + \"/api\";\n    };\n    EtherscanProvider.prototype.getPostData = function (module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    };\n    EtherscanProvider.prototype.fetch = function (module, params, post) {\n        return __awaiter(this, void 0, void 0, function () {\n            var url, payload, procFunc, connection, payloadStr, result;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        url = (post ? this.getPostUrl() : this.getUrl(module, params));\n                        payload = (post ? this.getPostData(module, params) : null);\n                        procFunc = (module === \"proxy\") ? getJsonResult : getResult;\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            request: url,\n                            provider: this\n                        });\n                        connection = {\n                            url: url,\n                            throttleSlotInterval: 1000,\n                            throttleCallback: function (attempt, url) {\n                                if (_this.isCommunityResource()) {\n                                    (0, formatter_1.showThrottleMessage)();\n                                }\n                                return Promise.resolve(true);\n                            }\n                        };\n                        payloadStr = null;\n                        if (payload) {\n                            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n                            payloadStr = Object.keys(payload).map(function (key) {\n                                return key + \"=\" + payload[key];\n                            }).join(\"&\");\n                        }\n                        return [4 /*yield*/, (0, web_1.fetchJson)(connection, payloadStr, procFunc || getJsonResult)];\n                    case 1:\n                        result = _a.sent();\n                        this.emit(\"debug\", {\n                            action: \"response\",\n                            request: url,\n                            response: (0, properties_1.deepCopy)(result),\n                            provider: this\n                        });\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    EtherscanProvider.prototype.detectNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.network];\n            });\n        });\n    };\n    EtherscanProvider.prototype.perform = function (method, params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, postData, error_1, postData, error_2, args, topic0, logs, blocks, i, log, block, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = method;\n                        switch (_a) {\n                            case \"getBlockNumber\": return [3 /*break*/, 1];\n                            case \"getGasPrice\": return [3 /*break*/, 2];\n                            case \"getBalance\": return [3 /*break*/, 3];\n                            case \"getTransactionCount\": return [3 /*break*/, 4];\n                            case \"getCode\": return [3 /*break*/, 5];\n                            case \"getStorageAt\": return [3 /*break*/, 6];\n                            case \"sendTransaction\": return [3 /*break*/, 7];\n                            case \"getBlock\": return [3 /*break*/, 8];\n                            case \"getTransaction\": return [3 /*break*/, 9];\n                            case \"getTransactionReceipt\": return [3 /*break*/, 10];\n                            case \"call\": return [3 /*break*/, 11];\n                            case \"estimateGas\": return [3 /*break*/, 15];\n                            case \"getLogs\": return [3 /*break*/, 19];\n                            case \"getEtherPrice\": return [3 /*break*/, 26];\n                        }\n                        return [3 /*break*/, 28];\n                    case 1: return [2 /*return*/, this.fetch(\"proxy\", { action: \"eth_blockNumber\" })];\n                    case 2: return [2 /*return*/, this.fetch(\"proxy\", { action: \"eth_gasPrice\" })];\n                    case 3: \n                    // Returns base-10 result\n                    return [2 /*return*/, this.fetch(\"account\", {\n                            action: \"balance\",\n                            address: params.address,\n                            tag: params.blockTag\n                        })];\n                    case 4: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_getTransactionCount\",\n                            address: params.address,\n                            tag: params.blockTag\n                        })];\n                    case 5: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_getCode\",\n                            address: params.address,\n                            tag: params.blockTag\n                        })];\n                    case 6: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_getStorageAt\",\n                            address: params.address,\n                            position: params.position,\n                            tag: params.blockTag\n                        })];\n                    case 7: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_sendRawTransaction\",\n                            hex: params.signedTransaction\n                        }, true).catch(function (error) {\n                            return checkError(\"sendTransaction\", error, params.signedTransaction);\n                        })];\n                    case 8:\n                        if (params.blockTag) {\n                            return [2 /*return*/, this.fetch(\"proxy\", {\n                                    action: \"eth_getBlockByNumber\",\n                                    tag: params.blockTag,\n                                    boolean: (params.includeTransactions ? \"true\" : \"false\")\n                                })];\n                        }\n                        throw new Error(\"getBlock by blockHash not implemented\");\n                    case 9: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_getTransactionByHash\",\n                            txhash: params.transactionHash\n                        })];\n                    case 10: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_getTransactionReceipt\",\n                            txhash: params.transactionHash\n                        })];\n                    case 11:\n                        if (params.blockTag !== \"latest\") {\n                            throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                        }\n                        postData = getTransactionPostData(params.transaction);\n                        postData.module = \"proxy\";\n                        postData.action = \"eth_call\";\n                        _c.label = 12;\n                    case 12:\n                        _c.trys.push([12, 14, , 15]);\n                        return [4 /*yield*/, this.fetch(\"proxy\", postData, true)];\n                    case 13: return [2 /*return*/, _c.sent()];\n                    case 14:\n                        error_1 = _c.sent();\n                        return [2 /*return*/, checkError(\"call\", error_1, params.transaction)];\n                    case 15:\n                        postData = getTransactionPostData(params.transaction);\n                        postData.module = \"proxy\";\n                        postData.action = \"eth_estimateGas\";\n                        _c.label = 16;\n                    case 16:\n                        _c.trys.push([16, 18, , 19]);\n                        return [4 /*yield*/, this.fetch(\"proxy\", postData, true)];\n                    case 17: return [2 /*return*/, _c.sent()];\n                    case 18:\n                        error_2 = _c.sent();\n                        return [2 /*return*/, checkError(\"estimateGas\", error_2, params.transaction)];\n                    case 19:\n                        args = { action: \"getLogs\" };\n                        if (params.filter.fromBlock) {\n                            args.fromBlock = checkLogTag(params.filter.fromBlock);\n                        }\n                        if (params.filter.toBlock) {\n                            args.toBlock = checkLogTag(params.filter.toBlock);\n                        }\n                        if (params.filter.address) {\n                            args.address = params.filter.address;\n                        }\n                        // @TODO: We can handle slightly more complicated logs using the logs API\n                        if (params.filter.topics && params.filter.topics.length > 0) {\n                            if (params.filter.topics.length > 1) {\n                                logger.throwError(\"unsupported topic count\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                            }\n                            if (params.filter.topics.length === 1) {\n                                topic0 = params.filter.topics[0];\n                                if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n                                    logger.throwError(\"unsupported topic format\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                                }\n                                args.topic0 = topic0;\n                            }\n                        }\n                        return [4 /*yield*/, this.fetch(\"logs\", args)];\n                    case 20:\n                        logs = _c.sent();\n                        blocks = {};\n                        i = 0;\n                        _c.label = 21;\n                    case 21:\n                        if (!(i < logs.length)) return [3 /*break*/, 25];\n                        log = logs[i];\n                        if (log.blockHash != null) {\n                            return [3 /*break*/, 24];\n                        }\n                        if (!(blocks[log.blockNumber] == null)) return [3 /*break*/, 23];\n                        return [4 /*yield*/, this.getBlock(log.blockNumber)];\n                    case 22:\n                        block = _c.sent();\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                        _c.label = 23;\n                    case 23:\n                        log.blockHash = blocks[log.blockNumber];\n                        _c.label = 24;\n                    case 24:\n                        i++;\n                        return [3 /*break*/, 21];\n                    case 25: return [2 /*return*/, logs];\n                    case 26:\n                        if (this.network.name !== \"homestead\") {\n                            return [2 /*return*/, 0.0];\n                        }\n                        _b = parseFloat;\n                        return [4 /*yield*/, this.fetch(\"stats\", { action: \"ethprice\" })];\n                    case 27: return [2 /*return*/, _b.apply(void 0, [(_c.sent()).ethusd])];\n                    case 28: return [3 /*break*/, 29];\n                    case 29: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];\n                }\n            });\n        });\n    };\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    EtherscanProvider.prototype.getHistory = function (addressOrName, startBlock, endBlock) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            var _a;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = {\n                            action: \"txlist\"\n                        };\n                        return [4 /*yield*/, this.resolveName(addressOrName)];\n                    case 1:\n                        params = (_a.address = (_b.sent()),\n                            _a.startblock = ((startBlock == null) ? 0 : startBlock),\n                            _a.endblock = ((endBlock == null) ? 99999999 : endBlock),\n                            _a.sort = \"asc\",\n                            _a);\n                        return [4 /*yield*/, this.fetch(\"account\", params)];\n                    case 2:\n                        result = _b.sent();\n                        return [2 /*return*/, result.map(function (tx) {\n                                [\"contractAddress\", \"to\"].forEach(function (key) {\n                                    if (tx[key] == \"\") {\n                                        delete tx[key];\n                                    }\n                                });\n                                if (tx.creates == null && tx.contractAddress != null) {\n                                    tx.creates = tx.contractAddress;\n                                }\n                                var item = _this.formatter.transactionResponse(tx);\n                                if (tx.timeStamp) {\n                                    item.timestamp = parseInt(tx.timeStamp);\n                                }\n                                return item;\n                            })];\n                }\n            });\n        });\n    };\n    EtherscanProvider.prototype.isCommunityResource = function () {\n        return (this.apiKey == null);\n    };\n    return EtherscanProvider;\n}(base_provider_1.BaseProvider));\nexports.EtherscanProvider = EtherscanProvider;\n//# sourceMappingURL=etherscan-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2V0aGVyc2Nhbi1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGNBQWMsbUJBQU8sQ0FBQyxzSUFBc0I7QUFDNUMsbUJBQW1CLG1CQUFP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QTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2V0aGVyc2Nhbi1wcm92aWRlci5qcz9hMzBkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gdm9pZCAwO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG52YXIgcHJvcGVydGllc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCIpO1xudmFyIHdlYl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3dlYlwiKTtcbnZhciBmb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdHRlclwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBiYXNlX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9iYXNlLXByb3ZpZGVyXCIpO1xuLy8gVGhlIHRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gc2FuaXRpemVkIGJ5IHRoZSBjYWxscyBpbiBQcm92aWRlclxuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YSh0cmFuc2FjdGlvbikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNhY3Rpb25ba2V5XTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFF1YW50aXR5LXR5cGVzIHJlcXVpcmUgbm8gbGVhZGluZyB6ZXJvLCB1bmxlc3MgMFxuICAgICAgICBpZiAoeyB0eXBlOiB0cnVlLCBnYXNMaW1pdDogdHJ1ZSwgZ2FzUHJpY2U6IHRydWUsIG1heEZlZVBlckdzOiB0cnVlLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJ1ZSwgbm9uY2U6IHRydWUsIHZhbHVlOiB0cnVlIH1ba2V5XSkge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgYnl0ZXNfMS5oZXhWYWx1ZSkoKDAsIGJ5dGVzXzEuaGV4bGlmeSkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiYWNjZXNzTGlzdFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFwiW1wiICsgKDAsIHRyYW5zYWN0aW9uc18xLmFjY2Vzc0xpc3RpZnkpKHZhbHVlKS5tYXAoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInthZGRyZXNzOlxcXCJcIiArIHNldC5hZGRyZXNzICsgXCJcXFwiLHN0b3JhZ2VLZXlzOltcXFwiXCIgKyBzZXQuc3RvcmFnZUtleXMuam9pbignXCIsXCInKSArIFwiXFxcIl19XCI7XG4gICAgICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgYnl0ZXNfMS5oZXhsaWZ5KSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFJlc3VsdChyZXN1bHQpIHtcbiAgICAvLyBnZXRMb2dzLCBnZXRIaXN0b3J5IGhhdmUgd2VpcmQgc3VjY2VzcyByZXNwb25zZXNcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PSAwICYmIChyZXN1bHQubWVzc2FnZSA9PT0gXCJObyByZWNvcmRzIGZvdW5kXCIgfHwgcmVzdWx0Lm1lc3NhZ2UgPT09IFwiTm8gdHJhbnNhY3Rpb25zIGZvdW5kXCIpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSAxIHx8IHR5cGVvZiAocmVzdWx0Lm1lc3NhZ2UpICE9PSBcInN0cmluZ1wiIHx8ICFyZXN1bHQubWVzc2FnZS5tYXRjaCgvXk9LLykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZVwiKTtcbiAgICAgICAgZXJyb3IucmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgaWYgKChyZXN1bHQucmVzdWx0IHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInJhdGUgbGltaXRcIikgPj0gMCkge1xuICAgICAgICAgICAgZXJyb3IudGhyb3R0bGVSZXRyeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0SnNvblJlc3VsdChyZXN1bHQpIHtcbiAgICAvLyBUaGlzIHJlc3BvbnNlIGluZGljYXRlcyB3ZSBhcmUgYmVpbmcgdGhyb3R0bGVkXG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc3RhdHVzID09IDAgJiYgcmVzdWx0Lm1lc3NhZ2UgPT0gXCJOT1RPS1wiICYmIChyZXN1bHQucmVzdWx0IHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInJhdGUgbGltaXRcIikgPj0gMCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJ0aHJvdHRsZWQgcmVzcG9uc2VcIik7XG4gICAgICAgIGVycm9yLnJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGVycm9yLnRocm90dGxlUmV0cnkgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5qc29ucnBjICE9IFwiMi4wXCIpIHtcbiAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZVwiKTtcbiAgICAgICAgZXJyb3IucmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvci5jb2RlKSB7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gcmVzdWx0LmVycm9yLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvci5kYXRhKSB7XG4gICAgICAgICAgICBlcnJvci5kYXRhID0gcmVzdWx0LmVycm9yLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xufVxuLy8gVGhlIGJsb2NrVGFnIHdhcyBub3JtYWxpemVkIGFzIGEgc3RyaW5nIGJ5IHRoZSBQcm92aWRlciBwcmUtcGVyZm9ybSBvcGVyYXRpb25zXG5mdW5jdGlvbiBjaGVja0xvZ1RhZyhibG9ja1RhZykge1xuICAgIGlmIChibG9ja1RhZyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGVuZGluZyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAoYmxvY2tUYWcgPT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQoYmxvY2tUYWcuc3Vic3RyaW5nKDIpLCAxNik7XG59XG5mdW5jdGlvbiBjaGVja0Vycm9yKG1ldGhvZCwgZXJyb3IsIHRyYW5zYWN0aW9uKSB7XG4gICAgLy8gVW5kbyB0aGUgXCJjb252ZW5pZW5jZVwiIHNvbWUgbm9kZXMgYXJlIGF0dGVtcHRpbmcgdG8gcHJldmVudCBiYWNrd2FyZHNcbiAgICAvLyBpbmNvbXBhdGliaWxpdHk7IG1heWJlIGZvciB2NiBjb25zaWRlciBmb3J3YXJkaW5nIHJldmVydHMgYXMgZXJyb3JzXG4gICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIgJiYgZXJyb3IuY29kZSA9PT0gbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IpIHtcbiAgICAgICAgdmFyIGUgPSBlcnJvci5lcnJvcjtcbiAgICAgICAgLy8gRXRoZXJzY2FuIGtlZXBzIGNoYW5naW5nIHRoZWlyIHN0cmluZ1xuICAgICAgICBpZiAoZSAmJiAoZS5tZXNzYWdlLm1hdGNoKC9yZXZlcnRlZC9pKSB8fCBlLm1lc3NhZ2UubWF0Y2goL1ZNIGV4ZWN1dGlvbiBlcnJvci9pKSkpIHtcbiAgICAgICAgICAgIC8vIEV0aGVyc2NhbiBwcmVmaXhlcyB0aGUgZGF0YSBsaWtlIFwiUmV2ZXJ0ZWQgMHgxMjM0XCJcbiAgICAgICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gXCIweFwiICsgZGF0YS5yZXBsYWNlKC9eLioweC9pLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyByZXZlcnQgZGF0YSBpbiBjYWxsIGV4Y2VwdGlvblwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiMHhcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSBtZXNzYWdlIGZyb20gYW55IG5lc3RlZCBlcnJvciBzdHJ1Y3R1cmVcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09IGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SKSB7XG4gICAgICAgIGlmIChlcnJvci5lcnJvciAmJiB0eXBlb2YgKGVycm9yLmVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IuZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLmJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IuYm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLnJlc3BvbnNlVGV4dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gXCJJbnN1ZmZpY2llbnQgZnVuZHMuIFRoZSBhY2NvdW50IHlvdSB0cmllZCB0byBzZW5kIHRyYW5zYWN0aW9uIGZyb20gZG9lcyBub3QgaGF2ZSBlbm91Z2ggZnVuZHMuIFJlcXVpcmVkIDIxNDY0MDAwMDAwMDAwIGFuZCBnb3Q6IDBcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcIlRyYW5zYWN0aW9uIHdpdGggdGhlIHNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZC5cIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9zYW1lIGhhc2ggd2FzIGFscmVhZHkgaW1wb3J0ZWR8dHJhbnNhY3Rpb24gbm9uY2UgaXMgdG9vIGxvd3xub25jZSB0b28gbG93LykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJUcmFuc2FjdGlvbiBnYXMgcHJpY2UgaXMgdG9vIGxvdy4gVGhlcmUgaXMgYW5vdGhlciB0cmFuc2FjdGlvbiB3aXRoIHNhbWUgbm9uY2UgaW4gdGhlIHF1ZXVlLiBUcnkgaW5jcmVhc2luZyB0aGUgZ2FzIHByaWNlIG9yIGluY3JlbWVudGluZyB0aGUgbm9uY2UuXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvYW5vdGhlciB0cmFuc2FjdGlvbiB3aXRoIHNhbWUgbm9uY2UvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvZXhlY3V0aW9uIGZhaWxlZCBkdWUgdG8gYW4gZXhjZXB0aW9ufGV4ZWN1dGlvbiByZXZlcnRlZC8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG59XG52YXIgRXRoZXJzY2FuUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV0aGVyc2NhblByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV0aGVyc2NhblByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXR3b3JrKSB8fCB0aGlzO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJiYXNlVXJsXCIsIF90aGlzLmdldEJhc2VVcmwoKSk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImFwaUtleVwiLCBhcGlLZXkgfHwgbnVsbCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXRoZXJzY2FuUHJvdmlkZXIucHJvdG90eXBlLmdldEJhc2VVcmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5uZXR3b3JrID8gdGhpcy5uZXR3b3JrLm5hbWUgOiBcImludmFsaWRcIikge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGkuZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktcm9wc3Rlbi5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1yaW5rZWJ5LmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1rb3Zhbi5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWdvZXJsaS5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbS1rb3ZhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGkta292YW4tb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCB0aGlzLm5ldHdvcmsubmFtZSk7XG4gICAgfTtcbiAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0VXJsID0gZnVuY3Rpb24gKG1vZHVsZSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IE9iamVjdC5rZXlzKHBhcmFtcykucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWNjdW0gKz0gXCImXCIgKyBrZXkgKyBcIj1cIiArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgdmFyIGFwaUtleSA9ICgodGhpcy5hcGlLZXkpID8gXCImYXBpa2V5PVwiICsgdGhpcy5hcGlLZXkgOiBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVVybCArIFwiL2FwaT9tb2R1bGU9XCIgKyBtb2R1bGUgKyBxdWVyeSArIGFwaUtleTtcbiAgICB9O1xuICAgIEV0aGVyc2NhblByb3ZpZGVyLnByb3RvdHlwZS5nZXRQb3N0VXJsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlVXJsICsgXCIvYXBpXCI7XG4gICAgfTtcbiAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0UG9zdERhdGEgPSBmdW5jdGlvbiAobW9kdWxlLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgcGFyYW1zLmFwaWtleSA9IHRoaXMuYXBpS2V5O1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgRXRoZXJzY2FuUHJvdmlkZXIucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKG1vZHVsZSwgcGFyYW1zLCBwb3N0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1cmwsIHBheWxvYWQsIHByb2NGdW5jLCBjb25uZWN0aW9uLCBwYXlsb2FkU3RyLCByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKHBvc3QgPyB0aGlzLmdldFBvc3RVcmwoKSA6IHRoaXMuZ2V0VXJsKG1vZHVsZSwgcGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gKHBvc3QgPyB0aGlzLmdldFBvc3REYXRhKG1vZHVsZSwgcGFyYW1zKSA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY0Z1bmMgPSAobW9kdWxlID09PSBcInByb3h5XCIpID8gZ2V0SnNvblJlc3VsdCA6IGdldFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlU2xvdEludGVydmFsOiAxMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlQ2FsbGJhY2s6IGZ1bmN0aW9uIChhdHRlbXB0LCB1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzQ29tbXVuaXR5UmVzb3VyY2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGZvcm1hdHRlcl8xLnNob3dUaHJvdHRsZU1lc3NhZ2UpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFN0ciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uaGVhZGVycyA9IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRTdHIgPSBPYmplY3Qua2V5cyhwYXlsb2FkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5ICsgXCI9XCIgKyBwYXlsb2FkW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIiZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgd2ViXzEuZmV0Y2hKc29uKShjb25uZWN0aW9uLCBwYXlsb2FkU3RyLCBwcm9jRnVuYyB8fCBnZXRKc29uUmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6ICgwLCBwcm9wZXJ0aWVzXzEuZGVlcENvcHkpKHJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXRoZXJzY2FuUHJvdmlkZXIucHJvdG90eXBlLmRldGVjdE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5uZXR3b3JrXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV0aGVyc2NhblByb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgcG9zdERhdGEsIGVycm9yXzEsIHBvc3REYXRhLCBlcnJvcl8yLCBhcmdzLCB0b3BpYzAsIGxvZ3MsIGJsb2NrcywgaSwgbG9nLCBibG9jaywgX2I7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IG1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbmRUcmFuc2FjdGlvblwiOiByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAyNl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyOF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7IGFjdGlvbjogXCJldGhfYmxvY2tOdW1iZXJcIiB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7IGFjdGlvbjogXCJldGhfZ2FzUHJpY2VcIiB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybnMgYmFzZS0xMCByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJhY2NvdW50XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiYmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBwYXJhbXMuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHBhcmFtcy5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0U3RvcmFnZUF0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBhcmFtcy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHBhcmFtcy5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4OiBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwic2VuZFRyYW5zYWN0aW9uXCIsIGVycm9yLCBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldEJsb2NrIGJ5IGJsb2NrSGFzaCBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcGFyYW1zLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcGFyYW1zLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZyAhPT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0aGVyc2NhblByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgYmxvY2tUYWcgZm9yIGNhbGxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0RGF0YSA9IGdldFRyYW5zYWN0aW9uUG9zdERhdGEocGFyYW1zLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLm1vZHVsZSA9IFwicHJveHlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLmFjdGlvbiA9IFwiZXRoX2NhbGxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzEyLCAxNCwgLCAxNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mZXRjaChcInByb3h5XCIsIHBvc3REYXRhLCB0cnVlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjaGVja0Vycm9yKFwiY2FsbFwiLCBlcnJvcl8xLCBwYXJhbXMudHJhbnNhY3Rpb24pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3REYXRhID0gZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YShwYXJhbXMudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdERhdGEubW9kdWxlID0gXCJwcm94eVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdERhdGEuYWN0aW9uID0gXCJldGhfZXN0aW1hdGVHYXNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTY7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzE2LCAxOCwgLCAxOV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mZXRjaChcInByb3h5XCIsIHBvc3REYXRhLCB0cnVlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6IHJldHVybiBbMiAvKnJldHVybiovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjaGVja0Vycm9yKFwiZXN0aW1hdGVHYXNcIiwgZXJyb3JfMiwgcGFyYW1zLnRyYW5zYWN0aW9uKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0geyBhY3Rpb246IFwiZ2V0TG9nc1wiIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci5mcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmZyb21CbG9jayA9IGNoZWNrTG9nVGFnKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvQmxvY2sgPSBjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLnRvQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuYWRkcmVzcyA9IHBhcmFtcy5maWx0ZXIuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBXZSBjYW4gaGFuZGxlIHNsaWdodGx5IG1vcmUgY29tcGxpY2F0ZWQgbG9ncyB1c2luZyB0aGUgbG9ncyBBUElcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcyAmJiBwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCB0b3BpYyBjb3VudFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyB0b3BpY3M6IHBhcmFtcy5maWx0ZXIudG9waWNzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljMCA9IHBhcmFtcy5maWx0ZXIudG9waWNzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0b3BpYzApICE9PSBcInN0cmluZ1wiIHx8IHRvcGljMC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRvcGljIGZvcm1hdFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyB0b3BpYzA6IHRvcGljMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvcGljMCA9IHRvcGljMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKFwibG9nc1wiLCBhcmdzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgbG9ncy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAyNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cgPSBsb2dzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5ibG9ja0hhc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDI0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEJsb2NrKGxvZy5ibG9ja051bWJlcildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbbG9nLmJsb2NrTnVtYmVyXSA9IGJsb2NrLmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDIzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmJsb2NrSGFzaCA9IGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDIxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ3NdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmV0d29yay5uYW1lICE9PSBcImhvbWVzdGVhZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIDAuMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IHBhcnNlRmxvYXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKFwic3RhdHNcIiwgeyBhY3Rpb246IFwiZXRocHJpY2VcIiB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseSh2b2lkIDAsIFsoX2Muc2VudCgpKS5ldGh1c2RdKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDI5XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9zdXBlci5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsIG1ldGhvZCwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gTm90ZTogVGhlIGBwYWdlYCBwYWdlIHBhcmFtZXRlciBvbmx5IGFsbG93cyBwYWdpbmF0aW9uIHdpdGhpbiB0aGVcbiAgICAvLyAgICAgICAxMCwwMDAgd2luZG93IGF2YWlsYWJsZSB3aXRob3V0IGEgcGFnZSBhbmQgb2Zmc2V0IHBhcmFtZXRlclxuICAgIC8vICAgICAgIEVycm9yOiBSZXN1bHQgd2luZG93IGlzIHRvbyBsYXJnZSwgUGFnZU5vIHggT2Zmc2V0IHNpemUgbXVzdFxuICAgIC8vICAgICAgICAgICAgICBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMTAwMDBcbiAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0SGlzdG9yeSA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBzdGFydEJsb2NrLCBlbmRCbG9jaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zLCByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInR4bGlzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXNvbHZlTmFtZShhZGRyZXNzT3JOYW1lKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IChfYS5hZGRyZXNzID0gKF9iLnNlbnQoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc3RhcnRibG9jayA9ICgoc3RhcnRCbG9jayA9PSBudWxsKSA/IDAgOiBzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5lbmRibG9jayA9ICgoZW5kQmxvY2sgPT0gbnVsbCkgPyA5OTk5OTk5OSA6IGVuZEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zb3J0ID0gXCJhc2NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKFwiYWNjb3VudFwiLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5tYXAoZnVuY3Rpb24gKHR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImNvbnRyYWN0QWRkcmVzc1wiLCBcInRvXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmNyZWF0ZXMgPT0gbnVsbCAmJiB0eC5jb250cmFjdEFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY3JlYXRlcyA9IHR4LmNvbnRyYWN0QWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF90aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlc3BvbnNlKHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LnRpbWVTdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50aW1lc3RhbXAgPSBwYXJzZUludCh0eC50aW1lU3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PSBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBFdGhlcnNjYW5Qcm92aWRlcjtcbn0oYmFzZV9wcm92aWRlcl8xLkJhc2VQcm92aWRlcikpO1xuZXhwb3J0cy5FdGhlcnNjYW5Qcm92aWRlciA9IEV0aGVyc2NhblByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXRoZXJzY2FuLXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/etherscan-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/fallback-provider.js":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/fallback-provider.js ***!
  \***********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FallbackProvider = void 0;\nvar abstract_provider_1 = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+abstract-provider@5.7.0/node_modules/@ethersproject/abstract-provider/lib/index.js\");\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar random_1 = __webpack_require__(/*! @ethersproject/random */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+random@5.7.0/node_modules/@ethersproject/random/lib/index.js\");\nvar web_1 = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+web@5.7.0/node_modules/@ethersproject/web/lib/index.js\");\nvar base_provider_1 = __webpack_require__(/*! ./base-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/base-provider.js\");\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/formatter.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    var result = null;\n    for (var i = 0; i < networks.length; i++) {\n        var network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    var middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    var a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (bignumber_1.BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map(function (i) { return serialize(i); }));\n    }\n    else if (typeof (value) === \"object\") {\n        var keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map(function (key) {\n            var v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nvar nextRid = 1;\n;\nfunction stall(duration) {\n    var cancel = null;\n    var timer = null;\n    var promise = (new Promise(function (resolve) {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    var wait = function (func) {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel: cancel, getPromise: getPromise, wait: wait };\n}\nvar ForwardErrors = [\n    logger_1.Logger.errors.CALL_EXCEPTION,\n    logger_1.Logger.errors.INSUFFICIENT_FUNDS,\n    logger_1.Logger.errors.NONCE_EXPIRED,\n    logger_1.Logger.errors.REPLACEMENT_UNDERPRICED,\n    logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nvar ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    var result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: function () { return config.provider; } });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        var tally = {};\n        configs.forEach(function (c) {\n            var value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        var keys = Object.keys(tally);\n        for (var i = 0; i < keys.length; i++) {\n            var check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    var normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                var values = configs.map(function (c) { return c.result; });\n                // Get the median block number\n                var blockNumber = median(configs.map(function (c) { return c.result; }), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                var values = configs.map(function (c) { return c.result; });\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map(function (c) { return c.result; }));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = (0, properties_1.shallowCopy)(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = (0, properties_1.shallowCopy)(block);\n                    block.transactions = block.transactions.map(function (tx) {\n                        tx = (0, properties_1.shallowCopy)(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n        var provider;\n        return __generator(this, function (_a) {\n            provider = (config.provider);\n            if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n                return [2 /*return*/, provider];\n            }\n            return [2 /*return*/, (0, web_1.poll)(function () {\n                    return new Promise(function (resolve, reject) {\n                        setTimeout(function () {\n                            // We are synced\n                            if (provider.blockNumber >= blockNumber) {\n                                return resolve(provider);\n                            }\n                            // We're done; just quit\n                            if (config.cancelled) {\n                                return resolve(null);\n                            }\n                            // Try again, next block\n                            return resolve(undefined);\n                        }, 0);\n                    });\n                }, { oncePoll: provider })];\n        });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function () {\n        var provider, _a, filter;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    provider = config.provider;\n                    _a = method;\n                    switch (_a) {\n                        case \"getBlockNumber\": return [3 /*break*/, 1];\n                        case \"getGasPrice\": return [3 /*break*/, 1];\n                        case \"getEtherPrice\": return [3 /*break*/, 2];\n                        case \"getBalance\": return [3 /*break*/, 3];\n                        case \"getTransactionCount\": return [3 /*break*/, 3];\n                        case \"getCode\": return [3 /*break*/, 3];\n                        case \"getStorageAt\": return [3 /*break*/, 6];\n                        case \"getBlock\": return [3 /*break*/, 9];\n                        case \"call\": return [3 /*break*/, 12];\n                        case \"estimateGas\": return [3 /*break*/, 12];\n                        case \"getTransaction\": return [3 /*break*/, 15];\n                        case \"getTransactionReceipt\": return [3 /*break*/, 15];\n                        case \"getLogs\": return [3 /*break*/, 16];\n                    }\n                    return [3 /*break*/, 19];\n                case 1: return [2 /*return*/, provider[method]()];\n                case 2:\n                    if (provider.getEtherPrice) {\n                        return [2 /*return*/, provider.getEtherPrice()];\n                    }\n                    return [3 /*break*/, 19];\n                case 3:\n                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 5];\n                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n                case 4:\n                    provider = _b.sent();\n                    _b.label = 5;\n                case 5: return [2 /*return*/, provider[method](params.address, params.blockTag || \"latest\")];\n                case 6:\n                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 8];\n                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n                case 7:\n                    provider = _b.sent();\n                    _b.label = 8;\n                case 8: return [2 /*return*/, provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\")];\n                case 9:\n                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 11];\n                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n                case 10:\n                    provider = _b.sent();\n                    _b.label = 11;\n                case 11: return [2 /*return*/, provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash)];\n                case 12:\n                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 14];\n                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n                case 13:\n                    provider = _b.sent();\n                    _b.label = 14;\n                case 14:\n                    if (method === \"call\" && params.blockTag) {\n                        return [2 /*return*/, provider[method](params.transaction, params.blockTag)];\n                    }\n                    return [2 /*return*/, provider[method](params.transaction)];\n                case 15: return [2 /*return*/, provider[method](params.transactionHash)];\n                case 16:\n                    filter = params.filter;\n                    if (!((filter.fromBlock && (0, bytes_1.isHexString)(filter.fromBlock)) || (filter.toBlock && (0, bytes_1.isHexString)(filter.toBlock)))) return [3 /*break*/, 18];\n                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n                case 17:\n                    provider = _b.sent();\n                    _b.label = 18;\n                case 18: return [2 /*return*/, provider.getLogs(filter)];\n                case 19: return [2 /*return*/, logger.throwError(\"unknown method error\", logger_1.Logger.errors.UNKNOWN_ERROR, {\n                        method: method,\n                        params: params\n                    })];\n            }\n        });\n    });\n}\nvar FallbackProvider = /** @class */ (function (_super) {\n    __extends(FallbackProvider, _super);\n    function FallbackProvider(providers, quorum) {\n        var _this = this;\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        var providerConfigs = providers.map(function (configOrProvider, index) {\n            if (abstract_provider_1.Provider.isProvider(configOrProvider)) {\n                var stallTimeout = (0, formatter_1.isCommunityResource)(configOrProvider) ? 2000 : 750;\n                var priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout: stallTimeout, priority: priority });\n            }\n            var config = (0, properties_1.shallowCopy)(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = (0, formatter_1.isCommunityResource)(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            var weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", \"providers[\" + index + \"].weight\", weight);\n            }\n            return Object.freeze(config);\n        });\n        var total = providerConfigs.reduce(function (accum, c) { return (accum + c.weight); }, 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        var networkOrReady = checkNetworks(providerConfigs.map(function (c) { return (c.provider).network; }));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise(function (resolve, reject) {\n                setTimeout(function () {\n                    _this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        _this = _super.call(this, networkOrReady) || this;\n        // Preserve a copy, so we do not get mutated\n        (0, properties_1.defineReadOnly)(_this, \"providerConfigs\", Object.freeze(providerConfigs));\n        (0, properties_1.defineReadOnly)(_this, \"quorum\", quorum);\n        _this._highestBlockNumber = -1;\n        return _this;\n    }\n    FallbackProvider.prototype.detectNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var networks;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) { return c.provider.getNetwork(); }))];\n                    case 1:\n                        networks = _a.sent();\n                        return [2 /*return*/, checkNetworks(networks)];\n                }\n            });\n        });\n    };\n    FallbackProvider.prototype.perform = function (method, params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var results, i_1, result, processFunc, configs, currentBlockNumber, i, first, _loop_1, this_1, state_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(method === \"sendTransaction\")) return [3 /*break*/, 2];\n                        return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) {\n                                return c.provider.sendTransaction(params.signedTransaction).then(function (result) {\n                                    return result.hash;\n                                }, function (error) {\n                                    return error;\n                                });\n                            }))];\n                    case 1:\n                        results = _a.sent();\n                        // Any success is good enough (other errors are likely \"already seen\" errors\n                        for (i_1 = 0; i_1 < results.length; i_1++) {\n                            result = results[i_1];\n                            if (typeof (result) === \"string\") {\n                                return [2 /*return*/, result];\n                            }\n                        }\n                        // They were all an error; pick the first error\n                        throw results[0];\n                    case 2:\n                        if (!(this._highestBlockNumber === -1 && method !== \"getBlockNumber\")) return [3 /*break*/, 4];\n                        return [4 /*yield*/, this.getBlockNumber()];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        processFunc = getProcessFunc(this, method, params);\n                        configs = (0, random_1.shuffled)(this.providerConfigs.map(properties_1.shallowCopy));\n                        configs.sort(function (a, b) { return (a.priority - b.priority); });\n                        currentBlockNumber = this._highestBlockNumber;\n                        i = 0;\n                        first = true;\n                        _loop_1 = function () {\n                            var t0, inflightWeight, _loop_2, waiting, results, result, errors;\n                            return __generator(this, function (_b) {\n                                switch (_b.label) {\n                                    case 0:\n                                        t0 = now();\n                                        inflightWeight = configs.filter(function (c) { return (c.runner && ((t0 - c.start) < c.stallTimeout)); })\n                                            .reduce(function (accum, c) { return (accum + c.weight); }, 0);\n                                        _loop_2 = function () {\n                                            var config = configs[i++];\n                                            var rid = nextRid++;\n                                            config.start = now();\n                                            config.staller = stall(config.stallTimeout);\n                                            config.staller.wait(function () { config.staller = null; });\n                                            config.runner = getRunner(config, currentBlockNumber, method, params).then(function (result) {\n                                                config.done = true;\n                                                config.result = result;\n                                                if (_this.listenerCount(\"debug\")) {\n                                                    _this.emit(\"debug\", {\n                                                        action: \"request\",\n                                                        rid: rid,\n                                                        backend: exposeDebugConfig(config, now()),\n                                                        request: { method: method, params: (0, properties_1.deepCopy)(params) },\n                                                        provider: _this\n                                                    });\n                                                }\n                                            }, function (error) {\n                                                config.done = true;\n                                                config.error = error;\n                                                if (_this.listenerCount(\"debug\")) {\n                                                    _this.emit(\"debug\", {\n                                                        action: \"request\",\n                                                        rid: rid,\n                                                        backend: exposeDebugConfig(config, now()),\n                                                        request: { method: method, params: (0, properties_1.deepCopy)(params) },\n                                                        provider: _this\n                                                    });\n                                                }\n                                            });\n                                            if (this_1.listenerCount(\"debug\")) {\n                                                this_1.emit(\"debug\", {\n                                                    action: \"request\",\n                                                    rid: rid,\n                                                    backend: exposeDebugConfig(config, null),\n                                                    request: { method: method, params: (0, properties_1.deepCopy)(params) },\n                                                    provider: this_1\n                                                });\n                                            }\n                                            inflightWeight += config.weight;\n                                        };\n                                        // Start running enough to meet quorum\n                                        while (inflightWeight < this_1.quorum && i < configs.length) {\n                                            _loop_2();\n                                        }\n                                        waiting = [];\n                                        configs.forEach(function (c) {\n                                            if (c.done || !c.runner) {\n                                                return;\n                                            }\n                                            waiting.push(c.runner);\n                                            if (c.staller) {\n                                                waiting.push(c.staller.getPromise());\n                                            }\n                                        });\n                                        if (!waiting.length) return [3 /*break*/, 2];\n                                        return [4 /*yield*/, Promise.race(waiting)];\n                                    case 1:\n                                        _b.sent();\n                                        _b.label = 2;\n                                    case 2:\n                                        results = configs.filter(function (c) { return (c.done && c.error == null); });\n                                        if (!(results.length >= this_1.quorum)) return [3 /*break*/, 5];\n                                        result = processFunc(results);\n                                        if (result !== undefined) {\n                                            // Shut down any stallers\n                                            configs.forEach(function (c) {\n                                                if (c.staller) {\n                                                    c.staller.cancel();\n                                                }\n                                                c.cancelled = true;\n                                            });\n                                            return [2 /*return*/, { value: result }];\n                                        }\n                                        if (!!first) return [3 /*break*/, 4];\n                                        return [4 /*yield*/, stall(100).getPromise()];\n                                    case 3:\n                                        _b.sent();\n                                        _b.label = 4;\n                                    case 4:\n                                        first = false;\n                                        _b.label = 5;\n                                    case 5:\n                                        errors = configs.reduce(function (accum, c) {\n                                            if (!c.done || c.error == null) {\n                                                return accum;\n                                            }\n                                            var code = (c.error).code;\n                                            if (ForwardErrors.indexOf(code) >= 0) {\n                                                if (!accum[code]) {\n                                                    accum[code] = { error: c.error, weight: 0 };\n                                                }\n                                                accum[code].weight += c.weight;\n                                            }\n                                            return accum;\n                                        }, ({}));\n                                        Object.keys(errors).forEach(function (errorCode) {\n                                            var tally = errors[errorCode];\n                                            if (tally.weight < _this.quorum) {\n                                                return;\n                                            }\n                                            // Shut down any stallers\n                                            configs.forEach(function (c) {\n                                                if (c.staller) {\n                                                    c.staller.cancel();\n                                                }\n                                                c.cancelled = true;\n                                            });\n                                            var e = (tally.error);\n                                            var props = {};\n                                            ForwardProperties.forEach(function (name) {\n                                                if (e[name] == null) {\n                                                    return;\n                                                }\n                                                props[name] = e[name];\n                                            });\n                                            logger.throwError(e.reason || e.message, errorCode, props);\n                                        });\n                                        // All configs have run to completion; we will never get more data\n                                        if (configs.filter(function (c) { return !c.done; }).length === 0) {\n                                            return [2 /*return*/, \"break\"];\n                                        }\n                                        return [2 /*return*/];\n                                }\n                            });\n                        };\n                        this_1 = this;\n                        _a.label = 5;\n                    case 5:\n                        if (false) {}\n                        return [5 /*yield**/, _loop_1()];\n                    case 6:\n                        state_1 = _a.sent();\n                        if (typeof state_1 === \"object\")\n                            return [2 /*return*/, state_1.value];\n                        if (state_1 === \"break\")\n                            return [3 /*break*/, 7];\n                        return [3 /*break*/, 5];\n                    case 7:\n                        // Shut down any stallers; shouldn't be any\n                        configs.forEach(function (c) {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return [2 /*return*/, logger.throwError(\"failed to meet quorum\", logger_1.Logger.errors.SERVER_ERROR, {\n                                method: method,\n                                params: params,\n                                //results: configs.map((c) => c.result),\n                                //errors: configs.map((c) => c.error),\n                                results: configs.map(function (c) { return exposeDebugConfig(c); }),\n                                provider: this\n                            })];\n                }\n            });\n        });\n    };\n    return FallbackProvider;\n}(base_provider_1.BaseProvider));\nexports.FallbackProvider = FallbackProvider;\n//# sourceMappingURL=fallback-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2ZhbGxiYWNrLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsMEJBQTBCLG1CQUFPLENBQUMsMEtBQWtDO0FBQ3BFLGtCQUFrQixtQkFB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NkM7QUFDN0Msb0VBQW9FLGVBQWU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSx5Q0FBeUM7QUFDekMsK0VBQStFO0FBQy9FLDBFQUEwRSxpQkFBaUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSyxFQUFFLEVBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsOEJBQThCO0FBQ2xHO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2ZhbGxiYWNrLXByb3ZpZGVyLmpzP2NjM2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IHZvaWQgMDtcbnZhciBhYnN0cmFjdF9wcm92aWRlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCIpO1xudmFyIGJpZ251bWJlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCIpO1xudmFyIHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCIpO1xudmFyIHJhbmRvbV8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3JhbmRvbVwiKTtcbnZhciB3ZWJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC93ZWJcIik7XG52YXIgYmFzZV9wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vYmFzZS1wcm92aWRlclwiKTtcbnZhciBmb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdHRlclwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbi8vIFJldHVybnMgdG8gbmV0d29yayBhcyBsb25nIGFzIGFsbCBhZ3JlZSwgb3IgbnVsbCBpZiBhbnkgaXMgbnVsbC5cbi8vIFRocm93cyBhbiBlcnJvciBpZiBhbnkgdHdvIG5ldHdvcmtzIGRvIG5vdCBtYXRjaC5cbmZ1bmN0aW9uIGNoZWNrTmV0d29ya3MobmV0d29ya3MpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ldHdvcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXR3b3JrID0gbmV0d29ya3NbaV07XG4gICAgICAgIC8vIE51bGwhIFdlIGRvIG5vdCBrbm93IG91ciBuZXR3b3JrOyBiYWlsLlxuICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG5ldHdvcmsgbWF0Y2hlcyB0aGUgcHJldmlvdXMgbmV0d29ya3NcbiAgICAgICAgICAgIGlmICghKHJlc3VsdC5uYW1lID09PSBuZXR3b3JrLm5hbWUgJiYgcmVzdWx0LmNoYWluSWQgPT09IG5ldHdvcmsuY2hhaW5JZCAmJlxuICAgICAgICAgICAgICAgICgocmVzdWx0LmVuc0FkZHJlc3MgPT09IG5ldHdvcmsuZW5zQWRkcmVzcykgfHwgKHJlc3VsdC5lbnNBZGRyZXNzID09IG51bGwgJiYgbmV0d29yay5lbnNBZGRyZXNzID09IG51bGwpKSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJvdmlkZXIgbWlzbWF0Y2hcIiwgXCJuZXR3b3Jrc1wiLCBuZXR3b3Jrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXR3b3JrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtZWRpYW4odmFsdWVzLCBtYXhEZWx0YSkge1xuICAgIHZhbHVlcyA9IHZhbHVlcy5zbGljZSgpLnNvcnQoKTtcbiAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XG4gICAgLy8gT2RkIGxlbmd0aDsgdGFrZSB0aGUgbWlkZGxlXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggJSAyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbbWlkZGxlXTtcbiAgICB9XG4gICAgLy8gRXZlbiBsZW5ndGg7IHRha2UgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBtaWRkbGVcbiAgICB2YXIgYSA9IHZhbHVlc1ttaWRkbGUgLSAxXSwgYiA9IHZhbHVlc1ttaWRkbGVdO1xuICAgIGlmIChtYXhEZWx0YSAhPSBudWxsICYmIE1hdGguYWJzKGEgLSBiKSA+IG1heERlbHRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGEgKyBiKSAvIDI7XG59XG5mdW5jdGlvbiBzZXJpYWxpemUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChiaWdudW1iZXJfMS5CaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBzZXJpYWxpemUoaSk7IH0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdiA9IFwiW2Z1bmN0aW9uXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdiA9IHNlcmlhbGl6ZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXkpICsgXCI6XCIgKyB2O1xuICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwifVwiO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHZhbHVlIHR5cGU6IFwiICsgdHlwZW9mICh2YWx1ZSkpO1xufVxuLy8gTmV4dCByZXF1ZXN0IElEIHRvIHVzZSBmb3IgZW1pdHRpbmcgZGVidWcgaW5mb1xudmFyIG5leHRSaWQgPSAxO1xuO1xuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICB2YXIgY2FuY2VsID0gbnVsbDtcbiAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgIHZhciBwcm9taXNlID0gKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FuY2VsLCBkdXJhdGlvbik7XG4gICAgfSkpO1xuICAgIHZhciB3YWl0ID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBnZXRQcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2FuY2VsOiBjYW5jZWwsIGdldFByb21pc2U6IGdldFByb21pc2UsIHdhaXQ6IHdhaXQgfTtcbn1cbnZhciBGb3J3YXJkRXJyb3JzID0gW1xuICAgIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sXG4gICAgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsXG4gICAgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELFxuICAgIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsXG4gICAgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVFxuXTtcbnZhciBGb3J3YXJkUHJvcGVydGllcyA9IFtcbiAgICBcImFkZHJlc3NcIixcbiAgICBcImFyZ3NcIixcbiAgICBcImVycm9yQXJnc1wiLFxuICAgIFwiZXJyb3JTaWduYXR1cmVcIixcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwidHJhbnNhY3Rpb25cIixcbl07XG47XG5mdW5jdGlvbiBleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsIG5vdykge1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHdlaWdodDogY29uZmlnLndlaWdodFxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgXCJwcm92aWRlclwiLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnLnByb3ZpZGVyOyB9IH0pO1xuICAgIGlmIChjb25maWcuc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0LnN0YXJ0ID0gY29uZmlnLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAobm93KSB7XG4gICAgICAgIHJlc3VsdC5kdXJhdGlvbiA9IChub3cgLSBjb25maWcuc3RhcnQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmRvbmUpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5lcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gY29uZmlnLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnJlc3VsdCA9IGNvbmZpZy5yZXN1bHQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplZFRhbGx5KG5vcm1hbGl6ZSwgcXVvcnVtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG4gICAgICAgIC8vIENvdW50IHRoZSB2b3RlcyBmb3IgZWFjaCByZXN1bHRcbiAgICAgICAgdmFyIHRhbGx5ID0ge307XG4gICAgICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplKGMucmVzdWx0KTtcbiAgICAgICAgICAgIGlmICghdGFsbHlbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgdGFsbHlbdmFsdWVdID0geyBjb3VudDogMCwgcmVzdWx0OiBjLnJlc3VsdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFsbHlbdmFsdWVdLmNvdW50Kys7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDaGVjayBmb3IgYSBxdW9ydW0gb24gYW55IGdpdmVuIHJlc3VsdFxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRhbGx5KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2sgPSB0YWxseVtrZXlzW2ldXTtcbiAgICAgICAgICAgIGlmIChjaGVjay5jb3VudCA+PSBxdW9ydW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2sucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHF1cm91bVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQcm9jZXNzRnVuYyhwcm92aWRlciwgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICB2YXIgbm9ybWFsaXplID0gc2VyaWFsaXplO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBtZWRpYW4gdmFsdWUsIHVubGVzcyB0aGVyZSBpcyAobWVkaWFuICsgMSkgaXMgYWxzb1xuICAgICAgICAgICAgLy8gcHJlc2VudCwgaW4gd2hpY2ggY2FzZSB0aGF0IGlzIHByb2JhYmx5IHRydWUgYW5kIHRoZSBtZWRpYW5cbiAgICAgICAgICAgIC8vIGlzIGdvaW5nIHRvIGJlIHN0YWxlIHNvb24uIEluIHRoZSBldmVudCBvZiBhIG1hbGljaW91cyBub2RlLFxuICAgICAgICAgICAgLy8gdGhlIGxpZSB3aWxsIGJlIHRydWUgc29vbiBlbm91Z2guXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gY29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucmVzdWx0OyB9KTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIG1lZGlhbiBibG9jayBudW1iZXJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tOdW1iZXIgPSBtZWRpYW4oY29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucmVzdWx0OyB9KSwgMik7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBNYXRoLmNlaWwoYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IGJsb2NrIGhlaWdodCBpcyBwcmVzZW50LCBpdHMgcHJvbGx5IHNhZmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5pbmRleE9mKGJsb2NrTnVtYmVyICsgMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEb24ndCBldmVyIHJvbGwgYmFjayB0aGUgYmxvY2tOdW1iZXJcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPj0gcHJvdmlkZXIuX2hpZ2hlc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG1pZGRsZSAocm91bmQgaW5kZXggdXApIHZhbHVlLCBzaW1pbGFyIHRvIG1lZGlhblxuICAgICAgICAgICAgLy8gYnV0IGRvIG5vdCBhdmVyYWdlIGV2ZW4gZW50cmllcyBhbmQgY2hvb3NlIHRoZSBoaWdoZXIuXG4gICAgICAgICAgICAvLyBNYWxpY2lvdXMgYWN0b3JzIG11c3QgY29tcHJvbWlzZSA1MCUgb2YgdGhlIG5vZGVzIHRvIGxpZS5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBjb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5yZXN1bHQ7IH0pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5zb3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKV07XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOlxuICAgICAgICAgICAgLy8gUmV0dXJucyB0aGUgbWVkaWFuIHByaWNlLiBNYWxpY2lvdXMgYWN0b3JzIG11c3QgY29tcHJvbWlzZSBhdFxuICAgICAgICAgICAgLy8gbGVhc3QgNTAlIG9mIHRoZSBub2RlcyB0byBsaWUgKGluIGEgbWVhbmluZ2Z1bCB3YXkpLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhbihjb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5yZXN1bHQ7IH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8vIE5vIGFkZGl0aW9uYWwgbm9ybWFsaXppbmcgcmVxdWlyZWQ7IHNlcmlhbGl6ZSBpcyBlbm91Z2hcbiAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOlxuICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjpcbiAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBXZSBkcm9wIHRoZSBjb25maXJtYXRpb25zIGZyb20gdHJhbnNhY3Rpb25zIGFzIGl0IGlzIGFwcHJveGltYXRlXG4gICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICBub3JtYWxpemUgPSBmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHggPSAoMCwgcHJvcGVydGllc18xLnNoYWxsb3dDb3B5KSh0eCk7XG4gICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IC0xO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUodHgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBXZSBkcm9wIHRoZSBjb25maXJtYXRpb25zIGZyb20gdHJhbnNhY3Rpb25zIGFzIGl0IGlzIGFwcHJveGltYXRlXG4gICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgLy8gV2UgZHJvcCB0aGUgY29uZmlybWF0aW9ucyBmcm9tIHRyYW5zYWN0aW9ucyBhcyBpdCBpcyBhcHByb3hpbWF0ZVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBibG9jayA9ICgwLCBwcm9wZXJ0aWVzXzEuc2hhbGxvd0NvcHkpKGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sudHJhbnNhY3Rpb25zID0gYmxvY2sudHJhbnNhY3Rpb25zLm1hcChmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkodHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShibG9jayk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShibG9jayk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBtZXRob2Q6IFwiICsgbWV0aG9kKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgaWYgYW5kIG9ubHkgaWYgdGhlIGV4cGVjdGVkIHF1b3J1bSBpc1xuICAgIC8vIHNhdGlzZmllZCBhbmQgYWdyZWVkIHVwb24gZm9yIHRoZSBmaW5hbCByZXN1bHQuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRUYWxseShub3JtYWxpemUsIHByb3ZpZGVyLnF1b3J1bSk7XG59XG4vLyBJZiB3ZSBhcmUgZG9pbmcgYSBibG9ja1RhZyBxdWVyeSwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXNcbi8vIGNhdWdodCB1cCB0byB0aGUgRmFsbGJhY2tQcm92aWRlciwgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0IHRvIGl0LlxuZnVuY3Rpb24gd2FpdEZvclN5bmMoY29uZmlnLCBibG9ja051bWJlcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3ZpZGVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBwcm92aWRlciA9IChjb25maWcucHJvdmlkZXIpO1xuICAgICAgICAgICAgaWYgKChwcm92aWRlci5ibG9ja051bWJlciAhPSBudWxsICYmIHByb3ZpZGVyLmJsb2NrTnVtYmVyID49IGJsb2NrTnVtYmVyKSB8fCBibG9ja051bWJlciA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCB3ZWJfMS5wb2xsKShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc3luY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLmJsb2NrTnVtYmVyID49IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgZG9uZTsganVzdCBxdWl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSBhZ2FpbiwgbmV4dCBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgeyBvbmNlUG9sbDogcHJvdmlkZXIgfSldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJ1bm5lcihjb25maWcsIGN1cnJlbnRCbG9ja051bWJlciwgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm92aWRlciwgX2EsIGZpbHRlcjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBjb25maWcucHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgICAgIF9hID0gbWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2FsbFwiOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclttZXRob2RdKCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLmdldEV0aGVyUHJpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlci5nZXRFdGhlclByaWNlKCldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtcy5ibG9ja1RhZyAmJiAoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykocGFyYW1zLmJsb2NrVGFnKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcildO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclttZXRob2RdKHBhcmFtcy5hZGRyZXNzLCBwYXJhbXMuYmxvY2tUYWcgfHwgXCJsYXRlc3RcIildO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW1zLmJsb2NrVGFnICYmICgwLCBieXRlc18xLmlzSGV4U3RyaW5nKShwYXJhbXMuYmxvY2tUYWcpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyLmdldFN0b3JhZ2VBdChwYXJhbXMuYWRkcmVzcywgcGFyYW1zLnBvc2l0aW9uLCBwYXJhbXMuYmxvY2tUYWcgfHwgXCJsYXRlc3RcIildO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW1zLmJsb2NrVGFnICYmICgwLCBieXRlc18xLmlzSGV4U3RyaW5nKShwYXJhbXMuYmxvY2tUYWcpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcildO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDExO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclsocGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnMgPyBcImdldEJsb2NrV2l0aFRyYW5zYWN0aW9uc1wiIDogXCJnZXRCbG9ja1wiKV0ocGFyYW1zLmJsb2NrVGFnIHx8IHBhcmFtcy5ibG9ja0hhc2gpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbXMuYmxvY2tUYWcgJiYgKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKHBhcmFtcy5ibG9ja1RhZykpKSByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIgJiYgcGFyYW1zLmJsb2NrVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMudHJhbnNhY3Rpb24sIHBhcmFtcy5ibG9ja1RhZyldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclttZXRob2RdKHBhcmFtcy50cmFuc2FjdGlvbildO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclttZXRob2RdKHBhcmFtcy50cmFuc2FjdGlvbkhhc2gpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBwYXJhbXMuZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgoZmlsdGVyLmZyb21CbG9jayAmJiAoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykoZmlsdGVyLmZyb21CbG9jaykpIHx8IChmaWx0ZXIudG9CbG9jayAmJiAoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykoZmlsdGVyLnRvQmxvY2spKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE4XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxODtcbiAgICAgICAgICAgICAgICBjYXNlIDE4OiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE5OiByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bmtub3duIG1ldGhvZCBlcnJvclwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbnZhciBGYWxsYmFja1Byb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGYWxsYmFja1Byb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZhbGxiYWNrUHJvdmlkZXIocHJvdmlkZXJzLCBxdW9ydW0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHByb3ZpZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyc1wiLCBcInByb3ZpZGVyc1wiLCBwcm92aWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm92aWRlckNvbmZpZ3MgPSBwcm92aWRlcnMubWFwKGZ1bmN0aW9uIChjb25maWdPclByb3ZpZGVyLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGFic3RyYWN0X3Byb3ZpZGVyXzEuUHJvdmlkZXIuaXNQcm92aWRlcihjb25maWdPclByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFsbFRpbWVvdXQgPSAoMCwgZm9ybWF0dGVyXzEuaXNDb21tdW5pdHlSZXNvdXJjZSkoY29uZmlnT3JQcm92aWRlcikgPyAyMDAwIDogNzUwO1xuICAgICAgICAgICAgICAgIHZhciBwcmlvcml0eSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBwcm92aWRlcjogY29uZmlnT3JQcm92aWRlciwgd2VpZ2h0OiAxLCBzdGFsbFRpbWVvdXQ6IHN0YWxsVGltZW91dCwgcHJpb3JpdHk6IHByaW9yaXR5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9ICgwLCBwcm9wZXJ0aWVzXzEuc2hhbGxvd0NvcHkpKGNvbmZpZ09yUHJvdmlkZXIpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5wcmlvcml0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnByaW9yaXR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcuc3RhbGxUaW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc3RhbGxUaW1lb3V0ID0gKDAsIGZvcm1hdHRlcl8xLmlzQ29tbXVuaXR5UmVzb3VyY2UpKGNvbmZpZ09yUHJvdmlkZXIpID8gMjAwMCA6IDc1MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcud2VpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcud2VpZ2h0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBjb25maWcud2VpZ2h0O1xuICAgICAgICAgICAgaWYgKHdlaWdodCAlIDEgfHwgd2VpZ2h0ID4gNTEyIHx8IHdlaWdodCA8IDEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB3ZWlnaHQ7IG11c3QgYmUgaW50ZWdlciBpbiBbMSwgNTEyXVwiLCBcInByb3ZpZGVyc1tcIiArIGluZGV4ICsgXCJdLndlaWdodFwiLCB3ZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoY29uZmlnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0b3RhbCA9IHByb3ZpZGVyQ29uZmlncy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBjKSB7IHJldHVybiAoYWNjdW0gKyBjLndlaWdodCk7IH0sIDApO1xuICAgICAgICBpZiAocXVvcnVtID09IG51bGwpIHtcbiAgICAgICAgICAgIHF1b3J1bSA9IHRvdGFsIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxdW9ydW0gPiB0b3RhbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInF1b3J1bSB3aWxsIGFsd2F5cyBmYWlsOyBsYXJnZXIgdGhhbiB0b3RhbCB3ZWlnaHRcIiwgXCJxdW9ydW1cIiwgcXVvcnVtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcmUgYWxsIHByb3ZpZGVycycgbmV0d29ya3MgYXJlIGtub3duXG4gICAgICAgIHZhciBuZXR3b3JrT3JSZWFkeSA9IGNoZWNrTmV0d29ya3MocHJvdmlkZXJDb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMucHJvdmlkZXIpLm5ldHdvcms7IH0pKTtcbiAgICAgICAgLy8gTm90IGFsbCBuZXR3b3JrcyBhcmUga25vd247IHdlIG11c3Qgc3RhbGxcbiAgICAgICAgaWYgKG5ldHdvcmtPclJlYWR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIG5ldHdvcmtPclJlYWR5ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXR3b3JrT3JSZWFkeSkgfHwgdGhpcztcbiAgICAgICAgLy8gUHJlc2VydmUgYSBjb3B5LCBzbyB3ZSBkbyBub3QgZ2V0IG11dGF0ZWRcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicHJvdmlkZXJDb25maWdzXCIsIE9iamVjdC5mcmVlemUocHJvdmlkZXJDb25maWdzKSk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcInF1b3J1bVwiLCBxdW9ydW0pO1xuICAgICAgICBfdGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyID0gLTE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmFsbGJhY2tQcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ldHdvcmtzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucHJvdmlkZXIuZ2V0TmV0d29yaygpOyB9KSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjaGVja05ldHdvcmtzKG5ldHdvcmtzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRmFsbGJhY2tQcm92aWRlci5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cywgaV8xLCByZXN1bHQsIHByb2Nlc3NGdW5jLCBjb25maWdzLCBjdXJyZW50QmxvY2tOdW1iZXIsIGksIGZpcnN0LCBfbG9vcF8xLCB0aGlzXzEsIHN0YXRlXzE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWV0aG9kID09PSBcInNlbmRUcmFuc2FjdGlvblwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW55IHN1Y2Nlc3MgaXMgZ29vZCBlbm91Z2ggKG90aGVyIGVycm9ycyBhcmUgbGlrZWx5IFwiYWxyZWFkeSBzZWVuXCIgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGlfMSA9IDA7IGlfMSA8IHJlc3VsdHMubGVuZ3RoOyBpXzErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHNbaV8xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZXN1bHQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgd2VyZSBhbGwgYW4gZXJyb3I7IHBpY2sgdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXIgPT09IC0xICYmIG1ldGhvZCAhPT0gXCJnZXRCbG9ja051bWJlclwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEJsb2NrTnVtYmVyKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NGdW5jID0gZ2V0UHJvY2Vzc0Z1bmModGhpcywgbWV0aG9kLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncyA9ICgwLCByYW5kb21fMS5zaHVmZmxlZCkodGhpcy5wcm92aWRlckNvbmZpZ3MubWFwKHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9ja051bWJlciA9IHRoaXMuX2hpZ2hlc3RCbG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdDAsIGluZmxpZ2h0V2VpZ2h0LCBfbG9vcF8yLCB3YWl0aW5nLCByZXN1bHRzLCByZXN1bHQsIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MCA9IG5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0V2VpZ2h0ID0gY29uZmlncy5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIChjLnJ1bm5lciAmJiAoKHQwIC0gYy5zdGFydCkgPCBjLnN0YWxsVGltZW91dCkpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgYykgeyByZXR1cm4gKGFjY3VtICsgYy53ZWlnaHQpOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gY29uZmlnc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmlkID0gbmV4dFJpZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhcnQgPSBub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0YWxsZXIgPSBzdGFsbChjb25maWcuc3RhbGxUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0YWxsZXIud2FpdChmdW5jdGlvbiAoKSB7IGNvbmZpZy5zdGFsbGVyID0gbnVsbDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5ydW5uZXIgPSBnZXRSdW5uZXIoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIsIG1ldGhvZCwgcGFyYW1zKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlkOiByaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbm93KCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbXM6ICgwLCBwcm9wZXJ0aWVzXzEuZGVlcENvcHkpKHBhcmFtcykgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlkOiByaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbm93KCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbXM6ICgwLCBwcm9wZXJ0aWVzXzEuZGVlcENvcHkpKHBhcmFtcykgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc18xLmxpc3RlbmVyQ291bnQoXCJkZWJ1Z1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWQ6IHJpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kOiBleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsIG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogKDAsIHByb3BlcnRpZXNfMS5kZWVwQ29weSkocGFyYW1zKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0V2VpZ2h0ICs9IGNvbmZpZy53ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBydW5uaW5nIGVub3VnaCB0byBtZWV0IHF1b3J1bVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmZsaWdodFdlaWdodCA8IHRoaXNfMS5xdW9ydW0gJiYgaSA8IGNvbmZpZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5kb25lIHx8ICFjLnJ1bm5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmcucHVzaChjLnJ1bm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YWxsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmcucHVzaChjLnN0YWxsZXIuZ2V0UHJvbWlzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2FpdGluZy5sZW5ndGgpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmFjZSh3YWl0aW5nKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gY29uZmlncy5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIChjLmRvbmUgJiYgYy5lcnJvciA9PSBudWxsKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzdWx0cy5sZW5ndGggPj0gdGhpc18xLnF1b3J1bSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb2Nlc3NGdW5jKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaHV0IGRvd24gYW55IHN0YWxsZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3RhbGxlci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IHZhbHVlOiByZXN1bHQgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIWZpcnN0KSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdGFsbCgxMDApLmdldFByb21pc2UoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBjb25maWdzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjLmRvbmUgfHwgYy5lcnJvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSAoYy5lcnJvcikuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEZvcndhcmRFcnJvcnMuaW5kZXhPZihjb2RlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFjY3VtW2NvZGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW1bY29kZV0gPSB7IGVycm9yOiBjLmVycm9yLCB3ZWlnaHQ6IDAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtW2NvZGVdLndlaWdodCArPSBjLndlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgKHt9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZXJyb3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhbGx5ID0gZXJyb3JzW2Vycm9yQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWxseS53ZWlnaHQgPCBfdGhpcy5xdW9ydW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaHV0IGRvd24gYW55IHN0YWxsZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3RhbGxlci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gKHRhbGx5LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvcndhcmRQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1tuYW1lXSA9IGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihlLnJlYXNvbiB8fCBlLm1lc3NhZ2UsIGVycm9yQ29kZSwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBjb25maWdzIGhhdmUgcnVuIHRvIGNvbXBsZXRpb247IHdlIHdpbGwgbmV2ZXIgZ2V0IG1vcmUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIWMuZG9uZTsgfSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBcImJyZWFrXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRydWUpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs1IC8qeWllbGQqKi8sIF9sb29wXzEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlXzEgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHN0YXRlXzEudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaHV0IGRvd24gYW55IHN0YWxsZXJzOyBzaG91bGRuJ3QgYmUgYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5zdGFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3RhbGxlci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgdG8gbWVldCBxdW9ydW1cIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc3VsdHM6IGNvbmZpZ3MubWFwKChjKSA9PiBjLnJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXJyb3JzOiBjb25maWdzLm1hcCgoYykgPT4gYy5lcnJvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IGNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBleHBvc2VEZWJ1Z0NvbmZpZyhjKTsgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBGYWxsYmFja1Byb3ZpZGVyO1xufShiYXNlX3Byb3ZpZGVyXzEuQmFzZVByb3ZpZGVyKSk7XG5leHBvcnRzLkZhbGxiYWNrUHJvdmlkZXIgPSBGYWxsYmFja1Byb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFsbGJhY2stcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/fallback-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/formatter.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/formatter.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.showThrottleMessage = exports.isCommunityResource = exports.isCommunityResourcable = exports.Formatter = void 0;\nvar address_1 = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib/index.js\");\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib/index.js\");\nvar constants_1 = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar transactions_1 = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar Formatter = /** @class */ (function () {\n    function Formatter() {\n        this.formats = this.getDefaultFormats();\n    }\n    Formatter.prototype.getDefaultFormats = function () {\n        var _this = this;\n        var formats = ({});\n        var address = this.address.bind(this);\n        var bigNumber = this.bigNumber.bind(this);\n        var blockTag = this.blockTag.bind(this);\n        var data = this.data.bind(this);\n        var hash = this.hash.bind(this);\n        var hex = this.hex.bind(this);\n        var number = this.number.bind(this);\n        var type = this.type.bind(this);\n        var strictData = function (v) { return _this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = (0, properties_1.shallowCopy)(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    };\n    Formatter.prototype.accessList = function (accessList) {\n        return (0, transactions_1.accessListify)(accessList || []);\n    };\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    Formatter.prototype.number = function (number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return bignumber_1.BigNumber.from(number).toNumber();\n    };\n    Formatter.prototype.type = function (number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return bignumber_1.BigNumber.from(number).toNumber();\n    };\n    // Strict! Used on input.\n    Formatter.prototype.bigNumber = function (value) {\n        return bignumber_1.BigNumber.from(value);\n    };\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    Formatter.prototype.boolean = function (value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    };\n    Formatter.prototype.hex = function (value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if ((0, bytes_1.isHexString)(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    };\n    Formatter.prototype.data = function (value, strict) {\n        var result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    };\n    // Requires an address\n    // Strict! Used on input.\n    Formatter.prototype.address = function (value) {\n        return (0, address_1.getAddress)(value);\n    };\n    Formatter.prototype.callAddress = function (value) {\n        if (!(0, bytes_1.isHexString)(value, 32)) {\n            return null;\n        }\n        var address = (0, address_1.getAddress)((0, bytes_1.hexDataSlice)(value, 12));\n        return (address === constants_1.AddressZero) ? null : address;\n    };\n    Formatter.prototype.contractAddress = function (value) {\n        return (0, address_1.getContractAddress)(value);\n    };\n    // Strict! Used on input.\n    Formatter.prototype.blockTag = function (blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        switch (blockTag) {\n            case \"earliest\": return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || (0, bytes_1.isHexString)(blockTag)) {\n            return (0, bytes_1.hexValue)(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    };\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    Formatter.prototype.hash = function (value, strict) {\n        var result = this.hex(value, strict);\n        if ((0, bytes_1.hexDataLength)(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    };\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    Formatter.prototype.difficulty = function (value) {\n        if (value == null) {\n            return null;\n        }\n        var v = bignumber_1.BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    };\n    Formatter.prototype.uint256 = function (value) {\n        if (!(0, bytes_1.isHexString)(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return (0, bytes_1.hexZeroPad)(value, 32);\n    };\n    Formatter.prototype._block = function (value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        var difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        var result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : bignumber_1.BigNumber.from(difficulty));\n        return result;\n    };\n    Formatter.prototype.block = function (value) {\n        return this._block(value, this.formats.block);\n    };\n    Formatter.prototype.blockWithTransactions = function (value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    };\n    // Strict! Used on input.\n    Formatter.prototype.transactionRequest = function (value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    };\n    Formatter.prototype.transactionResponse = function (transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && bignumber_1.BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        var result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            var chainId = transaction.chainId;\n            if ((0, bytes_1.isHexString)(chainId)) {\n                chainId = bignumber_1.BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            var chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if ((0, bytes_1.isHexString)(chainId)) {\n                chainId = bignumber_1.BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    };\n    Formatter.prototype.transaction = function (value) {\n        return (0, transactions_1.parse)(value);\n    };\n    Formatter.prototype.receiptLog = function (value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    };\n    Formatter.prototype.receipt = function (value) {\n        var result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                var value_1 = bignumber_1.BigNumber.from(result.root).toNumber();\n                if (value_1 === 0 || value_1 === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value_1)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value_1;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    };\n    Formatter.prototype.topics = function (value) {\n        var _this = this;\n        if (Array.isArray(value)) {\n            return value.map(function (v) { return _this.topics(v); });\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    };\n    Formatter.prototype.filter = function (value) {\n        return Formatter.check(this.formats.filter, value);\n    };\n    Formatter.prototype.filterLog = function (value) {\n        return Formatter.check(this.formats.filterLog, value);\n    };\n    Formatter.check = function (format, object) {\n        var result = {};\n        for (var key in format) {\n            try {\n                var value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    };\n    // if value is null-ish, nullValue is returned\n    Formatter.allowNull = function (format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    };\n    // If value is false-ish, replaceValue is returned\n    Formatter.allowFalsish = function (format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    };\n    // Requires an Array satisfying check\n    Formatter.arrayOf = function (format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            var result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    };\n    return Formatter;\n}());\nexports.Formatter = Formatter;\nfunction isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nexports.isCommunityResourcable = isCommunityResourcable;\nfunction isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\nexports.isCommunityResource = isCommunityResource;\n// Show the throttle message only once\nvar throttleMessage = false;\nfunction showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\nexports.showThrottleMessage = showThrottleMessage;\n//# sourceMappingURL=formatter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2Zvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyxpQkFBaUI7QUFDOUcsZ0JBQWdCLG1CQUFPLENBQUMsNElBQXdCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGtKQUEwQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsc0lBQXNCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGtKQUEwQjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxxSkFBMkI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsMkpBQTZCO0FBQzFELGVBQWUsbUJBQU8sQ0FBQyx5SUFBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsd0pBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLDBDQUEwQztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2Zvcm1hdHRlci5qcz9kNWQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaG93VGhyb3R0bGVNZXNzYWdlID0gZXhwb3J0cy5pc0NvbW11bml0eVJlc291cmNlID0gZXhwb3J0cy5pc0NvbW11bml0eVJlc291cmNhYmxlID0gZXhwb3J0cy5Gb3JtYXR0ZXIgPSB2b2lkIDA7XG52YXIgYWRkcmVzc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIik7XG52YXIgYmlnbnVtYmVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzXCIpO1xudmFyIHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9uc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9ybWF0dGVyKCkge1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB0aGlzLmdldERlZmF1bHRGb3JtYXRzKCk7XG4gICAgfVxuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZ2V0RGVmYXVsdEZvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmb3JtYXRzID0gKHt9KTtcbiAgICAgICAgdmFyIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3MuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGJpZ051bWJlciA9IHRoaXMuYmlnTnVtYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZhciBibG9ja1RhZyA9IHRoaXMuYmxvY2tUYWcuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGhhc2ggPSB0aGlzLmhhc2guYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGhleCA9IHRoaXMuaGV4LmJpbmQodGhpcyk7XG4gICAgICAgIHZhciBudW1iZXIgPSB0aGlzLm51bWJlci5iaW5kKHRoaXMpO1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZS5iaW5kKHRoaXMpO1xuICAgICAgICB2YXIgc3RyaWN0RGF0YSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy5kYXRhKHYsIHRydWUpOyB9O1xuICAgICAgICBmb3JtYXRzLnRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLCBudWxsKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCBudWxsKSxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBjb25maXJtYXRpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgLy8gZWl0aGVyIChnYXNQcmljZSkgb3IgKG1heFByaW9yaXR5RmVlUGVyR2FzICsgbWF4RmVlUGVyR2FzKVxuICAgICAgICAgICAgLy8gbXVzdCBiZSBzZXRcbiAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBnYXNMaW1pdDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICB2YWx1ZTogYmlnTnVtYmVyLFxuICAgICAgICAgICAgbm9uY2U6IG51bWJlcixcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksXG4gICAgICAgICAgICBzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksXG4gICAgICAgICAgICB2OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBjcmVhdGVzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgcmF3OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGZyb206IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyksXG4gICAgICAgICAgICBub25jZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIHZhbHVlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBkYXRhOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHN0cmljdERhdGEpLFxuICAgICAgICAgICAgdHlwZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFjY2Vzc0xpc3QuYmluZCh0aGlzKSwgbnVsbCksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMucmVjZWlwdExvZyA9IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgdG9waWNzOiBGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBsb2dJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBoYXNoLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLnJlY2VpcHQgPSB7XG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGFsbG93TnVsbChoYXNoKSwgYnV0IGJyb2tlbi1FSVAtNjU4IHN1cHBvcnQgaXMgaGFuZGxlZCBpbiByZWNlaXB0XG4gICAgICAgICAgICByb290OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhleCksXG4gICAgICAgICAgICBnYXNVc2VkOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBsb2dzQmxvb206IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG4gICAgICAgICAgICBibG9ja0hhc2g6IGhhc2gsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBsb2dzOiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnJlY2VpcHRMb2cuYmluZCh0aGlzKSksXG4gICAgICAgICAgICBibG9ja051bWJlcjogbnVtYmVyLFxuICAgICAgICAgICAgY29uZmlybWF0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBzdGF0dXM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5ibG9jayA9IHtcbiAgICAgICAgICAgIGhhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCksXG4gICAgICAgICAgICBwYXJlbnRIYXNoOiBoYXNoLFxuICAgICAgICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG51bWJlcixcbiAgICAgICAgICAgIG5vbmNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhleCksXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiB0aGlzLmRpZmZpY3VsdHkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBnYXNVc2VkOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBtaW5lcjogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIGV4dHJhRGF0YTogZGF0YSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSksXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlcilcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMgPSAoMCwgcHJvcGVydGllc18xLnNoYWxsb3dDb3B5KShmb3JtYXRzLmJsb2NrKTtcbiAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMudHJhbnNhY3Rpb25zID0gRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnRyYW5zYWN0aW9uUmVzcG9uc2UuYmluZCh0aGlzKSkpO1xuICAgICAgICBmb3JtYXRzLmZpbHRlciA9IHtcbiAgICAgICAgICAgIGZyb21CbG9jazogRm9ybWF0dGVyLmFsbG93TnVsbChibG9ja1RhZywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIHRvQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnRvcGljcy5iaW5kKHRoaXMpLCB1bmRlZmluZWQpLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmZpbHRlckxvZyA9IHtcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICByZW1vdmVkOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYm9vbGVhbi5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBGb3JtYXR0ZXIuYWxsb3dGYWxzaXNoKGRhdGEsIFwiMHhcIiksXG4gICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuICAgICAgICAgICAgbG9nSW5kZXg6IG51bWJlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgfTtcbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmFjY2Vzc0xpc3QgPSBmdW5jdGlvbiAoYWNjZXNzTGlzdCkge1xuICAgICAgICByZXR1cm4gKDAsIHRyYW5zYWN0aW9uc18xLmFjY2Vzc0xpc3RpZnkpKGFjY2Vzc0xpc3QgfHwgW10pO1xuICAgIH07XG4gICAgLy8gUmVxdWlyZXMgYSBCaWdOdW1iZXJpc2ggdGhhdCBpcyB3aXRoaW4gdGhlIElFRUU3NTQgc2FmZSBpbnRlZ2VyIHJhbmdlOyByZXR1cm5zIGEgbnVtYmVyXG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIEZvcm1hdHRlci5wcm90b3R5cGUubnVtYmVyID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgfTtcbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPT09IFwiMHhcIiB8fCBudW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKG51bWJlcikudG9OdW1iZXIoKTtcbiAgICB9O1xuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmJpZ051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgIH07XG4gICAgLy8gUmVxdWlyZXMgYSBib29sZWFuLCBcInRydWVcIiBvciAgXCJmYWxzZVwiOyByZXR1cm5zIGEgYm9vbGVhblxuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJvb2xlYW4gLSBcIiArIHZhbHVlKTtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuICAgICAgICBpZiAoKHJlc3VsdC5sZW5ndGggJSAyKSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhOyBvZGQtbGVuZ3RoIC0gXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIFJlcXVpcmVzIGFuIGFkZHJlc3NcbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoMCwgYWRkcmVzc18xLmdldEFkZHJlc3MpKHZhbHVlKTtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuY2FsbEFkZHJlc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCEoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykodmFsdWUsIDMyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkZHJlc3MgPSAoMCwgYWRkcmVzc18xLmdldEFkZHJlc3MpKCgwLCBieXRlc18xLmhleERhdGFTbGljZSkodmFsdWUsIDEyKSk7XG4gICAgICAgIHJldHVybiAoYWRkcmVzcyA9PT0gY29uc3RhbnRzXzEuQWRkcmVzc1plcm8pID8gbnVsbCA6IGFkZHJlc3M7XG4gICAgfTtcbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmNvbnRyYWN0QWRkcmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKDAsIGFkZHJlc3NfMS5nZXRDb250cmFjdEFkZHJlc3MpKHZhbHVlKTtcbiAgICB9O1xuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmJsb2NrVGFnID0gZnVuY3Rpb24gKGJsb2NrVGFnKSB7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tUYWcgPT09IFwiZWFybGllc3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChibG9ja1RhZykge1xuICAgICAgICAgICAgY2FzZSBcImVhcmxpZXN0XCI6IHJldHVybiBcIjB4MFwiO1xuICAgICAgICAgICAgY2FzZSBcImxhdGVzdFwiOlxuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIiB8fCAoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4VmFsdWUpKGJsb2NrVGFnKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJsb2NrVGFnXCIpO1xuICAgIH07XG4gICAgLy8gUmVxdWlyZXMgYSBoYXNoLCBvcHRpb25hbGx5IHJlcXVpcmVzIDB4IHByZWZpeDsgcmV0dXJucyBwcmVmaXhlZCBsb3dlcmNhc2UgaGFzaC5cbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAodmFsdWUsIHN0cmljdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oZXgodmFsdWUsIHN0cmljdCk7XG4gICAgICAgIGlmICgoMCwgYnl0ZXNfMS5oZXhEYXRhTGVuZ3RoKShyZXN1bHQpICE9PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdGhlIGRpZmZpY3VsdHkgYXMgYSBudW1iZXIsIG9yIGlmIHRvbyBsYXJnZSAoaS5lLiBQb0EgbmV0d29yaykgbnVsbFxuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZGlmZmljdWx0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS51aW50MjU2ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgYnl0ZXNfMS5oZXhaZXJvUGFkKSh2YWx1ZSwgMzIpO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5fYmxvY2sgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodmFsdWUuYXV0aG9yICE9IG51bGwgJiYgdmFsdWUubWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUubWluZXIgPSB2YWx1ZS5hdXRob3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGRpZmZpY3VsdHkgbWF5IG5lZWQgdG8gY29tZSBmcm9tIF9kaWZmaWN1bHR5IGluIHJlY3Vyc2VkIGJsb2Nrc1xuICAgICAgICB2YXIgZGlmZmljdWx0eSA9ICh2YWx1ZS5fZGlmZmljdWx0eSAhPSBudWxsKSA/IHZhbHVlLl9kaWZmaWN1bHR5IDogdmFsdWUuZGlmZmljdWx0eTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayhmb3JtYXQsIHZhbHVlKTtcbiAgICAgICAgcmVzdWx0Ll9kaWZmaWN1bHR5ID0gKChkaWZmaWN1bHR5ID09IG51bGwpID8gbnVsbCA6IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKGRpZmZpY3VsdHkpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYmxvY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2spO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5ibG9ja1dpdGhUcmFuc2FjdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKTtcbiAgICB9O1xuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRyYW5zYWN0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy50cmFuc2FjdGlvblJlcXVlc3QsIHZhbHVlKTtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUudHJhbnNhY3Rpb25SZXNwb25zZSA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBSZW5hbWUgZ2FzIHRvIGdhc0xpbWl0XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXMgIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9IHRyYW5zYWN0aW9uLmdhcztcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGNsaWVudHMgKFRlc3RSUEMpIGRvIHN0cmFuZ2UgdGhpbmdzIGxpa2UgcmV0dXJuIDB4MCBmb3IgdGhlXG4gICAgICAgIC8vIDAgYWRkcmVzczsgY29ycmVjdCB0aGlzIHRvIGJlIGEgcmVhbCBhZGRyZXNzXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50byAmJiBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi50bykuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnRvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5hbWUgaW5wdXQgdG8gZGF0YVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uaW5wdXQgIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5kYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSB0cmFuc2FjdGlvbi5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0byBhbmQgY3JlYXRlcyBhcmUgZW1wdHksIHBvcHVsYXRlIHRoZSBjcmVhdGVzIGZyb20gdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50byA9PSBudWxsICYmIHRyYW5zYWN0aW9uLmNyZWF0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3JlYXRlcyA9IHRoaXMuY29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRyYW5zYWN0aW9uLnR5cGUgPT09IDEgfHwgdHJhbnNhY3Rpb24udHlwZSA9PT0gMikgJiYgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICAgICAgaWYgKCgwLCBieXRlc18xLmlzSGV4U3RyaW5nKShjaGFpbklkKSkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5uZXR3b3JrSWQ7XG4gICAgICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcbiAgICAgICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBieXRlc18xLmlzSGV4U3RyaW5nKShjaGFpbklkKSkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIgJiYgcmVzdWx0LnYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSAocmVzdWx0LnYgLSAzNSkgLyAyO1xuICAgICAgICAgICAgICAgIGlmIChjaGFpbklkIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KGNoYWluSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICAvLyAweDAwMDAuLi4gc2hvdWxkIGFjdHVhbGx5IGJlIG51bGxcbiAgICAgICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgcmVzdWx0LmJsb2NrSGFzaC5yZXBsYWNlKC8wL2csIFwiXCIpID09PSBcInhcIikge1xuICAgICAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUudHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgwLCB0cmFuc2FjdGlvbnNfMS5wYXJzZSkodmFsdWUpO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5yZWNlaXB0TG9nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnJlY2VpcHRMb2csIHZhbHVlKTtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUucmVjZWlwdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0LCB2YWx1ZSk7XG4gICAgICAgIC8vIFJTSyBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCBFSVAtNjU4LCBzbyB3ZSBtdW5nZSB0aGluZ3MgYSBiaXQgaGVyZSBmb3IgaXRcbiAgICAgICAgaWYgKHJlc3VsdC5yb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucm9vdC5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgIC8vIENvdWxkIGJlIDB4MDAsIDB4MCwgMHgwMSBvciAweDFcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMSA9IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHJlc3VsdC5yb290KS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8xID09PSAwIHx8IHZhbHVlXzEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGlmIGJvdGggYXJlIHNwZWNpZmllZCwgdGhleSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSBudWxsICYmIChyZXN1bHQuc3RhdHVzICE9PSB2YWx1ZV8xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFsdC1yb290LXN0YXR1cy9zdGF0dXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZVwiLCB7IHJvb3Q6IHJlc3VsdC5yb290LCBzdGF0dXM6IHJlc3VsdC5zdGF0dXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9IHZhbHVlXzE7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQucm9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFsdC1yb290LXN0YXR1c1wiLCBcInZhbHVlLnJvb3RcIiwgcmVzdWx0LnJvb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5yb290Lmxlbmd0aCAhPT0gNjYpIHtcbiAgICAgICAgICAgICAgICAvLyBNdXN0IGJlIGEgdmFsaWQgYnl0ZXMzMlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJvb3QgaGFzaFwiLCBcInZhbHVlLnJvb3RcIiwgcmVzdWx0LnJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ieXphbnRpdW0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRvcGljcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLnRvcGljcyh2KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXIsIHZhbHVlKTtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZmlsdGVyTG9nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLmZpbHRlckxvZywgdmFsdWUpO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLmNoZWNrID0gZnVuY3Rpb24gKGZvcm1hdCwgb2JqZWN0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGZvcm1hdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmb3JtYXRba2V5XShvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5jaGVja0tleSA9IGtleTtcbiAgICAgICAgICAgICAgICBlcnJvci5jaGVja1ZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIGlmIHZhbHVlIGlzIG51bGwtaXNoLCBudWxsVmFsdWUgaXMgcmV0dXJuZWRcbiAgICBGb3JtYXR0ZXIuYWxsb3dOdWxsID0gZnVuY3Rpb24gKGZvcm1hdCwgbnVsbFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBJZiB2YWx1ZSBpcyBmYWxzZS1pc2gsIHJlcGxhY2VWYWx1ZSBpcyByZXR1cm5lZFxuICAgIEZvcm1hdHRlci5hbGxvd0ZhbHNpc2ggPSBmdW5jdGlvbiAoZm9ybWF0LCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gUmVxdWlyZXMgYW4gQXJyYXkgc2F0aXNmeWluZyBjaGVja1xuICAgIEZvcm1hdHRlci5hcnJheU9mID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZm9ybWF0KHZhbHVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcm1hdHRlcjtcbn0oKSk7XG5leHBvcnRzLkZvcm1hdHRlciA9IEZvcm1hdHRlcjtcbmZ1bmN0aW9uIGlzQ29tbXVuaXR5UmVzb3VyY2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZSkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnRzLmlzQ29tbXVuaXR5UmVzb3VyY2FibGUgPSBpc0NvbW11bml0eVJlc291cmNhYmxlO1xuZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkgJiYgdmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZSgpKTtcbn1cbmV4cG9ydHMuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGlzQ29tbXVuaXR5UmVzb3VyY2U7XG4vLyBTaG93IHRoZSB0aHJvdHRsZSBtZXNzYWdlIG9ubHkgb25jZVxudmFyIHRocm90dGxlTWVzc2FnZSA9IGZhbHNlO1xuZnVuY3Rpb24gc2hvd1Rocm90dGxlTWVzc2FnZSgpIHtcbiAgICBpZiAodGhyb3R0bGVNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3R0bGVNZXNzYWdlID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PSBOT1RJQ0UgPT09PT09PT09XCIpO1xuICAgIGNvbnNvbGUubG9nKFwiUmVxdWVzdC1SYXRlIEV4Y2VlZGVkICAodGhpcyBtZXNzYWdlIHdpbGwgbm90IGJlIHJlcGVhdGVkKVwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlRoZSBkZWZhdWx0IEFQSSBrZXlzIGZvciBlYWNoIHNlcnZpY2UgYXJlIHByb3ZpZGVkIGFzIGEgaGlnaGx5LXRocm90dGxlZCxcIik7XG4gICAgY29uc29sZS5sb2coXCJjb21tdW5pdHkgcmVzb3VyY2UgZm9yIGxvdy10cmFmZmljIHByb2plY3RzIGFuZCBlYXJseSBwcm90b3R5cGluZy5cIik7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJXaGlsZSB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgY29udGludWUgdG8gZnVuY3Rpb24sIHdlIGhpZ2hseSByZWNvbW1lbmRlZFwiKTtcbiAgICBjb25zb2xlLmxvZyhcInNpZ25pbmcgdXAgZm9yIHlvdXIgb3duIEFQSSBrZXlzIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIGluY3JlYXNlIHlvdXJcIik7XG4gICAgY29uc29sZS5sb2coXCJyZXF1ZXN0IHJhdGUvbGltaXQgYW5kIGVuYWJsZSBvdGhlciBwZXJrcywgc3VjaCBhcyBtZXRyaWNzIGFuZCBhZHZhbmNlZCBBUElzLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi9cXC9kb2NzLmV0aGVycy5pby9hcGkta2V5cy9cIik7XG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcbn1cbmV4cG9ydHMuc2hvd1Rocm90dGxlTWVzc2FnZSA9IHNob3dUaHJvdHRsZU1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXR0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/formatter.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/index.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/index.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Formatter = exports.showThrottleMessage = exports.isCommunityResourcable = exports.isCommunityResource = exports.getNetwork = exports.getDefaultProvider = exports.JsonRpcSigner = exports.IpcProvider = exports.WebSocketProvider = exports.Web3Provider = exports.StaticJsonRpcProvider = exports.PocketProvider = exports.NodesmithProvider = exports.JsonRpcBatchProvider = exports.JsonRpcProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyWebSocketProvider = exports.AlchemyProvider = exports.FallbackProvider = exports.UrlJsonRpcProvider = exports.Resolver = exports.BaseProvider = exports.Provider = void 0;\nvar abstract_provider_1 = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+abstract-provider@5.7.0/node_modules/@ethersproject/abstract-provider/lib/index.js\");\nObject.defineProperty(exports, \"Provider\", ({ enumerable: true, get: function () { return abstract_provider_1.Provider; } }));\nvar networks_1 = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+networks@5.7.0/node_modules/@ethersproject/networks/lib/index.js\");\nObject.defineProperty(exports, \"getNetwork\", ({ enumerable: true, get: function () { return networks_1.getNetwork; } }));\nvar base_provider_1 = __webpack_require__(/*! ./base-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/base-provider.js\");\nObject.defineProperty(exports, \"BaseProvider\", ({ enumerable: true, get: function () { return base_provider_1.BaseProvider; } }));\nObject.defineProperty(exports, \"Resolver\", ({ enumerable: true, get: function () { return base_provider_1.Resolver; } }));\nvar alchemy_provider_1 = __webpack_require__(/*! ./alchemy-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/alchemy-provider.js\");\nObject.defineProperty(exports, \"AlchemyProvider\", ({ enumerable: true, get: function () { return alchemy_provider_1.AlchemyProvider; } }));\nObject.defineProperty(exports, \"AlchemyWebSocketProvider\", ({ enumerable: true, get: function () { return alchemy_provider_1.AlchemyWebSocketProvider; } }));\nvar ankr_provider_1 = __webpack_require__(/*! ./ankr-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ankr-provider.js\");\nObject.defineProperty(exports, \"AnkrProvider\", ({ enumerable: true, get: function () { return ankr_provider_1.AnkrProvider; } }));\nvar cloudflare_provider_1 = __webpack_require__(/*! ./cloudflare-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/cloudflare-provider.js\");\nObject.defineProperty(exports, \"CloudflareProvider\", ({ enumerable: true, get: function () { return cloudflare_provider_1.CloudflareProvider; } }));\nvar etherscan_provider_1 = __webpack_require__(/*! ./etherscan-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/etherscan-provider.js\");\nObject.defineProperty(exports, \"EtherscanProvider\", ({ enumerable: true, get: function () { return etherscan_provider_1.EtherscanProvider; } }));\nvar fallback_provider_1 = __webpack_require__(/*! ./fallback-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/fallback-provider.js\");\nObject.defineProperty(exports, \"FallbackProvider\", ({ enumerable: true, get: function () { return fallback_provider_1.FallbackProvider; } }));\nvar ipc_provider_1 = __webpack_require__(/*! ./ipc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ipc-provider.js\");\nObject.defineProperty(exports, \"IpcProvider\", ({ enumerable: true, get: function () { return ipc_provider_1.IpcProvider; } }));\nvar infura_provider_1 = __webpack_require__(/*! ./infura-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/infura-provider.js\");\nObject.defineProperty(exports, \"InfuraProvider\", ({ enumerable: true, get: function () { return infura_provider_1.InfuraProvider; } }));\nObject.defineProperty(exports, \"InfuraWebSocketProvider\", ({ enumerable: true, get: function () { return infura_provider_1.InfuraWebSocketProvider; } }));\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\nObject.defineProperty(exports, \"JsonRpcProvider\", ({ enumerable: true, get: function () { return json_rpc_provider_1.JsonRpcProvider; } }));\nObject.defineProperty(exports, \"JsonRpcSigner\", ({ enumerable: true, get: function () { return json_rpc_provider_1.JsonRpcSigner; } }));\nvar json_rpc_batch_provider_1 = __webpack_require__(/*! ./json-rpc-batch-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js\");\nObject.defineProperty(exports, \"JsonRpcBatchProvider\", ({ enumerable: true, get: function () { return json_rpc_batch_provider_1.JsonRpcBatchProvider; } }));\nvar nodesmith_provider_1 = __webpack_require__(/*! ./nodesmith-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/nodesmith-provider.js\");\nObject.defineProperty(exports, \"NodesmithProvider\", ({ enumerable: true, get: function () { return nodesmith_provider_1.NodesmithProvider; } }));\nvar pocket_provider_1 = __webpack_require__(/*! ./pocket-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/pocket-provider.js\");\nObject.defineProperty(exports, \"PocketProvider\", ({ enumerable: true, get: function () { return pocket_provider_1.PocketProvider; } }));\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\nObject.defineProperty(exports, \"StaticJsonRpcProvider\", ({ enumerable: true, get: function () { return url_json_rpc_provider_1.StaticJsonRpcProvider; } }));\nObject.defineProperty(exports, \"UrlJsonRpcProvider\", ({ enumerable: true, get: function () { return url_json_rpc_provider_1.UrlJsonRpcProvider; } }));\nvar web3_provider_1 = __webpack_require__(/*! ./web3-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/web3-provider.js\");\nObject.defineProperty(exports, \"Web3Provider\", ({ enumerable: true, get: function () { return web3_provider_1.Web3Provider; } }));\nvar websocket_provider_1 = __webpack_require__(/*! ./websocket-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/websocket-provider.js\");\nObject.defineProperty(exports, \"WebSocketProvider\", ({ enumerable: true, get: function () { return websocket_provider_1.WebSocketProvider; } }));\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/formatter.js\");\nObject.defineProperty(exports, \"Formatter\", ({ enumerable: true, get: function () { return formatter_1.Formatter; } }));\nObject.defineProperty(exports, \"isCommunityResourcable\", ({ enumerable: true, get: function () { return formatter_1.isCommunityResourcable; } }));\nObject.defineProperty(exports, \"isCommunityResource\", ({ enumerable: true, get: function () { return formatter_1.isCommunityResource; } }));\nObject.defineProperty(exports, \"showThrottleMessage\", ({ enumerable: true, get: function () { return formatter_1.showThrottleMessage; } }));\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\n////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network, options) {\n    if (network == null) {\n        network = \"homestead\";\n    }\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof (network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n        // Handle http and ws (and their secure variants)\n        var match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1].toLowerCase()) {\n                case \"http\":\n                case \"https\":\n                    return new json_rpc_provider_1.JsonRpcProvider(network);\n                case \"ws\":\n                case \"wss\":\n                    return new websocket_provider_1.WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n    var n = (0, networks_1.getNetwork)(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", logger_1.Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n    return n._defaultProvider({\n        FallbackProvider: fallback_provider_1.FallbackProvider,\n        AlchemyProvider: alchemy_provider_1.AlchemyProvider,\n        AnkrProvider: ankr_provider_1.AnkrProvider,\n        CloudflareProvider: cloudflare_provider_1.CloudflareProvider,\n        EtherscanProvider: etherscan_provider_1.EtherscanProvider,\n        InfuraProvider: infura_provider_1.InfuraProvider,\n        JsonRpcProvider: json_rpc_provider_1.JsonRpcProvider,\n        NodesmithProvider: nodesmith_provider_1.NodesmithProvider,\n        PocketProvider: pocket_provider_1.PocketProvider,\n        Web3Provider: web3_provider_1.Web3Provider,\n        IpcProvider: ipc_provider_1.IpcProvider,\n    }, options);\n}\nexports.getDefaultProvider = getDefaultProvider;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLDJCQUEyQixHQUFHLDhCQUE4QixHQUFHLDJCQUEyQixHQUFHLGtCQUFrQixHQUFHLDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLHlCQUF5QixHQUFHLG9CQUFvQixHQUFHLDZCQUE2QixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLCtCQUErQixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLG9CQUFvQixHQUFHLGdDQUFnQyxHQUFHLHVCQUF1QixHQUFHLHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLGdCQUFnQjtBQUM1c0IsMEJBQTBCLG1CQUFPLENBQUMsMEtBQWtDO0FBQ3BFLDRDQUEyQyxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUMzSCxpQkFBaUIsbUJBQU8sQ0FBQywrSUFBeUI7QUFDbEQsOENBQTZDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3RILHNCQUFzQixtQkFBTyxDQUFDLGtLQUFpQjtBQUMvQyxnREFBK0MsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDL0gsNENBQTJDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3ZILHlCQUF5QixtQkFBTyxDQUFDLHdLQUFvQjtBQUNyRCxtREFBa0QsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDeEksNERBQTJELEVBQUUscUNBQXFDLHVEQUF1RCxFQUFDO0FBQzFKLHNCQUFzQixtQkFBTyxDQUFDLGtLQUFpQjtBQUMvQyxnREFBK0MsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDL0gsNEJBQTRCLG1CQUFPLENBQUMsOEtBQXVCO0FBQzNELHNEQUFxRCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUNqSiwyQkFBMkIsbUJBQU8sQ0FBQyw0S0FBc0I7QUFDekQscURBQW9ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzlJLDBCQUEwQixtQkFBTyxDQUFDLDBLQUFxQjtBQUN2RCxvREFBbUQsRUFBRSxxQ0FBcUMsZ0RBQWdELEVBQUM7QUFDM0kscUJBQXFCLG1CQUFPLENBQUMsZ0tBQWdCO0FBQzdDLCtDQUE4QyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM1SCx3QkFBd0IsbUJBQU8sQ0FBQyxzS0FBbUI7QUFDbkQsa0RBQWlELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ3JJLDJEQUEwRCxFQUFFLHFDQUFxQyxxREFBcUQsRUFBQztBQUN2SiwwQkFBMEIsbUJBQU8sQ0FBQywwS0FBcUI7QUFDdkQsbURBQWtELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQ3pJLGlEQUFnRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUNySSxnQ0FBZ0MsbUJBQU8sQ0FBQyxzTEFBMkI7QUFDbkUsd0RBQXVELEVBQUUscUNBQXFDLDBEQUEwRCxFQUFDO0FBQ3pKLDJCQUEyQixtQkFBTyxDQUFDLDRLQUFzQjtBQUN6RCxxREFBb0QsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDOUksd0JBQXdCLG1CQUFPLENBQUMsc0tBQW1CO0FBQ25ELGtEQUFpRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUNySSw4QkFBOEIsbUJBQU8sQ0FBQyxrTEFBeUI7QUFDL0QseURBQXdELEVBQUUscUNBQXFDLHlEQUF5RCxFQUFDO0FBQ3pKLHNEQUFxRCxFQUFFLHFDQUFxQyxzREFBc0QsRUFBQztBQUNuSixzQkFBc0IsbUJBQU8sQ0FBQyxrS0FBaUI7QUFDL0MsZ0RBQStDLEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQy9ILDJCQUEyQixtQkFBTyxDQUFDLDRLQUFzQjtBQUN6RCxxREFBb0QsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDOUksa0JBQWtCLG1CQUFPLENBQUMsMEpBQWE7QUFDdkMsNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILDBEQUF5RCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUMvSSx1REFBc0QsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDekksdURBQXNELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3pJLGVBQWUsbUJBQU8sQ0FBQyx5SUFBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsd0pBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi9pbmRleC5qcz9mZDIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gb3JtYXR0ZXIgPSBleHBvcnRzLnNob3dUaHJvdHRsZU1lc3NhZ2UgPSBleHBvcnRzLmlzQ29tbXVuaXR5UmVzb3VyY2FibGUgPSBleHBvcnRzLmlzQ29tbXVuaXR5UmVzb3VyY2UgPSBleHBvcnRzLmdldE5ldHdvcmsgPSBleHBvcnRzLmdldERlZmF1bHRQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY1NpZ25lciA9IGV4cG9ydHMuSXBjUHJvdmlkZXIgPSBleHBvcnRzLldlYlNvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5XZWIzUHJvdmlkZXIgPSBleHBvcnRzLlN0YXRpY0pzb25ScGNQcm92aWRlciA9IGV4cG9ydHMuUG9ja2V0UHJvdmlkZXIgPSBleHBvcnRzLk5vZGVzbWl0aFByb3ZpZGVyID0gZXhwb3J0cy5Kc29uUnBjQmF0Y2hQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0gZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuSW5mdXJhUHJvdmlkZXIgPSBleHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gZXhwb3J0cy5DbG91ZGZsYXJlUHJvdmlkZXIgPSBleHBvcnRzLkFua3JQcm92aWRlciA9IGV4cG9ydHMuQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5BbGNoZW15UHJvdmlkZXIgPSBleHBvcnRzLkZhbGxiYWNrUHJvdmlkZXIgPSBleHBvcnRzLlVybEpzb25ScGNQcm92aWRlciA9IGV4cG9ydHMuUmVzb2x2ZXIgPSBleHBvcnRzLkJhc2VQcm92aWRlciA9IGV4cG9ydHMuUHJvdmlkZXIgPSB2b2lkIDA7XG52YXIgYWJzdHJhY3RfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYnN0cmFjdF9wcm92aWRlcl8xLlByb3ZpZGVyOyB9IH0pO1xudmFyIG5ldHdvcmtzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvbmV0d29ya3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXROZXR3b3JrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXR3b3Jrc18xLmdldE5ldHdvcms7IH0gfSk7XG52YXIgYmFzZV9wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vYmFzZS1wcm92aWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV9wcm92aWRlcl8xLkJhc2VQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX3Byb3ZpZGVyXzEuUmVzb2x2ZXI7IH0gfSk7XG52YXIgYWxjaGVteV9wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vYWxjaGVteS1wcm92aWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFsY2hlbXlQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWxjaGVteV9wcm92aWRlcl8xLkFsY2hlbXlQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFsY2hlbXlXZWJTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWxjaGVteV9wcm92aWRlcl8xLkFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcjsgfSB9KTtcbnZhciBhbmtyX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9hbmtyLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5rclByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhbmtyX3Byb3ZpZGVyXzEuQW5rclByb3ZpZGVyOyB9IH0pO1xudmFyIGNsb3VkZmxhcmVfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2Nsb3VkZmxhcmUtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbG91ZGZsYXJlUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsb3VkZmxhcmVfcHJvdmlkZXJfMS5DbG91ZGZsYXJlUHJvdmlkZXI7IH0gfSk7XG52YXIgZXRoZXJzY2FuX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9ldGhlcnNjYW4tcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlcnNjYW5Qcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzY2FuX3Byb3ZpZGVyXzEuRXRoZXJzY2FuUHJvdmlkZXI7IH0gfSk7XG52YXIgZmFsbGJhY2tfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2ZhbGxiYWNrLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmFsbGJhY2tQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsbGJhY2tfcHJvdmlkZXJfMS5GYWxsYmFja1Byb3ZpZGVyOyB9IH0pO1xudmFyIGlwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vaXBjLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSXBjUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlwY19wcm92aWRlcl8xLklwY1Byb3ZpZGVyOyB9IH0pO1xudmFyIGluZnVyYV9wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vaW5mdXJhLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5mdXJhUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZnVyYV9wcm92aWRlcl8xLkluZnVyYVByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5mdXJhV2ViU29ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZnVyYV9wcm92aWRlcl8xLkluZnVyYVdlYlNvY2tldFByb3ZpZGVyOyB9IH0pO1xudmFyIGpzb25fcnBjX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9qc29uLXJwYy1wcm92aWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9ycGNfcHJvdmlkZXJfMS5Kc29uUnBjUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc29uUnBjU2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX3JwY19wcm92aWRlcl8xLkpzb25ScGNTaWduZXI7IH0gfSk7XG52YXIganNvbl9ycGNfYmF0Y2hfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2pzb24tcnBjLWJhdGNoLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSnNvblJwY0JhdGNoUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fcnBjX2JhdGNoX3Byb3ZpZGVyXzEuSnNvblJwY0JhdGNoUHJvdmlkZXI7IH0gfSk7XG52YXIgbm9kZXNtaXRoX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9ub2Rlc21pdGgtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb2Rlc21pdGhQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9kZXNtaXRoX3Byb3ZpZGVyXzEuTm9kZXNtaXRoUHJvdmlkZXI7IH0gfSk7XG52YXIgcG9ja2V0X3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wb2NrZXQtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcG9ja2V0X3Byb3ZpZGVyXzEuUG9ja2V0UHJvdmlkZXI7IH0gfSk7XG52YXIgdXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi91cmwtanNvbi1ycGMtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdGF0aWNKc29uUnBjUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVybF9qc29uX3JwY19wcm92aWRlcl8xLlN0YXRpY0pzb25ScGNQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVybEpzb25ScGNQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEuVXJsSnNvblJwY1Byb3ZpZGVyOyB9IH0pO1xudmFyIHdlYjNfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3dlYjMtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWIzUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdlYjNfcHJvdmlkZXJfMS5XZWIzUHJvdmlkZXI7IH0gfSk7XG52YXIgd2Vic29ja2V0X3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi93ZWJzb2NrZXQtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWJTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2Vic29ja2V0X3Byb3ZpZGVyXzEuV2ViU29ja2V0UHJvdmlkZXI7IH0gfSk7XG52YXIgZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi9mb3JtYXR0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGb3JtYXR0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvcm1hdHRlcl8xLkZvcm1hdHRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQ29tbXVuaXR5UmVzb3VyY2FibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvcm1hdHRlcl8xLmlzQ29tbXVuaXR5UmVzb3VyY2FibGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0NvbW11bml0eVJlc291cmNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JtYXR0ZXJfMS5pc0NvbW11bml0eVJlc291cmNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hvd1Rocm90dGxlTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZm9ybWF0dGVyXzEuc2hvd1Rocm90dGxlTWVzc2FnZTsgfSB9KTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIEZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgIG5ldHdvcmsgPSBcImhvbWVzdGVhZFwiO1xuICAgIH1cbiAgICAvLyBJZiBwYXNzZWQgYSBVUkwsIGZpZ3VyZSBvdXQgdGhlIHJpZ2h0IHR5cGUgb2YgcHJvdmlkZXIgYmFzZWQgb24gdGhlIHNjaGVtZVxuICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgc3VwcG9ydCBmb3IgSXBjUHJvdmlkZXI7IG1heWJlIGlmIGl0IGVuZHMgaW4gXCIuaXBjXCI/XG4gICAgICAgIC8vIEhhbmRsZSBodHRwIGFuZCB3cyAoYW5kIHRoZWlyIHNlY3VyZSB2YXJpYW50cylcbiAgICAgICAgdmFyIG1hdGNoID0gbmV0d29yay5tYXRjaCgvXih3c3xodHRwKXM/Oi9pKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwc1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGpzb25fcnBjX3Byb3ZpZGVyXzEuSnNvblJwY1Byb3ZpZGVyKG5ldHdvcmspO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ3c1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ3c3NcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3ZWJzb2NrZXRfcHJvdmlkZXJfMS5XZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgVVJMIHNjaGVtZVwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG4gPSAoMCwgbmV0d29ya3NfMS5nZXROZXR3b3JrKShuZXR3b3JrKTtcbiAgICBpZiAoIW4gfHwgIW4uX2RlZmF1bHRQcm92aWRlcikge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIGdldERlZmF1bHRQcm92aWRlciBuZXR3b3JrXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldERlZmF1bHRQcm92aWRlclwiLFxuICAgICAgICAgICAgbmV0d29yazogbmV0d29ya1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG4uX2RlZmF1bHRQcm92aWRlcih7XG4gICAgICAgIEZhbGxiYWNrUHJvdmlkZXI6IGZhbGxiYWNrX3Byb3ZpZGVyXzEuRmFsbGJhY2tQcm92aWRlcixcbiAgICAgICAgQWxjaGVteVByb3ZpZGVyOiBhbGNoZW15X3Byb3ZpZGVyXzEuQWxjaGVteVByb3ZpZGVyLFxuICAgICAgICBBbmtyUHJvdmlkZXI6IGFua3JfcHJvdmlkZXJfMS5BbmtyUHJvdmlkZXIsXG4gICAgICAgIENsb3VkZmxhcmVQcm92aWRlcjogY2xvdWRmbGFyZV9wcm92aWRlcl8xLkNsb3VkZmxhcmVQcm92aWRlcixcbiAgICAgICAgRXRoZXJzY2FuUHJvdmlkZXI6IGV0aGVyc2Nhbl9wcm92aWRlcl8xLkV0aGVyc2NhblByb3ZpZGVyLFxuICAgICAgICBJbmZ1cmFQcm92aWRlcjogaW5mdXJhX3Byb3ZpZGVyXzEuSW5mdXJhUHJvdmlkZXIsXG4gICAgICAgIEpzb25ScGNQcm92aWRlcjoganNvbl9ycGNfcHJvdmlkZXJfMS5Kc29uUnBjUHJvdmlkZXIsXG4gICAgICAgIE5vZGVzbWl0aFByb3ZpZGVyOiBub2Rlc21pdGhfcHJvdmlkZXJfMS5Ob2Rlc21pdGhQcm92aWRlcixcbiAgICAgICAgUG9ja2V0UHJvdmlkZXI6IHBvY2tldF9wcm92aWRlcl8xLlBvY2tldFByb3ZpZGVyLFxuICAgICAgICBXZWIzUHJvdmlkZXI6IHdlYjNfcHJvdmlkZXJfMS5XZWIzUHJvdmlkZXIsXG4gICAgICAgIElwY1Byb3ZpZGVyOiBpcGNfcHJvdmlkZXJfMS5JcGNQcm92aWRlcixcbiAgICB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gZ2V0RGVmYXVsdFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/infura-provider.js":
/*!*********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/infura-provider.js ***!
  \*********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar websocket_provider_1 = __webpack_require__(/*! ./websocket-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/websocket-provider.js\");\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/formatter.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\nvar defaultProjectId = \"84842078b09946638c03157f83405213\";\nvar InfuraWebSocketProvider = /** @class */ (function (_super) {\n    __extends(InfuraWebSocketProvider, _super);\n    function InfuraWebSocketProvider(network, apiKey) {\n        var _this = this;\n        var provider = new InfuraProvider(network, apiKey);\n        var connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n        var url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        _this = _super.call(this, url, network) || this;\n        (0, properties_1.defineReadOnly)(_this, \"apiKey\", provider.projectId);\n        (0, properties_1.defineReadOnly)(_this, \"projectId\", provider.projectId);\n        (0, properties_1.defineReadOnly)(_this, \"projectSecret\", provider.projectSecret);\n        return _this;\n    }\n    InfuraWebSocketProvider.prototype.isCommunityResource = function () {\n        return (this.projectId === defaultProjectId);\n    };\n    return InfuraWebSocketProvider;\n}(websocket_provider_1.WebSocketProvider));\nexports.InfuraWebSocketProvider = InfuraWebSocketProvider;\nvar InfuraProvider = /** @class */ (function (_super) {\n    __extends(InfuraProvider, _super);\n    function InfuraProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    InfuraProvider.getWebSocketProvider = function (network, apiKey) {\n        return new InfuraWebSocketProvider(network, apiKey);\n    };\n    InfuraProvider.getApiKey = function (apiKey) {\n        var apiKeyObj = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n        if (apiKey == null) {\n            return apiKeyObj;\n        }\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n        }\n        else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof (apiKey.projectId) === \"string\"), \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof (apiKey.projectSecret) === \"string\"), \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n        }\n        else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n        return apiKeyObj;\n    };\n    InfuraProvider.getUrl = function (network, apiKey) {\n        var host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", logger_1.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        var connection = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: function (attempt, url) {\n                if (apiKey.projectId === defaultProjectId) {\n                    (0, formatter_1.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    };\n    InfuraProvider.prototype.isCommunityResource = function () {\n        return (this.projectId === defaultProjectId);\n    };\n    return InfuraProvider;\n}(url_json_rpc_provider_1.UrlJsonRpcProvider));\nexports.InfuraProvider = InfuraProvider;\n//# sourceMappingURL=infura-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2luZnVyYS1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRywrQkFBK0I7QUFDeEQsbUJBQW1CLG1CQUFPLENBQUMscUpBQTJCO0FBQ3RELDJCQUEyQixtQkFBTyxDQUFDLDRLQUFzQjtBQUN6RCxrQkFBa0IsbUJBQU8sQ0FBQywwSkFBYTtBQUN2QyxlQUFlLG1CQUFPLENBQUMseUlBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHdKQUFZO0FBQ3JDO0FBQ0EsOEJBQThCLG1CQUFPLENBQUMsa0xBQXlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi9pbmZ1cmEtcHJvdmlkZXIuanM/MzQ0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluZnVyYVByb3ZpZGVyID0gZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IHZvaWQgMDtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciB3ZWJzb2NrZXRfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3dlYnNvY2tldC1wcm92aWRlclwiKTtcbnZhciBmb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdHRlclwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciB1cmxfanNvbl9ycGNfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiKTtcbnZhciBkZWZhdWx0UHJvamVjdElkID0gXCI4NDg0MjA3OGIwOTk0NjYzOGMwMzE1N2Y4MzQwNTIxM1wiO1xudmFyIEluZnVyYVdlYlNvY2tldFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IEluZnVyYVByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSk7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gcHJvdmlkZXIuY29ubmVjdGlvbjtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24ucGFzc3dvcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiSU5GVVJBIFdlYlNvY2tldCBwcm9qZWN0IHNlY3JldHMgdW5zdXBwb3J0ZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiSW5mdXJhUHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKS5yZXBsYWNlKFwiL3YzL1wiLCBcIi93cy92My9cIik7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdXJsLCBuZXR3b3JrKSB8fCB0aGlzO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJhcGlLZXlcIiwgcHJvdmlkZXIucHJvamVjdElkKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicHJvamVjdElkXCIsIHByb3ZpZGVyLnByb2plY3RJZCk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcInByb2plY3RTZWNyZXRcIiwgcHJvdmlkZXIucHJvamVjdFNlY3JldCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmlzQ29tbXVuaXR5UmVzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpO1xuICAgIH07XG4gICAgcmV0dXJuIEluZnVyYVdlYlNvY2tldFByb3ZpZGVyO1xufSh3ZWJzb2NrZXRfcHJvdmlkZXJfMS5XZWJTb2NrZXRQcm92aWRlcikpO1xuZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IEluZnVyYVdlYlNvY2tldFByb3ZpZGVyO1xudmFyIEluZnVyYVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmZ1cmFQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmZ1cmFQcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbmZ1cmFQcm92aWRlci5nZXRXZWJTb2NrZXRQcm92aWRlciA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpO1xuICAgIH07XG4gICAgSW5mdXJhUHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuICAgICAgICB2YXIgYXBpS2V5T2JqID0ge1xuICAgICAgICAgICAgYXBpS2V5OiBkZWZhdWx0UHJvamVjdElkLFxuICAgICAgICAgICAgcHJvamVjdElkOiBkZWZhdWx0UHJvamVjdElkLFxuICAgICAgICAgICAgcHJvamVjdFNlY3JldDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGlLZXlPYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYXBpS2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RJZCA9IGFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdFNlY3JldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RJZCkgPT09IFwic3RyaW5nXCIpLCBcInByb2plY3RTZWNyZXQgcmVxdWlyZXMgYSBwcm9qZWN0SWRcIiwgXCJwcm9qZWN0SWRcIiwgYXBpS2V5LnByb2plY3RJZCk7XG4gICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RTZWNyZXQpID09PSBcInN0cmluZ1wiKSwgXCJpbnZhbGlkIHByb2plY3RTZWNyZXRcIiwgXCJwcm9qZWN0U2VjcmV0XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0SWQgPSBhcGlLZXkucHJvamVjdElkO1xuICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RTZWNyZXQgPSBhcGlLZXkucHJvamVjdFNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdElkKSB7XG4gICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdElkID0gYXBpS2V5LnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBhcGlLZXlPYmouYXBpS2V5ID0gYXBpS2V5T2JqLnByb2plY3RJZDtcbiAgICAgICAgcmV0dXJuIGFwaUtleU9iajtcbiAgICB9O1xuICAgIEluZnVyYVByb3ZpZGVyLmdldFVybCA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsgPyBuZXR3b3JrLm5hbWUgOiBcInVua25vd25cIikge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInJvcHN0ZW4uaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInJpbmtlYnkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJrb3Zhbi5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJnb2VybGkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNtdW1cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW11bWJhaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm9wdGltaXNtLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3B0aW1pc20ta292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJvcHRpbWlzbS1rb3Zhbi5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYml0cnVtLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW0tcmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYml0cnVtLXJpbmtlYnkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV0d29ya1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgYWxsb3dHemlwOiB0cnVlLFxuICAgICAgICAgICAgdXJsOiAoXCJodHRwczovXCIgKyBcIi9cIiArIGhvc3QgKyBcIi92My9cIiArIGFwaUtleS5wcm9qZWN0SWQpLFxuICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogZnVuY3Rpb24gKGF0dGVtcHQsIHVybCkge1xuICAgICAgICAgICAgICAgIGlmIChhcGlLZXkucHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBmb3JtYXR0ZXJfMS5zaG93VGhyb3R0bGVNZXNzYWdlKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXBpS2V5LnByb2plY3RTZWNyZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51c2VyID0gXCJcIjtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucGFzc3dvcmQgPSBhcGlLZXkucHJvamVjdFNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9O1xuICAgIEluZnVyYVByb3ZpZGVyLnByb3RvdHlwZS5pc0NvbW11bml0eVJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKTtcbiAgICB9O1xuICAgIHJldHVybiBJbmZ1cmFQcm92aWRlcjtcbn0odXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLkluZnVyYVByb3ZpZGVyID0gSW5mdXJhUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZ1cmEtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/infura-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ipc-provider.js":
/*!******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ipc-provider.js ***!
  \******************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IpcProvider = void 0;\nvar net_1 = __webpack_require__(/*! net */ \"net\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\nvar IpcProvider = /** @class */ (function (_super) {\n    __extends(IpcProvider, _super);\n    function IpcProvider(path, network) {\n        var _this = this;\n        if (path == null) {\n            logger.throwError(\"missing path\", logger_1.Logger.errors.MISSING_ARGUMENT, { arg: \"path\" });\n        }\n        _this = _super.call(this, \"ipc://\" + path, network) || this;\n        (0, properties_1.defineReadOnly)(_this, \"path\", path);\n        return _this;\n    }\n    // @TODO: Create a connection to the IPC path and use filters instead of polling for block\n    IpcProvider.prototype.send = function (method, params) {\n        // This method is very simple right now. We create a new socket\n        // connection each time, which may be slower, but the main\n        // advantage we are aiming for now is security. This simplifies\n        // multiplexing requests (since we do not need to multiplex).\n        var _this = this;\n        var payload = JSON.stringify({\n            method: method,\n            params: params,\n            id: 42,\n            jsonrpc: \"2.0\"\n        });\n        return new Promise(function (resolve, reject) {\n            var response = Buffer.alloc(0);\n            var stream = (0, net_1.connect)(_this.path);\n            stream.on(\"data\", function (data) {\n                response = Buffer.concat([response, data]);\n            });\n            stream.on(\"end\", function () {\n                try {\n                    resolve(JSON.parse(response.toString()).result);\n                    // @TODO: Better pull apart the error\n                    stream.destroy();\n                }\n                catch (error) {\n                    reject(error);\n                    stream.destroy();\n                }\n            });\n            stream.on(\"error\", function (error) {\n                reject(error);\n                stream.destroy();\n            });\n            stream.write(payload);\n            stream.end();\n        });\n    };\n    return IpcProvider;\n}(json_rpc_provider_1.JsonRpcProvider));\nexports.IpcProvider = IpcProvider;\n//# sourceMappingURL=ipc-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2lwYy1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLG1CQUFtQixtQkFBTyxDQUFDLHFKQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMseUlBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHdKQUFZO0FBQ3JDO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsMEtBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi9pcGMtcHJvdmlkZXIuanM/MDBkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklwY1Byb3ZpZGVyID0gdm9pZCAwO1xudmFyIG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBqc29uX3JwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vanNvbi1ycGMtcHJvdmlkZXJcIik7XG52YXIgSXBjUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElwY1Byb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElwY1Byb3ZpZGVyKHBhdGgsIG5ldHdvcmspIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHBhdGhcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7IGFyZzogXCJwYXRoXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcImlwYzovL1wiICsgcGF0aCwgbmV0d29yaykgfHwgdGhpcztcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicGF0aFwiLCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQ3JlYXRlIGEgY29ubmVjdGlvbiB0byB0aGUgSVBDIHBhdGggYW5kIHVzZSBmaWx0ZXJzIGluc3RlYWQgb2YgcG9sbGluZyBmb3IgYmxvY2tcbiAgICBJcGNQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyB2ZXJ5IHNpbXBsZSByaWdodCBub3cuIFdlIGNyZWF0ZSBhIG5ldyBzb2NrZXRcbiAgICAgICAgLy8gY29ubmVjdGlvbiBlYWNoIHRpbWUsIHdoaWNoIG1heSBiZSBzbG93ZXIsIGJ1dCB0aGUgbWFpblxuICAgICAgICAvLyBhZHZhbnRhZ2Ugd2UgYXJlIGFpbWluZyBmb3Igbm93IGlzIHNlY3VyaXR5LiBUaGlzIHNpbXBsaWZpZXNcbiAgICAgICAgLy8gbXVsdGlwbGV4aW5nIHJlcXVlc3RzIChzaW5jZSB3ZSBkbyBub3QgbmVlZCB0byBtdWx0aXBsZXgpLlxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogNDIsXG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICAgICAgdmFyIHN0cmVhbSA9ICgwLCBuZXRfMS5jb25uZWN0KShfdGhpcy5wYXRoKTtcbiAgICAgICAgICAgIHN0cmVhbS5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IEJ1ZmZlci5jb25jYXQoW3Jlc3BvbnNlLCBkYXRhXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0cmVhbS5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKHJlc3BvbnNlLnRvU3RyaW5nKCkpLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBCZXR0ZXIgcHVsbCBhcGFydCB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW0ub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZShwYXlsb2FkKTtcbiAgICAgICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSXBjUHJvdmlkZXI7XG59KGpzb25fcnBjX3Byb3ZpZGVyXzEuSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLklwY1Byb3ZpZGVyID0gSXBjUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcGMtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ipc-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js ***!
  \*****************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonRpcBatchProvider = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar web_1 = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+web@5.7.0/node_modules/@ethersproject/web/lib/index.js\");\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\n// Experimental\nvar JsonRpcBatchProvider = /** @class */ (function (_super) {\n    __extends(JsonRpcBatchProvider, _super);\n    function JsonRpcBatchProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    JsonRpcBatchProvider.prototype.send = function (method, params) {\n        var _this = this;\n        var request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        var inflightRequest = { request: request, resolve: null, reject: null };\n        var promise = new Promise(function (resolve, reject) {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(function () {\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                var batch = _this._pendingBatch;\n                _this._pendingBatch = null;\n                _this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                var request = batch.map(function (inflight) { return inflight.request; });\n                _this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: (0, properties_1.deepCopy)(request),\n                    provider: _this\n                });\n                return (0, web_1.fetchJson)(_this.connection, JSON.stringify(request)).then(function (result) {\n                    _this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: _this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach(function (inflightRequest, index) {\n                        var payload = result[index];\n                        if (payload.error) {\n                            var error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        }\n                        else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, function (error) {\n                    _this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: _this\n                    });\n                    batch.forEach(function (inflightRequest) {\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    };\n    return JsonRpcBatchProvider;\n}(json_rpc_provider_1.JsonRpcProvider));\nexports.JsonRpcBatchProvider = JsonRpcBatchProvider;\n//# sourceMappingURL=json-rpc-batch-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2pzb24tcnBjLWJhdGNoLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QixtQkFBbUIsbUJBQU8sQ0FBQyxxSkFBMkI7QUFDdEQsWUFBWSxtQkFBTyxDQUFDLGdJQUFvQjtBQUN4QywwQkFBMEIsbUJBQU8sQ0FBQywwS0FBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsMEJBQTBCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuNy4wX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIvanNvbi1ycGMtYmF0Y2gtcHJvdmlkZXIuanM/NDY2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25ScGNCYXRjaFByb3ZpZGVyID0gdm9pZCAwO1xudmFyIHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCIpO1xudmFyIHdlYl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3dlYlwiKTtcbnZhciBqc29uX3JwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vanNvbi1ycGMtcHJvdmlkZXJcIik7XG4vLyBFeHBlcmltZW50YWxcbnZhciBKc29uUnBjQmF0Y2hQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSnNvblJwY0JhdGNoUHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSnNvblJwY0JhdGNoUHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSnNvblJwY0JhdGNoUHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgaWQ6ICh0aGlzLl9uZXh0SWQrKyksXG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nQmF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0JhdGNoID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZmxpZ2h0UmVxdWVzdCA9IHsgcmVxdWVzdDogcmVxdWVzdCwgcmVzb2x2ZTogbnVsbCwgcmVqZWN0OiBudWxsIH07XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdCYXRjaC5wdXNoKGluZmxpZ2h0UmVxdWVzdCk7XG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvcikge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYmF0Y2ggZm9yIG5leHQgZXZlbnQgbG9vcCArIHNob3J0IGR1cmF0aW9uXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQmF0Y2hBZ2dyZWdhdG9yID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRlaCBjdXJyZW50IGJhdGNoIGFuZCBjbGVhciBpdCwgc28gbmV3IHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgLy8gZ28gaW50byB0aGUgbmV4dCBiYXRjaFxuICAgICAgICAgICAgICAgIHZhciBiYXRjaCA9IF90aGlzLl9wZW5kaW5nQmF0Y2g7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdCYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVxdWVzdCBhcyBhbiBhcnJheSBvZiByZXF1ZXN0c1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gYmF0Y2gubWFwKGZ1bmN0aW9uIChpbmZsaWdodCkgeyByZXR1cm4gaW5mbGlnaHQucmVxdWVzdDsgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RCYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiAoMCwgcHJvcGVydGllc18xLmRlZXBDb3B5KShyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB3ZWJfMS5mZXRjaEpzb24pKF90aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIHJlc3VsdCwgZmVlZCBpdCB0byB0aGUgY29ycmVjdCBQcm9taXNlLCBkZXBlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gd2hldGhlciBpdCB3YXMgYSBzdWNjZXNzIG9yIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goZnVuY3Rpb24gKGluZmxpZ2h0UmVxdWVzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gcmVzdWx0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUocGF5bG9hZC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2guZm9yRWFjaChmdW5jdGlvbiAoaW5mbGlnaHRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gSnNvblJwY0JhdGNoUHJvdmlkZXI7XG59KGpzb25fcnBjX3Byb3ZpZGVyXzEuSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLkpzb25ScGNCYXRjaFByb3ZpZGVyID0gSnNvblJwY0JhdGNoUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLXJwYy1iYXRjaC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-provider.js":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-provider.js ***!
  \***********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonRpcProvider = exports.JsonRpcSigner = void 0;\nvar abstract_signer_1 = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+abstract-signer@5.7.0/node_modules/@ethersproject/abstract-signer/lib/index.js\");\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib/index.js\");\nvar hash_1 = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar strings_1 = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib/index.js\");\nvar transactions_1 = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib/index.js\");\nvar web_1 = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+web@5.7.0/node_modules/@ethersproject/web/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar base_provider_1 = __webpack_require__(/*! ./base-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/base-provider.js\");\nvar errorGas = [\"call\", \"estimateGas\"];\nfunction spelunk(value, requireData) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\" && value.message.match(\"reverted\")) {\n        var data = (0, bytes_1.isHexString)(value.data) ? value.data : null;\n        if (!requireData || data) {\n            return { message: value.message, data: data };\n        }\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (var key in value) {\n            var result = spelunk(value[key], requireData);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        }\n        catch (error) { }\n    }\n    return null;\n}\nfunction checkError(method, error, params) {\n    var transaction = params.transaction || params.signedTransaction;\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        var result = spelunk(error, true);\n        if (result) {\n            return result.data;\n        }\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", logger_1.Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\",\n            transaction: transaction,\n            error: error\n        });\n    }\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        var result = spelunk(error.body, false);\n        if (result == null) {\n            result = spelunk(error, false);\n        }\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message,\n                method: method,\n                transaction: transaction,\n                error: error\n            });\n        }\n    }\n    // @TODO: Should we spelunk for message too?\n    var message = error.message;\n    if (error.code === logger_1.Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", logger_1.Logger.errors.INSUFFICIENT_FUNDS, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", logger_1.Logger.errors.NONCE_EXPIRED, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", logger_1.Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        var error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nvar _constructorGuard = {};\nvar JsonRpcSigner = /** @class */ (function (_super) {\n    __extends(JsonRpcSigner, _super);\n    function JsonRpcSigner(constructorGuard, provider, addressOrIndex) {\n        var _this = _super.call(this) || this;\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        (0, properties_1.defineReadOnly)(_this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            (0, properties_1.defineReadOnly)(_this, \"_address\", _this.provider.formatter.address(addressOrIndex));\n            (0, properties_1.defineReadOnly)(_this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            (0, properties_1.defineReadOnly)(_this, \"_index\", addressOrIndex);\n            (0, properties_1.defineReadOnly)(_this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n        return _this;\n    }\n    JsonRpcSigner.prototype.connect = function (provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    };\n    JsonRpcSigner.prototype.connectUnchecked = function () {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    };\n    JsonRpcSigner.prototype.getAddress = function () {\n        var _this = this;\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then(function (accounts) {\n            if (accounts.length <= _this._index) {\n                logger.throwError(\"unknown account #\" + _this._index, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return _this.provider.formatter.address(accounts[_this._index]);\n        });\n    };\n    JsonRpcSigner.prototype.sendUncheckedTransaction = function (transaction) {\n        var _this = this;\n        transaction = (0, properties_1.shallowCopy)(transaction);\n        var fromAddress = this.getAddress().then(function (address) {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            var estimate = (0, properties_1.shallowCopy)(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(function (to) { return __awaiter(_this, void 0, void 0, function () {\n                var address;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (to == null) {\n                                return [2 /*return*/, null];\n                            }\n                            return [4 /*yield*/, this.provider.resolveName(to)];\n                        case 1:\n                            address = _a.sent();\n                            if (address == null) {\n                                logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                            }\n                            return [2 /*return*/, address];\n                    }\n                });\n            }); });\n        }\n        return (0, properties_1.resolveProperties)({\n            tx: (0, properties_1.resolveProperties)(transaction),\n            sender: fromAddress\n        }).then(function (_a) {\n            var tx = _a.tx, sender = _a.sender;\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            var hexTx = _this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return _this.provider.send(\"eth_sendTransaction\", [hexTx]).then(function (hash) {\n                return hash;\n            }, function (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", logger_1.Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    };\n    JsonRpcSigner.prototype.signTransaction = function (transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    };\n    JsonRpcSigner.prototype.sendTransaction = function (transaction) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockNumber, hash, error_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval)];\n                    case 1:\n                        blockNumber = _a.sent();\n                        return [4 /*yield*/, this.sendUncheckedTransaction(transaction)];\n                    case 2:\n                        hash = _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        _a.trys.push([3, 5, , 6]);\n                        return [4 /*yield*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n                                var tx;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, this.provider.getTransaction(hash)];\n                                        case 1:\n                                            tx = _a.sent();\n                                            if (tx === null) {\n                                                return [2 /*return*/, undefined];\n                                            }\n                                            return [2 /*return*/, this.provider._wrapTransaction(tx, hash, blockNumber)];\n                                    }\n                                });\n                            }); }, { oncePoll: this.provider })];\n                    case 4: \n                    // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                    // for a response, and we need the actual transaction, so we poll\n                    // for it; it should show up very quickly\n                    return [2 /*return*/, _a.sent()];\n                    case 5:\n                        error_1 = _a.sent();\n                        error_1.transactionHash = hash;\n                        throw error_1;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    JsonRpcSigner.prototype.signMessage = function (message) {\n        return __awaiter(this, void 0, void 0, function () {\n            var data, address, error_2;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        data = ((typeof (message) === \"string\") ? (0, strings_1.toUtf8Bytes)(message) : message);\n                        return [4 /*yield*/, this.getAddress()];\n                    case 1:\n                        address = _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.provider.send(\"personal_sign\", [(0, bytes_1.hexlify)(data), address.toLowerCase()])];\n                    case 3: return [2 /*return*/, _a.sent()];\n                    case 4:\n                        error_2 = _a.sent();\n                        if (typeof (error_2.message) === \"string\" && error_2.message.match(/user denied/i)) {\n                            logger.throwError(\"user rejected signing\", logger_1.Logger.errors.ACTION_REJECTED, {\n                                action: \"signMessage\",\n                                from: address,\n                                message: data\n                            });\n                        }\n                        throw error_2;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    JsonRpcSigner.prototype._legacySignMessage = function (message) {\n        return __awaiter(this, void 0, void 0, function () {\n            var data, address, error_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        data = ((typeof (message) === \"string\") ? (0, strings_1.toUtf8Bytes)(message) : message);\n                        return [4 /*yield*/, this.getAddress()];\n                    case 1:\n                        address = _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.provider.send(\"eth_sign\", [address.toLowerCase(), (0, bytes_1.hexlify)(data)])];\n                    case 3: \n                    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n                    return [2 /*return*/, _a.sent()];\n                    case 4:\n                        error_3 = _a.sent();\n                        if (typeof (error_3.message) === \"string\" && error_3.message.match(/user denied/i)) {\n                            logger.throwError(\"user rejected signing\", logger_1.Logger.errors.ACTION_REJECTED, {\n                                action: \"_legacySignMessage\",\n                                from: address,\n                                message: data\n                            });\n                        }\n                        throw error_3;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    JsonRpcSigner.prototype._signTypedData = function (domain, types, value) {\n        return __awaiter(this, void 0, void 0, function () {\n            var populated, address, error_4;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, hash_1._TypedDataEncoder.resolveNames(domain, types, value, function (name) {\n                            return _this.provider.resolveName(name);\n                        })];\n                    case 1:\n                        populated = _a.sent();\n                        return [4 /*yield*/, this.getAddress()];\n                    case 2:\n                        address = _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        _a.trys.push([3, 5, , 6]);\n                        return [4 /*yield*/, this.provider.send(\"eth_signTypedData_v4\", [\n                                address.toLowerCase(),\n                                JSON.stringify(hash_1._TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n                            ])];\n                    case 4: return [2 /*return*/, _a.sent()];\n                    case 5:\n                        error_4 = _a.sent();\n                        if (typeof (error_4.message) === \"string\" && error_4.message.match(/user denied/i)) {\n                            logger.throwError(\"user rejected signing\", logger_1.Logger.errors.ACTION_REJECTED, {\n                                action: \"_signTypedData\",\n                                from: address,\n                                message: { domain: populated.domain, types: types, value: populated.value }\n                            });\n                        }\n                        throw error_4;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    JsonRpcSigner.prototype.unlock = function (password) {\n        return __awaiter(this, void 0, void 0, function () {\n            var provider, address;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        provider = this.provider;\n                        return [4 /*yield*/, this.getAddress()];\n                    case 1:\n                        address = _a.sent();\n                        return [2 /*return*/, provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null])];\n                }\n            });\n        });\n    };\n    return JsonRpcSigner;\n}(abstract_signer_1.Signer));\nexports.JsonRpcSigner = JsonRpcSigner;\nvar UncheckedJsonRpcSigner = /** @class */ (function (_super) {\n    __extends(UncheckedJsonRpcSigner, _super);\n    function UncheckedJsonRpcSigner() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    UncheckedJsonRpcSigner.prototype.sendTransaction = function (transaction) {\n        var _this = this;\n        return this.sendUncheckedTransaction(transaction).then(function (hash) {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: function (confirmations) { return _this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    };\n    return UncheckedJsonRpcSigner;\n}(JsonRpcSigner));\nvar allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nvar JsonRpcProvider = /** @class */ (function (_super) {\n    __extends(JsonRpcProvider, _super);\n    function JsonRpcProvider(url, network) {\n        var _this = this;\n        var networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise(function (resolve, reject) {\n                setTimeout(function () {\n                    _this.detectNetwork().then(function (network) {\n                        resolve(network);\n                    }, function (error) {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        _this = _super.call(this, networkOrReady) || this;\n        // Default URL\n        if (!url) {\n            url = (0, properties_1.getStatic)(_this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            (0, properties_1.defineReadOnly)(_this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            (0, properties_1.defineReadOnly)(_this, \"connection\", Object.freeze((0, properties_1.shallowCopy)(url)));\n        }\n        _this._nextId = 42;\n        return _this;\n    }\n    Object.defineProperty(JsonRpcProvider.prototype, \"_cache\", {\n        get: function () {\n            if (this._eventLoopCache == null) {\n                this._eventLoopCache = {};\n            }\n            return this._eventLoopCache;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    JsonRpcProvider.defaultUrl = function () {\n        return \"http:/\\/localhost:8545\";\n    };\n    JsonRpcProvider.prototype.detectNetwork = function () {\n        var _this = this;\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(function () {\n                _this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    };\n    JsonRpcProvider.prototype._uncachedDetectNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var chainId, error_5, error_6, getNetwork;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, timer(0)];\n                    case 1:\n                        _a.sent();\n                        chainId = null;\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 9]);\n                        return [4 /*yield*/, this.send(\"eth_chainId\", [])];\n                    case 3:\n                        chainId = _a.sent();\n                        return [3 /*break*/, 9];\n                    case 4:\n                        error_5 = _a.sent();\n                        _a.label = 5;\n                    case 5:\n                        _a.trys.push([5, 7, , 8]);\n                        return [4 /*yield*/, this.send(\"net_version\", [])];\n                    case 6:\n                        chainId = _a.sent();\n                        return [3 /*break*/, 8];\n                    case 7:\n                        error_6 = _a.sent();\n                        return [3 /*break*/, 8];\n                    case 8: return [3 /*break*/, 9];\n                    case 9:\n                        if (chainId != null) {\n                            getNetwork = (0, properties_1.getStatic)(this.constructor, \"getNetwork\");\n                            try {\n                                return [2 /*return*/, getNetwork(bignumber_1.BigNumber.from(chainId).toNumber())];\n                            }\n                            catch (error) {\n                                return [2 /*return*/, logger.throwError(\"could not detect network\", logger_1.Logger.errors.NETWORK_ERROR, {\n                                        chainId: chainId,\n                                        event: \"invalidNetwork\",\n                                        serverError: error\n                                    })];\n                            }\n                        }\n                        return [2 /*return*/, logger.throwError(\"could not detect network\", logger_1.Logger.errors.NETWORK_ERROR, {\n                                event: \"noNetwork\"\n                            })];\n                }\n            });\n        });\n    };\n    JsonRpcProvider.prototype.getSigner = function (addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    };\n    JsonRpcProvider.prototype.getUncheckedSigner = function (addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    };\n    JsonRpcProvider.prototype.listAccounts = function () {\n        var _this = this;\n        return this.send(\"eth_accounts\", []).then(function (accounts) {\n            return accounts.map(function (a) { return _this.formatter.address(a); });\n        });\n    };\n    JsonRpcProvider.prototype.send = function (method, params) {\n        var _this = this;\n        var request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: (0, properties_1.deepCopy)(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        var cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        var result = (0, web_1.fetchJson)(this.connection, JSON.stringify(request), getResult).then(function (result) {\n            _this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: _this\n            });\n            return result;\n        }, function (error) {\n            _this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: _this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(function () {\n                _this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    };\n    JsonRpcProvider.prototype.prepareRequest = function (method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), (0, bytes_1.hexZeroPad)(params.position, 32), params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                var hexlifyTransaction = (0, properties_1.getStatic)(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                var hexlifyTransaction = (0, properties_1.getStatic)(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    };\n    JsonRpcProvider.prototype.perform = function (method, params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tx, feeData, args, error_7;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(method === \"call\" || method === \"estimateGas\")) return [3 /*break*/, 2];\n                        tx = params.transaction;\n                        if (!(tx && tx.type != null && bignumber_1.BigNumber.from(tx.type).isZero())) return [3 /*break*/, 2];\n                        if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.getFeeData()];\n                    case 1:\n                        feeData = _a.sent();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = (0, properties_1.shallowCopy)(params);\n                            params.transaction = (0, properties_1.shallowCopy)(tx);\n                            delete params.transaction.type;\n                        }\n                        _a.label = 2;\n                    case 2:\n                        args = this.prepareRequest(method, params);\n                        if (args == null) {\n                            logger.throwError(method + \" not implemented\", logger_1.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n                        }\n                        _a.label = 3;\n                    case 3:\n                        _a.trys.push([3, 5, , 6]);\n                        return [4 /*yield*/, this.send(args[0], args[1])];\n                    case 4: return [2 /*return*/, _a.sent()];\n                    case 5:\n                        error_7 = _a.sent();\n                        return [2 /*return*/, checkError(method, error_7, params)];\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    JsonRpcProvider.prototype._startEvent = function (event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        _super.prototype._startEvent.call(this, event);\n    };\n    JsonRpcProvider.prototype._startPending = function () {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        var self = this;\n        var pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    var seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch(function (error) { });\n            }\n            poll();\n            return filterId;\n        }).catch(function (error) { });\n    };\n    JsonRpcProvider.prototype._stopEvent = function (event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        _super.prototype._stopEvent.call(this, event);\n    };\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    JsonRpcProvider.hexlifyTransaction = function (transaction, allowExtra) {\n        // Check only allowed properties are given\n        var allowed = (0, properties_1.shallowCopy)(allowedTransactionKeys);\n        if (allowExtra) {\n            for (var key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        (0, properties_1.checkProperties)(transaction, allowed);\n        var result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            var value = (0, bytes_1.hexValue)(bignumber_1.BigNumber.from(transaction[key]));\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = (0, bytes_1.hexlify)(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = (0, transactions_1.accessListify)(transaction.accessList);\n        }\n        return result;\n    };\n    return JsonRpcProvider;\n}(base_provider_1.BaseProvider));\nexports.JsonRpcProvider = JsonRpcProvider;\n//# sourceMappingURL=json-rpc-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2pzb24tcnBjLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxxQkFBcUI7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMsb0tBQWdDO0FBQ2hF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QUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2pzb24tcnBjLXByb3ZpZGVyLmpzP2IzNGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0gZXhwb3J0cy5Kc29uUnBjU2lnbmVyID0gdm9pZCAwO1xudmFyIGFic3RyYWN0X3NpZ25lcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lclwiKTtcbnZhciBiaWdudW1iZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIik7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiKTtcbnZhciBoYXNoXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiKTtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnNcIik7XG52YXIgd2ViXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3Qvd2ViXCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xudmFyIGJhc2VfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2Jhc2UtcHJvdmlkZXJcIik7XG52YXIgZXJyb3JHYXMgPSBbXCJjYWxsXCIsIFwiZXN0aW1hdGVHYXNcIl07XG5mdW5jdGlvbiBzcGVsdW5rKHZhbHVlLCByZXF1aXJlRGF0YSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1lc3NhZ2UubWF0Y2goXCJyZXZlcnRlZFwiKSkge1xuICAgICAgICB2YXIgZGF0YSA9ICgwLCBieXRlc18xLmlzSGV4U3RyaW5nKSh2YWx1ZS5kYXRhKSA/IHZhbHVlLmRhdGEgOiBudWxsO1xuICAgICAgICBpZiAoIXJlcXVpcmVEYXRhIHx8IGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc3BlbHVuayh2YWx1ZVtrZXldLCByZXF1aXJlRGF0YSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlbHVuayhKU09OLnBhcnNlKHZhbHVlKSwgcmVxdWlyZURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2hlY2tFcnJvcihtZXRob2QsIGVycm9yLCBwYXJhbXMpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb24gPSBwYXJhbXMudHJhbnNhY3Rpb24gfHwgcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uO1xuICAgIC8vIFVuZG8gdGhlIFwiY29udmVuaWVuY2VcIiBzb21lIG5vZGVzIGFyZSBhdHRlbXB0aW5nIHRvIHByZXZlbnQgYmFja3dhcmRzXG4gICAgLy8gaW5jb21wYXRpYmlsaXR5OyBtYXliZSBmb3IgdjYgY29uc2lkZXIgZm9yd2FyZGluZyByZXZlcnRzIGFzIGVycm9yc1xuICAgIGlmIChtZXRob2QgPT09IFwiY2FsbFwiKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBzcGVsdW5rKGVycm9yLCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGhpbmcgZGVzY3JpcHRpdmUuLlxuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcmV2ZXJ0IGRhdGEgaW4gY2FsbCBleGNlcHRpb247IFRyYW5zYWN0aW9uIHJldmVydGVkIHdpdGhvdXQgYSByZWFzb24gc3RyaW5nXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgIGRhdGE6IFwiMHhcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgIC8vIFRyeSB0byBmaW5kIHNvbWV0aGluZywgd2l0aCBhIHByZWZlcmVuY2Ugb24gU0VSVkVSX0VSUk9SIGJvZHlcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNwZWx1bmsoZXJyb3IuYm9keSwgZmFsc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNwZWx1bmsoZXJyb3IsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3VuZCBcInJldmVydGVkXCIsIHRoaXMgaXMgYSBDQUxMX0VYQ0VQVElPTlxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0Lm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQFRPRE86IFNob3VsZCB3ZSBzcGVsdW5rIGZvciBtZXNzYWdlIHRvbz9cbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09IGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SICYmIGVycm9yLmVycm9yICYmIHR5cGVvZiAoZXJyb3IuZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLmVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IuYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLmJvZHk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IucmVzcG9uc2VUZXh0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgICBtZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBcImluc3VmZmljaWVudCBmdW5kcyBmb3IgZ2FzICogcHJpY2UgKyB2YWx1ZSArIGNvc3QoZGF0YSlcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHN8YmFzZSBmZWUgZXhjZWVkcyBnYXMgbGltaXQvaSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJub25jZSB0b28gbG93XCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UgKGlzICk/dG9vIGxvdy9pKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvcmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWR8dHJhbnNhY3Rpb24gZ2FzIHByaWNlLip0b28gbG93L2kpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCwge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9vbmx5IHJlcGxheS1wcm90ZWN0ZWQvaSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyb3JHYXMuaW5kZXhPZihtZXRob2QpID49IDAgJiYgbWVzc2FnZS5tYXRjaCgvZ2FzIHJlcXVpcmVkIGV4Y2VlZHMgYWxsb3dhbmNlfGFsd2F5cyBmYWlsaW5nIHRyYW5zYWN0aW9ufGV4ZWN1dGlvbiByZXZlcnRlZC8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiB0aW1lcih0aW1lb3V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRSZXN1bHQocGF5bG9hZCkge1xuICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xuICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQucmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG52YXIgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbnZhciBKc29uUnBjU2lnbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhKc29uUnBjU2lnbmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpzb25ScGNTaWduZXIoY29uc3RydWN0b3JHdWFyZCwgcHJvdmlkZXIsIGFkZHJlc3NPckluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZG8gbm90IGNhbGwgdGhlIEpzb25ScGNTaWduZXIgY29uc3RydWN0b3IgZGlyZWN0bHk7IHVzZSBwcm92aWRlci5nZXRTaWduZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuICAgICAgICBpZiAoYWRkcmVzc09ySW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkcmVzc09ySW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3NPckluZGV4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX2FkZHJlc3NcIiwgX3RoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzc09ySW5kZXgpKTtcbiAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl9pbmRleFwiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGFkZHJlc3NPckluZGV4KSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX2luZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcbiAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl9hZGRyZXNzXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBpbmRleFwiLCBcImFkZHJlc3NPckluZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGFsdGVyIEpTT04tUlBDIFNpZ25lciBjb25uZWN0aW9uXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuY29ubmVjdFVuY2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmNoZWNrZWRKc29uUnBjU2lnbmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0aGlzLnByb3ZpZGVyLCB0aGlzLl9hZGRyZXNzIHx8IHRoaXMuX2luZGV4KTtcbiAgICB9O1xuICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9hZGRyZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2FkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pLnRoZW4oZnVuY3Rpb24gKGFjY291bnRzKSB7XG4gICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoIDw9IF90aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBhY2NvdW50ICNcIiArIF90aGlzLl9pbmRleCwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEFkZHJlc3NcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFjY291bnRzW190aGlzLl9pbmRleF0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0cmFuc2FjdGlvbiA9ICgwLCBwcm9wZXJ0aWVzXzEuc2hhbGxvd0NvcHkpKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgdmFyIGZyb21BZGRyZXNzID0gdGhpcy5nZXRBZGRyZXNzKCkudGhlbihmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgSlNPTi1SUEMgZm9yIGV0aF9zZW5kVHJhbnNhY3Rpb24gdXNlcyA5MDAwMCBnYXM7IGlmIHRoZSB1c2VyXG4gICAgICAgIC8vIHdpc2hlcyB0byB1c2UgdGhpcywgaXQgaXMgZWFzeSB0byBzcGVjaWZ5IGV4cGxpY2l0bHksIG90aGVyd2lzZVxuICAgICAgICAvLyB3ZSBsb29rIGl0IHVwIGZvciB0aGVtLlxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGVzdGltYXRlID0gKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgZXN0aW1hdGUuZnJvbSA9IGZyb21BZGRyZXNzO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKGVzdGltYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24udG8pLnRoZW4oZnVuY3Rpb24gKHRvKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKHRvKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlZCBFTlMgbmFtZSByZXNvbHZlcyB0byBudWxsXCIsIFwidHgudG9cIiwgdG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYWRkcmVzc107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHByb3BlcnRpZXNfMS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgdHg6ICgwLCBwcm9wZXJ0aWVzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgIHNlbmRlcjogZnJvbUFkZHJlc3NcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0eCA9IF9hLnR4LCBzZW5kZXIgPSBfYS5zZW5kZXI7XG4gICAgICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmZyb20udG9Mb3dlckNhc2UoKSAhPT0gc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IHNlbmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZXhUeCA9IF90aGlzLnByb3ZpZGVyLmNvbnN0cnVjdG9yLmhleGxpZnlUcmFuc2FjdGlvbih0eCwgeyBmcm9tOiB0cnVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsIFtoZXhUeF0pLnRoZW4oZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlciByZWplY3RlZCB0cmFuc2FjdGlvblwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFcnJvcihcInNlbmRUcmFuc2FjdGlvblwiLCBlcnJvciwgaGV4VHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuc2lnblRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInNpZ25pbmcgdHJhbnNhY3Rpb25zIGlzIHVuc3VwcG9ydGVkXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2lnblRyYW5zYWN0aW9uXCJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyLCBoYXNoLCBlcnJvcl8xO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wcm92aWRlci5wb2xsaW5nSW50ZXJ2YWwpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHdlYl8xLnBvbGwpKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnByb3ZpZGVyLl93cmFwVHJhbnNhY3Rpb24odHgsIGhhc2gsIGJsb2NrTnVtYmVyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9LCB7IG9uY2VQb2xsOiB0aGlzLnByb3ZpZGVyIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGEgcmVzcG9uc2UsIGFuZCB3ZSBuZWVkIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb24sIHNvIHdlIHBvbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGl0OyBpdCBzaG91bGQgc2hvdyB1cCB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xLnRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5zaWduTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBhZGRyZXNzLCBlcnJvcl8yO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyAoMCwgc3RyaW5nc18xLnRvVXRmOEJ5dGVzKShtZXNzYWdlKSA6IG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRBZGRyZXNzKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzIsIDQsICwgNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbKDAsIGJ5dGVzXzEuaGV4bGlmeSkoZGF0YSksIGFkZHJlc3MudG9Mb3dlckNhc2UoKV0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGVycm9yXzIubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3JfMi5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlciByZWplY3RlZCBzaWduaW5nXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuQUNUSU9OX1JFSkVDVEVELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJzaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl8yO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5fbGVnYWN5U2lnbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSwgYWRkcmVzcywgZXJyb3JfMztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAoKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gKDAsIHN0cmluZ3NfMS50b1V0ZjhCeXRlcykobWVzc2FnZSkgOiBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QWRkcmVzcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsyLCA0LCAsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksICgwLCBieXRlc18xLmhleGxpZnkpKGRhdGEpXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0pTT04tUlBDI2V0aF9zaWduXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8zID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3JfMy5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvcl8zLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2VyIHJlamVjdGVkIHNpZ25pbmdcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5BQ1RJT05fUkVKRUNURUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIl9sZWdhY3lTaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl8zO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5fc2lnblR5cGVkRGF0YSA9IGZ1bmN0aW9uIChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9wdWxhdGVkLCBhZGRyZXNzLCBlcnJvcl80O1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgaGFzaF8xLl9UeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlZCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QWRkcmVzcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFszLCA1LCAsIDZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHlwZWREYXRhX3Y0XCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShoYXNoXzEuX1R5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvcl80Lm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yXzQubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgc2lnbmluZ1wiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiX3NpZ25UeXBlZERhdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogeyBkb21haW46IHBvcHVsYXRlZC5kb21haW4sIHR5cGVzOiB0eXBlcywgdmFsdWU6IHBvcHVsYXRlZC52YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl80O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS51bmxvY2sgPSBmdW5jdGlvbiAocGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyLCBhZGRyZXNzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRBZGRyZXNzKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBKc29uUnBjU2lnbmVyO1xufShhYnN0cmFjdF9zaWduZXJfMS5TaWduZXIpKTtcbmV4cG9ydHMuSnNvblJwY1NpZ25lciA9IEpzb25ScGNTaWduZXI7XG52YXIgVW5jaGVja2VkSnNvblJwY1NpZ25lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVW5jaGVja2VkSnNvblJwY1NpZ25lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbmNoZWNrZWRKc29uUnBjU2lnbmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFVuY2hlY2tlZEpzb25ScGNTaWduZXIucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pLnRoZW4oZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgICAgICBub25jZTogbnVsbCxcbiAgICAgICAgICAgICAgICBnYXNMaW1pdDogbnVsbCxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY29uZmlybWF0aW9uczogMCxcbiAgICAgICAgICAgICAgICBmcm9tOiBudWxsLFxuICAgICAgICAgICAgICAgIHdhaXQ6IGZ1bmN0aW9uIChjb25maXJtYXRpb25zKSB7IHJldHVybiBfdGhpcy5wcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgY29uZmlybWF0aW9ucyk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFVuY2hlY2tlZEpzb25ScGNTaWduZXI7XG59KEpzb25ScGNTaWduZXIpKTtcbnZhciBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB2YWx1ZTogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLCBhY2Nlc3NMaXN0OiB0cnVlLFxuICAgIG1heEZlZVBlckdhczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWVcbn07XG52YXIgSnNvblJwY1Byb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhKc29uUnBjUHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSnNvblJwY1Byb3ZpZGVyKHVybCwgbmV0d29yaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbmV0d29ya09yUmVhZHkgPSBuZXR3b3JrO1xuICAgICAgICAvLyBUaGUgbmV0d29yayBpcyB1bmtub3duLCBxdWVyeSB0aGUgSlNPTi1SUEMgZm9yIGl0XG4gICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXR3b3JrT3JSZWFkeSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGV0ZWN0TmV0d29yaygpLnRoZW4oZnVuY3Rpb24gKG5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ldHdvcmtPclJlYWR5KSB8fCB0aGlzO1xuICAgICAgICAvLyBEZWZhdWx0IFVSTFxuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgdXJsID0gKDAsIHByb3BlcnRpZXNfMS5nZXRTdGF0aWMpKF90aGlzLmNvbnN0cnVjdG9yLCBcImRlZmF1bHRVcmxcIikoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJjb25uZWN0aW9uXCIsIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJjb25uZWN0aW9uXCIsIE9iamVjdC5mcmVlemUoKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkodXJsKSkpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9uZXh0SWQgPSA0MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZSwgXCJfY2FjaGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudExvb3BDYWNoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRMb29wQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudExvb3BDYWNoZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEpzb25ScGNQcm92aWRlci5kZWZhdWx0VXJsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJodHRwOi9cXC9sb2NhbGhvc3Q6ODU0NVwiO1xuICAgIH07XG4gICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdID0gdGhpcy5fdW5jYWNoZWREZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGlzIGNhY2hlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgZXZlbnQgbG9vcFxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdO1xuICAgIH07XG4gICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5fdW5jYWNoZWREZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5JZCwgZXJyb3JfNSwgZXJyb3JfNiwgZ2V0TmV0d29yaztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGltZXIoMCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsyLCA0LCAsIDldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2VuZChcImV0aF9jaGFpbklkXCIsIFtdKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfNSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFs1LCA3LCAsIDhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2VuZChcIm5ldF92ZXJzaW9uXCIsIFtdKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfNiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TmV0d29yayA9ICgwLCBwcm9wZXJ0aWVzXzEuZ2V0U3RhdGljKSh0aGlzLmNvbnN0cnVjdG9yLCBcImdldE5ldHdvcmtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldE5ldHdvcmsoYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiaW52YWxpZE5ldHdvcmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJjb3VsZCBub3QgZGV0ZWN0IG5ldHdvcmtcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcIm5vTmV0d29ya1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZ2V0U2lnbmVyID0gZnVuY3Rpb24gKGFkZHJlc3NPckluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcihfY29uc3RydWN0b3JHdWFyZCwgdGhpcywgYWRkcmVzc09ySW5kZXgpO1xuICAgIH07XG4gICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5nZXRVbmNoZWNrZWRTaWduZXIgPSBmdW5jdGlvbiAoYWRkcmVzc09ySW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2lnbmVyKGFkZHJlc3NPckluZGV4KS5jb25uZWN0VW5jaGVja2VkKCk7XG4gICAgfTtcbiAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLmxpc3RBY2NvdW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSkudGhlbihmdW5jdGlvbiAoYWNjb3VudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIF90aGlzLmZvcm1hdHRlci5hZGRyZXNzKGEpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgaWQ6ICh0aGlzLl9uZXh0SWQrKyksXG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICByZXF1ZXN0OiAoMCwgcHJvcGVydGllc18xLmRlZXBDb3B5KShyZXF1ZXN0KSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBjYW4gZXhwYW5kIHRoaXMgaW4gdGhlIGZ1dHVyZSB0byBhbnkgY2FsbCwgYnV0IGZvciBub3cgdGhlc2VcbiAgICAgICAgLy8gYXJlIHRoZSBiaWdnZXN0IHdpbnMgYW5kIGRvIG5vdCByZXF1aXJlIGFueSBzZXJpYWxpemluZyBwYXJhbWV0ZXJzLlxuICAgICAgICB2YXIgY2FjaGUgPSAoW1wiZXRoX2NoYWluSWRcIiwgXCJldGhfYmxvY2tOdW1iZXJcIl0uaW5kZXhPZihtZXRob2QpID49IDApO1xuICAgICAgICBpZiAoY2FjaGUgJiYgdGhpcy5fY2FjaGVbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW21ldGhvZF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCB3ZWJfMS5mZXRjaEpzb24pKHRoaXMuY29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksIGdldFJlc3VsdCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENhY2hlIHRoZSBmZXRjaCwgYnV0IGNsZWFyIGl0IG9uIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gcmVzdWx0O1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NhY2hlW21ldGhvZF0gPSBudWxsO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUucHJlcGFyZVJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfYmxvY2tOdW1iZXJcIiwgW11dO1xuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nYXNQcmljZVwiLCBbXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmFsYW5jZVwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0Q29kZVwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZUF0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRTdG9yYWdlQXRcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksICgwLCBieXRlc18xLmhleFplcm9QYWQpKHBhcmFtcy5wb3NpdGlvbiwgMzIpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJzZW5kVHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLCBbcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLCBbcGFyYW1zLmJsb2NrVGFnLCAhIXBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtcy5ibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCbG9ja0J5SGFzaFwiLCBbcGFyYW1zLmJsb2NrSGFzaCwgISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBbcGFyYW1zLnRyYW5zYWN0aW9uSGFzaF1dO1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjoge1xuICAgICAgICAgICAgICAgIHZhciBoZXhsaWZ5VHJhbnNhY3Rpb24gPSAoMCwgcHJvcGVydGllc18xLmdldFN0YXRpYykodGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9jYWxsXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSksIHBhcmFtcy5ibG9ja1RhZ11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICB2YXIgaGV4bGlmeVRyYW5zYWN0aW9uID0gKDAsIHByb3BlcnRpZXNfMS5nZXRTdGF0aWMpKHRoaXMuY29uc3RydWN0b3IsIFwiaGV4bGlmeVRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZXN0aW1hdGVHYXNcIiwgW2hleGxpZnlUcmFuc2FjdGlvbihwYXJhbXMudHJhbnNhY3Rpb24sIHsgZnJvbTogdHJ1ZSB9KV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlciAmJiBwYXJhbXMuZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyLmFkZHJlc3MgPSBnZXRMb3dlckNhc2UocGFyYW1zLmZpbHRlci5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRMb2dzXCIsIFtwYXJhbXMuZmlsdGVyXV07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eCwgZmVlRGF0YSwgYXJncywgZXJyb3JfNztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1ldGhvZCA9PT0gXCJjYWxsXCIgfHwgbWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gcGFyYW1zLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHggJiYgdHgudHlwZSAhPSBudWxsICYmIGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHR4LnR5cGUpLmlzWmVybygpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEZlZURhdGEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlZURhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qga25vdyBhYm91dCBFSVAtMTU1OSAoYW5kIGhlbmNlIHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHJhbnNhY3Rpb24gPSAoMCwgcHJvcGVydGllc18xLnNoYWxsb3dDb3B5KSh0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy50cmFuc2FjdGlvbi50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gdGhpcy5wcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zZW5kKGFyZ3NbMF0sIGFyZ3NbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfNyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjaGVja0Vycm9yKG1ldGhvZCwgZXJyb3JfNywgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuX3N0YXJ0RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0UGVuZGluZygpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3N0YXJ0RXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbiAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLl9zdGFydFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwZW5kaW5nRmlsdGVyID0gdGhpcy5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdGaWx0ZXIgPSBwZW5kaW5nRmlsdGVyO1xuICAgICAgICBwZW5kaW5nRmlsdGVyLnRoZW4oZnVuY3Rpb24gKGZpbHRlcklkKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2xsKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VuZChcImV0aF9nZXRGaWx0ZXJDaGFuZ2VzXCIsIFtmaWx0ZXJJZF0pLnRoZW4oZnVuY3Rpb24gKGhhc2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VxID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogVGhpcyBzaG91bGQgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYXQgc29tZSBwb2ludC4uLiBIb3c/IFdoZW4/XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9lbWl0dGVkW1widDpcIiArIGhhc2gudG9Mb3dlckNhc2UoKV0gPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcSA9IHNlcS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRUcmFuc2FjdGlvbihoYXNoKS50aGVuKGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJwZW5kaW5nXCIsIHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZXIoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBwb2xsKCk7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2xsKCk7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuX3N0b3BFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFnID09PSBcInBlbmRpbmdcIiAmJiB0aGlzLmxpc3RlbmVyQ291bnQoXCJwZW5kaW5nXCIpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9zdG9wRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbiAgICAvLyBDb252ZXJ0IGFuIGV0aGVycy5qcyB0cmFuc2FjdGlvbiBpbnRvIGEgSlNPTi1SUEMgdHJhbnNhY3Rpb25cbiAgICAvLyAgLSBnYXNMaW1pdCA9PiBnYXNcbiAgICAvLyAgLSBBbGwgdmFsdWVzIGhleGxpZmllZFxuICAgIC8vICAtIEFsbCBudW1lcmljIHZhbHVlcyB6ZXJvLXN0cmlwZWRcbiAgICAvLyAgLSBBbGwgYWRkcmVzc2VzIGFyZSBsb3dlcmNhc2VkXG4gICAgLy8gTk9URTogVGhpcyBhbGxvd3MgYSBUcmFuc2FjdGlvblJlcXVlc3QsIGJ1dCBhbGwgdmFsdWVzIHNob3VsZCBiZSByZXNvbHZlZFxuICAgIC8vICAgICAgIGJlZm9yZSB0aGlzIGlzIGNhbGxlZFxuICAgIC8vIEBUT0RPOiBUaGlzIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zIGFuZCBwcmVwYXJlUmVxdWVzdFxuICAgIC8vICAgICAgICB3aWxsIGJlIHRoZSBwcmVmZXJyZWQgbWV0aG9kIGZvciB0aGlzLlxuICAgIEpzb25ScGNQcm92aWRlci5oZXhsaWZ5VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGFsbG93RXh0cmEpIHtcbiAgICAgICAgLy8gQ2hlY2sgb25seSBhbGxvd2VkIHByb3BlcnRpZXMgYXJlIGdpdmVuXG4gICAgICAgIHZhciBhbGxvd2VkID0gKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkoYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyk7XG4gICAgICAgIGlmIChhbGxvd0V4dHJhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0V4dHJhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5jaGVja1Byb3BlcnRpZXMpKHRyYW5zYWN0aW9uLCBhbGxvd2VkKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAvLyBKU09OLVJQQyBub3cgcmVxdWlyZXMgbnVtZXJpYyB2YWx1ZXMgdG8gYmUgXCJxdWFudGl0eVwiIHZhbHVlc1xuICAgICAgICBbXCJjaGFpbklkXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcInR5cGVcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidmFsdWVcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gKDAsIGJ5dGVzXzEuaGV4VmFsdWUpKGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uW2tleV0pKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZ2FzTGltaXRcIikge1xuICAgICAgICAgICAgICAgIGtleSA9IFwiZ2FzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgW1wiZnJvbVwiLCBcInRvXCIsIFwiZGF0YVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9ICgwLCBieXRlc18xLmhleGxpZnkpKHRyYW5zYWN0aW9uW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtcImFjY2Vzc0xpc3RcIl0gPSAoMCwgdHJhbnNhY3Rpb25zXzEuYWNjZXNzTGlzdGlmeSkodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBKc29uUnBjUHJvdmlkZXI7XG59KGJhc2VfcHJvdmlkZXJfMS5CYXNlUHJvdmlkZXIpKTtcbmV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0gSnNvblJwY1Byb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1ycGMtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/nodesmith-provider.js":
/*!************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/nodesmith-provider.js ***!
  \************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/* istanbul ignore file */\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NodesmithProvider = void 0;\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\n// Special API key provided by Nodesmith for ethers.js\nvar defaultApiKey = \"ETHERS_JS_SHARED\";\nvar NodesmithProvider = /** @class */ (function (_super) {\n    __extends(NodesmithProvider, _super);\n    function NodesmithProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NodesmithProvider.getApiKey = function (apiKey) {\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    };\n    NodesmithProvider.getUrl = function (network, apiKey) {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n        var host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return (host + \"?apiKey=\" + apiKey);\n    };\n    return NodesmithProvider;\n}(url_json_rpc_provider_1.UrlJsonRpcProvider));\nexports.NodesmithProvider = NodesmithProvider;\n//# sourceMappingURL=nodesmith-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL25vZGVzbWl0aC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6Qiw4QkFBOEIsbUJBQU8sQ0FBQyxrTEFBeUI7QUFDL0QsZUFBZSxtQkFBTyxDQUFDLHlJQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyx3SkFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi9ub2Rlc21pdGgtcHJvdmlkZXIuanM/ZDRjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob2Rlc21pdGhQcm92aWRlciA9IHZvaWQgMDtcbnZhciB1cmxfanNvbl9ycGNfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbi8vIFNwZWNpYWwgQVBJIGtleSBwcm92aWRlZCBieSBOb2Rlc21pdGggZm9yIGV0aGVycy5qc1xudmFyIGRlZmF1bHRBcGlLZXkgPSBcIkVUSEVSU19KU19TSEFSRURcIjtcbnZhciBOb2Rlc21pdGhQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm9kZXNtaXRoUHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9kZXNtaXRoUHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTm9kZXNtaXRoUHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ICYmIHR5cGVvZiAoYXBpS2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXBpS2V5XCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwaUtleSB8fCBkZWZhdWx0QXBpS2V5O1xuICAgIH07XG4gICAgTm9kZXNtaXRoUHJvdmlkZXIuZ2V0VXJsID0gZnVuY3Rpb24gKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBsb2dnZXIud2FybihcIk5vZGVTbWl0aCB3aWxsIGJlIGRpc2NvbnRpbnVlZCBvbiAyMDE5LTEyLTIwOyBwbGVhc2UgbWlncmF0ZSB0byBhbm90aGVyIHBsYXRmb3JtLlwiKTtcbiAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9tYWlubmV0L2pzb25ycGNcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL3JvcHN0ZW4vanNvbnJwY1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpbmtlYnlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvcmlua2VieS9qc29ucnBjXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL2dvZXJsaS9qc29ucnBjXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEva292YW4vanNvbnJwY1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGhvc3QgKyBcIj9hcGlLZXk9XCIgKyBhcGlLZXkpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vZGVzbWl0aFByb3ZpZGVyO1xufSh1cmxfanNvbl9ycGNfcHJvdmlkZXJfMS5VcmxKc29uUnBjUHJvdmlkZXIpKTtcbmV4cG9ydHMuTm9kZXNtaXRoUHJvdmlkZXIgPSBOb2Rlc21pdGhQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vZGVzbWl0aC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/nodesmith-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/pocket-provider.js":
/*!*********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/pocket-provider.js ***!
  \*********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PocketProvider = void 0;\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\nvar defaultApplicationId = \"62e1ad51b37b8e00394bda3b\";\nvar PocketProvider = /** @class */ (function (_super) {\n    __extends(PocketProvider, _super);\n    function PocketProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PocketProvider.getApiKey = function (apiKey) {\n        var apiKeyObj = {\n            applicationId: null,\n            loadBalancer: true,\n            applicationSecretKey: null\n        };\n        // Parse applicationId and applicationSecretKey\n        if (apiKey == null) {\n            apiKeyObj.applicationId = defaultApplicationId;\n        }\n        else if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n        }\n        else if (apiKey.applicationSecretKey != null) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n        }\n        else if (apiKey.applicationId) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n        }\n        else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKeyObj;\n    };\n    PocketProvider.getUrl = function (network, apiKey) {\n        var host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"kovan\":\n                host = \"poa-kovan.gateway.pokt.network\";\n                break;\n            case \"matic\":\n                host = \"poly-mainnet.gateway.pokt.network\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai-rpc.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", logger_1.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        var url = \"https://\" + host + \"/v1/lb/\" + apiKey.applicationId;\n        var connection = { headers: {}, url: url };\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey;\n        }\n        return connection;\n    };\n    PocketProvider.prototype.isCommunityResource = function () {\n        return (this.applicationId === defaultApplicationId);\n    };\n    return PocketProvider;\n}(url_json_rpc_provider_1.UrlJsonRpcProvider));\nexports.PocketProvider = PocketProvider;\n//# sourceMappingURL=pocket-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3BvY2tldC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsZUFBZSxtQkFBTyxDQUFDLHlJQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyx3SkFBWTtBQUNyQztBQUNBLDhCQUE4QixtQkFBTyxDQUFDLGtMQUF5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi9wb2NrZXQtcHJvdmlkZXIuanM/Yzc0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xudmFyIHVybF9qc29uX3JwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vdXJsLWpzb24tcnBjLXByb3ZpZGVyXCIpO1xudmFyIGRlZmF1bHRBcHBsaWNhdGlvbklkID0gXCI2MmUxYWQ1MWIzN2I4ZTAwMzk0YmRhM2JcIjtcbnZhciBQb2NrZXRQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9ja2V0UHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUG9ja2V0UHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgUG9ja2V0UHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuICAgICAgICB2YXIgYXBpS2V5T2JqID0ge1xuICAgICAgICAgICAgYXBwbGljYXRpb25JZDogbnVsbCxcbiAgICAgICAgICAgIGxvYWRCYWxhbmNlcjogdHJ1ZSxcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uU2VjcmV0S2V5OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFBhcnNlIGFwcGxpY2F0aW9uSWQgYW5kIGFwcGxpY2F0aW9uU2VjcmV0S2V5XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5T2JqLmFwcGxpY2F0aW9uSWQgPSBkZWZhdWx0QXBwbGljYXRpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGFwaUtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFwaUtleU9iai5hcHBsaWNhdGlvbklkID0gYXBpS2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwaUtleS5hcHBsaWNhdGlvblNlY3JldEtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcGlLZXlPYmouYXBwbGljYXRpb25JZCA9IGFwaUtleS5hcHBsaWNhdGlvbklkO1xuICAgICAgICAgICAgYXBpS2V5T2JqLmFwcGxpY2F0aW9uU2VjcmV0S2V5ID0gYXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwaUtleS5hcHBsaWNhdGlvbklkKSB7XG4gICAgICAgICAgICBhcGlLZXlPYmouYXBwbGljYXRpb25JZCA9IGFwaUtleS5hcHBsaWNhdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIFBvY2tldFByb3ZpZGVyIGFwaUtleVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcGlLZXlPYmo7XG4gICAgfTtcbiAgICBQb2NrZXRQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIHZhciBob3N0ID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChuZXR3b3JrID8gbmV0d29yay5uYW1lIDogXCJ1bmtub3duXCIpIHtcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtZ29lcmxpLmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLW1haW5uZXQuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJrb3ZhblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvYS1rb3Zhbi5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwicG9seS1tYWlubmV0LmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNtdW1cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW11bWJhaS1ycGMuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJpbmtlYnkuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJvcHN0ZW4uZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJuZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXR3b3JrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IFwiaHR0cHM6Ly9cIiArIGhvc3QgKyBcIi92MS9sYi9cIiArIGFwaUtleS5hcHBsaWNhdGlvbklkO1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHsgaGVhZGVyczoge30sIHVybDogdXJsIH07XG4gICAgICAgIGlmIChhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51c2VyID0gXCJcIjtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucGFzc3dvcmQgPSBhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfTtcbiAgICBQb2NrZXRQcm92aWRlci5wcm90b3R5cGUuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwcGxpY2F0aW9uSWQgPT09IGRlZmF1bHRBcHBsaWNhdGlvbklkKTtcbiAgICB9O1xuICAgIHJldHVybiBQb2NrZXRQcm92aWRlcjtcbn0odXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLlBvY2tldFByb3ZpZGVyID0gUG9ja2V0UHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2NrZXQtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/pocket-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js":
/*!***************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UrlJsonRpcProvider = exports.StaticJsonRpcProvider = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nvar StaticJsonRpcProvider = /** @class */ (function (_super) {\n    __extends(StaticJsonRpcProvider, _super);\n    function StaticJsonRpcProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StaticJsonRpcProvider.prototype.detectNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var network;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        network = this.network;\n                        if (!(network == null)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, _super.prototype.detectNetwork.call(this)];\n                    case 1:\n                        network = _a.sent();\n                        if (!network) {\n                            logger.throwError(\"no network detected\", logger_1.Logger.errors.UNKNOWN_ERROR, {});\n                        }\n                        // If still not set, set it\n                        if (this._network == null) {\n                            // A static network does not support \"any\"\n                            (0, properties_1.defineReadOnly)(this, \"_network\", network);\n                            this.emit(\"network\", network, null);\n                        }\n                        _a.label = 2;\n                    case 2: return [2 /*return*/, network];\n                }\n            });\n        });\n    };\n    return StaticJsonRpcProvider;\n}(json_rpc_provider_1.JsonRpcProvider));\nexports.StaticJsonRpcProvider = StaticJsonRpcProvider;\nvar UrlJsonRpcProvider = /** @class */ (function (_super) {\n    __extends(UrlJsonRpcProvider, _super);\n    function UrlJsonRpcProvider(network, apiKey) {\n        var _newTarget = this.constructor;\n        var _this = this;\n        logger.checkAbstract(_newTarget, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = (0, properties_1.getStatic)(_newTarget, \"getNetwork\")(network);\n        apiKey = (0, properties_1.getStatic)(_newTarget, \"getApiKey\")(apiKey);\n        var connection = (0, properties_1.getStatic)(_newTarget, \"getUrl\")(network, apiKey);\n        _this = _super.call(this, connection, network) || this;\n        if (typeof (apiKey) === \"string\") {\n            (0, properties_1.defineReadOnly)(_this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach(function (key) {\n                (0, properties_1.defineReadOnly)(_this, key, apiKey[key]);\n            });\n        }\n        return _this;\n    }\n    UrlJsonRpcProvider.prototype._startPending = function () {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    };\n    UrlJsonRpcProvider.prototype.isCommunityResource = function () {\n        return false;\n    };\n    UrlJsonRpcProvider.prototype.getSigner = function (address) {\n        return logger.throwError(\"API provider does not support signing\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    };\n    UrlJsonRpcProvider.prototype.listAccounts = function () {\n        return Promise.resolve([]);\n    };\n    // Return a defaultApiKey if null, otherwise validate the API key\n    UrlJsonRpcProvider.getApiKey = function (apiKey) {\n        return apiKey;\n    };\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    UrlJsonRpcProvider.getUrl = function (network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", logger_1.Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    };\n    return UrlJsonRpcProvider;\n}(StaticJsonRpcProvider));\nexports.UrlJsonRpcProvider = UrlJsonRpcProvider;\n//# sourceMappingURL=url-json-rpc-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3VybC1qc29uLXJwYy1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsNkJBQTZCO0FBQzFELG1CQUFtQixtQkFBTyxDQUFDLHFKQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMseUlBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHdKQUFZO0FBQ3JDO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsMEtBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBILHdCQUF3QjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi91cmwtanNvbi1ycGMtcHJvdmlkZXIuanM/M2E2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VcmxKc29uUnBjUHJvdmlkZXIgPSBleHBvcnRzLlN0YXRpY0pzb25ScGNQcm92aWRlciA9IHZvaWQgMDtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBqc29uX3JwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vanNvbi1ycGMtcHJvdmlkZXJcIik7XG4vLyBBIFN0YXRpY0pzb25ScGNQcm92aWRlciBpcyB1c2VmdWwgd2hlbiB5b3UgKmtub3cqIGZvciBjZXJ0YWluIHRoYXRcbi8vIHRoZSBiYWNrZW5kIHdpbGwgbmV2ZXIgY2hhbmdlLCBhcyBpdCBuZXZlciBjYWxscyBldGhfY2hhaW5JZCB0b1xuLy8gdmVyaWZ5IGl0cyBiYWNrZW5kLiBIb3dldmVyLCBpZiB0aGUgYmFja2VuZCBkb2VzIGNoYW5nZSwgdGhlIGVmZmVjdHNcbi8vIGFyZSB1bmRlZmluZWQgYW5kIG1heSBpbmNsdWRlOlxuLy8gLSBpbmNvbnNpc3RlbnQgcmVzdWx0c1xuLy8gLSBsb2NraW5nIHVwIHRoZSBVSVxuLy8gLSBibG9jayBza2V3IHdhcm5pbmdzXG4vLyAtIHdyb25nIHJlc3VsdHNcbi8vIElmIHRoZSBuZXR3b3JrIGlzIG5vdCBleHBsaWNpdCAoaS5lLiBhdXRvLWRldGVjdGlvbiBpcyBleHBlY3RlZCksIHRoZVxuLy8gbm9kZSBNVVNUIGJlIHJ1bm5pbmcgYW5kIGF2YWlsYWJsZSB0byByZXNwb25kIHRvIHJlcXVlc3RzIEJFRk9SRSB0aGlzXG4vLyBpcyBpbnN0YW50aWF0ZWQuXG52YXIgU3RhdGljSnNvblJwY1Byb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGF0aWNKc29uUnBjUHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhdGljSnNvblJwY1Byb3ZpZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFN0YXRpY0pzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ldHdvcms7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gdGhpcy5uZXR3b3JrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobmV0d29yayA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfc3VwZXIucHJvdG90eXBlLmRldGVjdE5ldHdvcmsuY2FsbCh0aGlzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vIG5ldHdvcmsgZGV0ZWN0ZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGlsbCBub3Qgc2V0LCBzZXQgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHN0YXRpYyBuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgXCJhbnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX25ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV0d29ya107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0pzb25ScGNQcm92aWRlcjtcbn0oanNvbl9ycGNfcHJvdmlkZXJfMS5Kc29uUnBjUHJvdmlkZXIpKTtcbmV4cG9ydHMuU3RhdGljSnNvblJwY1Byb3ZpZGVyID0gU3RhdGljSnNvblJwY1Byb3ZpZGVyO1xudmFyIFVybEpzb25ScGNQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVXJsSnNvblJwY1Byb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVybEpzb25ScGNQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXIuY2hlY2tBYnN0cmFjdChfbmV3VGFyZ2V0LCBVcmxKc29uUnBjUHJvdmlkZXIpO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIE5ldHdvcmsgYW5kIEFQSSBLZXlcbiAgICAgICAgbmV0d29yayA9ICgwLCBwcm9wZXJ0aWVzXzEuZ2V0U3RhdGljKShfbmV3VGFyZ2V0LCBcImdldE5ldHdvcmtcIikobmV0d29yayk7XG4gICAgICAgIGFwaUtleSA9ICgwLCBwcm9wZXJ0aWVzXzEuZ2V0U3RhdGljKShfbmV3VGFyZ2V0LCBcImdldEFwaUtleVwiKShhcGlLZXkpO1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9ICgwLCBwcm9wZXJ0aWVzXzEuZ2V0U3RhdGljKShfbmV3VGFyZ2V0LCBcImdldFVybFwiKShuZXR3b3JrLCBhcGlLZXkpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbm5lY3Rpb24sIG5ldHdvcmspIHx8IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgKGFwaUtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwaUtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhcGlLZXkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBrZXksIGFwaUtleVtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVXJsSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkc6IEFQSSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHBlbmRpbmcgZmlsdGVyc1wiKTtcbiAgICB9O1xuICAgIFVybEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVXJsSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5nZXRTaWduZXIgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJBUEkgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzaWduaW5nXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJnZXRTaWduZXJcIiB9KTtcbiAgICB9O1xuICAgIFVybEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUubGlzdEFjY291bnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9O1xuICAgIC8vIFJldHVybiBhIGRlZmF1bHRBcGlLZXkgaWYgbnVsbCwgb3RoZXJ3aXNlIHZhbGlkYXRlIHRoZSBBUEkga2V5XG4gICAgVXJsSnNvblJwY1Byb3ZpZGVyLmdldEFwaUtleSA9IGZ1bmN0aW9uIChhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIGFwaUtleTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdGhlIHVybCBvciBjb25uZWN0aW9uIGZvciB0aGUgZ2l2ZW4gbmV0d29yayBhbmQgQVBJIGtleS4gVGhlXG4gICAgLy8gQVBJIGtleSB3aWxsIGhhdmUgYmVlbiBzYW5pdGl6ZWQgYnkgdGhlIGdldEFwaUtleSBmaXJzdCwgc28gYW55IHZhbGlkYXRpb25cbiAgICAvLyBvciB0cmFuc2Zvcm1hdGlvbnMgY2FuIGJlIGRvbmUgdGhlcmUuXG4gICAgVXJsSnNvblJwY1Byb3ZpZGVyLmdldFVybCA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwibm90IGltcGxlbWVudGVkOyBzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGdldFVybFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldFVybFwiXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFVybEpzb25ScGNQcm92aWRlcjtcbn0oU3RhdGljSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLlVybEpzb25ScGNQcm92aWRlciA9IFVybEpzb25ScGNQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybC1qc29uLXJwYy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/web3-provider.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/web3-provider.js ***!
  \*******************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Web3Provider = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\nvar _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    var fetcher = \"Web3LegacyFetcher\";\n    return function (method, params) {\n        var _this = this;\n        var request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n        return new Promise(function (resolve, reject) {\n            _this.emit(\"debug\", {\n                action: \"request\",\n                fetcher: fetcher,\n                request: (0, properties_1.deepCopy)(request),\n                provider: _this\n            });\n            sendFunc(request, function (error, response) {\n                if (error) {\n                    _this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher: fetcher,\n                        error: error,\n                        request: request,\n                        provider: _this\n                    });\n                    return reject(error);\n                }\n                _this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher: fetcher,\n                    request: request,\n                    response: response,\n                    provider: _this\n                });\n                if (response.error) {\n                    var error_1 = new Error(response.error.message);\n                    error_1.code = response.error.code;\n                    error_1.data = response.error.data;\n                    return reject(error_1);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function (method, params) {\n        var _this = this;\n        if (params == null) {\n            params = [];\n        }\n        var request = { method: method, params: params };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: (0, properties_1.deepCopy)(request),\n            provider: this\n        });\n        return provider.request(request).then(function (response) {\n            _this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request: request,\n                response: response,\n                provider: _this\n            });\n            return response;\n        }, function (error) {\n            _this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request: request,\n                error: error,\n                provider: _this\n            });\n            throw error;\n        });\n    };\n}\nvar Web3Provider = /** @class */ (function (_super) {\n    __extends(Web3Provider, _super);\n    function Web3Provider(provider, network) {\n        var _this = this;\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        var path = null;\n        var jsonRpcFetchFunc = null;\n        var subprovider = null;\n        if (typeof (provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        }\n        else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            }\n            else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            }\n            else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            }\n            else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        _this = _super.call(this, path, network) || this;\n        (0, properties_1.defineReadOnly)(_this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        (0, properties_1.defineReadOnly)(_this, \"provider\", subprovider);\n        return _this;\n    }\n    Web3Provider.prototype.send = function (method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    };\n    return Web3Provider;\n}(json_rpc_provider_1.JsonRpcProvider));\nexports.Web3Provider = Web3Provider;\n//# sourceMappingURL=web3-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3dlYjMtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG1CQUFtQixtQkFBTyxDQUFDLHFKQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMseUlBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHdKQUFZO0FBQ3JDO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsMEtBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuNy4wX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIvd2ViMy1wcm92aWRlci5qcz82ODJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViM1Byb3ZpZGVyID0gdm9pZCAwO1xudmFyIHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xudmFyIGpzb25fcnBjX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9qc29uLXJwYy1wcm92aWRlclwiKTtcbnZhciBfbmV4dElkID0gMTtcbmZ1bmN0aW9uIGJ1aWxkV2ViM0xlZ2FjeUZldGNoZXIocHJvdmlkZXIsIHNlbmRGdW5jKSB7XG4gICAgdmFyIGZldGNoZXIgPSBcIldlYjNMZWdhY3lGZXRjaGVyXCI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogKF9uZXh0SWQrKyksXG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgZmV0Y2hlcjogZmV0Y2hlcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiAoMCwgcHJvcGVydGllc18xLmRlZXBDb3B5KShyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VuZEZ1bmMocmVxdWVzdCwgZnVuY3Rpb24gKGVycm9yLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaGVyOiBmZXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICBmZXRjaGVyOiBmZXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JfMSA9IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JfMS5jb2RlID0gcmVzcG9uc2UuZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JfMS5kYXRhID0gcmVzcG9uc2UuZXJyb3IuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcl8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXF1ZXN0ID0geyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBwYXJhbXMgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgIGZldGNoZXI6IFwiRWlwMTE5M0ZldGNoZXJcIixcbiAgICAgICAgICAgIHJlcXVlc3Q6ICgwLCBwcm9wZXJ0aWVzXzEuZGVlcENvcHkpKHJlcXVlc3QpLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm92aWRlci5yZXF1ZXN0KHJlcXVlc3QpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXI6IFwiRWlwMTE5M0ZldGNoZXJcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZmV0Y2hlcjogXCJFaXAxMTkzRmV0Y2hlclwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbnZhciBXZWIzUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdlYjNQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXZWIzUHJvdmlkZXIocHJvdmlkZXIsIG5ldHdvcmspIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHByb3ZpZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoID0gbnVsbDtcbiAgICAgICAgdmFyIGpzb25ScGNGZXRjaEZ1bmMgPSBudWxsO1xuICAgICAgICB2YXIgc3VicHJvdmlkZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIChwcm92aWRlcikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcGF0aCA9IFwidW5rbm93bjpcIjtcbiAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBwcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSBwcm92aWRlci5ob3N0IHx8IHByb3ZpZGVyLnBhdGggfHwgXCJcIjtcbiAgICAgICAgICAgIGlmICghcGF0aCAmJiBwcm92aWRlci5pc01ldGFNYXNrKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IFwibWV0YW1hc2tcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIucmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBcImVpcC0xMTkzOlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRFaXAxMTkzRmV0Y2hlcihwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci5zZW5kQXN5bmMpIHtcbiAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlciwgcHJvdmlkZXIuc2VuZEFzeW5jLmJpbmQocHJvdmlkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnNlbmQpIHtcbiAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlciwgcHJvdmlkZXIuc2VuZC5iaW5kKHByb3ZpZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGF0aCwgbmV0d29yaykgfHwgdGhpcztcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwianNvblJwY0ZldGNoRnVuY1wiLCBqc29uUnBjRmV0Y2hGdW5jKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicHJvdmlkZXJcIiwgc3VicHJvdmlkZXIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdlYjNQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5qc29uUnBjRmV0Y2hGdW5jKG1ldGhvZCwgcGFyYW1zKTtcbiAgICB9O1xuICAgIHJldHVybiBXZWIzUHJvdmlkZXI7XG59KGpzb25fcnBjX3Byb3ZpZGVyXzEuSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLldlYjNQcm92aWRlciA9IFdlYjNQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYjMtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/web3-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/websocket-provider.js":
/*!************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/websocket-provider.js ***!
  \************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebSocketProvider = void 0;\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib/index.js\");\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\nvar ws_1 = __webpack_require__(/*! ./ws */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ws.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nvar NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nvar WebSocketProvider = /** @class */ (function (_super) {\n    __extends(WebSocketProvider, _super);\n    function WebSocketProvider(url, network) {\n        var _this = this;\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            _this = _super.call(this, url, network) || this;\n        }\n        else {\n            _this = _super.call(this, \"_websocket\", network) || this;\n        }\n        _this._pollingInterval = -1;\n        _this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            (0, properties_1.defineReadOnly)(_this, \"_websocket\", new ws_1.WebSocket(_this.connection.url));\n        }\n        else {\n            (0, properties_1.defineReadOnly)(_this, \"_websocket\", url);\n        }\n        (0, properties_1.defineReadOnly)(_this, \"_requests\", {});\n        (0, properties_1.defineReadOnly)(_this, \"_subs\", {});\n        (0, properties_1.defineReadOnly)(_this, \"_subIds\", {});\n        (0, properties_1.defineReadOnly)(_this, \"_detectNetwork\", _super.prototype.detectNetwork.call(_this));\n        // Stall sending requests until the socket is open...\n        _this.websocket.onopen = function () {\n            _this._wsReady = true;\n            Object.keys(_this._requests).forEach(function (id) {\n                _this.websocket.send(_this._requests[id].payload);\n            });\n        };\n        _this.websocket.onmessage = function (messageEvent) {\n            var data = messageEvent.data;\n            var result = JSON.parse(data);\n            if (result.id != null) {\n                var id = String(result.id);\n                var request = _this._requests[id];\n                delete _this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    _this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: _this\n                    });\n                }\n                else {\n                    var error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        (0, properties_1.defineReadOnly)(error, \"code\", result.error.code || null);\n                        (0, properties_1.defineReadOnly)(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    _this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: _this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                var sub = _this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        var fauxPoll = setInterval(function () {\n            _this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n        return _this;\n    }\n    Object.defineProperty(WebSocketProvider.prototype, \"websocket\", {\n        // Cannot narrow the type of _websocket, as that is not backwards compatible\n        // so we add a getter and let the WebSocket be a public API.\n        get: function () { return this._websocket; },\n        enumerable: false,\n        configurable: true\n    });\n    WebSocketProvider.prototype.detectNetwork = function () {\n        return this._detectNetwork;\n    };\n    Object.defineProperty(WebSocketProvider.prototype, \"pollingInterval\", {\n        get: function () {\n            return 0;\n        },\n        set: function (value) {\n            logger.throwError(\"cannot set polling interval on WebSocketProvider\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setPollingInterval\"\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WebSocketProvider.prototype.resetEventsBlock = function (blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    };\n    WebSocketProvider.prototype.poll = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, null];\n            });\n        });\n    };\n    Object.defineProperty(WebSocketProvider.prototype, \"polling\", {\n        set: function (value) {\n            if (!value) {\n                return;\n            }\n            logger.throwError(\"cannot set polling on WebSocketProvider\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setPolling\"\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WebSocketProvider.prototype.send = function (method, params) {\n        var _this = this;\n        var rid = NextId++;\n        return new Promise(function (resolve, reject) {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            var payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            _this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: _this\n            });\n            _this._requests[String(rid)] = { callback: callback, payload: payload };\n            if (_this._wsReady) {\n                _this.websocket.send(payload);\n            }\n        });\n    };\n    WebSocketProvider.defaultUrl = function () {\n        return \"ws:/\\/localhost:8546\";\n    };\n    WebSocketProvider.prototype._subscribe = function (tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function () {\n            var subIdPromise, subId;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        subIdPromise = this._subIds[tag];\n                        if (subIdPromise == null) {\n                            subIdPromise = Promise.all(param).then(function (param) {\n                                return _this.send(\"eth_subscribe\", param);\n                            });\n                            this._subIds[tag] = subIdPromise;\n                        }\n                        return [4 /*yield*/, subIdPromise];\n                    case 1:\n                        subId = _a.sent();\n                        this._subs[subId] = { tag: tag, processFunc: processFunc };\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    WebSocketProvider.prototype._startEvent = function (event) {\n        var _this = this;\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], function (result) {\n                    var blockNumber = bignumber_1.BigNumber.from(result.number).toNumber();\n                    _this._emitted.block = blockNumber;\n                    _this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], function (result) {\n                    _this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], function (result) {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    _this.emit(event.filter, _this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                var emitReceipt_1 = function (event) {\n                    var hash = event.hash;\n                    _this.getTransactionReceipt(hash).then(function (receipt) {\n                        if (!receipt) {\n                            return;\n                        }\n                        _this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt_1(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], function (result) {\n                    _this._events.filter(function (e) { return (e.type === \"tx\"); }).forEach(emitReceipt_1);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    };\n    WebSocketProvider.prototype._stopEvent = function (event) {\n        var _this = this;\n        var tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter(function (e) { return (e.type === \"tx\"); }).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        var subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then(function (subId) {\n            if (!_this._subs[subId]) {\n                return;\n            }\n            delete _this._subs[subId];\n            _this.send(\"eth_unsubscribe\", [subId]);\n        });\n    };\n    WebSocketProvider.prototype.destroy = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.websocket.readyState === ws_1.WebSocket.CONNECTING)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, (new Promise(function (resolve) {\n                                _this.websocket.onopen = function () {\n                                    resolve(true);\n                                };\n                                _this.websocket.onerror = function () {\n                                    resolve(false);\n                                };\n                            }))];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        // Hangup\n                        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n                        this.websocket.close(1000);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return WebSocketProvider;\n}(json_rpc_provider_1.JsonRpcProvider));\nexports.WebSocketProvider = WebSocketProvider;\n//# sourceMappingURL=websocket-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3dlYnNvY2tldC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGtCQUFrQixtQkFBTyxDQUFDLGtKQUEwQjtBQUNwRCxtQkFBbUIsbUJB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3dlYnNvY2tldC1wcm92aWRlci5qcz80YTdmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlNvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xudmFyIGJpZ251bWJlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiKTtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBqc29uX3JwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vanNvbi1ycGMtcHJvdmlkZXJcIik7XG52YXIgd3NfMSA9IHJlcXVpcmUoXCIuL3dzXCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xuLyoqXG4gKiAgTm90ZXM6XG4gKlxuICogIFRoaXMgcHJvdmlkZXIgZGlmZmVycyBhIGJpdCBmcm9tIHRoZSBwb2xsaW5nIHByb3ZpZGVycy4gT25lIG1haW5cbiAqICBkaWZmZXJlbmNlIGlzIGhvdyBpdCBoYW5kbGVzIGNvbnNpc3RlbmN5LiBUaGUgcG9sbGluZyBwcm92aWRlcnNcbiAqICB3aWxsIHN0YWxsIHJlc3BvbnNlcyB0byBlbnN1cmUgYSBjb25zaXN0ZW50IHN0YXRlLCB3aGlsZSB0aGlzXG4gKiAgV2ViU29ja2V0IHByb3ZpZGVyIGFzc3VtZXMgdGhlIGNvbm5lY3RlZCBiYWNrZW5kIHdpbGwgbWFuYWdlIHRoaXMuXG4gKlxuICogIEZvciBleGFtcGxlLCBpZiBhIHBvbGxpbmcgcHJvdmlkZXIgZW1pdHMgYW4gZXZlbnQgd2hpY2ggaW5kaWNhdGVzXG4gKiAgdGhlIGV2ZW50IG9jY3VycmVkIGluIGJsb2NraGFzaCBYWFgsIGEgY2FsbCB0byBmZXRjaCB0aGF0IGJsb2NrIGJ5XG4gKiAgaXRzIGhhc2ggWFhYLCBpZiBub3QgcHJlc2VudCB3aWxsIHJldHJ5IHVudGlsIGl0IGlzIHByZXNlbnQuIFRoaXNcbiAqICBjYW4gb2NjdXIgd2hlbiBxdWVyeWluZyBhIHBvb2wgb2Ygbm9kZXMgdGhhdCBhcmUgbWlsZGx5IG91dCBvZiBzeW5jXG4gKiAgd2l0aCBlYWNoIG90aGVyLlxuICovXG52YXIgTmV4dElkID0gMTtcbi8vIEZvciBtb3JlIGluZm8gYWJvdXQgdGhlIFJlYWwtdGltZSBFdmVudCBBUEkgc2VlOlxuLy8gICBodHRwczovL2dldGguZXRoZXJldW0ub3JnL2RvY3MvcnBjL3B1YnN1YlxudmFyIFdlYlNvY2tldFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXZWJTb2NrZXRQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXZWJTb2NrZXRQcm92aWRlcih1cmwsIG5ldHdvcmspIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGFkZGVkIGluIHRoZSBmdXR1cmU7IHBsZWFzZSBvcGVuIGFuIGlzc3VlIHRvIGV4cGVkaXRlXG4gICAgICAgIGlmIChuZXR3b3JrID09PSBcImFueVwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIldlYlNvY2tldFByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJ2FueScgbmV0d29yayB5ZXRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV0d29yazphbnlcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1cmwsIG5ldHdvcmspIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiX3dlYnNvY2tldFwiLCBuZXR3b3JrKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSAtMTtcbiAgICAgICAgX3RoaXMuX3dzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX3dlYnNvY2tldFwiLCBuZXcgd3NfMS5XZWJTb2NrZXQoX3RoaXMuY29ubmVjdGlvbi51cmwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl93ZWJzb2NrZXRcIiwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJfcmVxdWVzdHNcIiwge30pO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJfc3Vic1wiLCB7fSk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl9zdWJJZHNcIiwge30pO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJfZGV0ZWN0TmV0d29ya1wiLCBfc3VwZXIucHJvdG90eXBlLmRldGVjdE5ldHdvcmsuY2FsbChfdGhpcykpO1xuICAgICAgICAvLyBTdGFsbCBzZW5kaW5nIHJlcXVlc3RzIHVudGlsIHRoZSBzb2NrZXQgaXMgb3Blbi4uLlxuICAgICAgICBfdGhpcy53ZWJzb2NrZXQub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3dzUmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3RoaXMuX3JlcXVlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLndlYnNvY2tldC5zZW5kKF90aGlzLl9yZXF1ZXN0c1tpZF0ucGF5bG9hZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMud2Vic29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gbWVzc2FnZUV2ZW50LmRhdGE7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IFN0cmluZyhyZXN1bHQuaWQpO1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gX3RoaXMuX3JlcXVlc3RzW2lkXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX3JlcXVlc3RzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IEpTT04ucGFyc2UocmVxdWVzdC5wYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoZXJyb3IsIFwiY29kZVwiLCByZXN1bHQuZXJyb3IuY29kZSB8fCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKGVycm9yLCBcInJlc3BvbnNlXCIsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJ1bmtub3duIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3IsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IEpTT04ucGFyc2UocmVxdWVzdC5wYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQubWV0aG9kID09PSBcImV0aF9zdWJzY3JpcHRpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIFN1YnNjcmlwdGlvbi4uLlxuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBfdGhpcy5fc3Vic1tyZXN1bHQucGFyYW1zLnN1YnNjcmlwdGlvbl07XG4gICAgICAgICAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgICAgICAgICAgICAvL3RoaXMuZW1pdC5hcHBseSh0aGlzLCAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi5wcm9jZXNzRnVuYyhyZXN1bHQucGFyYW1zLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwidGhpcyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyBQcm92aWRlciBkb2VzIG5vdCBhY3R1YWxseSBwb2xsLCBidXQgd2Ugd2FudCB0byB0cmlnZ2VyXG4gICAgICAgIC8vIHBvbGwgZXZlbnRzIGZvciB0aGluZ3MgdGhhdCBkZXBlbmQgb24gdGhlbSAobGlrZSBzdGFsbGluZyBmb3JcbiAgICAgICAgLy8gYmxvY2sgYW5kIHRyYW5zYWN0aW9uIGxvb2t1cHMpXG4gICAgICAgIHZhciBmYXV4UG9sbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwb2xsXCIpO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgaWYgKGZhdXhQb2xsLnVucmVmKSB7XG4gICAgICAgICAgICBmYXV4UG9sbC51bnJlZigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZSwgXCJ3ZWJzb2NrZXRcIiwge1xuICAgICAgICAvLyBDYW5ub3QgbmFycm93IHRoZSB0eXBlIG9mIF93ZWJzb2NrZXQsIGFzIHRoYXQgaXMgbm90IGJhY2t3YXJkcyBjb21wYXRpYmxlXG4gICAgICAgIC8vIHNvIHdlIGFkZCBhIGdldHRlciBhbmQgbGV0IHRoZSBXZWJTb2NrZXQgYmUgYSBwdWJsaWMgQVBJLlxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3dlYnNvY2tldDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGV0ZWN0TmV0d29yaztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUsIFwicG9sbGluZ0ludGVydmFsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHNldCBwb2xsaW5nIGludGVydmFsIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdJbnRlcnZhbFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5yZXNldEV2ZW50c0Jsb2NrID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHJlc2V0IGV2ZW50cyBibG9jayBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc2V0RXZlbnRCbG9ja1wiXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLCBcInBvbGxpbmdcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHNldCBwb2xsaW5nIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmlkID0gTmV4dElkKys7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgaWQ6IHJpZCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBKU09OLnBhcnNlKHBheWxvYWQpLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5fcmVxdWVzdHNbU3RyaW5nKHJpZCldID0geyBjYWxsYmFjazogY2FsbGJhY2ssIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fd3NSZWFkeSkge1xuICAgICAgICAgICAgICAgIF90aGlzLndlYnNvY2tldC5zZW5kKHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFByb3ZpZGVyLmRlZmF1bHRVcmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIndzOi9cXC9sb2NhbGhvc3Q6ODU0NlwiO1xuICAgIH07XG4gICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAodGFnLCBwYXJhbSwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN1YklkUHJvbWlzZSwgc3ViSWQ7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViSWRQcm9taXNlID0gdGhpcy5fc3ViSWRzW3RhZ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViSWRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJJZFByb21pc2UgPSBQcm9taXNlLmFsbChwYXJhbSkudGhlbihmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmQoXCJldGhfc3Vic2NyaWJlXCIsIHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJJZHNbdGFnXSA9IHN1YklkUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN1YklkUHJvbWlzZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YklkID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Vic1tzdWJJZF0gPSB7IHRhZzogdGFnLCBwcm9jZXNzRnVuYzogcHJvY2Vzc0Z1bmMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX3N0YXJ0RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJibG9ja1wiLCBbXCJuZXdIZWFkc1wiXSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tOdW1iZXIgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShyZXN1bHQubnVtYmVyKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiYmxvY2tcIiwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJwZW5kaW5nXCIsIFtcIm5ld1BlbmRpbmdUcmFuc2FjdGlvbnNcIl0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInBlbmRpbmdcIiwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLCBbXCJsb2dzXCIsIHRoaXMuX2dldEZpbHRlcihldmVudC5maWx0ZXIpXSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlbW92ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGV2ZW50LmZpbHRlciwgX3RoaXMuZm9ybWF0dGVyLmZpbHRlckxvZyhyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0eFwiOiB7XG4gICAgICAgICAgICAgICAgdmFyIGVtaXRSZWNlaXB0XzEgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBldmVudC5oYXNoO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChoYXNoLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIGl0IGlzIGFscmVhZHkgbWluZWRcbiAgICAgICAgICAgICAgICBlbWl0UmVjZWlwdF8xKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBUbyBrZWVwIHRoaW5ncyBzaW1wbGUsIHdlIHN0YXJ0IHVwIGEgc2luZ2xlIG5ld0hlYWRzIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgIC8vIHRvIGtlZXAgYW4gZXllIG91dCBmb3IgdHJhbnNhY3Rpb25zIHdlIGFyZSB3YXRjaGluZyBmb3IuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnRpbmcgYSBzdWJzY3JpcHRpb24gZm9yIGFuIGV2ZW50IChpLmUuIFwidHhcIikgdGhhdCBpcyBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gcnVubmluZyBpcyAoYmFzaWNhbGx5KSBhIG5vcC5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJ0eFwiLCBbXCJuZXdIZWFkc1wiXSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gKGUudHlwZSA9PT0gXCJ0eFwiKTsgfSkuZm9yRWFjaChlbWl0UmVjZWlwdF8xKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGhpbmcgaXMgbmVlZGVkXG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwid2lsbFBvbGxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaWRQb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmhhbmRsZWQ6XCIsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9zdG9wRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRhZyA9IGV2ZW50LnRhZztcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwidHhcIikge1xuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyB0cmFuc2FjdGlvbiBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoZS50eXBlID09PSBcInR4XCIpOyB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWcgPSBcInR4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KGV2ZW50LmV2ZW50KSkge1xuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ViSWQgPSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgaWYgKCFzdWJJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgc3ViSWQudGhlbihmdW5jdGlvbiAoc3ViSWQpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX3N1YnNbc3ViSWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIF90aGlzLl9zdWJzW3N1YklkXTtcbiAgICAgICAgICAgIF90aGlzLnNlbmQoXCJldGhfdW5zdWJzY3JpYmVcIiwgW3N1YklkXSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlID09PSB3c18xLldlYlNvY2tldC5DT05ORUNUSU5HKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMud2Vic29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLndlYnNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5ndXBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQjU3RhdHVzX2NvZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5jbG9zZSgxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2ViU29ja2V0UHJvdmlkZXI7XG59KGpzb25fcnBjX3Byb3ZpZGVyXzEuSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLldlYlNvY2tldFByb3ZpZGVyID0gV2ViU29ja2V0UHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJzb2NrZXQtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/websocket-provider.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ws.js":
/*!********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ws.js ***!
  \********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebSocket = void 0;\nvar ws_1 = __importDefault(__webpack_require__(/*! ws */ \"(ssr)/../../node_modules/.pnpm/ws@7.4.6_bufferutil@4.0.7/node_modules/ws/index.js\"));\nexports.WebSocket = ws_1.default;\n//# sourceMappingURL=ws.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3dzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLDJCQUEyQixtQkFBTyxDQUFDLDZGQUFJO0FBQ3ZDLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3dzLmpzP2MxYTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlNvY2tldCA9IHZvaWQgMDtcbnZhciB3c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ3c1wiKSk7XG5leHBvcnRzLldlYlNvY2tldCA9IHdzXzEuZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib/ws.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js":
/*!******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"providers/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxrQkFBa0IsQ0FDekMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuNy4wX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL192ZXJzaW9uLmpzP2UzMGYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInByb3ZpZGVycy81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js":
/*!**************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlchemyProvider: () => (/* binding */ AlchemyProvider),\n/* harmony export */   AlchemyWebSocketProvider: () => (/* binding */ AlchemyWebSocketProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatter */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nclass AlchemyWebSocketProvider extends _websocket_provider__WEBPACK_IMPORTED_MODULE_2__.WebSocketProvider {\n    constructor(network, apiKey){\n        const provider = new AlchemyProvider(network, apiKey);\n        const url = provider.connection.url.replace(/^http/i, \"ws\").replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n        super(url, provider.network);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"apiKey\", provider.apiKey);\n    }\n    isCommunityResource() {\n        return this.apiKey === defaultApiKey;\n    }\n}\nclass AlchemyProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__.UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        if (apiKey && typeof apiKey !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch(network.name){\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-goerli\":\n                host = \"arb-goerli.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-goerli\":\n                host = \"opt-goerli.g.alchemy.com/v2/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return {\n            allowGzip: true,\n            url: \"https:/\" + \"/\" + host + apiKey,\n            throttleCallback: (attempt, url)=>{\n                if (apiKey === defaultApiKey) {\n                    (0,_formatter__WEBPACK_IMPORTED_MODULE_5__.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n    isCommunityResource() {\n        return this.apiKey === defaultApiKey;\n    }\n} //# sourceMappingURL=alchemy-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9hbGNoZW15LXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWE7QUFDOEM7QUFDVDtBQUNPO0FBQ1Y7QUFDVjtBQUNyQyxNQUFNSyxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDNEI7QUFDN0Qsa0VBQWtFO0FBQ2xFLDREQUE0RDtBQUM1RCxpRUFBaUU7QUFDakUsb0NBQW9DO0FBQ3BDLE1BQU1HLGdCQUFnQjtBQUNmLE1BQU1DLGlDQUFpQ04sa0VBQWlCQTtJQUMzRE8sWUFBWUMsT0FBTyxFQUFFQyxNQUFNLENBQUU7UUFDekIsTUFBTUMsV0FBVyxJQUFJQyxnQkFBZ0JILFNBQVNDO1FBQzlDLE1BQU1HLE1BQU1GLFNBQVNHLFVBQVUsQ0FBQ0QsR0FBRyxDQUFDRSxPQUFPLENBQUMsVUFBVSxNQUNqREEsT0FBTyxDQUFDLGdCQUFnQjtRQUM3QixLQUFLLENBQUNGLEtBQUtGLFNBQVNGLE9BQU87UUFDM0JWLHlFQUFjQSxDQUFDLElBQUksRUFBRSxVQUFVWSxTQUFTRCxNQUFNO0lBQ2xEO0lBQ0FNLHNCQUFzQjtRQUNsQixPQUFRLElBQUksQ0FBQ04sTUFBTSxLQUFLSjtJQUM1QjtBQUNKO0FBQ08sTUFBTU0sd0JBQXdCUCxzRUFBa0JBO0lBQ25ELE9BQU9ZLHFCQUFxQlIsT0FBTyxFQUFFQyxNQUFNLEVBQUU7UUFDekMsT0FBTyxJQUFJSCx5QkFBeUJFLFNBQVNDO0lBQ2pEO0lBQ0EsT0FBT1EsVUFBVVIsTUFBTSxFQUFFO1FBQ3JCLElBQUlBLFVBQVUsTUFBTTtZQUNoQixPQUFPSjtRQUNYO1FBQ0EsSUFBSUksVUFBVSxPQUFRQSxXQUFZLFVBQVU7WUFDeENOLE9BQU9lLGtCQUFrQixDQUFDLGtCQUFrQixVQUFVVDtRQUMxRDtRQUNBLE9BQU9BO0lBQ1g7SUFDQSxPQUFPVSxPQUFPWCxPQUFPLEVBQUVDLE1BQU0sRUFBRTtRQUMzQixJQUFJVyxPQUFPO1FBQ1gsT0FBUVosUUFBUWEsSUFBSTtZQUNoQixLQUFLO2dCQUNERCxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0o7Z0JBQ0lqQixPQUFPZSxrQkFBa0IsQ0FBQyx1QkFBdUIsV0FBV0ksU0FBUyxDQUFDLEVBQUU7UUFDaEY7UUFDQSxPQUFPO1lBQ0hDLFdBQVc7WUFDWFgsS0FBTSxZQUFZLE1BQU1RLE9BQU9YO1lBQy9CZSxrQkFBa0IsQ0FBQ0MsU0FBU2I7Z0JBQ3hCLElBQUlILFdBQVdKLGVBQWU7b0JBQzFCTiwrREFBbUJBO2dCQUN2QjtnQkFDQSxPQUFPMkIsUUFBUUMsT0FBTyxDQUFDO1lBQzNCO1FBQ0o7SUFDSjtJQUNBWixzQkFBc0I7UUFDbEIsT0FBUSxJQUFJLENBQUNOLE1BQU0sS0FBS0o7SUFDNUI7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9hbGNoZW15LXByb3ZpZGVyLmpzP2MyNDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBzaG93VGhyb3R0bGVNZXNzYWdlIH0gZnJvbSBcIi4vZm9ybWF0dGVyXCI7XG5pbXBvcnQgeyBXZWJTb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL3dlYnNvY2tldC1wcm92aWRlclwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgVXJsSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vdXJsLWpzb24tcnBjLXByb3ZpZGVyXCI7XG4vLyBUaGlzIGtleSB3YXMgcHJvdmlkZWQgdG8gZXRoZXJzLmpzIGJ5IEFsY2hlbXkgdG8gYmUgdXNlZCBieSB0aGVcbi8vIGRlZmF1bHQgcHJvdmlkZXIsIGJ1dCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IGZvciB5b3VyIG93blxuLy8gcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMsIHRoYXQgeW91IGFjcXVpcmUgeW91ciBvd24gQVBJIGtleSBhdDpcbi8vICAgaHR0cHM6Ly9kYXNoYm9hcmQuYWxjaGVteWFwaS5pb1xuY29uc3QgZGVmYXVsdEFwaUtleSA9IFwiX2dnN3dTU2kwS01Cc2RLbkdWZkhEdWVxNnhNQjlFa0NcIjtcbmV4cG9ydCBjbGFzcyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBXZWJTb2NrZXRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IEFsY2hlbXlQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpO1xuICAgICAgICBjb25zdCB1cmwgPSBwcm92aWRlci5jb25uZWN0aW9uLnVybC5yZXBsYWNlKC9eaHR0cC9pLCBcIndzXCIpXG4gICAgICAgICAgICAucmVwbGFjZShcIi5hbGNoZW15YXBpLlwiLCBcIi53cy5hbGNoZW15YXBpLlwiKTtcbiAgICAgICAgc3VwZXIodXJsLCBwcm92aWRlci5uZXR3b3JrKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhcGlLZXlcIiwgcHJvdmlkZXIuYXBpS2V5KTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFsY2hlbXlQcm92aWRlciBleHRlbmRzIFVybEpzb25ScGNQcm92aWRlciB7XG4gICAgc3RhdGljIGdldFdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICByZXR1cm4gbmV3IEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QXBpS2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIChhcGlLZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcGlLZXlcIiwgXCJhcGlLZXlcIiwgYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBpS2V5O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VXJsKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBsZXQgaG9zdCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAobmV0d29yay5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLW1haW5uZXQuYWxjaGVteWFwaS5pby92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJvcHN0ZW4uYWxjaGVteWFwaS5pby92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJpbmtlYnkuYWxjaGVteWFwaS5pby92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtZ29lcmxpLmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgta292YW4uYWxjaGVteWFwaS5pby92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvbHlnb24tbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljbXVtXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwicG9seWdvbi1tdW1iYWkuZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYi1tYWlubmV0LmcuYWxjaGVteS5jb20vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW0tcmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYi1yaW5rZWJ5LmcuYWxjaGVteS5jb20vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW0tZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiYXJiLWdvZXJsaS5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwib3B0LW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbS1rb3ZhblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm9wdC1rb3Zhbi5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm9wdC1nb2VybGkuZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsbG93R3ppcDogdHJ1ZSxcbiAgICAgICAgICAgIHVybDogKFwiaHR0cHM6L1wiICsgXCIvXCIgKyBob3N0ICsgYXBpS2V5KSxcbiAgICAgICAgICAgIHRocm90dGxlQ2FsbGJhY2s6IChhdHRlbXB0LCB1cmwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dUaHJvdHRsZU1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxjaGVteS1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUmVhZE9ubHkiLCJzaG93VGhyb3R0bGVNZXNzYWdlIiwiV2ViU29ja2V0UHJvdmlkZXIiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiVXJsSnNvblJwY1Byb3ZpZGVyIiwiZGVmYXVsdEFwaUtleSIsIkFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciIsImNvbnN0cnVjdG9yIiwibmV0d29yayIsImFwaUtleSIsInByb3ZpZGVyIiwiQWxjaGVteVByb3ZpZGVyIiwidXJsIiwiY29ubmVjdGlvbiIsInJlcGxhY2UiLCJpc0NvbW11bml0eVJlc291cmNlIiwiZ2V0V2ViU29ja2V0UHJvdmlkZXIiLCJnZXRBcGlLZXkiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJnZXRVcmwiLCJob3N0IiwibmFtZSIsImFyZ3VtZW50cyIsImFsbG93R3ppcCIsInRocm90dGxlQ2FsbGJhY2siLCJhdHRlbXB0IiwiUHJvbWlzZSIsInJlc29sdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ankr-provider.js":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ankr-provider.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnkrProvider: () => (/* binding */ AnkrProvider)\n/* harmony export */ });\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatter */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\nfunction getHost(name) {\n    switch(name){\n        case \"homestead\":\n            return \"rpc.ankr.com/eth/\";\n        case \"ropsten\":\n            return \"rpc.ankr.com/eth_ropsten/\";\n        case \"rinkeby\":\n            return \"rpc.ankr.com/eth_rinkeby/\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli/\";\n        case \"matic\":\n            return \"rpc.ankr.com/polygon/\";\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum/\";\n    }\n    return logger.throwArgumentError(\"unsupported network\", \"name\", name);\n}\nclass AnkrProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {\n    isCommunityResource() {\n        return this.apiKey === defaultApiKey;\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const connection = {\n            allowGzip: true,\n            url: \"https://\" + getHost(network.name) + apiKey,\n            throttleCallback: (attempt, url)=>{\n                if (apiKey.apiKey === defaultApiKey) {\n                    (0,_formatter__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n} //# sourceMappingURL=ankr-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9hbmtyLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWtEO0FBQ1c7QUFDZDtBQUNWO0FBQ3JDLE1BQU1JLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUNqQyxNQUFNRSxnQkFBZ0I7QUFDdEIsU0FBU0MsUUFBUUMsSUFBSTtJQUNqQixPQUFRQTtRQUNKLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztJQUNmO0lBQ0EsT0FBT0gsT0FBT0ksa0JBQWtCLENBQUMsdUJBQXVCLFFBQVFEO0FBQ3BFO0FBQ08sTUFBTUUscUJBQXFCUixzRUFBa0JBO0lBQ2hEUyxzQkFBc0I7UUFDbEIsT0FBUSxJQUFJLENBQUNDLE1BQU0sS0FBS047SUFDNUI7SUFDQSxPQUFPTyxVQUFVRCxNQUFNLEVBQUU7UUFDckIsSUFBSUEsVUFBVSxNQUFNO1lBQ2hCLE9BQU9OO1FBQ1g7UUFDQSxPQUFPTTtJQUNYO0lBQ0EsT0FBT0UsT0FBT0MsT0FBTyxFQUFFSCxNQUFNLEVBQUU7UUFDM0IsSUFBSUEsVUFBVSxNQUFNO1lBQ2hCQSxTQUFTTjtRQUNiO1FBQ0EsTUFBTVUsYUFBYTtZQUNmQyxXQUFXO1lBQ1hDLEtBQU0sYUFBY1gsUUFBUVEsUUFBUVAsSUFBSSxJQUFJSTtZQUM1Q08sa0JBQWtCLENBQUNDLFNBQVNGO2dCQUN4QixJQUFJTixPQUFPQSxNQUFNLEtBQUtOLGVBQWU7b0JBQ2pDTCwrREFBbUJBO2dCQUN2QjtnQkFDQSxPQUFPb0IsUUFBUUMsT0FBTyxDQUFDO1lBQzNCO1FBQ0o7UUFDQSxJQUFJVixPQUFPVyxhQUFhLElBQUksTUFBTTtZQUM5QlAsV0FBV1EsSUFBSSxHQUFHO1lBQ2xCUixXQUFXUyxRQUFRLEdBQUdiLE9BQU9XLGFBQWE7UUFDOUM7UUFDQSxPQUFPUDtJQUNYO0FBQ0osRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vYW5rci1wcm92aWRlci5qcz84ZDc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbmltcG9ydCB7IFVybEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuY29uc3QgZGVmYXVsdEFwaUtleSA9IFwiOWY3ZDkyOWIwMThjZGZmYjMzODUxN2VmYTA2ZjU4MzU5ZTg2ZmYxZmZkMzUwYmM4ODk3Mzg1MjM2NTllNzk3MlwiO1xuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGgvXCI7XG4gICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vZXRoX3JvcHN0ZW4vXCI7XG4gICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vZXRoX3JpbmtlYnkvXCI7XG4gICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGhfZ29lcmxpL1wiO1xuICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9wb2x5Z29uL1wiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9hcmJpdHJ1bS9cIjtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmFtZVwiLCBuYW1lKTtcbn1cbmV4cG9ydCBjbGFzcyBBbmtyUHJvdmlkZXIgZXh0ZW5kcyBVcmxKc29uUnBjUHJvdmlkZXIge1xuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QXBpS2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcGlLZXk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRVcmwobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgYWxsb3dHemlwOiB0cnVlLFxuICAgICAgICAgICAgdXJsOiAoXCJodHRwczovXFwvXCIgKyBnZXRIb3N0KG5ldHdvcmsubmFtZSkgKyBhcGlLZXkpLFxuICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogKGF0dGVtcHQsIHVybCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcGlLZXkuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dUaHJvdHRsZU1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFwaUtleS5wcm9qZWN0U2VjcmV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24udXNlciA9IFwiXCI7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnBhc3N3b3JkID0gYXBpS2V5LnByb2plY3RTZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5rci1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsic2hvd1Rocm90dGxlTWVzc2FnZSIsIlVybEpzb25ScGNQcm92aWRlciIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJkZWZhdWx0QXBpS2V5IiwiZ2V0SG9zdCIsIm5hbWUiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJBbmtyUHJvdmlkZXIiLCJpc0NvbW11bml0eVJlc291cmNlIiwiYXBpS2V5IiwiZ2V0QXBpS2V5IiwiZ2V0VXJsIiwibmV0d29yayIsImNvbm5lY3Rpb24iLCJhbGxvd0d6aXAiLCJ1cmwiLCJ0aHJvdHRsZUNhbGxiYWNrIiwiYXR0ZW1wdCIsIlByb21pc2UiLCJyZXNvbHZlIiwicHJvamVjdFNlY3JldCIsInVzZXIiLCJwYXNzd29yZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ankr-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/base-provider.js":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/base-provider.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseProvider: () => (/* binding */ BaseProvider),\n/* harmony export */   Event: () => (/* binding */ Event),\n/* harmony export */   Resolver: () => (/* binding */ Resolver)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+abstract-provider@5.7.0/node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ethersproject/base64 */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+base64@5.7.0/node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/basex */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+basex@5.7.0/node_modules/@ethersproject/basex/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/constants */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/hashes.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/hash */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/namehash.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ethersproject/networks */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+networks@5.7.0/node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/sha2 */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+sha2@5.7.0/node_modules/@ethersproject/sha2/lib.esm/sha2.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/strings */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/web */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+web@5.7.0/node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bech32 */ \"(rsc)/../../node_modules/.pnpm/bech32@1.1.4/node_modules/bech32/index.js\");\n/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bech32__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./formatter */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\n\nconst MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while(topics.length > 0 && topics[topics.length - 1] == null){\n        topics.pop();\n    }\n    return topics.map((topic)=>{\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic)=>{\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic)=>{\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic)=>{\n            return topic === \"null\" ? null : topic;\n        });\n        return comps.length === 1 ? comps[0] : comps;\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof eventName === \"string\") {\n        eventName = eventName.toLowerCase();\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    } else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    } else if (eventName && typeof eventName === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return new Date().getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */ const PollableEvents = [\n    \"block\",\n    \"network\",\n    \"pending\",\n    \"poll\"\n];\nclass Event {\n    constructor(tag, listener, once){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"tag\", tag);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"listener\", listener);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch(this.type){\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": {\n        symbol: \"btc\",\n        p2pkh: 0x00,\n        p2sh: 0x05,\n        prefix: \"bc\"\n    },\n    \"2\": {\n        symbol: \"ltc\",\n        p2pkh: 0x30,\n        p2sh: 0x32,\n        prefix: \"ltc\"\n    },\n    \"3\": {\n        symbol: \"doge\",\n        p2pkh: 0x1e,\n        p2sh: 0x16\n    },\n    \"60\": {\n        symbol: \"eth\",\n        ilk: \"eth\"\n    },\n    \"61\": {\n        symbol: \"etc\",\n        ilk: \"eth\"\n    },\n    \"700\": {\n        symbol: \"xdai\",\n        ilk: \"eth\"\n    }\n};\nfunction bytes32ify(value) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n        data,\n        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)(data)), 0, 4)\n    ]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs)://(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https)://(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")\n];\nfunction _parseString(result, start) {\n    try {\n        return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(_parseBytes(result, start));\n    } catch (error) {}\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, start, start + 32)).toNumber();\n    const length = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset, offset + 32)).toNumber();\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nfunction numPad(value) {\n    const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if (value.length % 32 === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for(let i = 0; i < datas.length; i++){\n        result.push(null);\n        byteCount += 32;\n    }\n    for(let i = 0; i < datas.length; i++){\n        const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(result);\n}\nclass Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"provider\", provider);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"name\", name);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"address\", provider.formatter.address(address));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    supportsWildcard() {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result)=>{\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).eq(1);\n            }).catch((error)=>{\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    }\n    _fetch(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                ccipReadEnabled: true,\n                data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                    selector,\n                    (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(this.name),\n                    parameters || \"0x\"\n                ])\n            };\n            // Wildcard support; use EIP-2544 to resolve the request\n            let parseBytes = false;\n            if (yield this.supportsWildcard()) {\n                parseBytes = true;\n                // selector(\"resolve(bytes,bytes)\")\n                tx.data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                    \"0x9061b923\",\n                    encodeBytes([\n                        (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.dnsEncode)(this.name),\n                        tx.data\n                    ])\n                ]);\n            }\n            try {\n                let result = yield this.provider.call(tx);\n                if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(result).length % 32 === 4) {\n                    logger.throwError(\"resolver threw error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                        transaction: tx,\n                        data: result\n                    });\n                }\n                if (parseBytes) {\n                    result = _parseBytes(result, 0);\n                }\n                return result;\n            } catch (error) {\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const result = yield this._fetch(selector, parameters);\n            if (result != null) {\n                return _parseBytes(result, 0);\n            }\n            return null;\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                        [\n                            coinInfo.p2pkh\n                        ],\n                        \"0x\" + p2pkh[2]\n                    ]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                        [\n                            coinInfo.p2sh\n                        ],\n                        \"0x\" + p2sh[2]\n                    ]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32__WEBPACK_IMPORTED_MODULE_0___default().toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32__WEBPACK_IMPORTED_MODULE_0___default().encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const result = yield this._fetch(\"0x3b3b57de\");\n                    // No address\n                    if (result === \"0x\" || result === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__.HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(result);\n                } catch (error) {\n                    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const linkage = [\n                {\n                    type: \"name\",\n                    content: this.name\n                }\n            ];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for(let i = 0; i < matchers.length; i++){\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch(scheme){\n                        case \"https\":\n                            linkage.push({\n                                type: \"url\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: avatar\n                            };\n                        case \"data\":\n                            linkage.push({\n                                type: \"data\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: avatar\n                            };\n                        case \"ipfs\":\n                            linkage.push({\n                                type: \"ipfs\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: getIpfsLink(avatar)\n                            };\n                        case \"erc721\":\n                        case \"erc1155\":\n                            {\n                                // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                                const selector = scheme === \"erc721\" ? \"0xc87b56dd\" : \"0x0e89341c\";\n                                linkage.push({\n                                    type: scheme,\n                                    content: avatar\n                                });\n                                // The owner of this name\n                                const owner = this._resolvedAddress || (yield this.getAddress());\n                                const comps = (match[2] || \"\").split(\"/\");\n                                if (comps.length !== 2) {\n                                    return null;\n                                }\n                                const addr = yield this.provider.formatter.address(comps[0]);\n                                const tokenId = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(comps[1]).toHexString(), 32);\n                                // Check that this account owns the token\n                                if (scheme === \"erc721\") {\n                                    // ownerOf(uint256 tokenId)\n                                    const tokenOwner = this.provider.formatter.callAddress((yield this.provider.call({\n                                        to: addr,\n                                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                            \"0x6352211e\",\n                                            tokenId\n                                        ])\n                                    })));\n                                    if (owner !== tokenOwner) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"owner\",\n                                        content: tokenOwner\n                                    });\n                                } else if (scheme === \"erc1155\") {\n                                    // balanceOf(address owner, uint256 tokenId)\n                                    const balance = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((yield this.provider.call({\n                                        to: addr,\n                                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                            \"0x00fdd58e\",\n                                            (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(owner, 32),\n                                            tokenId\n                                        ])\n                                    })));\n                                    if (balance.isZero()) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"balance\",\n                                        content: balance.toString()\n                                    });\n                                }\n                                // Call the token contract for the metadata URL\n                                const tx = {\n                                    to: this.provider.formatter.address(comps[0]),\n                                    data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                        selector,\n                                        tokenId\n                                    ])\n                                };\n                                let metadataUrl = _parseString((yield this.provider.call(tx)), 0);\n                                if (metadataUrl == null) {\n                                    return null;\n                                }\n                                linkage.push({\n                                    type: \"metadata-url-base\",\n                                    content: metadataUrl\n                                });\n                                // ERC-1155 allows a generic {id} in the URL\n                                if (scheme === \"erc1155\") {\n                                    metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                    linkage.push({\n                                        type: \"metadata-url-expanded\",\n                                        content: metadataUrl\n                                    });\n                                }\n                                // Transform IPFS metadata links\n                                if (metadataUrl.match(/^ipfs:/i)) {\n                                    metadataUrl = getIpfsLink(metadataUrl);\n                                }\n                                linkage.push({\n                                    type: \"metadata-url\",\n                                    content: metadataUrl\n                                });\n                                // Get the token metadata\n                                const metadata = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)(metadataUrl);\n                                if (!metadata) {\n                                    return null;\n                                }\n                                linkage.push({\n                                    type: \"metadata\",\n                                    content: JSON.stringify(metadata)\n                                });\n                                // Pull the image URL out\n                                let imageUrl = metadata.image;\n                                if (typeof imageUrl !== \"string\") {\n                                    return null;\n                                }\n                                if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                                } else {\n                                    // Transform IPFS link to gateway\n                                    const ipfs = imageUrl.match(matcherIpfs);\n                                    if (ipfs == null) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"url-ipfs\",\n                                        content: imageUrl\n                                    });\n                                    imageUrl = getIpfsLink(imageUrl);\n                                }\n                                linkage.push({\n                                    type: \"url\",\n                                    content: imageUrl\n                                });\n                                return {\n                                    linkage,\n                                    url: imageUrl\n                                };\n                            }\n                    }\n                }\n            } catch (error) {}\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs://\" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // IPNS (CID: 1, Type: libp2p-key)\n            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipns) {\n                const length = parseInt(ipns[3], 16);\n                if (ipns[4].length === length * 2) {\n                    return \"ipns://\" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode(\"0x\" + ipns[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === 32 * 2) {\n                    return \"bzz://\" + swarm[1];\n                }\n            }\n            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n            if (skynet) {\n                if (skynet[1].length === 34 * 2) {\n                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                    const urlSafe = {\n                        \"=\": \"\",\n                        \"+\": \"-\",\n                        \"/\": \"_\"\n                    };\n                    const hash = (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_13__.encode)(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a)=>urlSafe[a]);\n                    return \"sia://\" + hash;\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8Bytes)(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                bytes32ify(64),\n                bytes32ify(keyBytes.length),\n                keyBytes\n            ]);\n            // Pad to word-size (32 bytes)\n            if (keyBytes.length % 32 !== 0) {\n                keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                    keyBytes,\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(\"0x\", 32 - key.length % 32)\n                ]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nclass BaseProvider extends _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */ constructor(network){\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = {\n            block: -2\n        };\n        this.disableCcipRead = false;\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"anyNetwork\", network === \"any\");\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error)=>{});\n            // Trigger initial network setting (async)\n            this._ready().catch((error)=>{});\n        } else {\n            const knownNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.getStatic)(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    } catch (error) {}\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    } else {\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>{\n            return this._ready().then((network)=>{\n                return network;\n            }, (error)=>{\n                // If the network isn't running yet, we will wait\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new _formatter__WEBPACK_IMPORTED_MODULE_14__.Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_15__.getNetwork)(network == null ? \"homestead\" : network);\n    }\n    ccipReadFetch(tx, calldata, urls) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.disableCcipRead || urls.length === 0) {\n                return null;\n            }\n            const sender = tx.to.toLowerCase();\n            const data = calldata.toLowerCase();\n            const errorMessages = [];\n            for(let i = 0; i < urls.length; i++){\n                const url = urls[i];\n                // URL expansion\n                const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                // If no {data} is present, use POST; otherwise GET\n                const json = url.indexOf(\"{data}\") >= 0 ? null : JSON.stringify({\n                    data,\n                    sender\n                });\n                const result = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)({\n                    url: href,\n                    errorPassThrough: true\n                }, json, (value, response)=>{\n                    value.status = response.statusCode;\n                    return value;\n                });\n                if (result.data) {\n                    return result.data;\n                }\n                const errorMessage = result.message || \"unknown error\";\n                // 4xx indicates the result is not present; stop\n                if (result.status >= 400 && result.status < 500) {\n                    return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                        url,\n                        errorMessage\n                    });\n                }\n                // 5xx indicates server issue; try the next url\n                errorMessages.push(errorMessage);\n            }\n            return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m)=>JSON.stringify(m)).join(\", \")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                urls,\n                errorMessages\n            });\n        });\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while(this._internalBlockNumber){\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if (getTime() - result.respTime <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        break;\n                    } catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network)=>null, (error)=>error)\n            }).then(({ blockNumber, networkError })=>{\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return {\n                    blockNumber,\n                    reqTime,\n                    respTime\n                };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error)=>{\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            } catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs(this._emitted.block - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            } else {\n                // Notify all listener for each block that has passed\n                for(let i = this._emitted.block + 1; i <= blockNumber; i++){\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key)=>{\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event)=>{\n                switch(event.type){\n                    case \"tx\":\n                        {\n                            const hash = event.hash;\n                            let runner = this.getTransactionReceipt(hash).then((receipt)=>{\n                                if (!receipt || receipt.blockNumber == null) {\n                                    return null;\n                                }\n                                this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                                this.emit(hash, receipt);\n                                return null;\n                            }).catch((error)=>{\n                                this.emit(\"error\", error);\n                            });\n                            runners.push(runner);\n                            break;\n                        }\n                    case \"filter\":\n                        {\n                            // We only allow a single getLogs to be in-flight at a time\n                            if (!event._inflight) {\n                                event._inflight = true;\n                                // This is the first filter for this event, so we want to\n                                // restrict events to events that happened no earlier than now\n                                if (event._lastBlockNumber === -2) {\n                                    event._lastBlockNumber = blockNumber - 1;\n                                }\n                                // Filter from the last *known* event; due to load-balancing\n                                // and some nodes returning updated block numbers before\n                                // indexing events, a logs result with 0 entries cannot be\n                                // trusted and we must retry a range which includes it again\n                                const filter = event.filter;\n                                filter.fromBlock = event._lastBlockNumber + 1;\n                                filter.toBlock = blockNumber;\n                                // Prevent fitler ranges from growing too wild, since it is quite\n                                // likely there just haven't been any events to move the lastBlockNumber.\n                                const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                                if (minFromBlock > filter.fromBlock) {\n                                    filter.fromBlock = minFromBlock;\n                                }\n                                if (filter.fromBlock < 0) {\n                                    filter.fromBlock = 0;\n                                }\n                                const runner = this.getLogs(filter).then((logs)=>{\n                                    // Allow the next getLogs\n                                    event._inflight = false;\n                                    if (logs.length === 0) {\n                                        return;\n                                    }\n                                    logs.forEach((log)=>{\n                                        // Only when we get an event for a given block number\n                                        // can we trust the events are indexed\n                                        if (log.blockNumber > event._lastBlockNumber) {\n                                            event._lastBlockNumber = log.blockNumber;\n                                        }\n                                        // Make sure we stall requests to fetch blocks and txs\n                                        this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                        this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                        this.emit(filter, log);\n                                    });\n                                }).catch((error)=>{\n                                    this.emit(\"error\", error);\n                                    // Allow another getLogs (the range was not updated)\n                                    event._inflight = false;\n                                });\n                                runners.push(runner);\n                            }\n                            break;\n                        }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(()=>{\n                this.emit(\"didPoll\", pollId);\n            }).catch((error)=>{\n                this.emit(\"error\", error);\n            });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return logger.throwError(\"provider does not support network detection\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber)=>{\n            this._setFastBlockNumber(blockNumber);\n        }, (error)=>{});\n        return this._fastBlockNumber != null ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return this._poller != null;\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(()=>{\n                this.poll();\n            }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(()=>{\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(()=>{\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof value !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(()=>{\n                this.poll();\n            }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if (now - this._fastQueryDate > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber)=>{\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject)=>{\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function() {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func)=>{\n                        func();\n                    });\n                    return false;\n                };\n                const minedHandler = (receipt)=>{\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(()=>{\n                    this.removeListener(transactionHash, minedHandler);\n                });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber)=>__awaiter(this, void 0, void 0, function*() {\n                            if (done) {\n                                return;\n                            }\n                            // Wait 1 second; this is only used in the case of a fault, so\n                            // we will trade off a little bit of latency for more consistent\n                            // results and fewer JSON-RPC calls\n                            yield stall(1000);\n                            this.getTransactionCount(replaceable.from).then((nonce)=>__awaiter(this, void 0, void 0, function*() {\n                                    if (done) {\n                                        return;\n                                    }\n                                    if (nonce <= replaceable.nonce) {\n                                        lastBlockNumber = blockNumber;\n                                    } else {\n                                        // First check if the transaction was mined\n                                        {\n                                            const mined = yield this.getTransaction(transactionHash);\n                                            if (mined && mined.blockNumber != null) {\n                                                return;\n                                            }\n                                        }\n                                        // First time scanning. We start a little earlier for some\n                                        // wiggle room here to handle the eventually consistent nature\n                                        // of blockchain (e.g. the getTransactionCount was for a\n                                        // different block)\n                                        if (scannedBlock == null) {\n                                            scannedBlock = lastBlockNumber - 3;\n                                            if (scannedBlock < replaceable.startBlock) {\n                                                scannedBlock = replaceable.startBlock;\n                                            }\n                                        }\n                                        while(scannedBlock <= blockNumber){\n                                            if (done) {\n                                                return;\n                                            }\n                                            const block = yield this.getBlockWithTransactions(scannedBlock);\n                                            for(let ti = 0; ti < block.transactions.length; ti++){\n                                                const tx = block.transactions[ti];\n                                                // Successfully mined!\n                                                if (tx.hash === transactionHash) {\n                                                    return;\n                                                }\n                                                // Matches our transaction from and nonce; its a replacement\n                                                if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                                    if (done) {\n                                                        return;\n                                                    }\n                                                    // Get the receipt of the replacement\n                                                    const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                                    // Already resolved or rejected (prolly a timeout)\n                                                    if (alreadyDone()) {\n                                                        return;\n                                                    }\n                                                    // The reason we were replaced\n                                                    let reason = \"replaced\";\n                                                    if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                        reason = \"repriced\";\n                                                    } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                        reason = \"cancelled\";\n                                                    }\n                                                    // Explain why we were replaced\n                                                    reject(logger.makeError(\"transaction was replaced\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TRANSACTION_REPLACED, {\n                                                        cancelled: reason === \"replaced\" || reason === \"cancelled\",\n                                                        reason,\n                                                        replacement: this._wrapTransaction(tx),\n                                                        hash: transactionHash,\n                                                        receipt\n                                                    }));\n                                                    return;\n                                                }\n                                            }\n                                            scannedBlock++;\n                                        }\n                                    }\n                                    if (done) {\n                                        return;\n                                    }\n                                    this.once(\"block\", replaceHandler);\n                                }), (error)=>{\n                                if (done) {\n                                    return;\n                                }\n                                this.once(\"block\", replaceHandler);\n                            });\n                        });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(()=>{\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof timeout === \"number\" && timeout > 0) {\n                    const timer = setTimeout(()=>{\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TIMEOUT, {\n                            timeout: timeout\n                        }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(()=>{\n                        clearTimeout(timer);\n                    });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).toNumber();\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p)=>(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexValue)(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, {\n                expectedHash: tx.hash,\n                returnedHash: hash\n            });\n        }\n        result.wait = (confirms, timeout)=>__awaiter(this, void 0, void 0, function*() {\n                if (confirms == null) {\n                    confirms = 1;\n                }\n                if (timeout == null) {\n                    timeout = 0;\n                }\n                // Get the details to detect replacement\n                let replacement = undefined;\n                if (confirms !== 0 && startBlock != null) {\n                    replacement = {\n                        data: tx.data,\n                        from: tx.from,\n                        nonce: tx.nonce,\n                        to: tx.to,\n                        value: tx.value,\n                        startBlock\n                    };\n                }\n                const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n                if (receipt == null && confirms === 0) {\n                    return null;\n                }\n                // No longer pending, allow the polling loop to garbage collect this\n                this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n                if (receipt.status === 0) {\n                    logger.throwError(\"transaction failed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                        transactionHash: tx.hash,\n                        transaction: tx,\n                        receipt: receipt\n                    });\n                }\n                return receipt;\n            });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then((t)=>(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", {\n                    signedTransaction: hexTx\n                });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            } catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const values = yield transaction;\n            const tx = {};\n            [\n                \"from\",\n                \"to\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? this._getAddress(v) : null);\n            });\n            [\n                \"gasLimit\",\n                \"gasPrice\",\n                \"maxFeePerGas\",\n                \"maxPriorityFeePerGas\",\n                \"value\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(v) : null);\n            });\n            [\n                \"type\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v != null ? v : null);\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\n                \"data\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(v) : null);\n            });\n            return this.formatter.transactionRequest((yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(tx)));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function*() {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\n                \"blockHash\",\n                \"topics\"\n            ].forEach((key)=>{\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\n                \"fromBlock\",\n                \"toBlock\"\n            ].forEach((key)=>{\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter((yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(result)));\n        });\n    }\n    _call(transaction, blockTag, attempt) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (attempt >= MAX_CCIP_REDIRECTS) {\n                logger.throwError(\"CCIP read exceeded maximum redirections\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    redirects: attempt,\n                    transaction\n                });\n            }\n            const txSender = transaction.to;\n            const result = yield this.perform(\"call\", {\n                transaction,\n                blockTag\n            });\n            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n            if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(result) % 32 === 4) {\n                try {\n                    const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, 4);\n                    // Check the sender of the OffchainLookup matches the transaction\n                    const sender = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 0, 32);\n                    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(sender).eq(txSender)) {\n                        logger.throwError(\"CCIP Read sender did not match\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    // Read the URLs from the response\n                    const urls = [];\n                    const urlsOffset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 32, 64)).toNumber();\n                    const urlsLength = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();\n                    const urlsData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset + 32);\n                    for(let u = 0; u < urlsLength; u++){\n                        const url = _parseString(urlsData, u * 32);\n                        if (url == null) {\n                            logger.throwError(\"CCIP Read contained corrupt URL string\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction,\n                                data: result\n                            });\n                        }\n                        urls.push(url);\n                    }\n                    // Get the CCIP calldata to forward\n                    const calldata = _parseBytes(data, 64);\n                    // Get the callbackSelector (bytes4)\n                    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 100, 128)).isZero()) {\n                        logger.throwError(\"CCIP Read callback selector included junk\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    const callbackSelector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 96, 100);\n                    // Get the extra data to send back to the contract as context\n                    const extraData = _parseBytes(data, 128);\n                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);\n                    if (ccipResult == null) {\n                        logger.throwError(\"CCIP Read disabled or provided no URLs\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    const tx = {\n                        to: txSender,\n                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                            callbackSelector,\n                            encodeBytes([\n                                ccipResult,\n                                extraData\n                            ])\n                        ])\n                    };\n                    return this._call(tx, blockTag, attempt + 1);\n                } catch (error) {\n                    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR) {\n                        throw error;\n                    }\n                }\n            }\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params: {\n                        transaction,\n                        blockTag\n                    },\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const resolved = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag),\n                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n            });\n            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function*() {\n            addressOrName = yield addressOrName;\n            if (typeof addressOrName !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            } else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                } catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const block = yield this.perform(\"getBlock\", params);\n                    // Block was not found\n                    if (block == null) {\n                        // For blockhashes, if we didn't say it existed, that blockhash may\n                        // not exist. If we did see it though, perhaps from a log, we know\n                        // it exists, and this node is just not caught up yet.\n                        if (params.blockHash != null) {\n                            if (this._emitted[\"b:\" + params.blockHash] == null) {\n                                return null;\n                            }\n                        }\n                        // For block tags, if we are asking for a future block, we return null\n                        if (params.blockTag != null) {\n                            if (blockNumber > this._emitted.block) {\n                                return null;\n                            }\n                        }\n                        // Retry on the next block\n                        return undefined;\n                    }\n                    // Add transactions\n                    if (includeTransactions) {\n                        let blockNumber = null;\n                        for(let i = 0; i < block.transactions.length; i++){\n                            const tx = block.transactions[i];\n                            if (tx.blockNumber == null) {\n                                tx.confirmations = 0;\n                            } else if (tx.confirmations == null) {\n                                if (blockNumber == null) {\n                                    blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                                }\n                                // Add the confirmations using the fast block number (pessimistic)\n                                let confirmations = blockNumber - tx.blockNumber + 1;\n                                if (confirmations <= 0) {\n                                    confirmations = 1;\n                                }\n                                tx.confirmations = confirmations;\n                            }\n                        }\n                        const blockWithTxs = this.formatter.blockWithTransactions(block);\n                        blockWithTxs.transactions = blockWithTxs.transactions.map((tx)=>this._wrapTransaction(tx));\n                        return blockWithTxs;\n                    }\n                    return this.formatter.block(block);\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, false);\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, true);\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = {\n                transactionHash: this.formatter.hash(transactionHash, true)\n            };\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const result = yield this.perform(\"getTransaction\", params);\n                    if (result == null) {\n                        if (this._emitted[\"t:\" + transactionHash] == null) {\n                            return null;\n                        }\n                        return undefined;\n                    }\n                    const tx = this.formatter.transactionResponse(result);\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n                    } else if (tx.confirmations == null) {\n                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = blockNumber - tx.blockNumber + 1;\n                        if (confirmations <= 0) {\n                            confirmations = 1;\n                        }\n                        tx.confirmations = confirmations;\n                    }\n                    return this._wrapTransaction(tx);\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = {\n                transactionHash: this.formatter.hash(transactionHash, true)\n            };\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const result = yield this.perform(\"getTransactionReceipt\", params);\n                    if (result == null) {\n                        if (this._emitted[\"t:\" + transactionHash] == null) {\n                            return null;\n                        }\n                        return undefined;\n                    }\n                    // \"geth-etc\" returns receipts before they are ready\n                    if (result.blockHash == null) {\n                        return undefined;\n                    }\n                    const receipt = this.formatter.receipt(result);\n                    if (receipt.blockNumber == null) {\n                        receipt.confirmations = 0;\n                    } else if (receipt.confirmations == null) {\n                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = blockNumber - receipt.blockNumber + 1;\n                        if (confirmations <= 0) {\n                            confirmations = 1;\n                        }\n                        receipt.confirmations = confirmations;\n                    }\n                    return receipt;\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                filter: this._getFilter(filter)\n            });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log)=>{\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return _formatter__WEBPACK_IMPORTED_MODULE_14__.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            blockTag = yield blockTag;\n            if (typeof blockTag === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let currentName = name;\n            while(true){\n                if (currentName === \"\" || currentName === \".\") {\n                    return null;\n                }\n                // Optimization since the eth node cannot change and does\n                // not have a wildcard resolver\n                if (name !== \"eth\" && currentName === \"eth\") {\n                    return null;\n                }\n                // Check the current node for a resolver\n                const addr = yield this._getResolver(currentName, \"getResolver\");\n                // Found a resolver!\n                if (addr != null) {\n                    const resolver = new Resolver(this, addr, name);\n                    // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                    if (currentName !== name && !(yield resolver.supportsWildcard())) {\n                        return null;\n                    }\n                    return resolver;\n                }\n                // Get the parent node\n                currentName = currentName.split(\".\").slice(1).join(\".\");\n            }\n        });\n    }\n    _getResolver(name, operation) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (operation == null) {\n                operation = \"ENS\";\n            }\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation,\n                    network: network.name\n                });\n            }\n            try {\n                // keccak256(\"resolver(bytes32)\")\n                const addrData = yield this.call({\n                    to: network.ensAddress,\n                    data: \"0x0178b8bf\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(name).substring(2)\n                });\n                return this.formatter.callAddress(addrData);\n            } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32)\n            }\n            return null;\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            } catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(name)) {\n                    throw error;\n                }\n            }\n            if (typeof name !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resolver\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function*() {\n            address = yield address;\n            address = this.formatter.address(address);\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddr = yield this._getResolver(node, \"lookupAddress\");\n            if (resolverAddr == null) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            const name = _parseString((yield this.call({\n                to: resolverAddr,\n                data: \"0x691f3431\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2)\n            })), 0);\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let resolver = null;\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(node, \"getAvatar\");\n                if (!resolverAddress) {\n                    return null;\n                }\n                // Try resolving the avatar against the addr.reverse resolver\n                resolver = new Resolver(this, resolverAddress, node);\n                try {\n                    const avatar = yield resolver.getAvatar();\n                    if (avatar) {\n                        return avatar.url;\n                    }\n                } catch (error) {\n                    if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                }\n                // Try getting the name and performing forward lookup; allowing wildcards\n                try {\n                    // keccak(\"name(bytes32)\")\n                    const name = _parseString((yield this.call({\n                        to: resolverAddress,\n                        data: \"0x691f3431\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2)\n                    })), 0);\n                    resolver = yield this.getResolver(name);\n                } catch (error) {\n                    if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                    return null;\n                }\n            } else {\n                // ENS name; forward lookup with wildcard\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NOT_IMPLEMENTED, {\n            operation: method\n        });\n    }\n    _startEvent(event) {\n        this.polling = this._events.filter((e)=>e.pollable()).length > 0;\n    }\n    _stopEvent(event) {\n        this.polling = this._events.filter((e)=>e.pollable()).length > 0;\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(()=>{\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event)=>{\n            return event.tag === eventTag;\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event)=>event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event)=>event.tag === eventTag).map((event)=>event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n} //# sourceMappingURL=base-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9iYXNlLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDdUU7QUFDUjtBQUNqQjtB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b3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vYmFzZS1wcm92aWRlci5qcz85NjliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGb3JrRXZlbnQsIFByb3ZpZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBlbmNvZGUgYXMgYmFzZTY0RW5jb2RlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2U2NFwiO1xuaW1wb3J0IHsgQmFzZTU4IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2V4XCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhDb25jYXQsIGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaGV4bGlmeSwgaGV4VmFsdWUsIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBIYXNoWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IGRuc0VuY29kZSwgbmFtZWhhc2ggfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9uZXR3b3Jrc1wiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHksIGdldFN0YXRpYywgcmVzb2x2ZVByb3BlcnRpZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3NoYTJcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsgZmV0Y2hKc29uLCBwb2xsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuaW1wb3J0IGJlY2gzMiBmcm9tIFwiYmVjaDMyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBGb3JtYXR0ZXIgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbmNvbnN0IE1BWF9DQ0lQX1JFRElSRUNUUyA9IDEwO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFdmVudCBTZXJpYWxpemVpbmdcbmZ1bmN0aW9uIGNoZWNrVG9waWModG9waWMpIHtcbiAgICBpZiAodG9waWMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChoZXhEYXRhTGVuZ3RoKHRvcGljKSAhPT0gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdG9waWNcIiwgXCJ0b3BpY1wiLCB0b3BpYyk7XG4gICAgfVxuICAgIHJldHVybiB0b3BpYy50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVG9waWNzKHRvcGljcykge1xuICAgIC8vIFJlbW92ZSB0cmFpbGluZyBudWxsIEFORC10b3BpY3M7IHRoZXkgYXJlIHJlZHVuZGFudFxuICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgpO1xuICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoID4gMCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09IG51bGwpIHtcbiAgICAgICAgdG9waWNzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gdG9waWNzLm1hcCgodG9waWMpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9waWMpKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHRyYWNrIHVuaXF1ZSBPUi10b3BpY3NcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZSA9IHt9O1xuICAgICAgICAgICAgdG9waWMuZm9yRWFjaCgodG9waWMpID0+IHtcbiAgICAgICAgICAgICAgICB1bmlxdWVbY2hlY2tUb3BpYyh0b3BpYyldID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVGhlIG9yZGVyIG9mIE9SLXRvcGljcyBkb2VzIG5vdCBtYXR0ZXJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZCA9IE9iamVjdC5rZXlzKHVuaXF1ZSk7XG4gICAgICAgICAgICBzb3J0ZWQuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZC5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1RvcGljKHRvcGljKTtcbiAgICAgICAgfVxuICAgIH0pLmpvaW4oXCImXCIpO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVUb3BpY3MoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuc3BsaXQoLyYvZykubWFwKCh0b3BpYykgPT4ge1xuICAgICAgICBpZiAodG9waWMgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wcyA9IHRvcGljLnNwbGl0KFwifFwiKS5tYXAoKHRvcGljKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKCh0b3BpYyA9PT0gXCJudWxsXCIpID8gbnVsbCA6IHRvcGljKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKGNvbXBzLmxlbmd0aCA9PT0gMSkgPyBjb21wc1swXSA6IGNvbXBzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50VGFnKGV2ZW50TmFtZSkge1xuICAgIGlmICh0eXBlb2YgKGV2ZW50TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChoZXhEYXRhTGVuZ3RoKGV2ZW50TmFtZSkgPT09IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ0eDpcIiArIGV2ZW50TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiZmlsdGVyOio6XCIgKyBzZXJpYWxpemVUb3BpY3MoZXZlbnROYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoRm9ya0V2ZW50LmlzRm9ya0V2ZW50KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnROYW1lICYmIHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gXCJmaWx0ZXI6XCIgKyAoZXZlbnROYW1lLmFkZHJlc3MgfHwgXCIqXCIpICsgXCI6XCIgKyBzZXJpYWxpemVUb3BpY3MoZXZlbnROYW1lLnRvcGljcyB8fCBbXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnQgLSBcIiArIGV2ZW50TmFtZSk7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlciBPYmplY3RcbmZ1bmN0aW9uIGdldFRpbWUoKSB7XG4gICAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG59XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcbiAgICB9KTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUHJvdmlkZXIgT2JqZWN0XG4vKipcbiAqICBFdmVudFR5cGVcbiAqICAgLSBcImJsb2NrXCJcbiAqICAgLSBcInBvbGxcIlxuICogICAtIFwiZGlkUG9sbFwiXG4gKiAgIC0gXCJwZW5kaW5nXCJcbiAqICAgLSBcImVycm9yXCJcbiAqICAgLSBcIm5ldHdvcmtcIlxuICogICAtIGZpbHRlclxuICogICAtIHRvcGljcyBhcnJheVxuICogICAtIHRyYW5zYWN0aW9uIGhhc2hcbiAqL1xuY29uc3QgUG9sbGFibGVFdmVudHMgPSBbXCJibG9ja1wiLCBcIm5ldHdvcmtcIiwgXCJwZW5kaW5nXCIsIFwicG9sbFwiXTtcbmV4cG9ydCBjbGFzcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IodGFnLCBsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInRhZ1wiLCB0YWcpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImxpc3RlbmVyXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJvbmNlXCIsIG9uY2UpO1xuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgdGhpcy5faW5mbGlnaHQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInR4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaDtcbiAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGFnO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnLnNwbGl0KFwiOlwiKVswXTtcbiAgICB9XG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoXCI6XCIpO1xuICAgICAgICBpZiAoY29tcHNbMF0gIT09IFwidHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBzWzFdO1xuICAgIH1cbiAgICBnZXQgZmlsdGVyKCkge1xuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBcImZpbHRlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gY29tcHNbMV07XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IGRlc2VyaWFsaXplVG9waWNzKGNvbXBzWzJdKTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge307XG4gICAgICAgIGlmICh0b3BpY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzcyAmJiBhZGRyZXNzICE9PSBcIipcIikge1xuICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIHBvbGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudGFnLmluZGV4T2YoXCI6XCIpID49IDAgfHwgUG9sbGFibGVFdmVudHMuaW5kZXhPZih0aGlzLnRhZykgPj0gMCk7XG4gICAgfVxufVxuO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NhdG9zaGlsYWJzL3NsaXBzL2Jsb2IvbWFzdGVyL3NsaXAtMDA0NC5tZFxuY29uc3QgY29pbkluZm9zID0ge1xuICAgIFwiMFwiOiB7IHN5bWJvbDogXCJidGNcIiwgcDJwa2g6IDB4MDAsIHAyc2g6IDB4MDUsIHByZWZpeDogXCJiY1wiIH0sXG4gICAgXCIyXCI6IHsgc3ltYm9sOiBcImx0Y1wiLCBwMnBraDogMHgzMCwgcDJzaDogMHgzMiwgcHJlZml4OiBcImx0Y1wiIH0sXG4gICAgXCIzXCI6IHsgc3ltYm9sOiBcImRvZ2VcIiwgcDJwa2g6IDB4MWUsIHAyc2g6IDB4MTYgfSxcbiAgICBcIjYwXCI6IHsgc3ltYm9sOiBcImV0aFwiLCBpbGs6IFwiZXRoXCIgfSxcbiAgICBcIjYxXCI6IHsgc3ltYm9sOiBcImV0Y1wiLCBpbGs6IFwiZXRoXCIgfSxcbiAgICBcIjcwMFwiOiB7IHN5bWJvbDogXCJ4ZGFpXCIsIGlsazogXCJldGhcIiB9LFxufTtcbmZ1bmN0aW9uIGJ5dGVzMzJpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gaGV4WmVyb1BhZChCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKSwgMzIpO1xufVxuLy8gQ29tcHV0ZSB0aGUgQmFzZTU4Q2hlY2sgZW5jb2RlZCBkYXRhIChjaGVja3N1bSBpcyBmaXJzdCA0IGJ5dGVzIG9mIHNoYTI1NmQpXG5mdW5jdGlvbiBiYXNlNThFbmNvZGUoZGF0YSkge1xuICAgIHJldHVybiBCYXNlNTguZW5jb2RlKGNvbmNhdChbZGF0YSwgaGV4RGF0YVNsaWNlKHNoYTI1NihzaGEyNTYoZGF0YSkpLCAwLCA0KV0pKTtcbn1cbmNvbnN0IG1hdGNoZXJJcGZzID0gbmV3IFJlZ0V4cChcIl4oaXBmcyk6L1xcLyguKikkXCIsIFwiaVwiKTtcbmNvbnN0IG1hdGNoZXJzID0gW1xuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcbiAgICBtYXRjaGVySXBmcyxcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxuXTtcbmZ1bmN0aW9uIF9wYXJzZVN0cmluZyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXQgPSBCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UocmVzdWx0LCBzdGFydCwgc3RhcnQgKyAzMikpLnRvTnVtYmVyKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gQmlnTnVtYmVyLmZyb20oaGV4RGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0LCBvZmZzZXQgKyAzMikpLnRvTnVtYmVyKCk7XG4gICAgcmV0dXJuIGhleERhdGFTbGljZShyZXN1bHQsIG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIGxlbmd0aCk7XG59XG4vLyBUcmltIG9mZiB0aGUgaXBmczovLyBwcmVmaXggYW5kIHJldHVybiB0aGUgZGVmYXVsdCBnYXRld2F5IFVSTFxuZnVuY3Rpb24gZ2V0SXBmc0xpbmsobGluaykge1xuICAgIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC9pcGZzXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZygxMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoNyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgSVBGUyBmb3JtYXRcIiwgXCJsaW5rXCIsIGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gYGh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy8ke2xpbmt9YDtcbn1cbmZ1bmN0aW9uIG51bVBhZCh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHBhZGRlZC5zZXQocmVzdWx0LCAzMiAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIHJldHVybiBwYWRkZWQ7XG59XG5mdW5jdGlvbiBieXRlc1BhZCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMyKSAqIDMyKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQUJJIEVuY29kZXMgYSBzZXJpZXMgb2YgKGJ5dGVzLCBieXRlcywgLi4uKVxuZnVuY3Rpb24gZW5jb2RlQnl0ZXMoZGF0YXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgYnl0ZUNvdW50ID0gMDtcbiAgICAvLyBBZGQgcGxhY2UtaG9sZGVycyBmb3IgcG9pbnRlcnMgYXMgd2UgYWRkIGl0ZW1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhcnJheWlmeShkYXRhc1tpXSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYnl0ZXMgb2Zmc2V0XG4gICAgICAgIHJlc3VsdFtpXSA9IG51bVBhZChieXRlQ291bnQpO1xuICAgICAgICAvLyBUaGUgbGVuZ3RoIGFuZCBwYWRkZWQgdmFsdWUgb2YgZGF0YVxuICAgICAgICByZXN1bHQucHVzaChudW1QYWQoZGF0YS5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZXNQYWQoZGF0YSkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzIgKyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyAzMikgKiAzMjtcbiAgICB9XG4gICAgcmV0dXJuIGhleENvbmNhdChyZXN1bHQpO1xufVxuZXhwb3J0IGNsYXNzIFJlc29sdmVyIHtcbiAgICAvLyBUaGUgcmVzb2x2ZWRBZGRyZXNzIGlzIG9ubHkgZm9yIGNyZWF0aW5nIGEgUmV2ZXJzZUxvb2t1cCByZXNvbHZlclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBhZGRyZXNzLCBuYW1lLCByZXNvbHZlZEFkZHJlc3MpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIHByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3MpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfcmVzb2x2ZWRBZGRyZXNzXCIsIHJlc29sdmVkQWRkcmVzcyk7XG4gICAgfVxuICAgIHN1cHBvcnRzV2lsZGNhcmQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3VwcG9ydHNFaXAyNTQ0KSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0c0ludGVyZmFjZShieXRlczQgPSBzZWxlY3RvcihcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCIpKVxuICAgICAgICAgICAgdGhpcy5fc3VwcG9ydHNFaXAyNTQ0ID0gdGhpcy5wcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiMHgwMWZmYzlhNzkwNjFiOTIzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIlxuICAgICAgICAgICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCkuZXEoMSk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldGhyb3cgdGhlIGVycm9yOiBsaW5rIGlzIGRvd24sIGV0Yy4gTGV0IGZ1dHVyZSBhdHRlbXB0cyByZXRyeS5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdXBwb3J0c0VpcDI1NDQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cHBvcnRzRWlwMjU0NDtcbiAgICB9XG4gICAgX2ZldGNoKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBlLmcuIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMix1aW50MjU2KVwiKVxuICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgdG86IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBjY2lwUmVhZEVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogaGV4Q29uY2F0KFtzZWxlY3RvciwgbmFtZWhhc2godGhpcy5uYW1lKSwgKHBhcmFtZXRlcnMgfHwgXCIweFwiKV0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gV2lsZGNhcmQgc3VwcG9ydDsgdXNlIEVJUC0yNTQ0IHRvIHJlc29sdmUgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIGxldCBwYXJzZUJ5dGVzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoeWllbGQgdGhpcy5zdXBwb3J0c1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZUJ5dGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3RvcihcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCIpXG4gICAgICAgICAgICAgICAgdHguZGF0YSA9IGhleENvbmNhdChbXCIweDkwNjFiOTIzXCIsIGVuY29kZUJ5dGVzKFtkbnNFbmNvZGUodGhpcy5uYW1lKSwgdHguZGF0YV0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHgpO1xuICAgICAgICAgICAgICAgIGlmICgoYXJyYXlpZnkocmVzdWx0KS5sZW5ndGggJSAzMikgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJyZXNvbHZlciB0aHJldyBlcnJvclwiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsIGRhdGE6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX3BhcnNlQnl0ZXMocmVzdWx0LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9mZXRjaEJ5dGVzKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLl9mZXRjaChzZWxlY3RvciwgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlQnl0ZXMocmVzdWx0LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEFkZHJlc3MoY29pblR5cGUsIGhleEJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IGNvaW5JbmZvID0gY29pbkluZm9zW1N0cmluZyhjb2luVHlwZSldO1xuICAgICAgICBpZiAoY29pbkluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoYHVuc3VwcG9ydGVkIGNvaW4gdHlwZTogJHtjb2luVHlwZX1gLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5JbmZvLmlsayA9PT0gXCJldGhcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoaGV4Qnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoaGV4Qnl0ZXMpO1xuICAgICAgICAvLyBQMlBLSDogT1BfRFVQIE9QX0hBU0gxNjAgPHB1YktleUhhc2g+IE9QX0VRVUFMVkVSSUZZIE9QX0NIRUNLU0lHXG4gICAgICAgIGlmIChjb2luSW5mby5wMnBraCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwMnBraCA9IGhleEJ5dGVzLm1hdGNoKC9eMHg3NmE5KFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKik4OGFjJC8pO1xuICAgICAgICAgICAgaWYgKHAycGtoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQocDJwa2hbMV0sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAocDJwa2hbMl0ubGVuZ3RoID09PSBsZW5ndGggKiAyICYmIGxlbmd0aCA+PSAxICYmIGxlbmd0aCA8PSA3NSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTU4RW5jb2RlKGNvbmNhdChbW2NvaW5JbmZvLnAycGtoXSwgKFwiMHhcIiArIHAycGtoWzJdKV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUDJTSDogT1BfSEFTSDE2MCA8c2NyaXB0SGFzaD4gT1BfRVFVQUxcbiAgICAgICAgaWYgKGNvaW5JbmZvLnAyc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcDJzaCA9IGhleEJ5dGVzLm1hdGNoKC9eMHhhOShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopODckLyk7XG4gICAgICAgICAgICBpZiAocDJzaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHAyc2hbMV0sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAocDJzaFsyXS5sZW5ndGggPT09IGxlbmd0aCAqIDIgJiYgbGVuZ3RoID49IDEgJiYgbGVuZ3RoIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNThFbmNvZGUoY29uY2F0KFtbY29pbkluZm8ucDJzaF0sIChcIjB4XCIgKyBwMnNoWzJdKV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVjaDMyXG4gICAgICAgIGlmIChjb2luSW5mby5wcmVmaXggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXNbMV07XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMTQxLm1lZGlhd2lraSN3aXRuZXNzLXByb2dyYW1cbiAgICAgICAgICAgIGxldCB2ZXJzaW9uID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggIT09IDIwICYmIGxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbiA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID49IDAgJiYgYnl0ZXMubGVuZ3RoID09PSAyICsgbGVuZ3RoICYmIGxlbmd0aCA+PSAxICYmIGxlbmd0aCA8PSA3NSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gYmVjaDMyLnRvV29yZHMoYnl0ZXMuc2xpY2UoMikpO1xuICAgICAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlY2gzMi5lbmNvZGUoY29pbkluZm8ucHJlZml4LCB3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoY29pblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChjb2luVHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29pblR5cGUgPSA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIEV0aGVyZXVtLCB1c2UgdGhlIHN0YW5kYXJkIGBhZGRyKGJ5dGVzMzIpYFxuICAgICAgICAgICAgaWYgKGNvaW5UeXBlID09PSA2MCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMilcIilcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5fZmV0Y2goXCIweDNiM2I1N2RlXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIiB8fCByZXN1bHQgPT09IEhhc2haZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuY2FsbEFkZHJlc3MocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIsdWludDI1NlwiKVxuICAgICAgICAgICAgY29uc3QgaGV4Qnl0ZXMgPSB5aWVsZCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHhmMWNiN2UwNlwiLCBieXRlczMyaWZ5KGNvaW5UeXBlKSk7XG4gICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICBpZiAoaGV4Qnl0ZXMgPT0gbnVsbCB8fCBoZXhCeXRlcyA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBhZGRyZXNzXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhjb2luVHlwZSwgaGV4Qnl0ZXMpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvaW4gZGF0YWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxcbiAgICAgICAgICAgICAgICAgICAgY29pblR5cGU6IGNvaW5UeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhCeXRlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBdmF0YXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rYWdlID0gW3sgdHlwZTogXCJuYW1lXCIsIGNvbnRlbnQ6IHRoaXMubmFtZSB9XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBkYXRhIGZvciByaWNtb28uZXRoXG4gICAgICAgICAgICAgICAgLy9jb25zdCBhdmF0YXIgPSBcImVpcDE1NToxL2VyYzcyMToweDI2NTM4NWM3ZjQxMzIyMjhBMGQ1NEVCMUE5ZTc0NjBiOTFjMGNDNjgvMjkyMzNcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBhdmF0YXIgPSB5aWVsZCB0aGlzLmdldFRleHQoXCJhdmF0YXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYXZhdGFyLm1hdGNoKG1hdGNoZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJkYXRhXCIsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlwZnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImlwZnNcIiwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogZ2V0SXBmc0xpbmsoYXZhdGFyKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzExNTVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgRVJDIHR5cGUsIHVzZSB0b2tlblVSSSh1aW50MjU2KSBvciB1cmwodWludDI1NilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IChzY2hlbWUgPT09IFwiZXJjNzIxXCIpID8gXCIweGM4N2I1NmRkXCIgOiBcIjB4MGU4OTM0MWNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBzY2hlbWUsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3duZXIgb2YgdGhpcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3duZXIgPSAodGhpcy5fcmVzb2x2ZWRBZGRyZXNzIHx8ICh5aWVsZCB0aGlzLmdldEFkZHJlc3MoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG1hdGNoWzJdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRyID0geWllbGQgdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhjb21wc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IGhleFplcm9QYWQoQmlnTnVtYmVyLmZyb20oY29tcHNbMV0pLnRvSGV4U3RyaW5nKCksIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgYWNjb3VudCBvd25zIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjNzIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3duZXJPZih1aW50MjU2IHRva2VuSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuT3duZXIgPSB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5jYWxsQWRkcmVzcyh5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGFkZHIsIGRhdGE6IGhleENvbmNhdChbXCIweDYzNTIyMTFlXCIsIHRva2VuSWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJvd25lclwiLCBjb250ZW50OiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhbGFuY2VPZihhZGRyZXNzIG93bmVyLCB1aW50MjU2IHRva2VuSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBCaWdOdW1iZXIuZnJvbSh5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGFkZHIsIGRhdGE6IGhleENvbmNhdChbXCIweDAwZmRkNThlXCIsIGhleFplcm9QYWQob3duZXIsIDMyKSwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhbGFuY2UuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYmFsYW5jZVwiLCBjb250ZW50OiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIHRva2VuIGNvbnRyYWN0IGZvciB0aGUgbWV0YWRhdGEgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGNvbXBzWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4Q29uY2F0KFtzZWxlY3RvciwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGFVcmwgPSBfcGFyc2VTdHJpbmcoeWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHR4KSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWJhc2VcIiwgY29udGVudDogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IG1ldGFkYXRhVXJsLnJlcGxhY2UoXCJ7aWR9XCIsIHRva2VuSWQuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtZXhwYW5kZWRcIiwgY29udGVudDogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIG1ldGFkYXRhIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsLm1hdGNoKC9eaXBmczovaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBnZXRJcGZzTGluayhtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsXCIsIGNvbnRlbnQ6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdG9rZW4gbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHlpZWxkIGZldGNoSnNvbihtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YVwiLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVsbCB0aGUgaW1hZ2UgVVJMIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZVVybCA9IG1ldGFkYXRhLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGltYWdlVXJsKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlVXJsLm1hdGNoKC9eKGh0dHBzOlxcL1xcL3xkYXRhOikvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIGxpbmsgdG8gZ2F0ZXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpcGZzID0gaW1hZ2VVcmwubWF0Y2gobWF0Y2hlcklwZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybC1pcGZzXCIsIGNvbnRlbnQ6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGdldElwZnNMaW5rKGltYWdlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgY29udGVudDogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBpbWFnZVVybCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29udGVudEhhc2goKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBrZWNjYWsyNTYoXCJjb250ZW50aGFzaCgpXCIpXG4gICAgICAgICAgICBjb25zdCBoZXhCeXRlcyA9IHlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweGJjMWM1OGQxXCIpO1xuICAgICAgICAgICAgLy8gTm8gY29udGVudGhhc2hcbiAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElQRlMgKENJRDogMSwgVHlwZTogREFHLVBCKVxuICAgICAgICAgICAgY29uc3QgaXBmcyA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlMzAxMDE3MCgoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XG4gICAgICAgICAgICBpZiAoaXBmcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGlwZnNbM10sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoaXBmc1s0XS5sZW5ndGggPT09IGxlbmd0aCAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaXBmczovXFwvXCIgKyBCYXNlNTguZW5jb2RlKFwiMHhcIiArIGlwZnNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElQTlMgKENJRDogMSwgVHlwZTogbGlicDJwLWtleSlcbiAgICAgICAgICAgIGNvbnN0IGlwbnMgPSBoZXhCeXRlcy5tYXRjaCgvXjB4ZTUwMTAxNzIoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuICAgICAgICAgICAgaWYgKGlwbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChpcG5zWzNdLCAxNik7XG4gICAgICAgICAgICAgICAgaWYgKGlwbnNbNF0ubGVuZ3RoID09PSBsZW5ndGggKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlwbnM6L1xcL1wiICsgQmFzZTU4LmVuY29kZShcIjB4XCIgKyBpcG5zWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTd2FybSAoQ0lEOiAxLCBUeXBlOiBzd2FybS1tYW5pZmVzdDsgaGFzaC9sZW5ndGggaGFyZC1jb2RlZCB0byBrZWNjYWsyNTYvMzIpXG4gICAgICAgICAgICBjb25zdCBzd2FybSA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO1xuICAgICAgICAgICAgaWYgKHN3YXJtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN3YXJtWzFdLmxlbmd0aCA9PT0gKDMyICogMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnp6Oi9cXC9cIiArIHN3YXJtWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNreW5ldCA9IGhleEJ5dGVzLm1hdGNoKC9eMHg5MGIyYzYwNShbMC05YS1mXSopJC8pO1xuICAgICAgICAgICAgaWYgKHNreW5ldCkge1xuICAgICAgICAgICAgICAgIGlmIChza3luZXRbMV0ubGVuZ3RoID09PSAoMzQgKiAyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVUkwgU2FmZSBiYXNlNjQ7IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDY0OCNzZWN0aW9uLTVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsU2FmZSA9IHsgXCI9XCI6IFwiXCIsIFwiK1wiOiBcIi1cIiwgXCIvXCI6IFwiX1wiIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBiYXNlNjRFbmNvZGUoXCIweFwiICsgc2t5bmV0WzFdKS5yZXBsYWNlKC9bPStcXC9dL2csIChhKSA9PiAodXJsU2FmZVthXSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzaWE6L1xcL1wiICsgaGFzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFgLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRDb250ZW50SGFzaCgpXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogaGV4Qnl0ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VGV4dChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBrZXkgZW5jb2RlZCBhcyBwYXJhbWV0ZXIgdG8gZmV0Y2hCeXRlc1xuICAgICAgICAgICAgbGV0IGtleUJ5dGVzID0gdG9VdGY4Qnl0ZXMoa2V5KTtcbiAgICAgICAgICAgIC8vIFRoZSBub2RlaGFzaCBjb25zdW1lcyB0aGUgZmlyc3Qgc2xvdCwgc28gdGhlIHN0cmluZyBwb2ludGVyIHRhcmdldHNcbiAgICAgICAgICAgIC8vIG9mZnNldCA2NCwgd2l0aCB0aGUgbGVuZ3RoIGF0IG9mZnNldCA2NCBhbmQgZGF0YSBzdGFydGluZyBhdCBvZmZzZXQgOTZcbiAgICAgICAgICAgIGtleUJ5dGVzID0gY29uY2F0KFtieXRlczMyaWZ5KDY0KSwgYnl0ZXMzMmlmeShrZXlCeXRlcy5sZW5ndGgpLCBrZXlCeXRlc10pO1xuICAgICAgICAgICAgLy8gUGFkIHRvIHdvcmQtc2l6ZSAoMzIgYnl0ZXMpXG4gICAgICAgICAgICBpZiAoKGtleUJ5dGVzLmxlbmd0aCAlIDMyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGtleUJ5dGVzID0gY29uY2F0KFtrZXlCeXRlcywgaGV4WmVyb1BhZChcIjB4XCIsIDMyIC0gKGtleS5sZW5ndGggJSAzMikpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZXhCeXRlcyA9IHlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweDU5ZDFkNDNjXCIsIGhleGxpZnkoa2V5Qnl0ZXMpKTtcbiAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoaGV4Qnl0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5sZXQgZGVmYXVsdEZvcm1hdHRlciA9IG51bGw7XG5sZXQgbmV4dFBvbGxJZCA9IDE7XG5leHBvcnQgY2xhc3MgQmFzZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICByZWFkeVxuICAgICAqXG4gICAgICogIEEgUHJvbWlzZTxOZXR3b3JrPiB0aGF0IHJlc29sdmVzIG9ubHkgb25jZSB0aGUgcHJvdmlkZXIgaXMgcmVhZHkuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgdGhhdCBjYWxsIHRoZSBzdXBlciB3aXRoIGEgbmV0d29yayB3aXRob3V0IGEgY2hhaW5JZFxuICAgICAqICBNVVNUIHNldCB0aGlzLiBTdGFuZGFyZCBuYW1lZCBuZXR3b3JrcyBoYXZlIGEga25vd24gY2hhaW5JZC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gRXZlbnRzIGJlaW5nIGxpc3RlbmVkIHRvXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9lbWl0dGVkID0geyBibG9jazogLTIgfTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQ2NpcFJlYWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBuZXcudGFyZ2V0LmdldEZvcm1hdHRlcigpO1xuICAgICAgICAvLyBJZiBuZXR3b3JrIGlzIGFueSwgdGhpcyBQcm92aWRlciBhbGxvd3MgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgLy8gbmV0d29yayB0byBjaGFuZ2UgZHluYW1pY2FsbHksIGFuZCB3ZSBhdXRvLWRldGVjdCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBuZXR3b3JrXG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYW55TmV0d29ya1wiLCAobmV0d29yayA9PT0gXCJhbnlcIikpO1xuICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICBuZXR3b3JrID0gdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ldHdvcmsgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrUHJvbWlzZSA9IG5ldHdvcms7XG4gICAgICAgICAgICAvLyBTcXVhc2ggYW55IFwidW5oYW5kbGVkIHByb21pc2VcIiBlcnJvcnM7IHRoYXQgZG8gbm90IG5lZWQgdG8gYmUgaGFuZGxlZFxuICAgICAgICAgICAgbmV0d29yay5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGluaXRpYWwgbmV0d29yayBzZXR0aW5nIChhc3luYylcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5KCkuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga25vd25OZXR3b3JrID0gZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0TmV0d29ya1wiKShuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChrbm93bk5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9uZXR3b3JrXCIsIGtub3duTmV0d29yayk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBrbm93bk5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IC0xMDI0O1xuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgdGhpcy5fbWF4RmlsdGVyQmxvY2tSYW5nZSA9IDEwO1xuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSA0MDAwO1xuICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcbiAgICB9XG4gICAgX3JlYWR5KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29ya1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCB0aGlzLl9uZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnkgdGhlIFByb3ZpZGVyJ3MgbmV0d29yayBkZXRlY3Rpb24gKHRoaXMgTVVTVCB0aHJvdyBpZiBpdCBjYW5ub3QpXG4gICAgICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0geWllbGQgdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbjsgZXZlcnkgUHJvdmlkZXIgc3ViLWNsYXNzIHNob3VsZCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gc3VnZ2VzdGVkIGEgbmV0d29yayBieSBoZXJlIChvciBoYXZlIHRocm93bikuXG4gICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm8gbmV0d29yayBkZXRlY3RlZFwiLCBMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1IsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUG9zc2libGUgdGhpcyBjYWxsIHN0YWNrZWQgc28gZG8gbm90IGNhbGwgZGVmaW5lUmVhZE9ubHkgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFueU5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZXR3b3JrO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgZXN0YWJsaXNoZWQgbmV0d29yay5cbiAgICAvLyBGb3IgXCJhbnlcIiwgdGhpcyBjYW4gY2hhbmdlIChhIFwibmV0d29ya1wiIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlXG4gICAgLy8gYW55IGNoYW5nZSBpcyByZWZsZWN0ZWQpOyBvdGhlcndpc2UgdGhpcyBjYW5ub3QgY2hhbmdlXG4gICAgZ2V0IHJlYWR5KCkge1xuICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHkoKS50aGVuKChuZXR3b3JrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBpc24ndCBydW5uaW5nIHlldCwgd2Ugd2lsbCB3YWl0XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiAmJiBlcnJvci5ldmVudCA9PT0gXCJub05ldHdvcmtcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIGFuZCBqdXN0IGNyZWF0ZSBhIHNpbmdsZXRvbiBmb3JtYXR0ZXJcbiAgICBzdGF0aWMgZ2V0Rm9ybWF0dGVyKCkge1xuICAgICAgICBpZiAoZGVmYXVsdEZvcm1hdHRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Rm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyO1xuICAgIH1cbiAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgdXNlIGdldE5ldHdvcmtcbiAgICBzdGF0aWMgZ2V0TmV0d29yayhuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBnZXROZXR3b3JrKChuZXR3b3JrID09IG51bGwpID8gXCJob21lc3RlYWRcIiA6IG5ldHdvcmspO1xuICAgIH1cbiAgICBjY2lwUmVhZEZldGNoKHR4LCBjYWxsZGF0YSwgdXJscykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUNjaXBSZWFkIHx8IHVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZW5kZXIgPSB0eC50by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNhbGxkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxzW2ldO1xuICAgICAgICAgICAgICAgIC8vIFVSTCBleHBhbnNpb25cbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gdXJsLnJlcGxhY2UoXCJ7c2VuZGVyfVwiLCBzZW5kZXIpLnJlcGxhY2UoXCJ7ZGF0YX1cIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8ge2RhdGF9IGlzIHByZXNlbnQsIHVzZSBQT1NUOyBvdGhlcndpc2UgR0VUXG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9ICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA+PSAwKSA/IG51bGwgOiBKU09OLnN0cmluZ2lmeSh7IGRhdGEsIHNlbmRlciB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBmZXRjaEpzb24oeyB1cmw6IGhyZWYsIGVycm9yUGFzc1Rocm91Z2g6IHRydWUgfSwganNvbiwgKHZhbHVlLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKHJlc3VsdC5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAvLyA0eHggaW5kaWNhdGVzIHRoZSByZXN1bHQgaXMgbm90IHByZXNlbnQ7IHN0b3BcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA+PSA0MDAgJiYgcmVzdWx0LnN0YXR1cyA8IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYHJlc3BvbnNlIG5vdCBmb3VuZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2V9YCwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHsgdXJsLCBlcnJvck1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDV4eCBpbmRpY2F0ZXMgc2VydmVyIGlzc3VlOyB0cnkgdGhlIG5leHQgdXJsXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZXMubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtKSkuam9pbihcIiwgXCIpfWAsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgdXJscywgZXJyb3JNZXNzYWdlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBGZXRjaGVzIHRoZSBibG9ja051bWJlciwgYnV0IHdpbGwgcmV1c2UgYW55IHJlc3VsdCB0aGF0IGlzIGxlc3NcbiAgICAvLyB0aGFuIG1heEFnZSBvbGQgb3IgaGFzIGJlZW4gcmVxdWVzdGVkIHNpbmNlIHRoZSBsYXN0IHJlcXVlc3RcbiAgICBfZ2V0SW50ZXJuYWxCbG9ja051bWJlcihtYXhBZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX3JlYWR5KCk7XG4gICAgICAgICAgICAvLyBBbGxvd2luZyBzdGFsZSBkYXRhIHVwIHRvIG1heEFnZSBvbGRcbiAgICAgICAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgdGhlcmUgYXJlIHBlbmRpbmcgaW50ZXJuYWwgYmxvY2sgcmVxdWVzdHMuLi5cbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi5cInJlbWVtYmVyXCIgd2hpY2ggZmV0Y2ggd2Ugc3RhcnRlZCB3aXRoXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsQmxvY2tOdW1iZXIgPSB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJlc3VsdCBpcyBub3QgdG9vIHN0YWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBpbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChnZXRUaW1lKCkgLSByZXN1bHQucmVzcFRpbWUpIDw9IG1heEFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb28gb2xkOyBmZXRjaCBhIG5ldyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmV0Y2ggcmVqZWN0ZWQ7IGlmIHdlIGFyZSB0aGUgZmlyc3QgdG8gZ2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0aW9uLCBkcm9wIHRocm91Z2ggc28gd2UgcmVwbGFjZSBpdCB3aXRoIGEgbmV3XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmZXRjaDsgYWxsIG90aGVycyBibG9ja2VkIHdpbGwgdGhlbiBnZXQgdGhhdCBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggd29uJ3QgbWF0Y2ggdGhlIG9uZSB0aGV5IFwicmVtZW1iZXJlZFwiIGFuZCBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gaW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxVGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlciA9IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wZXJmb3JtKFwiZ2V0QmxvY2tOdW1iZXJcIiwge30pLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtFcnJvcjogdGhpcy5nZXROZXR3b3JrKCkudGhlbigobmV0d29yaykgPT4gKG51bGwpLCAoZXJyb3IpID0+IChlcnJvcikpXG4gICAgICAgICAgICB9KS50aGVuKCh7IGJsb2NrTnVtYmVyLCBuZXR3b3JrRXJyb3IgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5yZW1lbWJlciB0aGlzIGJhZCBpbnRlcm5hbCBibG9jayBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV0d29ya0Vycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwVGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IEJpZ051bWJlci5mcm9tKGJsb2NrTnVtYmVyKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTsgLy8gQFRPRE86IFN0aWxsIG5lZWQgdGhpcz9cbiAgICAgICAgICAgICAgICByZXR1cm4geyBibG9ja051bWJlciwgcmVxVGltZSwgcmVzcFRpbWUgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgdW5oYW5kbGVkIGV4Y2VwdGlvbnM7IGlmIG5lZWRlZCB0aGV5IGFyZSBoYW5kbGVkIGVsc2Ugd2hlcmVcbiAgICAgICAgICAgIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlci5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBudWxsIHRoZSBkZWFkIChyZWplY3RlZCkgZmV0Y2gsIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID09PSBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikuYmxvY2tOdW1iZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb2xsKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcG9sbElkID0gbmV4dFBvbGxJZCsrO1xuICAgICAgICAgICAgLy8gVHJhY2sgYWxsIHJ1bm5pbmcgcHJvbWlzZXMsIHNvIHdlIGNhbiB0cmlnZ2VyIGEgcG9zdC1wb2xsIG9uY2UgdGhleSBhcmUgY29tcGxldGVcbiAgICAgICAgICAgIGNvbnN0IHJ1bm5lcnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyB0aGlzLnBvbGxpbmdJbnRlcnZhbCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG4gICAgICAgICAgICAvLyBFbWl0IGEgcG9sbCBldmVudCBhZnRlciB3ZSBoYXZlIHRoZSBsYXRlc3QgKGZhc3QpIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgdGhpcy5lbWl0KFwicG9sbFwiLCBwb2xsSWQsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBibG9jayBoYXMgbm90IGNoYW5nZWQsIG1laC5cbiAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PT0gdGhpcy5fbGFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGlkUG9sbFwiLCBwb2xsSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcnN0IHBvbGxpbmcgY3ljbGUsIHRyaWdnZXIgYSBcImJsb2NrXCIgZXZlbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKCh0aGlzLl9lbWl0dGVkLmJsb2NrKSAtIGJsb2NrTnVtYmVyKSA+IDEwMDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgbmV0d29yayBibG9jayBza2V3IGRldGVjdGVkOyBza2lwcGluZyBibG9jayBldmVudHMgKGVtaXR0ZWQ9JHt0aGlzLl9lbWl0dGVkLmJsb2NrfSBibG9ja051bWJlciR7YmxvY2tOdW1iZXJ9KWApO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGxvZ2dlci5tYWtlRXJyb3IoXCJuZXR3b3JrIGJsb2NrIHNrZXcgZGV0ZWN0ZWRcIiwgTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBibG9ja051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiYmxvY2tTa2V3XCIsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQmxvY2tOdW1iZXI6IHRoaXMuX2VtaXR0ZWQuYmxvY2tcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYmxvY2tcIiwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBsaXN0ZW5lciBmb3IgZWFjaCBibG9jayB0aGF0IGhhcyBwYXNzZWRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fZW1pdHRlZC5ibG9jayArIDE7IGkgPD0gYmxvY2tOdW1iZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgZW1pdHRlZCBibG9jayB3YXMgdXBkYXRlZCwgY2hlY2sgZm9yIG9ic29sZXRlIGV2ZW50c1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWQuYmxvY2sgIT09IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2VtaXR0ZWQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmxvY2sgZXZlbnQgZG9lcyBub3QgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiYmxvY2tcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayB3ZSB3ZXJlIGF0IHdoZW4gd2UgZW1pdHRlZCB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50QmxvY2tOdW1iZXIgPSB0aGlzLl9lbWl0dGVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBnYXJiYWdlIGNvbGxlY3QgcGVuZGluZyB0cmFuc2FjdGlvbnMgb3IgYmxvY2tzIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBzaG91bGQgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYnkgdGhlIFByb3ZpZGVyIHdoZW4gc2V0dGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBcInBlbmRpbmdcIiBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50QmxvY2tOdW1iZXIgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXZpY3QgYW55IHRyYW5zYWN0aW9uIGhhc2hlcyBvciBibG9jayBoYXNoZXMgb3ZlciAxMiBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgLy8gb2xkLCBzaW5jZSB0aGV5IHNob3VsZCBub3QgcmV0dXJuIG51bGwgYW55d2F5c1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgLSBldmVudEJsb2NrTnVtYmVyID4gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9lbWl0dGVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcnN0IHBvbGxpbmcgY3ljbGVcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluZCBhbGwgdHJhbnNhY3Rpb24gaGFzaGVzIHdlIGFyZSB3YWl0aW5nIG9uXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBldmVudC5oYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bm5lciA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpLnRoZW4oKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQgfHwgcmVjZWlwdC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkW1widDpcIiArIGhhc2hdID0gcmVjZWlwdC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoaGFzaCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGFsbG93IGEgc2luZ2xlIGdldExvZ3MgdG8gYmUgaW4tZmxpZ2h0IGF0IGEgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5faW5mbGlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5faW5mbGlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGZpbHRlciBmb3IgdGhpcyBldmVudCwgc28gd2Ugd2FudCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3RyaWN0IGV2ZW50cyB0byBldmVudHMgdGhhdCBoYXBwZW5lZCBubyBlYXJsaWVyIHRoYW4gbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBmcm9tIHRoZSBsYXN0ICprbm93biogZXZlbnQ7IGR1ZSB0byBsb2FkLWJhbGFuY2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBzb21lIG5vZGVzIHJldHVybmluZyB1cGRhdGVkIGJsb2NrIG51bWJlcnMgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhpbmcgZXZlbnRzLCBhIGxvZ3MgcmVzdWx0IHdpdGggMCBlbnRyaWVzIGNhbm5vdCBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydXN0ZWQgYW5kIHdlIG11c3QgcmV0cnkgYSByYW5nZSB3aGljaCBpbmNsdWRlcyBpdCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGV2ZW50LmZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gZXZlbnQuX2xhc3RCbG9ja051bWJlciArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGZpdGxlciByYW5nZXMgZnJvbSBncm93aW5nIHRvbyB3aWxkLCBzaW5jZSBpdCBpcyBxdWl0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpa2VseSB0aGVyZSBqdXN0IGhhdmVuJ3QgYmVlbiBhbnkgZXZlbnRzIHRvIG1vdmUgdGhlIGxhc3RCbG9ja051bWJlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW5Gcm9tQmxvY2sgPSBmaWx0ZXIudG9CbG9jayAtIHRoaXMuX21heEZpbHRlckJsb2NrUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkZyb21CbG9jayA+IGZpbHRlci5mcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IG1pbkZyb21CbG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5mcm9tQmxvY2sgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBydW5uZXIgPSB0aGlzLmdldExvZ3MoZmlsdGVyKS50aGVuKChsb2dzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBuZXh0IGdldExvZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2luZmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3MuZm9yRWFjaCgobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHdoZW4gd2UgZ2V0IGFuIGV2ZW50IGZvciBhIGdpdmVuIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHdlIHRydXN0IHRoZSBldmVudHMgYXJlIGluZGV4ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cuYmxvY2tOdW1iZXIgPiBldmVudC5fbGFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2xhc3RCbG9ja051bWJlciA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzdGFsbCByZXF1ZXN0cyB0byBmZXRjaCBibG9ja3MgYW5kIHR4c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcImI6XCIgKyBsb2cuYmxvY2tIYXNoXSA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgbG9nLnRyYW5zYWN0aW9uSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZmlsdGVyLCBsb2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbm90aGVyIGdldExvZ3MgKHRoZSByYW5nZSB3YXMgbm90IHVwZGF0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9pbmZsaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgLy8gT25jZSBhbGwgZXZlbnRzIGZvciB0aGlzIGxvb3AgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgZW1pdCBcImRpZFBvbGxcIlxuICAgICAgICAgICAgUHJvbWlzZS5hbGwocnVubmVycykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGlkUG9sbFwiLCBwb2xsSWQpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBEZXByZWNhdGVkOyBkbyBub3QgdXNlIHRoaXNcbiAgICByZXNldEV2ZW50c0Jsb2NrKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gMTtcbiAgICAgICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXR3b3JrO1xuICAgIH1cbiAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgcXVlcnkgdGhlIG5ldHdvcmsgaWYgdGhlIHVuZGVybHlpbmcgbmV0d29ya1xuICAgIC8vIGNhbiBjaGFuZ2UsIHN1Y2ggYXMgd2hlbiBjb25uZWN0ZWQgdG8gYSBKU09OLVJQQyBiYWNrZW5kXG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgbmV0d29yayBkZXRlY3Rpb25cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicHJvdmlkZXIuZGV0ZWN0TmV0d29ya1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0geWllbGQgdGhpcy5fcmVhZHkoKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhcmUgc3RpbGwgY29ubmVjdGVkIHRvIHRoZSBzYW1lIG5ldHdvcms7IHRoaXMgaXNcbiAgICAgICAgICAgIC8vIG9ubHkgYW4gZXh0ZXJuYWwgY2FsbCBmb3IgYmFja2VuZHMgd2hpY2ggY2FuIGhhdmUgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgICAgIC8vIG5ldHdvcmsgY2hhbmdlIHNwb250YW5lb3VzbHlcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROZXR3b3JrID0geWllbGQgdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICBpZiAobmV0d29yay5jaGFpbklkICE9PSBjdXJyZW50TmV0d29yay5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGFsbG93aW5nIG5ldHdvcmsgY2hhbmdlcywgdGhpbmdzIGNhbiBnZXQgY29tcGxleCBmYXN0O1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcgaWYgeW91IHVzZSBcImFueVwiXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXR3b3JrID0gY3VycmVudE5ldHdvcms7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGFsbCBpbnRlcm5hbCBibG9jayBudW1iZXIgZ3VhcmRzIGFuZCBjYWNoZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IC0yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gLTEwMjQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgXCJuZXR3b3JrXCIgZXZlbnQgTVVTVCBoYXBwZW4gYmVmb3JlIHRoaXMgbWV0aG9kIHJlc29sdmVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGFueSBldmVudHMgaGF2ZSBhIGNoYW5jZSB0byB1bnJlZ2lzdGVyLCBzbyB3ZSBzdGFsbCBhblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbmFsIGV2ZW50IGxvb3AgYmVmb3JlIHJldHVybmluZyBmcm9tIC90aGlzLyBjYWxsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgY3VycmVudE5ldHdvcmssIG5ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBzdGFsbCgwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbG9nZ2VyLm1ha2VFcnJvcihcInVuZGVybHlpbmcgbmV0d29yayBjaGFuZ2VkXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCIsXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcms6IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgIGRldGVjdGVkTmV0d29yazogY3VycmVudE5ldHdvcmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBibG9ja051bWJlcigpIHtcbiAgICAgICAgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyB0aGlzLnBvbGxpbmdJbnRlcnZhbCAvIDIpLnRoZW4oKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgIHJldHVybiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyICE9IG51bGwpID8gdGhpcy5fZmFzdEJsb2NrTnVtYmVyIDogLTE7XG4gICAgfVxuICAgIGdldCBwb2xsaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3BvbGxlciAhPSBudWxsKTtcbiAgICB9XG4gICAgc2V0IHBvbGxpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IHNldEludGVydmFsKCgpID0+IHsgdGhpcy5wb2xsKCk7IH0sIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYm9vdHN0cmFwUG9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcFBvbGwgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGJsb2NrIGFkZGl0aW9uYWwgcG9sbHMgdW50aWwgdGhlIHBvbGxpbmcgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgZG9uZSwgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHBvbGwgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcG9sbGluZyB3YXMgZGlzYWJsZWQsIHNvbWV0aGluZyBtYXkgcmVxdWlyZSBhIHBva2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHN0YXJ0aW5nIHRoZSBib290c3RyYXAgcG9sbCBhbmQgaXQgd2FzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9sbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBib290c3RyYXAgc28gd2UgY2FuIGRvIGFub3RoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcFBvbGwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9sbGluZ0ludGVydmFsO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8PSAwIHx8IHBhcnNlSW50KFN0cmluZyh2YWx1ZSkpICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvbGxpbmcgaW50ZXJ2YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcG9sbGVyKTtcbiAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IHNldEludGVydmFsKCgpID0+IHsgdGhpcy5wb2xsKCk7IH0sIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldEZhc3RCbG9ja051bWJlcigpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBTdGFsZSBibG9jayBudW1iZXIsIHJlcXVlc3QgYSBuZXdlciB2YWx1ZVxuICAgICAgICBpZiAoKG5vdyAtIHRoaXMuX2Zhc3RRdWVyeURhdGUpID4gMiAqIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IG5vdztcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSB0aGlzLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyID09IG51bGwgfHwgYmxvY2tOdW1iZXIgPiB0aGlzLl9mYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYXN0QmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZTtcbiAgICB9XG4gICAgX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcikge1xuICAgICAgICAvLyBPbGRlciBibG9jaywgbWF5YmUgYSBzdGFsZSByZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCAmJiBibG9ja051bWJlciA8IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdGltZSB3ZSB1cGRhdGVkIHRoZSBibG9ja251bWJlclxuICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBOZXdlciBibG9jayBudW1iZXIsIHVzZSAgaXRcbiAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYmxvY2tOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCAoY29uZmlybWF0aW9ucyA9PSBudWxsKSA/IDEgOiBjb25maXJtYXRpb25zLCB0aW1lb3V0IHx8IDAsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3dhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQsIHJlcGxhY2VhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0geWllbGQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgIC8vIFJlY2VpcHQgaXMgYWxyZWFkeSBnb29kXG4gICAgICAgICAgICBpZiAoKHJlY2VpcHQgPyByZWNlaXB0LmNvbmZpcm1hdGlvbnMgOiAwKSA+PSBjb25maXJtYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQb2xsIHVudGlsIHRoZSByZWNlaXB0IGlzIGdvb2QuLi5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsRnVuY3MgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscmVhZHlEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHsgZnVuYygpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgbWluZWRIYW5kbGVyID0gKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuY29uZmlybWF0aW9ucyA8IGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKHRyYW5zYWN0aW9uSGFzaCwgbWluZWRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKCgpID0+IHsgdGhpcy5yZW1vdmVMaXN0ZW5lcih0cmFuc2FjdGlvbkhhc2gsIG1pbmVkSGFuZGxlcik7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdEJsb2NrTnVtYmVyID0gcmVwbGFjZWFibGUuc3RhcnRCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjYW5uZWRCbG9jayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VIYW5kbGVyID0gKGJsb2NrTnVtYmVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgMSBzZWNvbmQ7IHRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBjYXNlIG9mIGEgZmF1bHQsIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3aWxsIHRyYWRlIG9mZiBhIGxpdHRsZSBiaXQgb2YgbGF0ZW5jeSBmb3IgbW9yZSBjb25zaXN0ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGFuZCBmZXdlciBKU09OLVJQQyBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGwoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFRyYW5zYWN0aW9uQ291bnQocmVwbGFjZWFibGUuZnJvbSkudGhlbigobm9uY2UpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25jZSA8PSByZXBsYWNlYWJsZS5ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgbWluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluZWQgPSB5aWVsZCB0aGlzLmdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCB0aW1lIHNjYW5uaW5nLiBXZSBzdGFydCBhIGxpdHRsZSBlYXJsaWVyIGZvciBzb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpZ2dsZSByb29tIGhlcmUgdG8gaGFuZGxlIHRoZSBldmVudHVhbGx5IGNvbnNpc3RlbnQgbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGJsb2NrY2hhaW4gKGUuZy4gdGhlIGdldFRyYW5zYWN0aW9uQ291bnQgd2FzIGZvciBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCBibG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYW5uZWRCbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2sgPSBsYXN0QmxvY2tOdW1iZXIgLSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYW5uZWRCbG9jayA8IHJlcGxhY2VhYmxlLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2sgPSByZXBsYWNlYWJsZS5zdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzY2FubmVkQmxvY2sgPD0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCB0aGlzLmdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyhzY2FubmVkQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdGkgPSAwOyB0aSA8IGJsb2NrLnRyYW5zYWN0aW9ucy5sZW5ndGg7IHRpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGJsb2NrLnRyYW5zYWN0aW9uc1t0aV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bGx5IG1pbmVkIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSB0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVzIG91ciB0cmFuc2FjdGlvbiBmcm9tIGFuZCBub25jZTsgaXRzIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZnJvbSA9PT0gcmVwbGFjZWFibGUuZnJvbSAmJiB0eC5ub25jZSA9PT0gcmVwbGFjZWFibGUubm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlY2VpcHQgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB5aWVsZCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbih0eC5oYXNoLCBjb25maXJtYXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSByZXNvbHZlZCBvciByZWplY3RlZCAocHJvbGx5IGEgdGltZW91dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVhc29uIHdlIHdlcmUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEgPT09IHJlcGxhY2VhYmxlLmRhdGEgJiYgdHgudG8gPT09IHJlcGxhY2VhYmxlLnRvICYmIHR4LnZhbHVlLmVxKHJlcGxhY2VhYmxlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJyZXByaWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmRhdGEgPT09IFwiMHhcIiAmJiB0eC5mcm9tID09PSB0eC50byAmJiB0eC52YWx1ZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBsYWluIHdoeSB3ZSB3ZXJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkXCIsIExvZ2dlci5lcnJvcnMuVFJBTlNBQ1RJT05fUkVQTEFDRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZDogKHJlYXNvbiA9PT0gXCJyZXBsYWNlZFwiIHx8IHJlYXNvbiA9PT0gXCJjYW5jZWxsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IHRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbm5lZEJsb2NrKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0aW1lb3V0KSA9PT0gXCJudW1iZXJcIiAmJiB0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRpbWVvdXQgZXhjZWVkZWRcIiwgTG9nZ2VyLmVycm9ycy5USU1FT1VULCB7IHRpbWVvdXQ6IHRpbWVvdXQgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyLnVucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLnB1c2goKCkgPT4geyBjbGVhclRpbWVvdXQodGltZXIpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJsb2NrTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRHYXNQcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0R2FzUHJpY2VcIiwge30pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRHYXNQcmljZVwiLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRCYWxhbmNlKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0QmFsYW5jZVwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25Db3VudChhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uQ291bnRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29kZShhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldENvZGVcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0U3RvcmFnZUF0KGFkZHJlc3NPck5hbWUsIHBvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBQcm9taXNlLnJlc29sdmUocG9zaXRpb24pLnRoZW4oKHApID0+IGhleFZhbHVlKHApKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRTdG9yYWdlQXRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRTdG9yYWdlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYnkgYW55IHN1YmNsYXNzIHdyYXBwaW5nIGEgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgIF93cmFwVHJhbnNhY3Rpb24odHgsIGhhc2gsIHN0YXJ0QmxvY2spIHtcbiAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiBoZXhEYXRhTGVuZ3RoKGhhc2gpICE9PSAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZSAtIHNlbmRUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0eDtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGhhc2ggd2UgZXhwZWN0IGlzIHRoZSBzYW1lIGFzIHRoZSBoYXNoIHRoZSBzZXJ2ZXIgcmVwb3J0ZWRcbiAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiB0eC5oYXNoICE9PSBoYXNoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIlRyYW5zYWN0aW9uIGhhc2ggbWlzbWF0Y2ggZnJvbSBQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24uXCIsIExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwgeyBleHBlY3RlZEhhc2g6IHR4Lmhhc2gsIHJldHVybmVkSGFzaDogaGFzaCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQud2FpdCA9IChjb25maXJtcywgdGltZW91dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maXJtcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGRldGFpbHMgdG8gZGV0ZWN0IHJlcGxhY2VtZW50XG4gICAgICAgICAgICBsZXQgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29uZmlybXMgIT09IDAgJiYgc3RhcnRCbG9jayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHR4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHR4LmZyb20sXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlOiB0eC5ub25jZSxcbiAgICAgICAgICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2tcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHlpZWxkIHRoaXMuX3dhaXRGb3JUcmFuc2FjdGlvbih0eC5oYXNoLCBjb25maXJtcywgdGltZW91dCwgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCAmJiBjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbG9uZ2VyIHBlbmRpbmcsIGFsbG93IHRoZSBwb2xsaW5nIGxvb3AgdG8gZ2FyYmFnZSBjb2xsZWN0IHRoaXNcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHguaGFzaF0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0cmFuc2FjdGlvbiBmYWlsZWRcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdDogcmVjZWlwdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgaGV4VHggPSB5aWVsZCBQcm9taXNlLnJlc29sdmUoc2lnbmVkVHJhbnNhY3Rpb24pLnRoZW4odCA9PiBoZXhsaWZ5KHQpKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJzZW5kVHJhbnNhY3Rpb25cIiwgeyBzaWduZWRUcmFuc2FjdGlvbjogaGV4VHggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCwgaGFzaCwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IudHJhbnNhY3Rpb24gPSB0eDtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbkhhc2ggPSB0eC5oYXNoO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0geWllbGQgdHJhbnNhY3Rpb247XG4gICAgICAgICAgICBjb25zdCB0eCA9IHt9O1xuICAgICAgICAgICAgW1wiZnJvbVwiLCBcInRvXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKHYgPyB0aGlzLl9nZXRBZGRyZXNzKHYpIDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBbXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oKHYpID0+ICh2ID8gQmlnTnVtYmVyLmZyb20odikgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFtcInR5cGVcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKCh2KSA9PiAoKHYgIT0gbnVsbCkgPyB2IDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICB0eC5hY2Nlc3NMaXN0ID0gdGhpcy5mb3JtYXR0ZXIuYWNjZXNzTGlzdCh2YWx1ZXMuYWNjZXNzTGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbXCJkYXRhXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKHYgPyBoZXhsaWZ5KHYpIDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXF1ZXN0KHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHR4KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmlsdGVyKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZmlsdGVyID0geWllbGQgZmlsdGVyO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbXCJibG9ja0hhc2hcIiwgXCJ0b3BpY3NcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGZpbHRlcltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBbXCJmcm9tQmxvY2tcIiwgXCJ0b0Jsb2NrXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXJba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5maWx0ZXIoeWllbGQgcmVzb2x2ZVByb3BlcnRpZXMocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tUYWcsIGF0dGVtcHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0ID49IE1BWF9DQ0lQX1JFRElSRUNUUykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCByZWFkIGV4Y2VlZGVkIG1heGltdW0gcmVkaXJlY3Rpb25zXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0czogYXR0ZW1wdCwgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4U2VuZGVyID0gdHJhbnNhY3Rpb24udG87XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJjYWxsXCIsIHsgdHJhbnNhY3Rpb24sIGJsb2NrVGFnIH0pO1xuICAgICAgICAgICAgLy8gQ0NJUCBSZWFkIHJlcXVlc3QgdmlhIE9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVxuICAgICAgICAgICAgaWYgKGF0dGVtcHQgPj0gMCAmJiBibG9ja1RhZyA9PT0gXCJsYXRlc3RcIiAmJiB0eFNlbmRlciAhPSBudWxsICYmIHJlc3VsdC5zdWJzdHJpbmcoMCwgMTApID09PSBcIjB4NTU2ZjE4MzBcIiAmJiAoaGV4RGF0YUxlbmd0aChyZXN1bHQpICUgMzIgPT09IDQpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGhleERhdGFTbGljZShyZXN1bHQsIDQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgc2VuZGVyIG9mIHRoZSBPZmZjaGFpbkxvb2t1cCBtYXRjaGVzIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZW5kZXIgPSBoZXhEYXRhU2xpY2UoZGF0YSwgMCwgMzIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUJpZ051bWJlci5mcm9tKHNlbmRlcikuZXEodHhTZW5kZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBzZW5kZXIgZGlkIG5vdCBtYXRjaFwiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIHRoZSBVUkxzIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsc09mZnNldCA9IEJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShkYXRhLCAzMiwgNjQpKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxzTGVuZ3RoID0gQmlnTnVtYmVyLmZyb20oaGV4RGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQsIHVybHNPZmZzZXQgKyAzMikpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybHNEYXRhID0gaGV4RGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQgKyAzMik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdXJsc0xlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBfcGFyc2VTdHJpbmcodXJsc0RhdGEsIHUgKiAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBjb250YWluZWQgY29ycnVwdCBVUkwgc3RyaW5nXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVybHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgQ0NJUCBjYWxsZGF0YSB0byBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxkYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgNjQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNhbGxiYWNrU2VsZWN0b3IgKGJ5dGVzNClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UoZGF0YSwgMTAwLCAxMjgpKS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIFJlYWQgY2FsbGJhY2sgc2VsZWN0b3IgaW5jbHVkZWQganVua1wiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFja1NlbGVjdG9yID0gaGV4RGF0YVNsaWNlKGRhdGEsIDk2LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGV4dHJhIGRhdGEgdG8gc2VuZCBiYWNrIHRvIHRoZSBjb250cmFjdCBhcyBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhRGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDEyOCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNjaXBSZXN1bHQgPSB5aWVsZCB0aGlzLmNjaXBSZWFkRmV0Y2godHJhbnNhY3Rpb24sIGNhbGxkYXRhLCB1cmxzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNjaXBSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIFJlYWQgZGlzYWJsZWQgb3IgcHJvdmlkZWQgbm8gVVJMc1wiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0eFNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleENvbmNhdChbY2FsbGJhY2tTZWxlY3RvciwgZW5jb2RlQnl0ZXMoW2NjaXBSZXN1bHQsIGV4dHJhRGF0YV0pXSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7IHRyYW5zYWN0aW9uLCBibG9ja1RhZyB9LCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpLFxuICAgICAgICAgICAgICAgIGNjaXBSZWFkRW5hYmxlZDogUHJvbWlzZS5yZXNvbHZlKHRyYW5zYWN0aW9uLmNjaXBSZWFkRW5hYmxlZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGwocmVzb2x2ZWQudHJhbnNhY3Rpb24sIHJlc29sdmVkLmJsb2NrVGFnLCByZXNvbHZlZC5jY2lwUmVhZEVuYWJsZWQgPyAwIDogLTEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImVzdGltYXRlR2FzXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImVzdGltYXRlR2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYWRkcmVzc09yTmFtZSA9IHlpZWxkIGFkZHJlc3NPck5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzT3JOYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3Mgb3IgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIGFkZHJlc3NPck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJFTlMgbmFtZSBub3QgY29uZmlndXJlZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IGByZXNvbHZlTmFtZSgke0pTT04uc3RyaW5naWZ5KGFkZHJlc3NPck5hbWUpfSlgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCBpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGJsb2NrSGFzaE9yQmxvY2tUYWcgPSB5aWVsZCBibG9ja0hhc2hPckJsb2NrVGFnO1xuICAgICAgICAgICAgLy8gSWYgYmxvY2tUYWcgaXMgYSBudW1iZXIgKG5vdCBcImxhdGVzdFwiLCBldGMpLCB0aGlzIGlzIHRoZSBibG9jayBudW1iZXJcbiAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IC0xMjg7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaW5jbHVkZVRyYW5zYWN0aW9uczogISFpbmNsdWRlVHJhbnNhY3Rpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrSGFzaE9yQmxvY2tUYWcsIDMyKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5ibG9ja0hhc2ggPSBibG9ja0hhc2hPckJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmJsb2NrVGFnID0geWllbGQgdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tIYXNoT3JCbG9ja1RhZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IHBhcnNlSW50KHBhcmFtcy5ibG9ja1RhZy5zdWJzdHJpbmcoMiksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYmxvY2sgaGFzaCBvciBibG9jayB0YWdcIiwgXCJibG9ja0hhc2hPckJsb2NrVGFnXCIsIGJsb2NrSGFzaE9yQmxvY2tUYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2xsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldEJsb2NrXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgd2FzIG5vdCBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBibG9ja2hhc2hlcywgaWYgd2UgZGlkbid0IHNheSBpdCBleGlzdGVkLCB0aGF0IGJsb2NraGFzaCBtYXlcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGV4aXN0LiBJZiB3ZSBkaWQgc2VlIGl0IHRob3VnaCwgcGVyaGFwcyBmcm9tIGEgbG9nLCB3ZSBrbm93XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGV4aXN0cywgYW5kIHRoaXMgbm9kZSBpcyBqdXN0IG5vdCBjYXVnaHQgdXAgeWV0LlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrSGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZFtcImI6XCIgKyBwYXJhbXMuYmxvY2tIYXNoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NrIHRhZ3MsIGlmIHdlIGFyZSBhc2tpbmcgZm9yIGEgZnV0dXJlIGJsb2NrLCB3ZSByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA+IHRoaXMuX2VtaXR0ZWQuYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXRyeSBvbiB0aGUgbmV4dCBibG9ja1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYmxvY2sudHJhbnNhY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNvbmZpcm1hdGlvbnMgdXNpbmcgdGhlIGZhc3QgYmxvY2sgbnVtYmVyIChwZXNzaW1pc3RpYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlciAtIHR4LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IGNvbmZpcm1hdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tXaXRoVHhzID0gdGhpcy5mb3JtYXR0ZXIuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tXaXRoVHhzLnRyYW5zYWN0aW9ucyA9IGJsb2NrV2l0aFR4cy50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1dpdGhUeHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5ibG9jayhibG9jayk7XG4gICAgICAgICAgICB9KSwgeyBvbmNlUG9sbDogdGhpcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCBmYWxzZSkpO1xuICAgIH1cbiAgICBnZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMoYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsIHRydWUpKTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IHlpZWxkIHRyYW5zYWN0aW9uSGFzaDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgdHJhbnNhY3Rpb25IYXNoOiB0aGlzLmZvcm1hdHRlci5oYXNoKHRyYW5zYWN0aW9uSGFzaCwgdHJ1ZSkgfTtcbiAgICAgICAgICAgIHJldHVybiBwb2xsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0cmFuc2FjdGlvbkhhc2hdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXNwb25zZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmICh0eC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5jb25maXJtYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29uZmlybWF0aW9ucyB1c2luZyB0aGUgZmFzdCBibG9jayBudW1iZXIgKHBlc3NpbWlzdGljKVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlciAtIHR4LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSBjb25maXJtYXRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICAgIH0pLCB7IG9uY2VQb2xsOiB0aGlzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2ggPSB5aWVsZCB0cmFuc2FjdGlvbkhhc2g7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7IHRyYW5zYWN0aW9uSGFzaDogdGhpcy5mb3JtYXR0ZXIuaGFzaCh0cmFuc2FjdGlvbkhhc2gsIHRydWUpIH07XG4gICAgICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gXCJnZXRoLWV0Y1wiIHJldHVybnMgcmVjZWlwdHMgYmVmb3JlIHRoZXkgYXJlIHJlYWR5XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gdGhpcy5mb3JtYXR0ZXIucmVjZWlwdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjZWlwdC5jb25maXJtYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29uZmlybWF0aW9ucyB1c2luZyB0aGUgZmFzdCBibG9jayBudW1iZXIgKHBlc3NpbWlzdGljKVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9KSwgeyBvbmNlUG9sbDogdGhpcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldExvZ3MoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHsgZmlsdGVyOiB0aGlzLl9nZXRGaWx0ZXIoZmlsdGVyKSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxvZ3MgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRMb2dzXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICBsb2dzLmZvckVhY2goKGxvZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsb2cucmVtb3ZlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5yZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmFycmF5T2YodGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nLmJpbmQodGhpcy5mb3JtYXR0ZXIpKShsb2dzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEV0aGVyUHJpY2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm0oXCJnZXRFdGhlclByaWNlXCIsIHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRCbG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYmxvY2tUYWcgPSB5aWVsZCBibG9ja1RhZztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIiAmJiBibG9ja1RhZyA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tUYWcgJSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgKz0gYmxvY2tUYWc7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja051bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuYmxvY2tUYWcoYmxvY2tUYWcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UmVzb2x2ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnROYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lID09PSBcIlwiIHx8IGN1cnJlbnROYW1lID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uIHNpbmNlIHRoZSBldGggbm9kZSBjYW5ub3QgY2hhbmdlIGFuZCBkb2VzXG4gICAgICAgICAgICAgICAgLy8gbm90IGhhdmUgYSB3aWxkY2FyZCByZXNvbHZlclxuICAgICAgICAgICAgICAgIGlmIChuYW1lICE9PSBcImV0aFwiICYmIGN1cnJlbnROYW1lID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgY3VycmVudCBub2RlIGZvciBhIHJlc29sdmVyXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkciA9IHlpZWxkIHRoaXMuX2dldFJlc29sdmVyKGN1cnJlbnROYW1lLCBcImdldFJlc29sdmVyXCIpO1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgcmVzb2x2ZXIhXG4gICAgICAgICAgICAgICAgaWYgKGFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IG5ldyBSZXNvbHZlcih0aGlzLCBhZGRyLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVnYWN5IHJlc29sdmVyIGZvdW5kLCB1c2luZyBFSVAtMjU0NCBzbyBpdCBpc24ndCBzYWZlIHRvIHVzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgIT09IG5hbWUgJiYgISh5aWVsZCByZXNvbHZlci5zdXBwb3J0c1dpbGRjYXJkKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBjdXJyZW50TmFtZSA9IGN1cnJlbnROYW1lLnNwbGl0KFwiLlwiKS5zbGljZSgxKS5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRSZXNvbHZlcihuYW1lLCBvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IFwiRU5TXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0geWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICAvLyBObyBFTlMuLi5cbiAgICAgICAgICAgIGlmICghbmV0d29yay5lbnNBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbiwgbmV0d29yazogbmV0d29yay5uYW1lIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBrZWNjYWsyNTYoXCJyZXNvbHZlcihieXRlczMyKVwiKVxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJEYXRhID0geWllbGQgdGhpcy5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgdG86IG5ldHdvcmsuZW5zQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHgwMTc4YjhiZlwiICsgbmFtZWhhc2gobmFtZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5jYWxsQWRkcmVzcyhhZGRyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBFTlMgcmVnaXN0cnkgY2Fubm90IHRocm93IGVycm9ycyBvbiByZXNvbHZlcihieXRlczMyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBuYW1lID0geWllbGQgbmFtZTtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIGFscmVhZHkgYW4gYWRkcmVzcywgbm90aGluZyB0byByZXNvbHZlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpcyBpcyBhIGhleHN0cmluZywgdGhlIGFkZHJlc3MgaXMgYmFkIChTZWUgIzY5NClcbiAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGFkZHIgZnJvbSB0aGUgcmVzb2x2ZXJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0geWllbGQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNvbHZlci5nZXRBZGRyZXNzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb29rdXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSB5aWVsZCBhZGRyZXNzO1xuICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSArIFwiLmFkZHIucmV2ZXJzZVwiO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJBZGRyID0geWllbGQgdGhpcy5fZ2V0UmVzb2x2ZXIobm9kZSwgXCJsb29rdXBBZGRyZXNzXCIpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyQWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWNjYWsoXCJuYW1lKGJ5dGVzMzIpXCIpXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gX3BhcnNlU3RyaW5nKHlpZWxkIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcixcbiAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDY5MWYzNDMxXCIgKyBuYW1laGFzaChub2RlKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0geWllbGQgdGhpcy5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChhZGRyICE9IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QXZhdGFyKG5hbWVPckFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZU9yQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGRyZXNzOyByZXZlcnNlIGxvb2t1cFxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKG5hbWVPckFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJBZGRyZXNzID0geWllbGQgdGhpcy5fZ2V0UmVzb2x2ZXIobm9kZSwgXCJnZXRBdmF0YXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlckFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyeSByZXNvbHZpbmcgdGhlIGF2YXRhciBhZ2FpbnN0IHRoZSBhZGRyLnJldmVyc2UgcmVzb2x2ZXJcbiAgICAgICAgICAgICAgICByZXNvbHZlciA9IG5ldyBSZXNvbHZlcih0aGlzLCByZXNvbHZlckFkZHJlc3MsIG5vZGUpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IHlpZWxkIHJlc29sdmVyLmdldEF2YXRhcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXZhdGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXZhdGFyLnVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSBuYW1lIGFuZCBwZXJmb3JtaW5nIGZvcndhcmQgbG9va3VwOyBhbGxvd2luZyB3aWxkY2FyZHNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZWNjYWsoXCJuYW1lKGJ5dGVzMzIpXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBfcGFyc2VTdHJpbmcoeWllbGQgdGhpcy5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDY5MWYzNDMxXCIgKyBuYW1laGFzaChub2RlKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICAgICAgICAgIH0pLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSB5aWVsZCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVOUyBuYW1lOyBmb3J3YXJkIGxvb2t1cCB3aXRoIHdpbGRjYXJkXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSB5aWVsZCB0aGlzLmdldFJlc29sdmVyKG5hbWVPckFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXZhdGFyID0geWllbGQgcmVzb2x2ZXIuZ2V0QXZhdGFyKCk7XG4gICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdmF0YXIudXJsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIExvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuICAgIH1cbiAgICBfc3RhcnRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLnBvbGxpbmcgPSAodGhpcy5fZXZlbnRzLmZpbHRlcigoZSkgPT4gZS5wb2xsYWJsZSgpKS5sZW5ndGggPiAwKTtcbiAgICB9XG4gICAgX3N0b3BFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLnBvbGxpbmcgPSAodGhpcy5fZXZlbnRzLmZpbHRlcigoZSkgPT4gZS5wb2xsYWJsZSgpKS5sZW5ndGggPiAwKTtcbiAgICB9XG4gICAgX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudChnZXRFdmVudFRhZyhldmVudE5hbWUpLCBsaXN0ZW5lciwgb25jZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgdGhpcy5fc3RhcnRFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGxldCBzdG9wcGVkID0gW107XG4gICAgICAgIGxldCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQubGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZXZlbnQub25jZSkge1xuICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9wcGVkLmZvckVhY2goKGV2ZW50KSA9PiB7IHRoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGV2ZW50LnRhZyA9PT0gZXZlbnRUYWcpO1xuICAgICAgICB9KS5sZW5ndGg7XG4gICAgfVxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLm1hcCgoZXZlbnQpID0+IGV2ZW50Lmxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzXG4gICAgICAgICAgICAuZmlsdGVyKChldmVudCkgPT4gKGV2ZW50LnRhZyA9PT0gZXZlbnRUYWcpKVxuICAgICAgICAgICAgLm1hcCgoZXZlbnQpID0+IGV2ZW50Lmxpc3RlbmVyKTtcbiAgICB9XG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0b3BwZWQgPSBbXTtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGxldCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZyB8fCBldmVudC5saXN0ZW5lciAhPSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKChldmVudCkgPT4geyB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBbXTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdG9wcGVkID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaCgoZXZlbnQpID0+IHsgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIkZvcmtFdmVudCIsIlByb3ZpZGVyIiwiZW5jb2RlIiwiYmFzZTY0RW5jb2RlIiwiQmFzZTU4IiwiQmlnTnVtYmVyIiwiYXJyYXlpZnkiLCJjb25jYXQiLCJoZXhDb25jYXQiLCJoZXhEYXRhTGVuZ3RoIiwiaGV4RGF0YVNsaWNlIiwiaGV4bGlmeSIsImhleFZhbHVlIiwiaGV4WmVyb1BhZCIsImlzSGV4U3RyaW5nIiwiSGFzaFplcm8iLCJkbnNFbmNvZGUiLCJuYW1laGFzaCIsImdldE5ldHdvcmsiLCJkZWZpbmVSZWFkT25seSIsImdldFN0YXRpYyIsInJlc29sdmVQcm9wZXJ0aWVzIiwic2hhMjU2IiwidG9VdGY4Qnl0ZXMiLCJ0b1V0ZjhTdHJpbmciLCJmZXRjaEpzb24iLCJwb2xsIiwiYmVjaDMyIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIkZvcm1hdHRlciIsIk1BWF9DQ0lQX1JFRElSRUNUUyIsImNoZWNrVG9waWMiLCJ0b3BpYyIsInRocm93QXJndW1lbnRFcnJvciIsInRvTG93ZXJDYXNlIiwic2VyaWFsaXplVG9waWNzIiwidG9waWNzIiwic2xpY2UiLCJsZW5ndGgiLCJwb3AiLCJtYXAiLCJBcnJheSIsImlzQXJyYXkiLCJ1bmlxdWUiLCJmb3JFYWNoIiwic29ydGVkIiwiT2JqZWN0Iiwia2V5cyIsInNvcnQiLCJqb2luIiwiZGVzZXJpYWxpemVUb3BpY3MiLCJkYXRhIiwic3BsaXQiLCJjb21wcyIsImdldEV2ZW50VGFnIiwiZXZlbnROYW1lIiwiaW5kZXhPZiIsImlzRm9ya0V2ZW50Iiwid2FybiIsIkVycm9yIiwiYWRkcmVzcyIsImdldFRpbWUiLCJEYXRlIiwic3RhbGwiLCJkdXJhdGlvbiIsInNldFRpbWVvdXQiLCJQb2xsYWJsZUV2ZW50cyIsIkV2ZW50IiwiY29uc3RydWN0b3IiLCJ0YWciLCJsaXN0ZW5lciIsIm9uY2UiLCJfbGFzdEJsb2NrTnVtYmVyIiwiX2luZmxpZ2h0IiwiZXZlbnQiLCJ0eXBlIiwiaGFzaCIsImZpbHRlciIsInBvbGxhYmxlIiwiY29pbkluZm9zIiwic3ltYm9sIiwicDJwa2giLCJwMnNoIiwicHJlZml4IiwiaWxrIiwiYnl0ZXMzMmlmeSIsImZyb20iLCJ0b0hleFN0cmluZyIsImJhc2U1OEVuY29kZSIsIm1hdGNoZXJJcGZzIiwiUmVnRXhwIiwibWF0Y2hlcnMiLCJfcGFyc2VTdHJpbmciLCJzdGFydCIsIl9wYXJzZUJ5dGVzIiwiZXJyb3IiLCJvZmZzZXQiLCJ0b051bWJlciIsImdldElwZnNMaW5rIiwibGluayIsIm1hdGNoIiwic3Vic3RyaW5nIiwibnVtUGFkIiwicGFkZGVkIiwiVWludDhBcnJheSIsInNldCIsImJ5dGVzUGFkIiwiTWF0aCIsImNlaWwiLCJlbmNvZGVCeXRlcyIsImRhdGFzIiwiYnl0ZUNvdW50IiwiaSIsInB1c2giLCJSZXNvbHZlciIsInByb3ZpZGVyIiwibmFtZSIsInJlc29sdmVkQWRkcmVzcyIsImZvcm1hdHRlciIsInN1cHBvcnRzV2lsZGNhcmQiLCJfc3VwcG9ydHNFaXAyNTQ0IiwiY2FsbCIsInRvIiwiZXEiLCJjYXRjaCIsImNvZGUiLCJlcnJvcnMiLCJDQUxMX0VYQ0VQVElPTiIsIl9mZXRjaCIsInNlbGVjdG9yIiwicGFyYW1ldGVycyIsInR4IiwiY2NpcFJlYWRFbmFibGVkIiwicGFyc2VCeXRlcyIsInRocm93RXJyb3IiLCJ0cmFuc2FjdGlvbiIsIl9mZXRjaEJ5dGVzIiwiX2dldEFkZHJlc3MiLCJjb2luVHlwZSIsImhleEJ5dGVzIiwiY29pbkluZm8iLCJTdHJpbmciLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJvcGVyYXRpb24iLCJieXRlcyIsInBhcnNlSW50Iiwid29yZHMiLCJ0b1dvcmRzIiwidW5zaGlmdCIsImdldEFkZHJlc3MiLCJjYWxsQWRkcmVzcyIsImdldEF2YXRhciIsImxpbmthZ2UiLCJjb250ZW50IiwiYXZhdGFyIiwiZ2V0VGV4dCIsInNjaGVtZSIsInVybCIsIm93bmVyIiwiX3Jlc29sdmVkQWRkcmVzcyIsImFkZHIiLCJ0b2tlbklkIiwidG9rZW5Pd25lciIsImJhbGFuY2UiLCJpc1plcm8iLCJ0b1N0cmluZyIsIm1ldGFkYXRhVXJsIiwicmVwbGFjZSIsIm1ldGFkYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImltYWdlVXJsIiwiaW1hZ2UiLCJpcGZzIiwiZ2V0Q29udGVudEhhc2giLCJpcG5zIiwic3dhcm0iLCJza3luZXQiLCJ1cmxTYWZlIiwiYSIsImtleSIsImtleUJ5dGVzIiwiZGVmYXVsdEZvcm1hdHRlciIsIm5leHRQb2xsSWQiLCJCYXNlUHJvdmlkZXIiLCJuZXR3b3JrIiwiX2V2ZW50cyIsIl9lbWl0dGVkIiwiYmxvY2siLCJkaXNhYmxlQ2NpcFJlYWQiLCJnZXRGb3JtYXR0ZXIiLCJhbnlOZXR3b3JrIiwiZGV0ZWN0TmV0d29yayIsIl9uZXR3b3JrUHJvbWlzZSIsIl9yZWFkeSIsImtub3duTmV0d29yayIsImVtaXQiLCJfbWF4SW50ZXJuYWxCbG9ja051bWJlciIsIl9tYXhGaWx0ZXJCbG9ja1JhbmdlIiwiX3BvbGxpbmdJbnRlcnZhbCIsIl9mYXN0UXVlcnlEYXRlIiwiX25ldHdvcmsiLCJVTktOT1dOX0VSUk9SIiwicmVhZHkiLCJORVRXT1JLX0VSUk9SIiwidW5kZWZpbmVkIiwiY2NpcFJlYWRGZXRjaCIsImNhbGxkYXRhIiwidXJscyIsInNlbmRlciIsImVycm9yTWVzc2FnZXMiLCJocmVmIiwianNvbiIsImVycm9yUGFzc1Rocm91Z2giLCJyZXNwb25zZSIsInN0YXR1cyIsInN0YXR1c0NvZGUiLCJlcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwiU0VSVkVSX0VSUk9SIiwibSIsIl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyIiwibWF4QWdlIiwiX2ludGVybmFsQmxvY2tOdW1iZXIiLCJpbnRlcm5hbEJsb2NrTnVtYmVyIiwicmVzcFRpbWUiLCJibG9ja051bWJlciIsInJlcVRpbWUiLCJjaGVja0ludGVybmFsQmxvY2tOdW1iZXIiLCJwZXJmb3JtIiwibmV0d29ya0Vycm9yIiwiX3NldEZhc3RCbG9ja051bWJlciIsInBvbGxJZCIsInJ1bm5lcnMiLCJwb2xsaW5nSW50ZXJ2YWwiLCJhYnMiLCJtYWtlRXJyb3IiLCJwcmV2aW91c0Jsb2NrTnVtYmVyIiwiZXZlbnRCbG9ja051bWJlciIsInJ1bm5lciIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsInJlY2VpcHQiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwibWluRnJvbUJsb2NrIiwiZ2V0TG9ncyIsImxvZ3MiLCJsb2ciLCJibG9ja0hhc2giLCJ0cmFuc2FjdGlvbkhhc2giLCJhbGwiLCJyZXNldEV2ZW50c0Jsb2NrIiwicG9sbGluZyIsImN1cnJlbnROZXR3b3JrIiwiY2hhaW5JZCIsIl9mYXN0QmxvY2tOdW1iZXIiLCJfZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSIsImRldGVjdGVkTmV0d29yayIsIl9wb2xsZXIiLCJzZXRJbnRlcnZhbCIsIl9ib290c3RyYXBQb2xsIiwiY2xlYXJJbnRlcnZhbCIsIl9nZXRGYXN0QmxvY2tOdW1iZXIiLCJub3ciLCJnZXRCbG9ja051bWJlciIsIndhaXRGb3JUcmFuc2FjdGlvbiIsImNvbmZpcm1hdGlvbnMiLCJ0aW1lb3V0IiwiX3dhaXRGb3JUcmFuc2FjdGlvbiIsInJlcGxhY2VhYmxlIiwiY2FuY2VsRnVuY3MiLCJhbHJlYWR5RG9uZSIsImZ1bmMiLCJtaW5lZEhhbmRsZXIiLCJvbiIsInJlbW92ZUxpc3RlbmVyIiwibGFzdEJsb2NrTnVtYmVyIiwic3RhcnRCbG9jayIsInNjYW5uZWRCbG9jayIsInJlcGxhY2VIYW5kbGVyIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsIm5vbmNlIiwibWluZWQiLCJnZXRUcmFuc2FjdGlvbiIsImdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyIsInRpIiwidHJhbnNhY3Rpb25zIiwicmVhc29uIiwiVFJBTlNBQ1RJT05fUkVQTEFDRUQiLCJjYW5jZWxsZWQiLCJyZXBsYWNlbWVudCIsIl93cmFwVHJhbnNhY3Rpb24iLCJ0aW1lciIsIlRJTUVPVVQiLCJ1bnJlZiIsImNsZWFyVGltZW91dCIsImdldEdhc1ByaWNlIiwibWV0aG9kIiwiZ2V0QmFsYW5jZSIsImFkZHJlc3NPck5hbWUiLCJibG9ja1RhZyIsInBhcmFtcyIsIl9nZXRCbG9ja1RhZyIsImdldENvZGUiLCJnZXRTdG9yYWdlQXQiLCJwb3NpdGlvbiIsInAiLCJleHBlY3RlZEhhc2giLCJyZXR1cm5lZEhhc2giLCJ3YWl0IiwiY29uZmlybXMiLCJzZW5kVHJhbnNhY3Rpb24iLCJzaWduZWRUcmFuc2FjdGlvbiIsImhleFR4IiwidCIsIl9nZXRUcmFuc2FjdGlvblJlcXVlc3QiLCJ2YWx1ZXMiLCJ2IiwiYWNjZXNzTGlzdCIsInRyYW5zYWN0aW9uUmVxdWVzdCIsIl9nZXRGaWx0ZXIiLCJfY2FsbCIsImF0dGVtcHQiLCJyZWRpcmVjdHMiLCJ0eFNlbmRlciIsInNpZ25hdHVyZSIsInVybHNPZmZzZXQiLCJ1cmxzTGVuZ3RoIiwidXJsc0RhdGEiLCJ1IiwiY2FsbGJhY2tTZWxlY3RvciIsImV4dHJhRGF0YSIsImNjaXBSZXN1bHQiLCJyZXNvbHZlZCIsImVzdGltYXRlR2FzIiwicmVzb2x2ZU5hbWUiLCJfZ2V0QmxvY2siLCJibG9ja0hhc2hPckJsb2NrVGFnIiwiaW5jbHVkZVRyYW5zYWN0aW9ucyIsImJsb2NrV2l0aFR4cyIsImJsb2NrV2l0aFRyYW5zYWN0aW9ucyIsIm9uY2VQb2xsIiwiZ2V0QmxvY2siLCJ0cmFuc2FjdGlvblJlc3BvbnNlIiwicmVtb3ZlZCIsImFycmF5T2YiLCJmaWx0ZXJMb2ciLCJiaW5kIiwiZ2V0RXRoZXJQcmljZSIsImdldFJlc29sdmVyIiwiY3VycmVudE5hbWUiLCJfZ2V0UmVzb2x2ZXIiLCJyZXNvbHZlciIsImVuc0FkZHJlc3MiLCJhZGRyRGF0YSIsImxvb2t1cEFkZHJlc3MiLCJub2RlIiwicmVzb2x2ZXJBZGRyIiwibmFtZU9yQWRkcmVzcyIsInJlc29sdmVyQWRkcmVzcyIsIk5PVF9JTVBMRU1FTlRFRCIsIl9zdGFydEV2ZW50IiwiX3N0b3BFdmVudCIsIl9hZGRFdmVudExpc3RlbmVyIiwiYXJncyIsInN0b3BwZWQiLCJldmVudFRhZyIsImxpc3RlbmVyQ291bnQiLCJsaXN0ZW5lcnMiLCJvZmYiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJmb3VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/base-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloudflareProvider: () => (/* binding */ CloudflareProvider)\n/* harmony export */ });\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nclass CloudflareProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch(network.name){\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return host;\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: {\n                get: ()=>super.perform\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            // The Cloudflare provider does not support eth_blockNumber,\n            // so we get the latest block and pull it from that\n            if (method === \"getBlockNumber\") {\n                const block = yield _super.perform.call(this, \"getBlock\", {\n                    blockTag: \"latest\"\n                });\n                return block.number;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n} //# sourceMappingURL=cloudflare-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9jbG91ZGZsYXJlLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBYTtBQUNiLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUM2RDtBQUNkO0FBQ1Y7QUFDckMsTUFBTVUsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQzFCLE1BQU1FLDJCQUEyQkosc0VBQWtCQTtJQUN0RCxPQUFPSyxVQUFVQyxNQUFNLEVBQUU7UUFDckIsSUFBSUEsVUFBVSxNQUFNO1lBQ2hCSCxPQUFPSSxrQkFBa0IsQ0FBQyx1Q0FBdUMsVUFBVUQ7UUFDL0U7UUFDQSxPQUFPO0lBQ1g7SUFDQSxPQUFPRSxPQUFPQyxPQUFPLEVBQUVILE1BQU0sRUFBRTtRQUMzQixJQUFJSSxPQUFPO1FBQ1gsT0FBUUQsUUFBUUUsSUFBSTtZQUNoQixLQUFLO2dCQUNERCxPQUFPO2dCQUNQO1lBQ0o7Z0JBQ0lQLE9BQU9JLGtCQUFrQixDQUFDLHVCQUF1QixXQUFXSyxTQUFTLENBQUMsRUFBRTtRQUNoRjtRQUNBLE9BQU9GO0lBQ1g7SUFDQUcsUUFBUUMsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDcEIsTUFBTUMsU0FBU0MsT0FBT0MsTUFBTSxDQUFDLE1BQU07WUFDL0JMLFNBQVM7Z0JBQUVNLEtBQUssSUFBTSxLQUFLLENBQUNOO1lBQVE7UUFDeEM7UUFDQSxPQUFPaEMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyw0REFBNEQ7WUFDNUQsbURBQW1EO1lBQ25ELElBQUlpQyxXQUFXLGtCQUFrQjtnQkFDN0IsTUFBTU0sUUFBUSxNQUFNSixPQUFPSCxPQUFPLENBQUNRLElBQUksQ0FBQyxJQUFJLEVBQUUsWUFBWTtvQkFBRUMsVUFBVTtnQkFBUztnQkFDL0UsT0FBT0YsTUFBTUcsTUFBTTtZQUN2QjtZQUNBLE9BQU9QLE9BQU9ILE9BQU8sQ0FBQ1EsSUFBSSxDQUFDLElBQUksRUFBRVAsUUFBUUM7UUFDN0M7SUFDSjtBQUNKLEVBQ0EsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuNy4wX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Nsb3VkZmxhcmUtcHJvdmlkZXIuanM/OTYxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgVXJsSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vdXJsLWpzb24tcnBjLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgY2xhc3MgQ2xvdWRmbGFyZVByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhcGlLZXkgbm90IHN1cHBvcnRlZCBmb3IgY2xvdWRmbGFyZVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VXJsKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBsZXQgaG9zdCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAobmV0d29yay5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9jbG91ZGZsYXJlLWV0aC5jb20vXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBhcmd1bWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3N0O1xuICAgIH1cbiAgICBwZXJmb3JtKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgcGVyZm9ybTogeyBnZXQ6ICgpID0+IHN1cGVyLnBlcmZvcm0gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBDbG91ZGZsYXJlIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgZXRoX2Jsb2NrTnVtYmVyLFxuICAgICAgICAgICAgLy8gc28gd2UgZ2V0IHRoZSBsYXRlc3QgYmxvY2sgYW5kIHB1bGwgaXQgZnJvbSB0aGF0XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImdldEJsb2NrTnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIF9zdXBlci5wZXJmb3JtLmNhbGwodGhpcywgXCJnZXRCbG9ja1wiLCB7IGJsb2NrVGFnOiBcImxhdGVzdFwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9jay5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnBlcmZvcm0uY2FsbCh0aGlzLCBtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb3VkZmxhcmUtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIlVybEpzb25ScGNQcm92aWRlciIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJDbG91ZGZsYXJlUHJvdmlkZXIiLCJnZXRBcGlLZXkiLCJhcGlLZXkiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJnZXRVcmwiLCJuZXR3b3JrIiwiaG9zdCIsIm5hbWUiLCJhcmd1bWVudHMiLCJwZXJmb3JtIiwibWV0aG9kIiwicGFyYW1zIiwiX3N1cGVyIiwiT2JqZWN0IiwiY3JlYXRlIiwiZ2V0IiwiYmxvY2siLCJjYWxsIiwiYmxvY2tUYWciLCJudW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js":
/*!****************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EtherscanProvider: () => (/* binding */ EtherscanProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/transactions */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/web */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+web@5.7.0/node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatter */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction) {\n    const result = {};\n    for(let key in transaction){\n        if (transaction[key] == null) {\n            continue;\n        }\n        let value = transaction[key];\n        if (key === \"type\" && value === 0) {\n            continue;\n        }\n        // Quantity-types require no leading zero, unless 0\n        if (({\n            type: true,\n            gasLimit: true,\n            gasPrice: true,\n            maxFeePerGs: true,\n            maxPriorityFeePerGas: true,\n            nonce: true,\n            value: true\n        })[key]) {\n            value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexValue)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(value));\n        } else if (key === \"accessList\") {\n            value = \"[\" + (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.accessListify)(value).map((set)=>{\n                return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n            }).join(\",\") + \"]\";\n        } else {\n            value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\nfunction getResult(result) {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n    if (result.status != 1 || typeof result.message !== \"string\" || !result.message.match(/^OK/)) {\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n    return result.result;\n}\nfunction getJsonResult(result) {\n    // This response indicates we are being throttled\n    if (result && result.status == 0 && result.message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    if (result.error) {\n        // @TODO: not any\n        const error = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) {\n            error.code = result.error.code;\n        }\n        if (result.error.data) {\n            error.data = result.error.data;\n        }\n        throw error;\n    }\n    return result.result;\n}\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag) {\n    if (blockTag === \"pending\") {\n        throw new Error(\"pending not supported\");\n    }\n    if (blockTag === \"latest\") {\n        return blockTag;\n    }\n    return parseInt(blockTag.substring(2), 16);\n}\nfunction checkError(method, error, transaction) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) {\n                data = \"0x\" + data.replace(/^.*0x/i, \"\");\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(data)) {\n                return data;\n            }\n            logger.throwError(\"missing revert data in call exception\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {\n                error,\n                data: \"0x\"\n            });\n        }\n    }\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof error.error.message === \"string\") {\n            message = error.error.message;\n        } else if (typeof error.body === \"string\") {\n            message = error.body;\n        } else if (typeof error.responseText === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n        logger.throwError(\"replacement fee too low\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error,\n            method,\n            transaction\n        });\n    }\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error,\n            method,\n            transaction\n        });\n    }\n    throw error;\n}\nclass EtherscanProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_4__.BaseProvider {\n    constructor(network, apiKey){\n        super(network);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"baseUrl\", this.getBaseUrl());\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"apiKey\", apiKey || null);\n    }\n    getBaseUrl() {\n        switch(this.network ? this.network.name : \"invalid\"){\n            case \"homestead\":\n                return \"https://api.etherscan.io\";\n            case \"ropsten\":\n                return \"https://api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https://api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https://api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https://api-goerli.etherscan.io\";\n            case \"optimism\":\n                return \"https://api-optimistic.etherscan.io\";\n            case \"optimism-kovan\":\n                return \"https://api-kovan-optimistic.etherscan.io\";\n            default:\n        }\n        return logger.throwArgumentError(\"unsupported network\", \"network\", this.network.name);\n    }\n    getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key)=>{\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : \"\";\n        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;\n    }\n    getPostUrl() {\n        return `${this.baseUrl}/api`;\n    }\n    getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    fetch(module, params, post) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const url = post ? this.getPostUrl() : this.getUrl(module, params);\n            const payload = post ? this.getPostData(module, params) : null;\n            const procFunc = module === \"proxy\" ? getJsonResult : getResult;\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: url,\n                provider: this\n            });\n            const connection = {\n                url: url,\n                throttleSlotInterval: 1000,\n                throttleCallback: (attempt, url)=>{\n                    if (this.isCommunityResource()) {\n                        (0,_formatter__WEBPACK_IMPORTED_MODULE_6__.showThrottleMessage)();\n                    }\n                    return Promise.resolve(true);\n                }\n            };\n            let payloadStr = null;\n            if (payload) {\n                connection.headers = {\n                    \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\"\n                };\n                payloadStr = Object.keys(payload).map((key)=>{\n                    return `${key}=${payload[key]}`;\n                }).join(\"&\");\n            }\n            const result = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_7__.fetchJson)(connection, payloadStr, procFunc || getJsonResult);\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: url,\n                response: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.deepCopy)(result),\n                provider: this\n            });\n            return result;\n        });\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.network;\n        });\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: {\n                get: ()=>super.perform\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            switch(method){\n                case \"getBlockNumber\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_blockNumber\"\n                    });\n                case \"getGasPrice\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_gasPrice\"\n                    });\n                case \"getBalance\":\n                    // Returns base-10 result\n                    return this.fetch(\"account\", {\n                        action: \"balance\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getTransactionCount\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionCount\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getCode\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getCode\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getStorageAt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getStorageAt\",\n                        address: params.address,\n                        position: params.position,\n                        tag: params.blockTag\n                    });\n                case \"sendTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_sendRawTransaction\",\n                        hex: params.signedTransaction\n                    }, true).catch((error)=>{\n                        return checkError(\"sendTransaction\", error, params.signedTransaction);\n                    });\n                case \"getBlock\":\n                    if (params.blockTag) {\n                        return this.fetch(\"proxy\", {\n                            action: \"eth_getBlockByNumber\",\n                            tag: params.blockTag,\n                            boolean: params.includeTransactions ? \"true\" : \"false\"\n                        });\n                    }\n                    throw new Error(\"getBlock by blockHash not implemented\");\n                case \"getTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionByHash\",\n                        txhash: params.transactionHash\n                    });\n                case \"getTransactionReceipt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionReceipt\",\n                        txhash: params.transactionHash\n                    });\n                case \"call\":\n                    {\n                        if (params.blockTag !== \"latest\") {\n                            throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                        }\n                        const postData = getTransactionPostData(params.transaction);\n                        postData.module = \"proxy\";\n                        postData.action = \"eth_call\";\n                        try {\n                            return yield this.fetch(\"proxy\", postData, true);\n                        } catch (error) {\n                            return checkError(\"call\", error, params.transaction);\n                        }\n                    }\n                case \"estimateGas\":\n                    {\n                        const postData = getTransactionPostData(params.transaction);\n                        postData.module = \"proxy\";\n                        postData.action = \"eth_estimateGas\";\n                        try {\n                            return yield this.fetch(\"proxy\", postData, true);\n                        } catch (error) {\n                            return checkError(\"estimateGas\", error, params.transaction);\n                        }\n                    }\n                case \"getLogs\":\n                    {\n                        const args = {\n                            action: \"getLogs\"\n                        };\n                        if (params.filter.fromBlock) {\n                            args.fromBlock = checkLogTag(params.filter.fromBlock);\n                        }\n                        if (params.filter.toBlock) {\n                            args.toBlock = checkLogTag(params.filter.toBlock);\n                        }\n                        if (params.filter.address) {\n                            args.address = params.filter.address;\n                        }\n                        // @TODO: We can handle slightly more complicated logs using the logs API\n                        if (params.filter.topics && params.filter.topics.length > 0) {\n                            if (params.filter.topics.length > 1) {\n                                logger.throwError(\"unsupported topic count\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                                    topics: params.filter.topics\n                                });\n                            }\n                            if (params.filter.topics.length === 1) {\n                                const topic0 = params.filter.topics[0];\n                                if (typeof topic0 !== \"string\" || topic0.length !== 66) {\n                                    logger.throwError(\"unsupported topic format\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                                        topic0: topic0\n                                    });\n                                }\n                                args.topic0 = topic0;\n                            }\n                        }\n                        const logs = yield this.fetch(\"logs\", args);\n                        // Cache txHash => blockHash\n                        let blocks = {};\n                        // Add any missing blockHash to the logs\n                        for(let i = 0; i < logs.length; i++){\n                            const log = logs[i];\n                            if (log.blockHash != null) {\n                                continue;\n                            }\n                            if (blocks[log.blockNumber] == null) {\n                                const block = yield this.getBlock(log.blockNumber);\n                                if (block) {\n                                    blocks[log.blockNumber] = block.hash;\n                                }\n                            }\n                            log.blockHash = blocks[log.blockNumber];\n                        }\n                        return logs;\n                    }\n                case \"getEtherPrice\":\n                    if (this.network.name !== \"homestead\") {\n                        return 0.0;\n                    }\n                    return parseFloat((yield this.fetch(\"stats\", {\n                        action: \"ethprice\"\n                    })).ethusd);\n                default:\n                    break;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    getHistory(addressOrName, startBlock, endBlock) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const params = {\n                action: \"txlist\",\n                address: yield this.resolveName(addressOrName),\n                startblock: startBlock == null ? 0 : startBlock,\n                endblock: endBlock == null ? 99999999 : endBlock,\n                sort: \"asc\"\n            };\n            const result = yield this.fetch(\"account\", params);\n            return result.map((tx)=>{\n                [\n                    \"contractAddress\",\n                    \"to\"\n                ].forEach(function(key) {\n                    if (tx[key] == \"\") {\n                        delete tx[key];\n                    }\n                });\n                if (tx.creates == null && tx.contractAddress != null) {\n                    tx.creates = tx.contractAddress;\n                }\n                const item = this.formatter.transactionResponse(tx);\n                if (tx.timeStamp) {\n                    item.timestamp = parseInt(tx.timeStamp);\n                }\n                return item;\n            });\n        });\n    }\n    isCommunityResource() {\n        return this.apiKey == null;\n    }\n} //# sourceMappingURL=etherscan-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9ldGhlcnNjYW4tcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDc0U7QUFDRDtBQUNUO0FBQ2I7QUFD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LENBQUMsQ0FBQ29IO2dCQUNmO29CQUFDO29CQUFtQjtpQkFBSyxDQUFDQyxPQUFPLENBQUMsU0FBVTVILEdBQUc7b0JBQzNDLElBQUkySCxFQUFFLENBQUMzSCxJQUFJLElBQUksSUFBSTt3QkFDZixPQUFPMkgsRUFBRSxDQUFDM0gsSUFBSTtvQkFDbEI7Z0JBQ0o7Z0JBQ0EsSUFBSTJILEdBQUdFLE9BQU8sSUFBSSxRQUFRRixHQUFHRyxlQUFlLElBQUksTUFBTTtvQkFDbERILEdBQUdFLE9BQU8sR0FBR0YsR0FBR0csZUFBZTtnQkFDbkM7Z0JBQ0EsTUFBTUMsT0FBTyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsbUJBQW1CLENBQUNOO2dCQUNoRCxJQUFJQSxHQUFHTyxTQUFTLEVBQUU7b0JBQ2RILEtBQUtJLFNBQVMsR0FBR3RHLFNBQVM4RixHQUFHTyxTQUFTO2dCQUMxQztnQkFDQSxPQUFPSDtZQUNYO1FBQ0o7SUFDSjtJQUNBbkQsc0JBQXNCO1FBQ2xCLE9BQVEsSUFBSSxDQUFDN0IsTUFBTSxJQUFJO0lBQzNCO0FBQ0osRUFDQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vZXRoZXJzY2FuLXByb3ZpZGVyLmpzP2ZiMGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGhleGxpZnksIGhleFZhbHVlLCBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBmZXRjaEpzb24gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd2ViXCI7XG5pbXBvcnQgeyBzaG93VGhyb3R0bGVNZXNzYWdlIH0gZnJvbSBcIi4vZm9ybWF0dGVyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBCYXNlUHJvdmlkZXIgfSBmcm9tIFwiLi9iYXNlLXByb3ZpZGVyXCI7XG4vLyBUaGUgdHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBzYW5pdGl6ZWQgYnkgdGhlIGNhbGxzIGluIFByb3ZpZGVyXG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvblBvc3REYXRhKHRyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZSA9IHRyYW5zYWN0aW9uW2tleV07XG4gICAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiICYmIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBRdWFudGl0eS10eXBlcyByZXF1aXJlIG5vIGxlYWRpbmcgemVybywgdW5sZXNzIDBcbiAgICAgICAgaWYgKHsgdHlwZTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBtYXhGZWVQZXJHczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWUsIG5vbmNlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9W2tleV0pIHtcbiAgICAgICAgICAgIHZhbHVlID0gaGV4VmFsdWUoaGV4bGlmeSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJhY2Nlc3NMaXN0XCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gXCJbXCIgKyBhY2Nlc3NMaXN0aWZ5KHZhbHVlKS5tYXAoKHNldCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBge2FkZHJlc3M6XCIke3NldC5hZGRyZXNzfVwiLHN0b3JhZ2VLZXlzOltcIiR7c2V0LnN0b3JhZ2VLZXlzLmpvaW4oJ1wiLFwiJyl9XCJdfWA7XG4gICAgICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0UmVzdWx0KHJlc3VsdCkge1xuICAgIC8vIGdldExvZ3MsIGdldEhpc3RvcnkgaGF2ZSB3ZWlyZCBzdWNjZXNzIHJlc3BvbnNlc1xuICAgIGlmIChyZXN1bHQuc3RhdHVzID09IDAgJiYgKHJlc3VsdC5tZXNzYWdlID09PSBcIk5vIHJlY29yZHMgZm91bmRcIiB8fCByZXN1bHQubWVzc2FnZSA9PT0gXCJObyB0cmFuc2FjdGlvbnMgZm91bmRcIikpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IDEgfHwgdHlwZW9mIChyZXN1bHQubWVzc2FnZSkgIT09IFwic3RyaW5nXCIgfHwgIXJlc3VsdC5tZXNzYWdlLm1hdGNoKC9eT0svKSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VcIik7XG4gICAgICAgIGVycm9yLnJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGlmICgocmVzdWx0LnJlc3VsdCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyYXRlIGxpbWl0XCIpID49IDApIHtcbiAgICAgICAgICAgIGVycm9yLnRocm90dGxlUmV0cnkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldEpzb25SZXN1bHQocmVzdWx0KSB7XG4gICAgLy8gVGhpcyByZXNwb25zZSBpbmRpY2F0ZXMgd2UgYXJlIGJlaW5nIHRocm90dGxlZFxuICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnN0YXR1cyA9PSAwICYmIHJlc3VsdC5tZXNzYWdlID09IFwiTk9UT0tcIiAmJiAocmVzdWx0LnJlc3VsdCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyYXRlIGxpbWl0XCIpID49IDApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJ0aHJvdHRsZWQgcmVzcG9uc2VcIik7XG4gICAgICAgIGVycm9yLnJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGVycm9yLnRocm90dGxlUmV0cnkgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5qc29ucnBjICE9IFwiMi4wXCIpIHtcbiAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlXCIpO1xuICAgICAgICBlcnJvci5yZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAvLyBAVE9ETzogbm90IGFueVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSB8fCBcInVua25vd24gZXJyb3JcIik7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IuY29kZSkge1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9IHJlc3VsdC5lcnJvci5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgZXJyb3IuZGF0YSA9IHJlc3VsdC5lcnJvci5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbn1cbi8vIFRoZSBibG9ja1RhZyB3YXMgbm9ybWFsaXplZCBhcyBhIHN0cmluZyBieSB0aGUgUHJvdmlkZXIgcHJlLXBlcmZvcm0gb3BlcmF0aW9uc1xuZnVuY3Rpb24gY2hlY2tMb2dUYWcoYmxvY2tUYWcpIHtcbiAgICBpZiAoYmxvY2tUYWcgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBlbmRpbmcgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKGJsb2NrVGFnID09PSBcImxhdGVzdFwiKSB7XG4gICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KGJsb2NrVGFnLnN1YnN0cmluZygyKSwgMTYpO1xufVxuZnVuY3Rpb24gY2hlY2tFcnJvcihtZXRob2QsIGVycm9yLCB0cmFuc2FjdGlvbikge1xuICAgIC8vIFVuZG8gdGhlIFwiY29udmVuaWVuY2VcIiBzb21lIG5vZGVzIGFyZSBhdHRlbXB0aW5nIHRvIHByZXZlbnQgYmFja3dhcmRzXG4gICAgLy8gaW5jb21wYXRpYmlsaXR5OyBtYXliZSBmb3IgdjYgY29uc2lkZXIgZm9yd2FyZGluZyByZXZlcnRzIGFzIGVycm9yc1xuICAgIGlmIChtZXRob2QgPT09IFwiY2FsbFwiICYmIGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SKSB7XG4gICAgICAgIGNvbnN0IGUgPSBlcnJvci5lcnJvcjtcbiAgICAgICAgLy8gRXRoZXJzY2FuIGtlZXBzIGNoYW5naW5nIHRoZWlyIHN0cmluZ1xuICAgICAgICBpZiAoZSAmJiAoZS5tZXNzYWdlLm1hdGNoKC9yZXZlcnRlZC9pKSB8fCBlLm1lc3NhZ2UubWF0Y2goL1ZNIGV4ZWN1dGlvbiBlcnJvci9pKSkpIHtcbiAgICAgICAgICAgIC8vIEV0aGVyc2NhbiBwcmVmaXhlcyB0aGUgZGF0YSBsaWtlIFwiUmV2ZXJ0ZWQgMHgxMjM0XCJcbiAgICAgICAgICAgIGxldCBkYXRhID0gZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gXCIweFwiICsgZGF0YS5yZXBsYWNlKC9eLioweC9pLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJldmVydCBkYXRhIGluIGNhbGwgZXhjZXB0aW9uXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICBlcnJvciwgZGF0YTogXCIweFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHZXQgdGhlIG1lc3NhZ2UgZnJvbSBhbnkgbmVzdGVkIGVycm9yIHN0cnVjdHVyZVxuICAgIGxldCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IpIHtcbiAgICAgICAgaWYgKGVycm9yLmVycm9yICYmIHR5cGVvZiAoZXJyb3IuZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5lcnJvci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IuYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IucmVzcG9uc2VUZXh0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBcIkluc3VmZmljaWVudCBmdW5kcy4gVGhlIGFjY291bnQgeW91IHRyaWVkIHRvIHNlbmQgdHJhbnNhY3Rpb24gZnJvbSBkb2VzIG5vdCBoYXZlIGVub3VnaCBmdW5kcy4gUmVxdWlyZWQgMjE0NjQwMDAwMDAwMDAgYW5kIGdvdDogMFwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBMb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUywge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFwiVHJhbnNhY3Rpb24gd2l0aCB0aGUgc2FtZSBoYXNoIHdhcyBhbHJlYWR5IGltcG9ydGVkLlwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL3NhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZHx0cmFuc2FjdGlvbiBub25jZSBpcyB0b28gbG93fG5vbmNlIHRvbyBsb3cvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBMb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcIlRyYW5zYWN0aW9uIGdhcyBwcmljZSBpcyB0b28gbG93LiBUaGVyZSBpcyBhbm90aGVyIHRyYW5zYWN0aW9uIHdpdGggc2FtZSBub25jZSBpbiB0aGUgcXVldWUuIFRyeSBpbmNyZWFzaW5nIHRoZSBnYXMgcHJpY2Ugb3IgaW5jcmVtZW50aW5nIHRoZSBub25jZS5cIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9hbm90aGVyIHRyYW5zYWN0aW9uIHdpdGggc2FtZSBub25jZS8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCwge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9leGVjdXRpb24gZmFpbGVkIGR1ZSB0byBhbiBleGNlcHRpb258ZXhlY3V0aW9uIHJldmVydGVkLykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZXN0aW1hdGUgZ2FzOyB0cmFuc2FjdGlvbiBtYXkgZmFpbCBvciBtYXkgcmVxdWlyZSBtYW51YWwgZ2FzIGxpbWl0XCIsIExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbn1cbmV4cG9ydCBjbGFzcyBFdGhlcnNjYW5Qcm92aWRlciBleHRlbmRzIEJhc2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmspO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImJhc2VVcmxcIiwgdGhpcy5nZXRCYXNlVXJsKCkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFwaUtleVwiLCBhcGlLZXkgfHwgbnVsbCk7XG4gICAgfVxuICAgIGdldEJhc2VVcmwoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5uZXR3b3JrID8gdGhpcy5uZXR3b3JrLm5hbWUgOiBcImludmFsaWRcIikge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGkuZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktcm9wc3Rlbi5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1yaW5rZWJ5LmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1rb3Zhbi5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWdvZXJsaS5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbS1rb3ZhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGkta292YW4tb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCB0aGlzLm5ldHdvcmsubmFtZSk7XG4gICAgfVxuICAgIGdldFVybChtb2R1bGUsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBxdWVyeSA9IE9iamVjdC5rZXlzKHBhcmFtcykucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhY2N1bSArPSBgJiR7a2V5fT0ke3ZhbHVlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIFwiXCIpO1xuICAgICAgICBjb25zdCBhcGlLZXkgPSAoKHRoaXMuYXBpS2V5KSA/IGAmYXBpa2V5PSR7dGhpcy5hcGlLZXl9YCA6IFwiXCIpO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlVXJsfS9hcGk/bW9kdWxlPSR7bW9kdWxlfSR7cXVlcnl9JHthcGlLZXl9YDtcbiAgICB9XG4gICAgZ2V0UG9zdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuYmFzZVVybH0vYXBpYDtcbiAgICB9XG4gICAgZ2V0UG9zdERhdGEobW9kdWxlLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgcGFyYW1zLmFwaWtleSA9IHRoaXMuYXBpS2V5O1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBmZXRjaChtb2R1bGUsIHBhcmFtcywgcG9zdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gKHBvc3QgPyB0aGlzLmdldFBvc3RVcmwoKSA6IHRoaXMuZ2V0VXJsKG1vZHVsZSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gKHBvc3QgPyB0aGlzLmdldFBvc3REYXRhKG1vZHVsZSwgcGFyYW1zKSA6IG51bGwpO1xuICAgICAgICAgICAgY29uc3QgcHJvY0Z1bmMgPSAobW9kdWxlID09PSBcInByb3h5XCIpID8gZ2V0SnNvblJlc3VsdCA6IGdldFJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHVybCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHRocm90dGxlU2xvdEludGVydmFsOiAxMDAwLFxuICAgICAgICAgICAgICAgIHRocm90dGxlQ2FsbGJhY2s6IChhdHRlbXB0LCB1cmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21tdW5pdHlSZXNvdXJjZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93VGhyb3R0bGVNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHBheWxvYWRTdHIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmhlYWRlcnMgPSB7IFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIgfTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkU3RyID0gT2JqZWN0LmtleXMocGF5bG9hZCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2tleX09JHtwYXlsb2FkW2tleV19YDtcbiAgICAgICAgICAgICAgICB9KS5qb2luKFwiJlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGZldGNoSnNvbihjb25uZWN0aW9uLCBwYXlsb2FkU3RyLCBwcm9jRnVuYyB8fCBnZXRKc29uUmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB1cmwsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IGRlZXBDb3B5KHJlc3VsdCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHBlcmZvcm06IHsgZ2V0OiAoKSA9PiBzdXBlci5wZXJmb3JtIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHsgYWN0aW9uOiBcImV0aF9ibG9ja051bWJlclwiIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHsgYWN0aW9uOiBcImV0aF9nYXNQcmljZVwiIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybnMgYmFzZS0xMCByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJhY2NvdW50XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJiYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGFyYW1zLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBwYXJhbXMuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlbmRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZXg6IHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwic2VuZFRyYW5zYWN0aW9uXCIsIGVycm9yLCBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBwYXJhbXMuYmxvY2tUYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRCbG9jayBieSBibG9ja0hhc2ggbm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcGFyYW1zLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcGFyYW1zLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2FsbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgIT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0aGVyc2NhblByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgYmxvY2tUYWcgZm9yIGNhbGxcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdERhdGEgPSBnZXRUcmFuc2FjdGlvblBvc3REYXRhKHBhcmFtcy50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLm1vZHVsZSA9IFwicHJveHlcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zdERhdGEuYWN0aW9uID0gXCJldGhfY2FsbFwiO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZmV0Y2goXCJwcm94eVwiLCBwb3N0RGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFcnJvcihcImNhbGxcIiwgZXJyb3IsIHBhcmFtcy50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdERhdGEgPSBnZXRUcmFuc2FjdGlvblBvc3REYXRhKHBhcmFtcy50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLm1vZHVsZSA9IFwicHJveHlcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zdERhdGEuYWN0aW9uID0gXCJldGhfZXN0aW1hdGVHYXNcIjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmZldGNoKFwicHJveHlcIiwgcG9zdERhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrRXJyb3IoXCJlc3RpbWF0ZUdhc1wiLCBlcnJvciwgcGFyYW1zLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB7IGFjdGlvbjogXCJnZXRMb2dzXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmZyb21CbG9jayA9IGNoZWNrTG9nVGFnKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvQmxvY2sgPSBjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLnRvQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuYWRkcmVzcyA9IHBhcmFtcy5maWx0ZXIuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2UgY2FuIGhhbmRsZSBzbGlnaHRseSBtb3JlIGNvbXBsaWNhdGVkIGxvZ3MgdXNpbmcgdGhlIGxvZ3MgQVBJXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcyAmJiBwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgY291bnRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgdG9waWNzOiBwYXJhbXMuZmlsdGVyLnRvcGljcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3BpYzAgPSBwYXJhbXMuZmlsdGVyLnRvcGljc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0b3BpYzApICE9PSBcInN0cmluZ1wiIHx8IHRvcGljMC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgZm9ybWF0XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IHRvcGljMDogdG9waWMwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvcGljMCA9IHRvcGljMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dzID0geWllbGQgdGhpcy5mZXRjaChcImxvZ3NcIiwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHR4SGFzaCA9PiBibG9ja0hhc2hcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYW55IG1pc3NpbmcgYmxvY2tIYXNoIHRvIHRoZSBsb2dzXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nID0gbG9nc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cuYmxvY2tIYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja3NbbG9nLmJsb2NrTnVtYmVyXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCB0aGlzLmdldEJsb2NrKGxvZy5ibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdID0gYmxvY2suaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuYmxvY2tIYXNoID0gYmxvY2tzW2xvZy5ibG9ja051bWJlcl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRFdGhlclByaWNlXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ldHdvcmsubmFtZSAhPT0gXCJob21lc3RlYWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCgoeWllbGQgdGhpcy5mZXRjaChcInN0YXRzXCIsIHsgYWN0aW9uOiBcImV0aHByaWNlXCIgfSkpLmV0aHVzZCk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnBlcmZvcm0uY2FsbCh0aGlzLCBtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBOb3RlOiBUaGUgYHBhZ2VgIHBhZ2UgcGFyYW1ldGVyIG9ubHkgYWxsb3dzIHBhZ2luYXRpb24gd2l0aGluIHRoZVxuICAgIC8vICAgICAgIDEwLDAwMCB3aW5kb3cgYXZhaWxhYmxlIHdpdGhvdXQgYSBwYWdlIGFuZCBvZmZzZXQgcGFyYW1ldGVyXG4gICAgLy8gICAgICAgRXJyb3I6IFJlc3VsdCB3aW5kb3cgaXMgdG9vIGxhcmdlLCBQYWdlTm8geCBPZmZzZXQgc2l6ZSBtdXN0XG4gICAgLy8gICAgICAgICAgICAgIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAxMDAwMFxuICAgIGdldEhpc3RvcnkoYWRkcmVzc09yTmFtZSwgc3RhcnRCbG9jaywgZW5kQmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwidHhsaXN0XCIsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogKHlpZWxkIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSkpLFxuICAgICAgICAgICAgICAgIHN0YXJ0YmxvY2s6ICgoc3RhcnRCbG9jayA9PSBudWxsKSA/IDAgOiBzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICBlbmRibG9jazogKChlbmRCbG9jayA9PSBudWxsKSA/IDk5OTk5OTk5IDogZW5kQmxvY2spLFxuICAgICAgICAgICAgICAgIHNvcnQ6IFwiYXNjXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLmZldGNoKFwiYWNjb3VudFwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICAgICAgW1wiY29udHJhY3RBZGRyZXNzXCIsIFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eFtrZXldID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmNyZWF0ZXMgPT0gbnVsbCAmJiB0eC5jb250cmFjdEFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0eC5jcmVhdGVzID0gdHguY29udHJhY3RBZGRyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXNwb25zZSh0eCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4LnRpbWVTdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRpbWVzdGFtcCA9IHBhcnNlSW50KHR4LnRpbWVTdGFtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09IG51bGwpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0aGVyc2Nhbi1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiaGV4bGlmeSIsImhleFZhbHVlIiwiaXNIZXhTdHJpbmciLCJkZWVwQ29weSIsImRlZmluZVJlYWRPbmx5IiwiYWNjZXNzTGlzdGlmeSIsImZldGNoSnNvbiIsInNob3dUaHJvdHRsZU1lc3NhZ2UiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiQmFzZVByb3ZpZGVyIiwiZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YSIsInRyYW5zYWN0aW9uIiwia2V5IiwidHlwZSIsImdhc0xpbWl0IiwiZ2FzUHJpY2UiLCJtYXhGZWVQZXJHcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibm9uY2UiLCJtYXAiLCJzZXQiLCJhZGRyZXNzIiwic3RvcmFnZUtleXMiLCJqb2luIiwiZ2V0UmVzdWx0Iiwic3RhdHVzIiwibWVzc2FnZSIsIm1hdGNoIiwiZXJyb3IiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJ0aHJvdHRsZVJldHJ5IiwiZ2V0SnNvblJlc3VsdCIsImpzb25ycGMiLCJjb2RlIiwiZGF0YSIsImNoZWNrTG9nVGFnIiwiYmxvY2tUYWciLCJwYXJzZUludCIsInN1YnN0cmluZyIsImNoZWNrRXJyb3IiLCJtZXRob2QiLCJlcnJvcnMiLCJTRVJWRVJfRVJST1IiLCJyZXBsYWNlIiwidGhyb3dFcnJvciIsIkNBTExfRVhDRVBUSU9OIiwiYm9keSIsInJlc3BvbnNlVGV4dCIsIklOU1VGRklDSUVOVF9GVU5EUyIsIk5PTkNFX0VYUElSRUQiLCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCIsIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUIiwiRXRoZXJzY2FuUHJvdmlkZXIiLCJjb25zdHJ1Y3RvciIsIm5ldHdvcmsiLCJhcGlLZXkiLCJnZXRCYXNlVXJsIiwibmFtZSIsInRocm93QXJndW1lbnRFcnJvciIsImdldFVybCIsIm1vZHVsZSIsInBhcmFtcyIsInF1ZXJ5IiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsImFjY3VtIiwiYmFzZVVybCIsImdldFBvc3RVcmwiLCJnZXRQb3N0RGF0YSIsImFwaWtleSIsImZldGNoIiwicG9zdCIsInVybCIsInBheWxvYWQiLCJwcm9jRnVuYyIsImVtaXQiLCJhY3Rpb24iLCJyZXF1ZXN0IiwicHJvdmlkZXIiLCJjb25uZWN0aW9uIiwidGhyb3R0bGVTbG90SW50ZXJ2YWwiLCJ0aHJvdHRsZUNhbGxiYWNrIiwiYXR0ZW1wdCIsImlzQ29tbXVuaXR5UmVzb3VyY2UiLCJwYXlsb2FkU3RyIiwiaGVhZGVycyIsInJlc3BvbnNlIiwiZGV0ZWN0TmV0d29yayIsInBlcmZvcm0iLCJfc3VwZXIiLCJjcmVhdGUiLCJnZXQiLCJ0YWciLCJwb3NpdGlvbiIsImhleCIsInNpZ25lZFRyYW5zYWN0aW9uIiwiY2F0Y2giLCJib29sZWFuIiwiaW5jbHVkZVRyYW5zYWN0aW9ucyIsInR4aGFzaCIsInRyYW5zYWN0aW9uSGFzaCIsInBvc3REYXRhIiwiYXJncyIsImZpbHRlciIsImZyb21CbG9jayIsInRvQmxvY2siLCJ0b3BpY3MiLCJsZW5ndGgiLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJ0b3BpYzAiLCJsb2dzIiwiYmxvY2tzIiwiaSIsImxvZyIsImJsb2NrSGFzaCIsImJsb2NrTnVtYmVyIiwiYmxvY2siLCJnZXRCbG9jayIsImhhc2giLCJwYXJzZUZsb2F0IiwiZXRodXNkIiwiY2FsbCIsImdldEhpc3RvcnkiLCJhZGRyZXNzT3JOYW1lIiwic3RhcnRCbG9jayIsImVuZEJsb2NrIiwicmVzb2x2ZU5hbWUiLCJzdGFydGJsb2NrIiwiZW5kYmxvY2siLCJzb3J0IiwidHgiLCJmb3JFYWNoIiwiY3JlYXRlcyIsImNvbnRyYWN0QWRkcmVzcyIsIml0ZW0iLCJmb3JtYXR0ZXIiLCJ0cmFuc2FjdGlvblJlc3BvbnNlIiwidGltZVN0YW1wIiwidGltZXN0YW1wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js":
/*!***************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FallbackProvider: () => (/* binding */ FallbackProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+abstract-provider@5.7.0/node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/random */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+random@5.7.0/node_modules/@ethersproject/random/lib.esm/shuffle.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/web */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+web@5.7.0/node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./formatter */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction now() {\n    return new Date().getTime();\n}\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for(let i = 0; i < networks.length; i++){\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        } else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof value === \"number\" || typeof value === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof value === \"string\") {\n        return value;\n    } else if (_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i)=>serialize(i)));\n    } else if (typeof value === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key)=>{\n            let v = value[key];\n            if (typeof v === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof value);\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n    let cancel = null;\n    let timer = null;\n    let promise = new Promise((resolve)=>{\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    });\n    const wait = (func)=>{\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return {\n        cancel,\n        getPromise,\n        wait\n    };\n}\nconst ForwardErrors = [\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\"\n];\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", {\n        get: ()=>config.provider\n    });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = now - config.start;\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function(configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c)=>{\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = {\n                    count: 0,\n                    result: c.result\n                };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for(let i = 0; i < keys.length; i++){\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch(method){\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs) {\n                const values = configs.map((c)=>c.result);\n                // Get the median block number\n                let blockNumber = median(configs.map((c)=>c.result), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs) {\n                const values = configs.map((c)=>c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs) {\n                return median(configs.map((c)=>c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(block);\n                    block.transactions = block.transactions.map((tx)=>{\n                        tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const provider = config.provider;\n        if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {\n            return provider;\n        }\n        return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_4__.poll)(()=>{\n            return new Promise((resolve, reject)=>{\n                setTimeout(function() {\n                    // We are synced\n                    if (provider.blockNumber >= blockNumber) {\n                        return resolve(provider);\n                    }\n                    // We're done; just quit\n                    if (config.cancelled) {\n                        return resolve(null);\n                    }\n                    // Try again, next block\n                    return resolve(undefined);\n                }, 0);\n            });\n        }, {\n            oncePoll: provider\n        });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function*() {\n        let provider = config.provider;\n        switch(method){\n            case \"getBlockNumber\":\n            case \"getGasPrice\":\n                return provider[method]();\n            case \"getEtherPrice\":\n                if (provider.getEtherPrice) {\n                    return provider.getEtherPrice();\n                }\n                break;\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n                if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.address, params.blockTag || \"latest\");\n            case \"getStorageAt\":\n                if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n            case \"getBlock\":\n                if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\"](params.blockTag || params.blockHash);\n            case \"call\":\n            case \"estimateGas\":\n                if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                if (method === \"call\" && params.blockTag) {\n                    return provider[method](params.transaction, params.blockTag);\n                }\n                return provider[method](params.transaction);\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n                return provider[method](params.transactionHash);\n            case \"getLogs\":\n                {\n                    let filter = params.filter;\n                    if (filter.fromBlock && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(filter.fromBlock) || filter.toBlock && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(filter.toBlock)) {\n                        provider = yield waitForSync(config, currentBlockNumber);\n                    }\n                    return provider.getLogs(filter);\n                }\n        }\n        return logger.throwError(\"unknown method error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n        });\n    });\n}\nclass FallbackProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_6__.BaseProvider {\n    constructor(providers, quorum){\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index)=>{\n            if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_7__.Provider.isProvider(configOrProvider)) {\n                const stallTimeout = (0,_formatter__WEBPACK_IMPORTED_MODULE_8__.isCommunityResource)(configOrProvider) ? 2000 : 750;\n                const priority = 1;\n                return Object.freeze({\n                    provider: configOrProvider,\n                    weight: 1,\n                    stallTimeout,\n                    priority\n                });\n            }\n            const config = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = (0,_formatter__WEBPACK_IMPORTED_MODULE_8__.isCommunityResource)(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c)=>accum + c.weight, 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        let networkOrReady = checkNetworks(providerConfigs.map((c)=>c.provider.network));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject)=>{\n                setTimeout(()=>{\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Preserve a copy, so we do not get mutated\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const networks = yield Promise.all(this.providerConfigs.map((c)=>c.provider.getNetwork()));\n            return checkNetworks(networks);\n        });\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                const results = yield Promise.all(this.providerConfigs.map((c)=>{\n                    return c.provider.sendTransaction(params.signedTransaction).then((result)=>{\n                        return result.hash;\n                    }, (error)=>{\n                        return error;\n                    });\n                }));\n                // Any success is good enough (other errors are likely \"already seen\" errors\n                for(let i = 0; i < results.length; i++){\n                    const result = results[i];\n                    if (typeof result === \"string\") {\n                        return result;\n                    }\n                }\n                // They were all an error; pick the first error\n                throw results[0];\n            }\n            // We need to make sure we are in sync with our backends, so we need\n            // to know this before we can make a lot of calls\n            if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n                yield this.getBlockNumber();\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = (0,_ethersproject_random__WEBPACK_IMPORTED_MODULE_9__.shuffled)(this.providerConfigs.map(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy));\n            configs.sort((a, b)=>a.priority - b.priority);\n            const currentBlockNumber = this._highestBlockNumber;\n            let i = 0;\n            let first = true;\n            while(true){\n                const t0 = now();\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c)=>c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c)=>accum + c.weight, 0);\n                // Start running enough to meet quorum\n                while(inflightWeight < this.quorum && i < configs.length){\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout);\n                    config.staller.wait(()=>{\n                        config.staller = null;\n                    });\n                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result)=>{\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: {\n                                    method: method,\n                                    params: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(params)\n                                },\n                                provider: this\n                            });\n                        }\n                    }, (error)=>{\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: {\n                                    method: method,\n                                    params: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(params)\n                                },\n                                provider: this\n                            });\n                        }\n                    });\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: {\n                                method: method,\n                                params: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(params)\n                            },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c)=>{\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller.getPromise());\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c)=>c.done && c.error == null);\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        // Shut down any stallers\n                        configs.forEach((c)=>{\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return result;\n                    }\n                    if (!first) {\n                        yield stall(100).getPromise();\n                    }\n                    first = false;\n                }\n                // No result, check for errors that should be forwarded\n                const errors = configs.reduce((accum, c)=>{\n                    if (!c.done || c.error == null) {\n                        return accum;\n                    }\n                    const code = c.error.code;\n                    if (ForwardErrors.indexOf(code) >= 0) {\n                        if (!accum[code]) {\n                            accum[code] = {\n                                error: c.error,\n                                weight: 0\n                            };\n                        }\n                        accum[code].weight += c.weight;\n                    }\n                    return accum;\n                }, {});\n                Object.keys(errors).forEach((errorCode)=>{\n                    const tally = errors[errorCode];\n                    if (tally.weight < this.quorum) {\n                        return;\n                    }\n                    // Shut down any stallers\n                    configs.forEach((c)=>{\n                        if (c.staller) {\n                            c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                    });\n                    const e = tally.error;\n                    const props = {};\n                    ForwardProperties.forEach((name)=>{\n                        if (e[name] == null) {\n                            return;\n                        }\n                        props[name] = e[name];\n                    });\n                    logger.throwError(e.reason || e.message, errorCode, props);\n                });\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c)=>!c.done).length === 0) {\n                    break;\n                }\n            }\n            // Shut down any stallers; shouldn't be any\n            configs.forEach((c)=>{\n                if (c.staller) {\n                    c.staller.cancel();\n                }\n                c.cancelled = true;\n            });\n            return logger.throwError(\"failed to meet quorum\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c)=>exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n} //# sourceMappingURL=fallback-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9mYWxsYmFjay1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQzREO0FBQ1A7QUFDRjtBQUMrQjtB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Q0FBc0M7Z0JBQ3RDK0MsU0FBU3hELFFBQVFyQyxHQUFHLENBQUMsQ0FBQ3dDLElBQU1kLGtCQUFrQmM7Z0JBQzlDVCxVQUFVLElBQUk7WUFDbEI7UUFDSjtJQUNKO0FBQ0osRUFDQSw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vZmFsbGJhY2stcHJvdmlkZXIuanM/NDZlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXJcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWVwQ29weSwgZGVmaW5lUmVhZE9ubHksIHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IHNodWZmbGVkIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3JhbmRvbVwiO1xuaW1wb3J0IHsgcG9sbCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC93ZWJcIjtcbmltcG9ydCB7IEJhc2VQcm92aWRlciB9IGZyb20gXCIuL2Jhc2UtcHJvdmlkZXJcIjtcbmltcG9ydCB7IGlzQ29tbXVuaXR5UmVzb3VyY2UgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbi8vIFJldHVybnMgdG8gbmV0d29yayBhcyBsb25nIGFzIGFsbCBhZ3JlZSwgb3IgbnVsbCBpZiBhbnkgaXMgbnVsbC5cbi8vIFRocm93cyBhbiBlcnJvciBpZiBhbnkgdHdvIG5ldHdvcmtzIGRvIG5vdCBtYXRjaC5cbmZ1bmN0aW9uIGNoZWNrTmV0d29ya3MobmV0d29ya3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ldHdvcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXR3b3Jrc1tpXTtcbiAgICAgICAgLy8gTnVsbCEgV2UgZG8gbm90IGtub3cgb3VyIG5ldHdvcms7IGJhaWwuXG4gICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmV0d29yayBtYXRjaGVzIHRoZSBwcmV2aW91cyBuZXR3b3Jrc1xuICAgICAgICAgICAgaWYgKCEocmVzdWx0Lm5hbWUgPT09IG5ldHdvcmsubmFtZSAmJiByZXN1bHQuY2hhaW5JZCA9PT0gbmV0d29yay5jaGFpbklkICYmXG4gICAgICAgICAgICAgICAgKChyZXN1bHQuZW5zQWRkcmVzcyA9PT0gbmV0d29yay5lbnNBZGRyZXNzKSB8fCAocmVzdWx0LmVuc0FkZHJlc3MgPT0gbnVsbCAmJiBuZXR3b3JrLmVuc0FkZHJlc3MgPT0gbnVsbCkpKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlciBtaXNtYXRjaFwiLCBcIm5ldHdvcmtzXCIsIG5ldHdvcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldHdvcms7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1lZGlhbih2YWx1ZXMsIG1heERlbHRhKSB7XG4gICAgdmFsdWVzID0gdmFsdWVzLnNsaWNlKCkuc29ydCgpO1xuICAgIGNvbnN0IG1pZGRsZSA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xuICAgIC8vIE9kZCBsZW5ndGg7IHRha2UgdGhlIG1pZGRsZVxuICAgIGlmICh2YWx1ZXMubGVuZ3RoICUgMikge1xuICAgICAgICByZXR1cm4gdmFsdWVzW21pZGRsZV07XG4gICAgfVxuICAgIC8vIEV2ZW4gbGVuZ3RoOyB0YWtlIHRoZSBhdmVyYWdlIG9mIHRoZSB0d28gbWlkZGxlXG4gICAgY29uc3QgYSA9IHZhbHVlc1ttaWRkbGUgLSAxXSwgYiA9IHZhbHVlc1ttaWRkbGVdO1xuICAgIGlmIChtYXhEZWx0YSAhPSBudWxsICYmIE1hdGguYWJzKGEgLSBiKSA+IG1heERlbHRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGEgKyBiKSAvIDI7XG59XG5mdW5jdGlvbiBzZXJpYWxpemUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUubWFwKChpKSA9PiBzZXJpYWxpemUoaSkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgIHJldHVybiBcIntcIiArIGtleXMubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIGxldCB2ID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2ID0gXCJbZnVuY3Rpb25dXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ID0gc2VyaWFsaXplKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSkgKyBcIjpcIiArIHY7XG4gICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdmFsdWUgdHlwZTogXCIgKyB0eXBlb2YgKHZhbHVlKSk7XG59XG4vLyBOZXh0IHJlcXVlc3QgSUQgdG8gdXNlIGZvciBlbWl0dGluZyBkZWJ1ZyBpbmZvXG5sZXQgbmV4dFJpZCA9IDE7XG47XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIGxldCBjYW5jZWwgPSBudWxsO1xuICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgbGV0IHByb21pc2UgPSAobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYW5jZWwsIGR1cmF0aW9uKTtcbiAgICB9KSk7XG4gICAgY29uc3Qgd2FpdCA9IChmdW5jKSA9PiB7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuYyk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0UHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHJldHVybiB7IGNhbmNlbCwgZ2V0UHJvbWlzZSwgd2FpdCB9O1xufVxuY29uc3QgRm9yd2FyZEVycm9ycyA9IFtcbiAgICBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLFxuICAgIExvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLFxuICAgIExvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCxcbiAgICBMb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELFxuICAgIExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcbl07XG5jb25zdCBGb3J3YXJkUHJvcGVydGllcyA9IFtcbiAgICBcImFkZHJlc3NcIixcbiAgICBcImFyZ3NcIixcbiAgICBcImVycm9yQXJnc1wiLFxuICAgIFwiZXJyb3JTaWduYXR1cmVcIixcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwidHJhbnNhY3Rpb25cIixcbl07XG47XG5mdW5jdGlvbiBleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsIG5vdykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgd2VpZ2h0OiBjb25maWcud2VpZ2h0XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBcInByb3ZpZGVyXCIsIHsgZ2V0OiAoKSA9PiBjb25maWcucHJvdmlkZXIgfSk7XG4gICAgaWYgKGNvbmZpZy5zdGFydCkge1xuICAgICAgICByZXN1bHQuc3RhcnQgPSBjb25maWcuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChub3cpIHtcbiAgICAgICAgcmVzdWx0LmR1cmF0aW9uID0gKG5vdyAtIGNvbmZpZy5zdGFydCk7XG4gICAgfVxuICAgIGlmIChjb25maWcuZG9uZSkge1xuICAgICAgICBpZiAoY29uZmlnLmVycm9yKSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBjb25maWcuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucmVzdWx0ID0gY29uZmlnLnJlc3VsdCB8fCBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVkVGFsbHkobm9ybWFsaXplLCBxdW9ydW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZ3MpIHtcbiAgICAgICAgLy8gQ291bnQgdGhlIHZvdGVzIGZvciBlYWNoIHJlc3VsdFxuICAgICAgICBjb25zdCB0YWxseSA9IHt9O1xuICAgICAgICBjb25maWdzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbm9ybWFsaXplKGMucmVzdWx0KTtcbiAgICAgICAgICAgIGlmICghdGFsbHlbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgdGFsbHlbdmFsdWVdID0geyBjb3VudDogMCwgcmVzdWx0OiBjLnJlc3VsdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFsbHlbdmFsdWVdLmNvdW50Kys7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDaGVjayBmb3IgYSBxdW9ydW0gb24gYW55IGdpdmVuIHJlc3VsdFxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGFsbHkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gdGFsbHlba2V5c1tpXV07XG4gICAgICAgICAgICBpZiAoY2hlY2suY291bnQgPj0gcXVvcnVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrLnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBObyBxdXJvdW1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0UHJvY2Vzc0Z1bmMocHJvdmlkZXIsIG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgbGV0IG5vcm1hbGl6ZSA9IHNlcmlhbGl6ZTtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbWVkaWFuIHZhbHVlLCB1bmxlc3MgdGhlcmUgaXMgKG1lZGlhbiArIDEpIGlzIGFsc29cbiAgICAgICAgICAgIC8vIHByZXNlbnQsIGluIHdoaWNoIGNhc2UgdGhhdCBpcyBwcm9iYWJseSB0cnVlIGFuZCB0aGUgbWVkaWFuXG4gICAgICAgICAgICAvLyBpcyBnb2luZyB0byBiZSBzdGFsZSBzb29uLiBJbiB0aGUgZXZlbnQgb2YgYSBtYWxpY2lvdXMgbm9kZSxcbiAgICAgICAgICAgIC8vIHRoZSBsaWUgd2lsbCBiZSB0cnVlIHNvb24gZW5vdWdoLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gY29uZmlncy5tYXAoKGMpID0+IGMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIG1lZGlhbiBibG9jayBudW1iZXJcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSBtZWRpYW4oY29uZmlncy5tYXAoKGMpID0+IGMucmVzdWx0KSwgMik7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBNYXRoLmNlaWwoYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IGJsb2NrIGhlaWdodCBpcyBwcmVzZW50LCBpdHMgcHJvbGx5IHNhZmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5pbmRleE9mKGJsb2NrTnVtYmVyICsgMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEb24ndCBldmVyIHJvbGwgYmFjayB0aGUgYmxvY2tOdW1iZXJcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPj0gcHJvdmlkZXIuX2hpZ2hlc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG1pZGRsZSAocm91bmQgaW5kZXggdXApIHZhbHVlLCBzaW1pbGFyIHRvIG1lZGlhblxuICAgICAgICAgICAgLy8gYnV0IGRvIG5vdCBhdmVyYWdlIGV2ZW4gZW50cmllcyBhbmQgY2hvb3NlIHRoZSBoaWdoZXIuXG4gICAgICAgICAgICAvLyBNYWxpY2lvdXMgYWN0b3JzIG11c3QgY29tcHJvbWlzZSA1MCUgb2YgdGhlIG5vZGVzIHRvIGxpZS5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGNvbmZpZ3MubWFwKChjKSA9PiBjLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW01hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJnZXRFdGhlclByaWNlXCI6XG4gICAgICAgICAgICAvLyBSZXR1cm5zIHRoZSBtZWRpYW4gcHJpY2UuIE1hbGljaW91cyBhY3RvcnMgbXVzdCBjb21wcm9taXNlIGF0XG4gICAgICAgICAgICAvLyBsZWFzdCA1MCUgb2YgdGhlIG5vZGVzIHRvIGxpZSAoaW4gYSBtZWFuaW5nZnVsIHdheSkuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWFuKGNvbmZpZ3MubWFwKChjKSA9PiBjLnJlc3VsdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgLy8gTm8gYWRkaXRpb25hbCBub3JtYWxpemluZyByZXF1aXJlZDsgc2VyaWFsaXplIGlzIGVub3VnaFxuICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZUF0XCI6XG4gICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOlxuICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFdlIGRyb3AgdGhlIGNvbmZpcm1hdGlvbnMgZnJvbSB0cmFuc2FjdGlvbnMgYXMgaXQgaXMgYXBwcm94aW1hdGVcbiAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eCA9IHNoYWxsb3dDb3B5KHR4KTtcbiAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gLTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZSh0eCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFdlIGRyb3AgdGhlIGNvbmZpcm1hdGlvbnMgZnJvbSB0cmFuc2FjdGlvbnMgYXMgaXQgaXMgYXBwcm94aW1hdGVcbiAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAvLyBXZSBkcm9wIHRoZSBjb25maXJtYXRpb25zIGZyb20gdHJhbnNhY3Rpb25zIGFzIGl0IGlzIGFwcHJveGltYXRlXG4gICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemUgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrID0gc2hhbGxvd0NvcHkoYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBibG9jay50cmFuc2FjdGlvbnMgPSBibG9jay50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBzaGFsbG93Q29weSh0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKGJsb2NrKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKGJsb2NrKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBpZiBhbmQgb25seSBpZiB0aGUgZXhwZWN0ZWQgcXVvcnVtIGlzXG4gICAgLy8gc2F0aXNmaWVkIGFuZCBhZ3JlZWQgdXBvbiBmb3IgdGhlIGZpbmFsIHJlc3VsdC5cbiAgICByZXR1cm4gbm9ybWFsaXplZFRhbGx5KG5vcm1hbGl6ZSwgcHJvdmlkZXIucXVvcnVtKTtcbn1cbi8vIElmIHdlIGFyZSBkb2luZyBhIGJsb2NrVGFnIHF1ZXJ5LCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpc1xuLy8gY2F1Z2h0IHVwIHRvIHRoZSBGYWxsYmFja1Byb3ZpZGVyLCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QgdG8gaXQuXG5mdW5jdGlvbiB3YWl0Rm9yU3luYyhjb25maWcsIGJsb2NrTnVtYmVyKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSAoY29uZmlnLnByb3ZpZGVyKTtcbiAgICAgICAgaWYgKChwcm92aWRlci5ibG9ja051bWJlciAhPSBudWxsICYmIHByb3ZpZGVyLmJsb2NrTnVtYmVyID49IGJsb2NrTnVtYmVyKSB8fCBibG9ja051bWJlciA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc3luY2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5ibG9ja051bWJlciA+PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmU7IGp1c3QgcXVpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGFnYWluLCBuZXh0IGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgeyBvbmNlUG9sbDogcHJvdmlkZXIgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRSdW5uZXIoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIsIG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbGV0IHByb3ZpZGVyID0gY29uZmlnLnByb3ZpZGVyO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJbbWV0aG9kXSgpO1xuICAgICAgICAgICAgY2FzZSBcImdldEV0aGVyUHJpY2VcIjpcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIuZ2V0RXRoZXJQcmljZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0RXRoZXJQcmljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICYmIGlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB5aWVsZCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlclttZXRob2RdKHBhcmFtcy5hZGRyZXNzLCBwYXJhbXMuYmxvY2tUYWcgfHwgXCJsYXRlc3RcIik7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZUF0XCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZyAmJiBpc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0geWllbGQgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0U3RvcmFnZUF0KHBhcmFtcy5hZGRyZXNzLCBwYXJhbXMucG9zaXRpb24sIHBhcmFtcy5ibG9ja1RhZyB8fCBcImxhdGVzdFwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgJiYgaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IHlpZWxkIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyWyhwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9ucyA/IFwiZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zXCIgOiBcImdldEJsb2NrXCIpXShwYXJhbXMuYmxvY2tUYWcgfHwgcGFyYW1zLmJsb2NrSGFzaCk7XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZyAmJiBpc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0geWllbGQgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImNhbGxcIiAmJiBwYXJhbXMuYmxvY2tUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyW21ldGhvZF0ocGFyYW1zLnRyYW5zYWN0aW9uLCBwYXJhbXMuYmxvY2tUYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyW21ldGhvZF0ocGFyYW1zLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOiB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbHRlciA9IHBhcmFtcy5maWx0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKChmaWx0ZXIuZnJvbUJsb2NrICYmIGlzSGV4U3RyaW5nKGZpbHRlci5mcm9tQmxvY2spKSB8fCAoZmlsdGVyLnRvQmxvY2sgJiYgaXNIZXhTdHJpbmcoZmlsdGVyLnRvQmxvY2spKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IHlpZWxkIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJ1bmtub3duIG1ldGhvZCBlcnJvclwiLCBMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1IsIHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnQgY2xhc3MgRmFsbGJhY2tQcm92aWRlciBleHRlbmRzIEJhc2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJzLCBxdW9ydW0pIHtcbiAgICAgICAgaWYgKHByb3ZpZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyc1wiLCBcInByb3ZpZGVyc1wiLCBwcm92aWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyQ29uZmlncyA9IHByb3ZpZGVycy5tYXAoKGNvbmZpZ09yUHJvdmlkZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoUHJvdmlkZXIuaXNQcm92aWRlcihjb25maWdPclByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWxsVGltZW91dCA9IGlzQ29tbXVuaXR5UmVzb3VyY2UoY29uZmlnT3JQcm92aWRlcikgPyAyMDAwIDogNzUwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5ID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHByb3ZpZGVyOiBjb25maWdPclByb3ZpZGVyLCB3ZWlnaHQ6IDEsIHN0YWxsVGltZW91dCwgcHJpb3JpdHkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBzaGFsbG93Q29weShjb25maWdPclByb3ZpZGVyKTtcbiAgICAgICAgICAgIGlmIChjb25maWcucHJpb3JpdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wcmlvcml0eSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLnN0YWxsVGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnN0YWxsVGltZW91dCA9IGlzQ29tbXVuaXR5UmVzb3VyY2UoY29uZmlnT3JQcm92aWRlcikgPyAyMDAwIDogNzUwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy53ZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy53ZWlnaHQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gY29uZmlnLndlaWdodDtcbiAgICAgICAgICAgIGlmICh3ZWlnaHQgJSAxIHx8IHdlaWdodCA+IDUxMiB8fCB3ZWlnaHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgd2VpZ2h0OyBtdXN0IGJlIGludGVnZXIgaW4gWzEsIDUxMl1cIiwgYHByb3ZpZGVyc1ske2luZGV4fV0ud2VpZ2h0YCwgd2VpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKGNvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHByb3ZpZGVyQ29uZmlncy5yZWR1Y2UoKGFjY3VtLCBjKSA9PiAoYWNjdW0gKyBjLndlaWdodCksIDApO1xuICAgICAgICBpZiAocXVvcnVtID09IG51bGwpIHtcbiAgICAgICAgICAgIHF1b3J1bSA9IHRvdGFsIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxdW9ydW0gPiB0b3RhbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInF1b3J1bSB3aWxsIGFsd2F5cyBmYWlsOyBsYXJnZXIgdGhhbiB0b3RhbCB3ZWlnaHRcIiwgXCJxdW9ydW1cIiwgcXVvcnVtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcmUgYWxsIHByb3ZpZGVycycgbmV0d29ya3MgYXJlIGtub3duXG4gICAgICAgIGxldCBuZXR3b3JrT3JSZWFkeSA9IGNoZWNrTmV0d29ya3MocHJvdmlkZXJDb25maWdzLm1hcCgoYykgPT4gKGMucHJvdmlkZXIpLm5ldHdvcmspKTtcbiAgICAgICAgLy8gTm90IGFsbCBuZXR3b3JrcyBhcmUga25vd247IHdlIG11c3Qgc3RhbGxcbiAgICAgICAgaWYgKG5ldHdvcmtPclJlYWR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIG5ldHdvcmtPclJlYWR5ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRldGVjdE5ldHdvcmsoKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihuZXR3b3JrT3JSZWFkeSk7XG4gICAgICAgIC8vIFByZXNlcnZlIGEgY29weSwgc28gd2UgZG8gbm90IGdldCBtdXRhdGVkXG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJDb25maWdzXCIsIE9iamVjdC5mcmVlemUocHJvdmlkZXJDb25maWdzKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicXVvcnVtXCIsIHF1b3J1bSk7XG4gICAgICAgIHRoaXMuX2hpZ2hlc3RCbG9ja051bWJlciA9IC0xO1xuICAgIH1cbiAgICBkZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbmV0d29ya3MgPSB5aWVsZCBQcm9taXNlLmFsbCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAoKGMpID0+IGMucHJvdmlkZXIuZ2V0TmV0d29yaygpKSk7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tOZXR3b3JrcyhuZXR3b3Jrcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBTZW5kaW5nIHRyYW5zYWN0aW9ucyBpcyBzcGVjaWFsOyBhbHdheXMgYnJvYWRjYXN0IGl0IHRvIGFsbCBiYWNrZW5kc1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJzZW5kVHJhbnNhY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSB5aWVsZCBQcm9taXNlLmFsbCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAoKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvbikudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmhhc2g7XG4gICAgICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gQW55IHN1Y2Nlc3MgaXMgZ29vZCBlbm91Z2ggKG90aGVyIGVycm9ycyBhcmUgbGlrZWx5IFwiYWxyZWFkeSBzZWVuXCIgZXJyb3JzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlc3VsdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhleSB3ZXJlIGFsbCBhbiBlcnJvcjsgcGljayB0aGUgZmlyc3QgZXJyb3JcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgYXJlIGluIHN5bmMgd2l0aCBvdXIgYmFja2VuZHMsIHNvIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGtub3cgdGhpcyBiZWZvcmUgd2UgY2FuIG1ha2UgYSBsb3Qgb2YgY2FsbHNcbiAgICAgICAgICAgIGlmICh0aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXIgPT09IC0xICYmIG1ldGhvZCAhPT0gXCJnZXRCbG9ja051bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc0Z1bmMgPSBnZXRQcm9jZXNzRnVuYyh0aGlzLCBtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICAvLyBTaHVmZmxlIHRoZSBwcm92aWRlcnMgYW5kIHRoZW4gc29ydCB0aGVtIGJ5IHRoZWlyIHByaW9yaXR5OyB3ZVxuICAgICAgICAgICAgLy8gc2hhbGxvd0NvcHkgdGhlbSBzaW5jZSB3ZSB3aWxsIHN0b3JlIHRoZSByZXN1bHQgaW4gdGhlbSB0b29cbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ3MgPSBzaHVmZmxlZCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAoc2hhbGxvd0NvcHkpKTtcbiAgICAgICAgICAgIGNvbmZpZ3Muc29ydCgoYSwgYikgPT4gKGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tOdW1iZXIgPSB0aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXI7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0MCA9IG5vdygpO1xuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGluZmxpZ2h0IHdlaWdodCAoZXhjbHVkZSBhbnl0aGluZyBwYXN0KVxuICAgICAgICAgICAgICAgIGxldCBpbmZsaWdodFdlaWdodCA9IGNvbmZpZ3MuZmlsdGVyKChjKSA9PiAoYy5ydW5uZXIgJiYgKCh0MCAtIGMuc3RhcnQpIDwgYy5zdGFsbFRpbWVvdXQpKSlcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjdW0sIGMpID0+IChhY2N1bSArIGMud2VpZ2h0KSwgMCk7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgcnVubmluZyBlbm91Z2ggdG8gbWVldCBxdW9ydW1cbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5mbGlnaHRXZWlnaHQgPCB0aGlzLnF1b3J1bSAmJiBpIDwgY29uZmlncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gY29uZmlnc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByaWQgPSBuZXh0UmlkKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zdGFydCA9IG5vdygpO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhbGxlciA9IHN0YWxsKGNvbmZpZy5zdGFsbFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhbGxlci53YWl0KCgpID0+IHsgY29uZmlnLnN0YWxsZXIgPSBudWxsOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnJ1bm5lciA9IGdldFJ1bm5lcihjb25maWcsIGN1cnJlbnRCbG9ja051bWJlciwgbWV0aG9kLCBwYXJhbXMpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoXCJkZWJ1Z1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlkOiByaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbm93KCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbXM6IGRlZXBDb3B5KHBhcmFtcykgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoXCJkZWJ1Z1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlkOiByaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbm93KCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbXM6IGRlZXBDb3B5KHBhcmFtcykgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoXCJkZWJ1Z1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlkOiByaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZDogZXhwb3NlRGVidWdDb25maWcoY29uZmlnLCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbXM6IGRlZXBDb3B5KHBhcmFtcykgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRXZWlnaHQgKz0gY29uZmlnLndlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgYW55dGhpbmcgbWVhbmluZ2Z1bCB0byBmaW5pc2ggb3Igc3RhbGwgb3V0XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FpdGluZyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbmZpZ3MuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5kb25lIHx8ICFjLnJ1bm5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmcucHVzaChjLnJ1bm5lcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YWxsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmcucHVzaChjLnN0YWxsZXIuZ2V0UHJvbWlzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLnJhY2Uod2FpdGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBxdW9ydW0gYW5kIHByb2Nlc3MgdGhlIHJlc3VsdHM7IHRoZSBwcm9jZXNzIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8gbWF5IGFkZGl0aW9uYWxseSBkZWNpZGUgdGhlIHF1b3J1bSBpcyBub3QgbWV0XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGNvbmZpZ3MuZmlsdGVyKChjKSA9PiAoYy5kb25lICYmIGMuZXJyb3IgPT0gbnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+PSB0aGlzLnF1b3J1bSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzRnVuYyhyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaHV0IGRvd24gYW55IHN0YWxsZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnN0YWxsZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBzdGFsbCgxMDApLmdldFByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBObyByZXN1bHQsIGNoZWNrIGZvciBlcnJvcnMgdGhhdCBzaG91bGQgYmUgZm9yd2FyZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gY29uZmlncy5yZWR1Y2UoKGFjY3VtLCBjKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYy5kb25lIHx8IGMuZXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAoYy5lcnJvcikuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEZvcndhcmRFcnJvcnMuaW5kZXhPZihjb2RlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFjY3VtW2NvZGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW1bY29kZV0gPSB7IGVycm9yOiBjLmVycm9yLCB3ZWlnaHQ6IDAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtW2NvZGVdLndlaWdodCArPSBjLndlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICAgICAgfSwgKHt9KSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZXJyb3JzKS5mb3JFYWNoKChlcnJvckNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFsbHkgPSBlcnJvcnNbZXJyb3JDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhbGx5LndlaWdodCA8IHRoaXMucXVvcnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2h1dCBkb3duIGFueSBzdGFsbGVyc1xuICAgICAgICAgICAgICAgICAgICBjb25maWdzLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5zdGFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdGFsbGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9ICh0YWxseS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgIEZvcndhcmRQcm9wZXJ0aWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1tuYW1lXSA9IGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihlLnJlYXNvbiB8fCBlLm1lc3NhZ2UsIGVycm9yQ29kZSwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIEFsbCBjb25maWdzIGhhdmUgcnVuIHRvIGNvbXBsZXRpb247IHdlIHdpbGwgbmV2ZXIgZ2V0IG1vcmUgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChjb25maWdzLmZpbHRlcigoYykgPT4gIWMuZG9uZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNodXQgZG93biBhbnkgc3RhbGxlcnM7IHNob3VsZG4ndCBiZSBhbnlcbiAgICAgICAgICAgIGNvbmZpZ3MuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYy5zdGFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuc3RhbGxlci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgdG8gbWVldCBxdW9ydW1cIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAvL3Jlc3VsdHM6IGNvbmZpZ3MubWFwKChjKSA9PiBjLnJlc3VsdCksXG4gICAgICAgICAgICAgICAgLy9lcnJvcnM6IGNvbmZpZ3MubWFwKChjKSA9PiBjLmVycm9yKSxcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBjb25maWdzLm1hcCgoYykgPT4gZXhwb3NlRGVidWdDb25maWcoYykpLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFsbGJhY2stcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIlByb3ZpZGVyIiwiQmlnTnVtYmVyIiwiaXNIZXhTdHJpbmciLCJkZWVwQ29weSIsImRlZmluZVJlYWRPbmx5Iiwic2hhbGxvd0NvcHkiLCJzaHVmZmxlZCIsInBvbGwiLCJCYXNlUHJvdmlkZXIiLCJpc0NvbW11bml0eVJlc291cmNlIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwiY2hlY2tOZXR3b3JrcyIsIm5ldHdvcmtzIiwiaSIsImxlbmd0aCIsIm5ldHdvcmsiLCJuYW1lIiwiY2hhaW5JZCIsImVuc0FkZHJlc3MiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJtZWRpYW4iLCJ2YWx1ZXMiLCJtYXhEZWx0YSIsInNsaWNlIiwic29ydCIsIm1pZGRsZSIsIk1hdGgiLCJmbG9vciIsImEiLCJiIiwiYWJzIiwic2VyaWFsaXplIiwiSlNPTiIsInN0cmluZ2lmeSIsImlzQmlnTnVtYmVyIiwidG9TdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJrZXlzIiwiT2JqZWN0Iiwia2V5IiwidiIsImpvaW4iLCJFcnJvciIsIm5leHRSaWQiLCJzdGFsbCIsImR1cmF0aW9uIiwiY2FuY2VsIiwidGltZXIiLCJwcm9taXNlIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIndhaXQiLCJmdW5jIiwiZ2V0UHJvbWlzZSIsIkZvcndhcmRFcnJvcnMiLCJlcnJvcnMiLCJDQUxMX0VYQ0VQVElPTiIsIklOU1VGRklDSUVOVF9GVU5EUyIsIk5PTkNFX0VYUElSRUQiLCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCIsIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUIiwiRm9yd2FyZFByb3BlcnRpZXMiLCJleHBvc2VEZWJ1Z0NvbmZpZyIsImNvbmZpZyIsIndlaWdodCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwicHJvdmlkZXIiLCJzdGFydCIsImVycm9yIiwibm9ybWFsaXplZFRhbGx5Iiwibm9ybWFsaXplIiwicXVvcnVtIiwiY29uZmlncyIsInRhbGx5IiwiZm9yRWFjaCIsImMiLCJjb3VudCIsImNoZWNrIiwidW5kZWZpbmVkIiwiZ2V0UHJvY2Vzc0Z1bmMiLCJtZXRob2QiLCJwYXJhbXMiLCJibG9ja051bWJlciIsImNlaWwiLCJpbmRleE9mIiwiX2hpZ2hlc3RCbG9ja051bWJlciIsInR4IiwiY29uZmlybWF0aW9ucyIsImluY2x1ZGVUcmFuc2FjdGlvbnMiLCJibG9jayIsInRyYW5zYWN0aW9ucyIsIndhaXRGb3JTeW5jIiwiY2FuY2VsbGVkIiwib25jZVBvbGwiLCJnZXRSdW5uZXIiLCJjdXJyZW50QmxvY2tOdW1iZXIiLCJnZXRFdGhlclByaWNlIiwiYmxvY2tUYWciLCJhZGRyZXNzIiwiZ2V0U3RvcmFnZUF0IiwicG9zaXRpb24iLCJibG9ja0hhc2giLCJ0cmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uSGFzaCIsImZpbHRlciIsImZyb21CbG9jayIsInRvQmxvY2siLCJnZXRMb2dzIiwidGhyb3dFcnJvciIsIlVOS05PV05fRVJST1IiLCJGYWxsYmFja1Byb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJwcm92aWRlcnMiLCJwcm92aWRlckNvbmZpZ3MiLCJjb25maWdPclByb3ZpZGVyIiwiaW5kZXgiLCJpc1Byb3ZpZGVyIiwic3RhbGxUaW1lb3V0IiwicHJpb3JpdHkiLCJmcmVlemUiLCJ0b3RhbCIsInJlZHVjZSIsImFjY3VtIiwibmV0d29ya09yUmVhZHkiLCJkZXRlY3ROZXR3b3JrIiwiYWxsIiwiZ2V0TmV0d29yayIsInBlcmZvcm0iLCJyZXN1bHRzIiwic2VuZFRyYW5zYWN0aW9uIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJoYXNoIiwiZ2V0QmxvY2tOdW1iZXIiLCJwcm9jZXNzRnVuYyIsImZpcnN0IiwidDAiLCJpbmZsaWdodFdlaWdodCIsInJ1bm5lciIsInJpZCIsInN0YWxsZXIiLCJsaXN0ZW5lckNvdW50IiwiZW1pdCIsImFjdGlvbiIsImJhY2tlbmQiLCJyZXF1ZXN0Iiwid2FpdGluZyIsInB1c2giLCJyYWNlIiwiY29kZSIsImVycm9yQ29kZSIsInByb3BzIiwicmVhc29uIiwibWVzc2FnZSIsIlNFUlZFUl9FUlJPUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/formatter.js":
/*!*******************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/formatter.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Formatter: () => (/* binding */ Formatter),\n/* harmony export */   isCommunityResourcable: () => (/* binding */ isCommunityResourcable),\n/* harmony export */   isCommunityResource: () => (/* binding */ isCommunityResource),\n/* harmony export */   showThrottleMessage: () => (/* binding */ showThrottleMessage)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/address */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/constants */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+constants@5.7.0/node_modules/@ethersproject/constants/lib.esm/addresses.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/transactions */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nclass Formatter {\n    constructor(){\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = {};\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v)=>{\n            return this.data(v, true);\n        };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data)\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null)\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.shallowCopy)(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined)\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.accessListify)(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof value === \"boolean\") {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof value === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if (result.length % 2 !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)(value);\n    }\n    callAddress(value) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value, 32)) {\n            return null;\n        }\n        const address = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataSlice)(value, 12));\n        return address === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__.AddressZero ? null : address;\n    }\n    contractAddress(value) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getContractAddress)(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        switch(blockTag){\n            case \"earliest\":\n                return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if (typeof blockTag === \"number\" || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(blockTag)) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexValue)(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataLength)(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n        try {\n            return v.toNumber();\n        } catch (error) {}\n        return null;\n    }\n    uint256(value) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexZeroPad)(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = difficulty == null ? null : _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(difficulty);\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {\n                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        } else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {\n                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();\n            }\n            if (typeof chainId !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof chainId !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.parse)(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && result.status !== value) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", {\n                            root: result.root,\n                            status: result.status\n                        });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v)=>this.topics(v));\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for(const key in format){\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return function(value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        };\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return function(value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        };\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return function(array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n            return result;\n        };\n    }\n}\nfunction isCommunityResourcable(value) {\n    return value && typeof value.isCommunityResource === \"function\";\n}\nfunction isCommunityResource(value) {\n    return isCommunityResourcable(value) && value.isCommunityResource();\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nfunction showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https://docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n} //# sourceMappingURL=formatter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9mb3JtYXR0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDMkQ7QUFDbkI7QUFDaUQ7QUFDL0M7QUFDQztBQUMrQjtBQUN4QztBQUNWO0FBQ3JDLE1BQU1lLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUMxQixNQUFNRTtJQUNUQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSSxDQUFDQyxpQkFBaUI7SUFDekM7SUFDQUEsb0JBQW9CO1FBQ2hCLE1BQU1ELFVBQVcsQ0FBQztRQUNsQixNQUFNRSxVQUFVLElBQUksQ0FBQ0EsT0FBTyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUN0QyxNQUFNQyxZQUFZLElBQUksQ0FBQ0EsU0FBUyxDQUFDRCxJQUFJLENBQUMsSUFBSTtRQUMxQyxNQUFNRSxXQUFXLElBQUksQ0FBQ0EsUUFBUSxDQUFDRixJQUFJLENBQUMsSUFBSTtRQUN4QyxNQUFNRyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDSCxJQUFJLENBQUMsSUFBSTtRQUNoQyxNQUFNSSxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDSixJQUFJLENBQUMsSUFBSTtRQUNoQyxNQUFNSyxNQUFNLElBQUksQ0FBQ0EsR0FBRyxDQUFDTCxJQUFJLENBQUMsSUFBSTtRQUM5QixNQUFNTSxTQUFTLElBQUksQ0FBQ0EsTUFBTSxDQUFDTixJQUFJLENBQUMsSUFBSTtRQUNwQyxNQUFNTyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDUCxJQUFJLENBQUMsSUFBSTtRQUNoQyxNQUFNUSxhQUFhLENBQUNDO1lBQVEsT0FBTyxJQUFJLENBQUNOLElBQUksQ0FBQ00sR0FBRztRQUFPO1FBQ3ZEWixRQUFRYSxX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WkQsUUFBUUMsR0FBRyxDQUFDO0lBQ1pELFFBQVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0lBQ1pELFFBQVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0FBQ2hCLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuNy4wX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Zvcm1hdHRlci5qcz9kYjdjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q29udHJhY3RBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaGV4VmFsdWUsIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBBZGRyZXNzWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnksIHBhcnNlIGFzIHBhcnNlVHJhbnNhY3Rpb24gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgY2xhc3MgRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mb3JtYXRzID0gdGhpcy5nZXREZWZhdWx0Rm9ybWF0cygpO1xuICAgIH1cbiAgICBnZXREZWZhdWx0Rm9ybWF0cygpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0cyA9ICh7fSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmFkZHJlc3MuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgYmlnTnVtYmVyID0gdGhpcy5iaWdOdW1iZXIuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgYmxvY2tUYWcgPSB0aGlzLmJsb2NrVGFnLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuaGFzaC5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBoZXggPSB0aGlzLmhleC5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBudW1iZXIgPSB0aGlzLm51bWJlci5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IHN0cmljdERhdGEgPSAodikgPT4geyByZXR1cm4gdGhpcy5kYXRhKHYsIHRydWUpOyB9O1xuICAgICAgICBmb3JtYXRzLnRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLCBudWxsKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCBudWxsKSxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBjb25maXJtYXRpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgLy8gZWl0aGVyIChnYXNQcmljZSkgb3IgKG1heFByaW9yaXR5RmVlUGVyR2FzICsgbWF4RmVlUGVyR2FzKVxuICAgICAgICAgICAgLy8gbXVzdCBiZSBzZXRcbiAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBnYXNMaW1pdDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICB2YWx1ZTogYmlnTnVtYmVyLFxuICAgICAgICAgICAgbm9uY2U6IG51bWJlcixcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksXG4gICAgICAgICAgICBzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksXG4gICAgICAgICAgICB2OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBjcmVhdGVzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgcmF3OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGZyb206IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyksXG4gICAgICAgICAgICBub25jZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIHZhbHVlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBkYXRhOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHN0cmljdERhdGEpLFxuICAgICAgICAgICAgdHlwZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFjY2Vzc0xpc3QuYmluZCh0aGlzKSwgbnVsbCksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMucmVjZWlwdExvZyA9IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgdG9waWNzOiBGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBsb2dJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBoYXNoLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLnJlY2VpcHQgPSB7XG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGFsbG93TnVsbChoYXNoKSwgYnV0IGJyb2tlbi1FSVAtNjU4IHN1cHBvcnQgaXMgaGFuZGxlZCBpbiByZWNlaXB0XG4gICAgICAgICAgICByb290OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhleCksXG4gICAgICAgICAgICBnYXNVc2VkOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBsb2dzQmxvb206IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG4gICAgICAgICAgICBibG9ja0hhc2g6IGhhc2gsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBsb2dzOiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnJlY2VpcHRMb2cuYmluZCh0aGlzKSksXG4gICAgICAgICAgICBibG9ja051bWJlcjogbnVtYmVyLFxuICAgICAgICAgICAgY29uZmlybWF0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBzdGF0dXM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5ibG9jayA9IHtcbiAgICAgICAgICAgIGhhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCksXG4gICAgICAgICAgICBwYXJlbnRIYXNoOiBoYXNoLFxuICAgICAgICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG51bWJlcixcbiAgICAgICAgICAgIG5vbmNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhleCksXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiB0aGlzLmRpZmZpY3VsdHkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBnYXNVc2VkOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBtaW5lcjogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIGV4dHJhRGF0YTogZGF0YSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSksXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlcilcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMgPSBzaGFsbG93Q29weShmb3JtYXRzLmJsb2NrKTtcbiAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMudHJhbnNhY3Rpb25zID0gRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnRyYW5zYWN0aW9uUmVzcG9uc2UuYmluZCh0aGlzKSkpO1xuICAgICAgICBmb3JtYXRzLmZpbHRlciA9IHtcbiAgICAgICAgICAgIGZyb21CbG9jazogRm9ybWF0dGVyLmFsbG93TnVsbChibG9ja1RhZywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIHRvQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnRvcGljcy5iaW5kKHRoaXMpLCB1bmRlZmluZWQpLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmZpbHRlckxvZyA9IHtcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICByZW1vdmVkOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYm9vbGVhbi5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBGb3JtYXR0ZXIuYWxsb3dGYWxzaXNoKGRhdGEsIFwiMHhcIiksXG4gICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuICAgICAgICAgICAgbG9nSW5kZXg6IG51bWJlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgfVxuICAgIGFjY2Vzc0xpc3QoYWNjZXNzTGlzdCkge1xuICAgICAgICByZXR1cm4gYWNjZXNzTGlzdGlmeShhY2Nlc3NMaXN0IHx8IFtdKTtcbiAgICB9XG4gICAgLy8gUmVxdWlyZXMgYSBCaWdOdW1iZXJpc2ggdGhhdCBpcyB3aXRoaW4gdGhlIElFRUU3NTQgc2FmZSBpbnRlZ2VyIHJhbmdlOyByZXR1cm5zIGEgbnVtYmVyXG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIG51bWJlcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20obnVtYmVyKS50b051bWJlcigpO1xuICAgIH1cbiAgICB0eXBlKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID09PSBcIjB4XCIgfHwgbnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBiaWdOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gUmVxdWlyZXMgYSBib29sZWFuLCBcInRydWVcIiBvciAgXCJmYWxzZVwiOyByZXR1cm5zIGEgYm9vbGVhblxuICAgIGJvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib29sZWFuIC0gXCIgKyB2YWx1ZSk7XG4gICAgfVxuICAgIGhleCh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBkYXRhKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5oZXgodmFsdWUsIHN0cmljdCk7XG4gICAgICAgIGlmICgocmVzdWx0Lmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGE7IG9kZC1sZW5ndGggLSBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhbiBhZGRyZXNzXG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIGFkZHJlc3ModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpO1xuICAgIH1cbiAgICBjYWxsQWRkcmVzcyh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlLCAzMikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKGhleERhdGFTbGljZSh2YWx1ZSwgMTIpKTtcbiAgICAgICAgcmV0dXJuIChhZGRyZXNzID09PSBBZGRyZXNzWmVybykgPyBudWxsIDogYWRkcmVzcztcbiAgICB9XG4gICAgY29udHJhY3RBZGRyZXNzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdEFkZHJlc3ModmFsdWUpO1xuICAgIH1cbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgYmxvY2tUYWcoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja1RhZyA9PT0gXCJlYXJsaWVzdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIweDBcIjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGJsb2NrVGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwiZWFybGllc3RcIjogcmV0dXJuIFwiMHgwXCI7XG4gICAgICAgICAgICBjYXNlIFwibGF0ZXN0XCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcIm51bWJlclwiIHx8IGlzSGV4U3RyaW5nKGJsb2NrVGFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFZhbHVlKGJsb2NrVGFnKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJsb2NrVGFnXCIpO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhIGhhc2gsIG9wdGlvbmFsbHkgcmVxdWlyZXMgMHggcHJlZml4OyByZXR1cm5zIHByZWZpeGVkIGxvd2VyY2FzZSBoYXNoLlxuICAgIGhhc2godmFsdWUsIHN0cmljdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhleCh2YWx1ZSwgc3RyaWN0KTtcbiAgICAgICAgaWYgKGhleERhdGFMZW5ndGgocmVzdWx0KSAhPT0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGRpZmZpY3VsdHkgYXMgYSBudW1iZXIsIG9yIGlmIHRvbyBsYXJnZSAoaS5lLiBQb0EgbmV0d29yaykgbnVsbFxuICAgIGRpZmZpY3VsdHkodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHYgPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB1aW50MjU2KHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQyNTZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleFplcm9QYWQodmFsdWUsIDMyKTtcbiAgICB9XG4gICAgX2Jsb2NrKHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHZhbHVlLmF1dGhvciAhPSBudWxsICYmIHZhbHVlLm1pbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlLm1pbmVyID0gdmFsdWUuYXV0aG9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBkaWZmaWN1bHR5IG1heSBuZWVkIHRvIGNvbWUgZnJvbSBfZGlmZmljdWx0eSBpbiByZWN1cnNlZCBibG9ja3NcbiAgICAgICAgY29uc3QgZGlmZmljdWx0eSA9ICh2YWx1ZS5fZGlmZmljdWx0eSAhPSBudWxsKSA/IHZhbHVlLl9kaWZmaWN1bHR5IDogdmFsdWUuZGlmZmljdWx0eTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKGZvcm1hdCwgdmFsdWUpO1xuICAgICAgICByZXN1bHQuX2RpZmZpY3VsdHkgPSAoKGRpZmZpY3VsdHkgPT0gbnVsbCkgPyBudWxsIDogQmlnTnVtYmVyLmZyb20oZGlmZmljdWx0eSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBibG9jayh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2sodmFsdWUsIHRoaXMuZm9ybWF0cy5ibG9jayk7XG4gICAgfVxuICAgIGJsb2NrV2l0aFRyYW5zYWN0aW9ucyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2sodmFsdWUsIHRoaXMuZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMpO1xuICAgIH1cbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgdHJhbnNhY3Rpb25SZXF1ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCwgdmFsdWUpO1xuICAgIH1cbiAgICB0cmFuc2FjdGlvblJlc3BvbnNlKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIFJlbmFtZSBnYXMgdG8gZ2FzTGltaXRcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmdhcyAhPSBudWxsICYmIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID0gdHJhbnNhY3Rpb24uZ2FzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgY2xpZW50cyAoVGVzdFJQQykgZG8gc3RyYW5nZSB0aGluZ3MgbGlrZSByZXR1cm4gMHgwIGZvciB0aGVcbiAgICAgICAgLy8gMCBhZGRyZXNzOyBjb3JyZWN0IHRoaXMgdG8gYmUgYSByZWFsIGFkZHJlc3NcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvICYmIEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLnRvKS5pc1plcm8oKSkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmFtZSBpbnB1dCB0byBkYXRhXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5pbnB1dCAhPSBudWxsICYmIHRyYW5zYWN0aW9uLmRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IHRyYW5zYWN0aW9uLmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRvIGFuZCBjcmVhdGVzIGFyZSBlbXB0eSwgcG9wdWxhdGUgdGhlIGNyZWF0ZXMgZnJvbSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvID09IG51bGwgJiYgdHJhbnNhY3Rpb24uY3JlYXRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5jcmVhdGVzID0gdGhpcy5jb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodHJhbnNhY3Rpb24udHlwZSA9PT0gMSB8fCB0cmFuc2FjdGlvbi50eXBlID09PSAyKSAmJiB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjaGFpbklkID0gdHJhbnNhY3Rpb24uY2hhaW5JZDtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSB0cmFuc2FjdGlvbi5uZXR3b3JrSWQ7XG4gICAgICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcbiAgICAgICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIiAmJiByZXN1bHQudiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IChyZXN1bHQudiAtIDM1KSAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vIDB4MDAwMC4uLiBzaG91bGQgYWN0dWFsbHkgYmUgbnVsbFxuICAgICAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCAmJiByZXN1bHQuYmxvY2tIYXNoLnJlcGxhY2UoLzAvZywgXCJcIikgPT09IFwieFwiKSB7XG4gICAgICAgICAgICByZXN1bHQuYmxvY2tIYXNoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0cmFuc2FjdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VUcmFuc2FjdGlvbih2YWx1ZSk7XG4gICAgfVxuICAgIHJlY2VpcHRMb2codmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdExvZywgdmFsdWUpO1xuICAgIH1cbiAgICByZWNlaXB0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdCwgdmFsdWUpO1xuICAgICAgICAvLyBSU0sgaW5jb3JyZWN0bHkgaW1wbGVtZW50ZWQgRUlQLTY1OCwgc28gd2UgbXVuZ2UgdGhpbmdzIGEgYml0IGhlcmUgZm9yIGl0XG4gICAgICAgIGlmIChyZXN1bHQucm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJvb3QubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBiZSAweDAwLCAweDAsIDB4MDEgb3IgMHgxXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBCaWdOdW1iZXIuZnJvbShyZXN1bHQucm9vdCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDAgfHwgdmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGlmIGJvdGggYXJlIHNwZWNpZmllZCwgdGhleSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSBudWxsICYmIChyZXN1bHQuc3RhdHVzICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbHQtcm9vdC1zdGF0dXMvc3RhdHVzIG1pc21hdGNoXCIsIFwidmFsdWVcIiwgeyByb290OiByZXN1bHQucm9vdCwgc3RhdHVzOiByZXN1bHQuc3RhdHVzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGF0dXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdC5yb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWx0LXJvb3Qtc3RhdHVzXCIsIFwidmFsdWUucm9vdFwiLCByZXN1bHQucm9vdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJvb3QubGVuZ3RoICE9PSA2Nikge1xuICAgICAgICAgICAgICAgIC8vIE11c3QgYmUgYSB2YWxpZCBieXRlczMyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcm9vdCBoYXNoXCIsIFwidmFsdWUucm9vdFwiLCByZXN1bHQucm9vdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmJ5emFudGl1bSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9waWNzKHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy50b3BpY3ModikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc2godmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmaWx0ZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMuZmlsdGVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZpbHRlckxvZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXJMb2csIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGNoZWNrKGZvcm1hdCwgb2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmb3JtYXRba2V5XShvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5jaGVja0tleSA9IGtleTtcbiAgICAgICAgICAgICAgICBlcnJvci5jaGVja1ZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gaWYgdmFsdWUgaXMgbnVsbC1pc2gsIG51bGxWYWx1ZSBpcyByZXR1cm5lZFxuICAgIHN0YXRpYyBhbGxvd051bGwoZm9ybWF0LCBudWxsVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgdmFsdWUgaXMgZmFsc2UtaXNoLCByZXBsYWNlVmFsdWUgaXMgcmV0dXJuZWRcbiAgICBzdGF0aWMgYWxsb3dGYWxzaXNoKGZvcm1hdCwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmVxdWlyZXMgYW4gQXJyYXkgc2F0aXNmeWluZyBjaGVja1xuICAgIHN0YXRpYyBhcnJheU9mKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmb3JtYXQodmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tbXVuaXR5UmVzb3VyY2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZSkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkgJiYgdmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZSgpKTtcbn1cbi8vIFNob3cgdGhlIHRocm90dGxlIG1lc3NhZ2Ugb25seSBvbmNlXG5sZXQgdGhyb3R0bGVNZXNzYWdlID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gc2hvd1Rocm90dGxlTWVzc2FnZSgpIHtcbiAgICBpZiAodGhyb3R0bGVNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3R0bGVNZXNzYWdlID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PSBOT1RJQ0UgPT09PT09PT09XCIpO1xuICAgIGNvbnNvbGUubG9nKFwiUmVxdWVzdC1SYXRlIEV4Y2VlZGVkICAodGhpcyBtZXNzYWdlIHdpbGwgbm90IGJlIHJlcGVhdGVkKVwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlRoZSBkZWZhdWx0IEFQSSBrZXlzIGZvciBlYWNoIHNlcnZpY2UgYXJlIHByb3ZpZGVkIGFzIGEgaGlnaGx5LXRocm90dGxlZCxcIik7XG4gICAgY29uc29sZS5sb2coXCJjb21tdW5pdHkgcmVzb3VyY2UgZm9yIGxvdy10cmFmZmljIHByb2plY3RzIGFuZCBlYXJseSBwcm90b3R5cGluZy5cIik7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJXaGlsZSB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgY29udGludWUgdG8gZnVuY3Rpb24sIHdlIGhpZ2hseSByZWNvbW1lbmRlZFwiKTtcbiAgICBjb25zb2xlLmxvZyhcInNpZ25pbmcgdXAgZm9yIHlvdXIgb3duIEFQSSBrZXlzIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIGluY3JlYXNlIHlvdXJcIik7XG4gICAgY29uc29sZS5sb2coXCJyZXF1ZXN0IHJhdGUvbGltaXQgYW5kIGVuYWJsZSBvdGhlciBwZXJrcywgc3VjaCBhcyBtZXRyaWNzIGFuZCBhZHZhbmNlZCBBUElzLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi9cXC9kb2NzLmV0aGVycy5pby9hcGkta2V5cy9cIik7XG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdHRlci5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsImdldENvbnRyYWN0QWRkcmVzcyIsIkJpZ051bWJlciIsImhleERhdGFMZW5ndGgiLCJoZXhEYXRhU2xpY2UiLCJoZXhWYWx1ZSIsImhleFplcm9QYWQiLCJpc0hleFN0cmluZyIsIkFkZHJlc3NaZXJvIiwic2hhbGxvd0NvcHkiLCJhY2Nlc3NMaXN0aWZ5IiwicGFyc2UiLCJwYXJzZVRyYW5zYWN0aW9uIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIkZvcm1hdHRlciIsImNvbnN0cnVjdG9yIiwiZm9ybWF0cyIsImdldERlZmF1bHRGb3JtYXRzIiwiYWRkcmVzcyIsImJpbmQiLCJiaWdOdW1iZXIiLCJibG9ja1RhZyIsImRhdGEiLCJoYXNoIiwiaGV4IiwibnVtYmVyIiwidHlwZSIsInN0cmljdERhdGEiLCJ2IiwidHJhbnNhY3Rpb24iLCJhY2Nlc3NMaXN0IiwiYWxsb3dOdWxsIiwiYmxvY2tIYXNoIiwiYmxvY2tOdW1iZXIiLCJ0cmFuc2FjdGlvbkluZGV4IiwiY29uZmlybWF0aW9ucyIsImZyb20iLCJnYXNQcmljZSIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIiwiZ2FzTGltaXQiLCJ0byIsInZhbHVlIiwibm9uY2UiLCJyIiwidWludDI1NiIsInMiLCJjcmVhdGVzIiwicmF3IiwidHJhbnNhY3Rpb25SZXF1ZXN0IiwicmVjZWlwdExvZyIsInRyYW5zYWN0aW9uSGFzaCIsInRvcGljcyIsImFycmF5T2YiLCJsb2dJbmRleCIsInJlY2VpcHQiLCJjb250cmFjdEFkZHJlc3MiLCJyb290IiwiZ2FzVXNlZCIsImxvZ3NCbG9vbSIsImxvZ3MiLCJjdW11bGF0aXZlR2FzVXNlZCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwic3RhdHVzIiwiYmxvY2siLCJwYXJlbnRIYXNoIiwidGltZXN0YW1wIiwiZGlmZmljdWx0eSIsIm1pbmVyIiwiZXh0cmFEYXRhIiwidHJhbnNhY3Rpb25zIiwiYmFzZUZlZVBlckdhcyIsImJsb2NrV2l0aFRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9uUmVzcG9uc2UiLCJmaWx0ZXIiLCJmcm9tQmxvY2siLCJ1bmRlZmluZWQiLCJ0b0Jsb2NrIiwiZmlsdGVyTG9nIiwicmVtb3ZlZCIsImJvb2xlYW4iLCJhbGxvd0ZhbHNpc2giLCJ0b051bWJlciIsInRvTG93ZXJDYXNlIiwiRXJyb3IiLCJzdHJpY3QiLCJzdWJzdHJpbmciLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJyZXN1bHQiLCJsZW5ndGgiLCJjYWxsQWRkcmVzcyIsImVycm9yIiwiX2Jsb2NrIiwiZm9ybWF0IiwiYXV0aG9yIiwiX2RpZmZpY3VsdHkiLCJjaGVjayIsImdhcyIsImlzWmVybyIsImlucHV0IiwiY2hhaW5JZCIsIm5ldHdvcmtJZCIsInBhcnNlSW50IiwicmVwbGFjZSIsImJ5emFudGl1bSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIm9iamVjdCIsImtleSIsImNoZWNrS2V5IiwiY2hlY2tWYWx1ZSIsIm51bGxWYWx1ZSIsInJlcGxhY2VWYWx1ZSIsImFycmF5IiwiZm9yRWFjaCIsInB1c2giLCJpc0NvbW11bml0eVJlc291cmNhYmxlIiwiaXNDb21tdW5pdHlSZXNvdXJjZSIsInRocm90dGxlTWVzc2FnZSIsInNob3dUaHJvdHRsZU1lc3NhZ2UiLCJjb25zb2xlIiwibG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/formatter.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/index.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/index.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlchemyProvider: () => (/* reexport safe */ _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__.AlchemyProvider),\n/* harmony export */   AlchemyWebSocketProvider: () => (/* reexport safe */ _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__.AlchemyWebSocketProvider),\n/* harmony export */   AnkrProvider: () => (/* reexport safe */ _ankr_provider__WEBPACK_IMPORTED_MODULE_7__.AnkrProvider),\n/* harmony export */   BaseProvider: () => (/* reexport safe */ _base_provider__WEBPACK_IMPORTED_MODULE_16__.BaseProvider),\n/* harmony export */   CloudflareProvider: () => (/* reexport safe */ _cloudflare_provider__WEBPACK_IMPORTED_MODULE_8__.CloudflareProvider),\n/* harmony export */   EtherscanProvider: () => (/* reexport safe */ _etherscan_provider__WEBPACK_IMPORTED_MODULE_9__.EtherscanProvider),\n/* harmony export */   FallbackProvider: () => (/* reexport safe */ _fallback_provider__WEBPACK_IMPORTED_MODULE_5__.FallbackProvider),\n/* harmony export */   Formatter: () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.Formatter),\n/* harmony export */   InfuraProvider: () => (/* reexport safe */ _infura_provider__WEBPACK_IMPORTED_MODULE_10__.InfuraProvider),\n/* harmony export */   InfuraWebSocketProvider: () => (/* reexport safe */ _infura_provider__WEBPACK_IMPORTED_MODULE_10__.InfuraWebSocketProvider),\n/* harmony export */   IpcProvider: () => (/* reexport safe */ _ipc_provider__WEBPACK_IMPORTED_MODULE_14__.IpcProvider),\n/* harmony export */   JsonRpcBatchProvider: () => (/* reexport safe */ _json_rpc_batch_provider__WEBPACK_IMPORTED_MODULE_18__.JsonRpcBatchProvider),\n/* harmony export */   JsonRpcProvider: () => (/* reexport safe */ _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* reexport safe */ _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcSigner),\n/* harmony export */   NodesmithProvider: () => (/* reexport safe */ _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__.NodesmithProvider),\n/* harmony export */   PocketProvider: () => (/* reexport safe */ _pocket_provider__WEBPACK_IMPORTED_MODULE_12__.PocketProvider),\n/* harmony export */   Provider: () => (/* reexport safe */ _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_15__.Provider),\n/* harmony export */   Resolver: () => (/* reexport safe */ _base_provider__WEBPACK_IMPORTED_MODULE_16__.Resolver),\n/* harmony export */   StaticJsonRpcProvider: () => (/* reexport safe */ _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_17__.StaticJsonRpcProvider),\n/* harmony export */   UrlJsonRpcProvider: () => (/* reexport safe */ _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_17__.UrlJsonRpcProvider),\n/* harmony export */   Web3Provider: () => (/* reexport safe */ _web3_provider__WEBPACK_IMPORTED_MODULE_13__.Web3Provider),\n/* harmony export */   WebSocketProvider: () => (/* reexport safe */ _websocket_provider__WEBPACK_IMPORTED_MODULE_3__.WebSocketProvider),\n/* harmony export */   getDefaultProvider: () => (/* binding */ getDefaultProvider),\n/* harmony export */   getNetwork: () => (/* reexport safe */ _ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__.getNetwork),\n/* harmony export */   isCommunityResourcable: () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.isCommunityResourcable),\n/* harmony export */   isCommunityResource: () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.isCommunityResource),\n/* harmony export */   showThrottleMessage: () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.showThrottleMessage)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+abstract-provider@5.7.0/node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/networks */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+networks@5.7.0/node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./base-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n/* harmony import */ var _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./alchemy-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js\");\n/* harmony import */ var _ankr_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ankr-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ankr-provider.js\");\n/* harmony import */ var _cloudflare_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cloudflare-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js\");\n/* harmony import */ var _etherscan_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./etherscan-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js\");\n/* harmony import */ var _fallback_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fallback-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js\");\n/* harmony import */ var _ipc_provider__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ipc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js\");\n/* harmony import */ var _infura_provider__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./infura-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/infura-provider.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n/* harmony import */ var _json_rpc_batch_provider__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./json-rpc-batch-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js\");\n/* harmony import */ var _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nodesmith-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js\");\n/* harmony import */ var _pocket_provider__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pocket-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js\");\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n/* harmony import */ var _web3_provider__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./web3-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/web3-provider.js\");\n/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./websocket-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./formatter */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network, options) {\n    if (network == null) {\n        network = \"homestead\";\n    }\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof network === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch(match[1].toLowerCase()){\n                case \"http\":\n                case \"https\":\n                    return new _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider(network);\n                case \"ws\":\n                case \"wss\":\n                    return new _websocket_provider__WEBPACK_IMPORTED_MODULE_3__.WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n    const n = (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__.getNetwork)(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n    return n._defaultProvider({\n        FallbackProvider: _fallback_provider__WEBPACK_IMPORTED_MODULE_5__.FallbackProvider,\n        AlchemyProvider: _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__.AlchemyProvider,\n        AnkrProvider: _ankr_provider__WEBPACK_IMPORTED_MODULE_7__.AnkrProvider,\n        CloudflareProvider: _cloudflare_provider__WEBPACK_IMPORTED_MODULE_8__.CloudflareProvider,\n        EtherscanProvider: _etherscan_provider__WEBPACK_IMPORTED_MODULE_9__.EtherscanProvider,\n        InfuraProvider: _infura_provider__WEBPACK_IMPORTED_MODULE_10__.InfuraProvider,\n        JsonRpcProvider: _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider,\n        NodesmithProvider: _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__.NodesmithProvider,\n        PocketProvider: _pocket_provider__WEBPACK_IMPORTED_MODULE_12__.PocketProvider,\n        Web3Provider: _web3_provider__WEBPACK_IMPORTED_MODULE_13__.Web3Provider,\n        IpcProvider: _ipc_provider__WEBPACK_IMPORTED_MODULE_14__.IpcProvider\n    }, options);\n}\n////////////////////////\n// Exports\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQytDO0FBQ1A7QUFDSTtBQUNzQjtBQUNoQztBQUNZO0FBQ0Y7QUFDRjtBQUNWO0FBQytCO0FBQ1A7QUFDSjtBQUNSO0FBQ047QUFDaUM7QUFDckM7QUFDVTtBQUNpRDtBQUMzRDtBQUNWO0FBQ3JDLE1BQU00QixTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDakMsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQixTQUFTRSxtQkFBbUJDLE9BQU8sRUFBRUMsT0FBTztJQUN4QyxJQUFJRCxXQUFXLE1BQU07UUFDakJBLFVBQVU7SUFDZDtJQUNBLDZFQUE2RTtJQUM3RSxJQUFJLE9BQVFBLFlBQWEsVUFBVTtRQUMvQixrRUFBa0U7UUFDbEUsaURBQWlEO1FBQ2pELE1BQU1FLFFBQVFGLFFBQVFFLEtBQUssQ0FBQztRQUM1QixJQUFJQSxPQUFPO1lBQ1AsT0FBUUEsS0FBSyxDQUFDLEVBQUUsQ0FBQ0MsV0FBVztnQkFDeEIsS0FBSztnQkFDTCxLQUFLO29CQUNELE9BQU8sSUFBSXBCLCtEQUFlQSxDQUFDaUI7Z0JBQy9CLEtBQUs7Z0JBQ0wsS0FBSztvQkFDRCxPQUFPLElBQUlULGtFQUFpQkEsQ0FBQ1M7Z0JBQ2pDO29CQUNJRixPQUFPTSxrQkFBa0IsQ0FBQywwQkFBMEIsV0FBV0o7WUFDdkU7UUFDSjtJQUNKO0lBQ0EsTUFBTUssSUFBSWxDLG1FQUFVQSxDQUFDNkI7SUFDckIsSUFBSSxDQUFDSyxLQUFLLENBQUNBLEVBQUVDLGdCQUFnQixFQUFFO1FBQzNCUixPQUFPUyxVQUFVLENBQUMsMENBQTBDWCx5REFBTUEsQ0FBQ1ksTUFBTSxDQUFDQyxhQUFhLEVBQUU7WUFDckZDLFdBQVc7WUFDWFYsU0FBU0E7UUFDYjtJQUNKO0lBQ0EsT0FBT0ssRUFBRUMsZ0JBQWdCLENBQUM7UUFDdEIzQixnQkFBZ0JBLGtFQUFBQTtRQUNoQkwsZUFBZUEsZ0VBQUFBO1FBQ2ZFLFlBQVlBLDBEQUFBQTtRQUNaQyxrQkFBa0JBLHNFQUFBQTtRQUNsQkMsaUJBQWlCQSxvRUFBQUE7UUFDakJHLGNBQWNBLCtEQUFBQTtRQUNkRSxlQUFlQSxpRUFBQUE7UUFDZkcsaUJBQWlCQSxxRUFBQUE7UUFDakJDLGNBQWNBLCtEQUFBQTtRQUNkRyxZQUFZQSwyREFBQUE7UUFDWlYsV0FBV0EseURBQUFBO0lBQ2YsR0FBR3FCO0FBQ1A7QUFDQSx3QkFBd0I7QUFDeEIsVUFBVTtBQWVFLENBQ1osaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuNy4wX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2luZGV4LmpzP2Y3ZDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlclwiO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9uZXR3b3Jrc1wiO1xuaW1wb3J0IHsgQmFzZVByb3ZpZGVyLCBSZXNvbHZlciB9IGZyb20gXCIuL2Jhc2UtcHJvdmlkZXJcIjtcbmltcG9ydCB7IEFsY2hlbXlQcm92aWRlciwgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vYWxjaGVteS1wcm92aWRlclwiO1xuaW1wb3J0IHsgQW5rclByb3ZpZGVyIH0gZnJvbSBcIi4vYW5rci1wcm92aWRlclwiO1xuaW1wb3J0IHsgQ2xvdWRmbGFyZVByb3ZpZGVyIH0gZnJvbSBcIi4vY2xvdWRmbGFyZS1wcm92aWRlclwiO1xuaW1wb3J0IHsgRXRoZXJzY2FuUHJvdmlkZXIgfSBmcm9tIFwiLi9ldGhlcnNjYW4tcHJvdmlkZXJcIjtcbmltcG9ydCB7IEZhbGxiYWNrUHJvdmlkZXIgfSBmcm9tIFwiLi9mYWxsYmFjay1wcm92aWRlclwiO1xuaW1wb3J0IHsgSXBjUHJvdmlkZXIgfSBmcm9tIFwiLi9pcGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IEluZnVyYVByb3ZpZGVyLCBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL2luZnVyYS1wcm92aWRlclwiO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyLCBKc29uUnBjU2lnbmVyIH0gZnJvbSBcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IEpzb25ScGNCYXRjaFByb3ZpZGVyIH0gZnJvbSBcIi4vanNvbi1ycGMtYmF0Y2gtcHJvdmlkZXJcIjtcbmltcG9ydCB7IE5vZGVzbWl0aFByb3ZpZGVyIH0gZnJvbSBcIi4vbm9kZXNtaXRoLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBQb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL3BvY2tldC1wcm92aWRlclwiO1xuaW1wb3J0IHsgU3RhdGljSnNvblJwY1Byb3ZpZGVyLCBVcmxKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi91cmwtanNvbi1ycGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IFdlYjNQcm92aWRlciB9IGZyb20gXCIuL3dlYjMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IFdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vd2Vic29ja2V0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBGb3JtYXR0ZXIsIGlzQ29tbXVuaXR5UmVzb3VyY2FibGUsIGlzQ29tbXVuaXR5UmVzb3VyY2UsIHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIEZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgIG5ldHdvcmsgPSBcImhvbWVzdGVhZFwiO1xuICAgIH1cbiAgICAvLyBJZiBwYXNzZWQgYSBVUkwsIGZpZ3VyZSBvdXQgdGhlIHJpZ2h0IHR5cGUgb2YgcHJvdmlkZXIgYmFzZWQgb24gdGhlIHNjaGVtZVxuICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgc3VwcG9ydCBmb3IgSXBjUHJvdmlkZXI7IG1heWJlIGlmIGl0IGVuZHMgaW4gXCIuaXBjXCI/XG4gICAgICAgIC8vIEhhbmRsZSBodHRwIGFuZCB3cyAoYW5kIHRoZWlyIHNlY3VyZSB2YXJpYW50cylcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBuZXR3b3JrLm1hdGNoKC9eKHdzfGh0dHApcz86L2kpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobWF0Y2hbMV0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1Byb3ZpZGVyKG5ldHdvcmspO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ3c1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ3c3NcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgVVJMIHNjaGVtZVwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbiA9IGdldE5ldHdvcmsobmV0d29yayk7XG4gICAgaWYgKCFuIHx8ICFuLl9kZWZhdWx0UHJvdmlkZXIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBnZXREZWZhdWx0UHJvdmlkZXIgbmV0d29ya1wiLCBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXREZWZhdWx0UHJvdmlkZXJcIixcbiAgICAgICAgICAgIG5ldHdvcms6IG5ldHdvcmtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuLl9kZWZhdWx0UHJvdmlkZXIoe1xuICAgICAgICBGYWxsYmFja1Byb3ZpZGVyLFxuICAgICAgICBBbGNoZW15UHJvdmlkZXIsXG4gICAgICAgIEFua3JQcm92aWRlcixcbiAgICAgICAgQ2xvdWRmbGFyZVByb3ZpZGVyLFxuICAgICAgICBFdGhlcnNjYW5Qcm92aWRlcixcbiAgICAgICAgSW5mdXJhUHJvdmlkZXIsXG4gICAgICAgIEpzb25ScGNQcm92aWRlcixcbiAgICAgICAgTm9kZXNtaXRoUHJvdmlkZXIsXG4gICAgICAgIFBvY2tldFByb3ZpZGVyLFxuICAgICAgICBXZWIzUHJvdmlkZXIsXG4gICAgICAgIElwY1Byb3ZpZGVyLFxuICAgIH0sIG9wdGlvbnMpO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHBvcnRzXG5leHBvcnQgeyBcbi8vIEFic3RyYWN0IFByb3ZpZGVycyAob3IgQWJzdHJhY3QtaXNoKVxuUHJvdmlkZXIsIEJhc2VQcm92aWRlciwgUmVzb2x2ZXIsIFVybEpzb25ScGNQcm92aWRlciwgXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ29uY3JldGUgUHJvdmlkZXJzXG5GYWxsYmFja1Byb3ZpZGVyLCBBbGNoZW15UHJvdmlkZXIsIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciwgQW5rclByb3ZpZGVyLCBDbG91ZGZsYXJlUHJvdmlkZXIsIEV0aGVyc2NhblByb3ZpZGVyLCBJbmZ1cmFQcm92aWRlciwgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIsIEpzb25ScGNQcm92aWRlciwgSnNvblJwY0JhdGNoUHJvdmlkZXIsIE5vZGVzbWl0aFByb3ZpZGVyLCBQb2NrZXRQcm92aWRlciwgU3RhdGljSnNvblJwY1Byb3ZpZGVyLCBXZWIzUHJvdmlkZXIsIFdlYlNvY2tldFByb3ZpZGVyLCBJcGNQcm92aWRlciwgXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2lnbmVyXG5Kc29uUnBjU2lnbmVyLCBcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBGdW5jdGlvbnNcbmdldERlZmF1bHRQcm92aWRlciwgZ2V0TmV0d29yaywgaXNDb21tdW5pdHlSZXNvdXJjZSwgaXNDb21tdW5pdHlSZXNvdXJjYWJsZSwgc2hvd1Rocm90dGxlTWVzc2FnZSwgXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gT2JqZWN0c1xuRm9ybWF0dGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiUHJvdmlkZXIiLCJnZXROZXR3b3JrIiwiQmFzZVByb3ZpZGVyIiwiUmVzb2x2ZXIiLCJBbGNoZW15UHJvdmlkZXIiLCJBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIiLCJBbmtyUHJvdmlkZXIiLCJDbG91ZGZsYXJlUHJvdmlkZXIiLCJFdGhlcnNjYW5Qcm92aWRlciIsIkZhbGxiYWNrUHJvdmlkZXIiLCJJcGNQcm92aWRlciIsIkluZnVyYVByb3ZpZGVyIiwiSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIiLCJKc29uUnBjUHJvdmlkZXIiLCJKc29uUnBjU2lnbmVyIiwiSnNvblJwY0JhdGNoUHJvdmlkZXIiLCJOb2Rlc21pdGhQcm92aWRlciIsIlBvY2tldFByb3ZpZGVyIiwiU3RhdGljSnNvblJwY1Byb3ZpZGVyIiwiVXJsSnNvblJwY1Byb3ZpZGVyIiwiV2ViM1Byb3ZpZGVyIiwiV2ViU29ja2V0UHJvdmlkZXIiLCJGb3JtYXR0ZXIiLCJpc0NvbW11bml0eVJlc291cmNhYmxlIiwiaXNDb21tdW5pdHlSZXNvdXJjZSIsInNob3dUaHJvdHRsZU1lc3NhZ2UiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiZ2V0RGVmYXVsdFByb3ZpZGVyIiwibmV0d29yayIsIm9wdGlvbnMiLCJtYXRjaCIsInRvTG93ZXJDYXNlIiwidGhyb3dBcmd1bWVudEVycm9yIiwibiIsIl9kZWZhdWx0UHJvdmlkZXIiLCJ0aHJvd0Vycm9yIiwiZXJyb3JzIiwiTkVUV09SS19FUlJPUiIsIm9wZXJhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/infura-provider.js":
/*!*************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/infura-provider.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfuraProvider: () => (/* binding */ InfuraProvider),\n/* harmony export */   InfuraWebSocketProvider: () => (/* binding */ InfuraWebSocketProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatter */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nclass InfuraWebSocketProvider extends _websocket_provider__WEBPACK_IMPORTED_MODULE_2__.WebSocketProvider {\n    constructor(network, apiKey){\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"apiKey\", provider.projectId);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"projectId\", provider.projectId);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"projectSecret\", provider.projectSecret);\n    }\n    isCommunityResource() {\n        return this.projectId === defaultProjectId;\n    }\n}\nclass InfuraProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__.UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n        if (apiKey == null) {\n            return apiKeyObj;\n        }\n        if (typeof apiKey === \"string\") {\n            apiKeyObj.projectId = apiKey;\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument(typeof apiKey.projectId === \"string\", \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument(typeof apiKey.projectSecret === \"string\", \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch(network ? network.name : \"unknown\"){\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const connection = {\n            allowGzip: true,\n            url: \"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId,\n            throttleCallback: (attempt, url)=>{\n                if (apiKey.projectId === defaultProjectId) {\n                    (0,_formatter__WEBPACK_IMPORTED_MODULE_5__.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return this.projectId === defaultProjectId;\n    }\n} //# sourceMappingURL=infura-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9pbmZ1cmEtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBYTtBQUM4QztBQUNGO0FBQ1A7QUFDSDtBQUNWO0FBQ3JDLE1BQU1LLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUM0QjtBQUM3RCxNQUFNRyxtQkFBbUI7QUFDbEIsTUFBTUMsZ0NBQWdDUCxrRUFBaUJBO0lBQzFEUSxZQUFZQyxPQUFPLEVBQUVDLE1BQU0sQ0FBRTtRQUN6QixNQUFNQyxXQUFXLElBQUlDLGVBQWVILFNBQVNDO1FBQzdDLE1BQU1HLGFBQWFGLFNBQVNFLFVBQVU7UUFDdEMsSUFBSUEsV0FBV0MsUUFBUSxFQUFFO1lBQ3JCVixPQUFPVyxVQUFVLENBQUMsZ0RBQWdEYix5REFBTUEsQ0FBQ2MsTUFBTSxDQUFDQyxxQkFBcUIsRUFBRTtnQkFDbkdDLFdBQVc7WUFDZjtRQUNKO1FBQ0EsTUFBTUMsTUFBTU4sV0FBV00sR0FBRyxDQUFDQyxPQUFPLENBQUMsVUFBVSxNQUFNQSxPQUFPLENBQUMsUUFBUTtRQUNuRSxLQUFLLENBQUNELEtBQUtWO1FBQ1hWLHlFQUFjQSxDQUFDLElBQUksRUFBRSxVQUFVWSxTQUFTVSxTQUFTO1FBQ2pEdEIseUVBQWNBLENBQUMsSUFBSSxFQUFFLGFBQWFZLFNBQVNVLFNBQVM7UUFDcER0Qix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsaUJBQWlCWSxTQUFTVyxhQUFhO0lBQ2hFO0lBQ0FDLHNCQUFzQjtRQUNsQixPQUFRLElBQUksQ0FBQ0YsU0FBUyxLQUFLZjtJQUMvQjtBQUNKO0FBQ08sTUFBTU0sdUJBQXVCUCxzRUFBa0JBO0lBQ2xELE9BQU9tQixxQkFBcUJmLE9BQU8sRUFBRUMsTUFBTSxFQUFFO1FBQ3pDLE9BQU8sSUFBSUgsd0JBQXdCRSxTQUFTQztJQUNoRDtJQUNBLE9BQU9lLFVBQVVmLE1BQU0sRUFBRTtRQUNyQixNQUFNZ0IsWUFBWTtZQUNkaEIsUUFBUUo7WUFDUmUsV0FBV2Y7WUFDWGdCLGVBQWU7UUFDbkI7UUFDQSxJQUFJWixVQUFVLE1BQU07WUFDaEIsT0FBT2dCO1FBQ1g7UUFDQSxJQUFJLE9BQVFoQixXQUFZLFVBQVU7WUFDOUJnQixVQUFVTCxTQUFTLEdBQUdYO1FBQzFCLE9BQ0ssSUFBSUEsT0FBT1ksYUFBYSxJQUFJLE1BQU07WUFDbkNsQixPQUFPdUIsY0FBYyxDQUFFLE9BQVFqQixPQUFPVyxTQUFTLEtBQU0sVUFBVyxzQ0FBc0MsYUFBYVgsT0FBT1csU0FBUztZQUNuSWpCLE9BQU91QixjQUFjLENBQUUsT0FBUWpCLE9BQU9ZLGFBQWEsS0FBTSxVQUFXLHlCQUF5QixpQkFBaUI7WUFDOUdJLFVBQVVMLFNBQVMsR0FBR1gsT0FBT1csU0FBUztZQUN0Q0ssVUFBVUosYUFBYSxHQUFHWixPQUFPWSxhQUFhO1FBQ2xELE9BQ0ssSUFBSVosT0FBT1csU0FBUyxFQUFFO1lBQ3ZCSyxVQUFVTCxTQUFTLEdBQUdYLE9BQU9XLFNBQVM7UUFDMUM7UUFDQUssVUFBVWhCLE1BQU0sR0FBR2dCLFVBQVVMLFNBQVM7UUFDdEMsT0FBT0s7SUFDWDtJQUNBLE9BQU9FLE9BQU9uQixPQUFPLEVBQUVDLE1BQU0sRUFBRTtRQUMzQixJQUFJbUIsT0FBTztRQUNYLE9BQVFwQixVQUFVQSxRQUFRcUIsSUFBSSxHQUFHO1lBQzdCLEtBQUs7Z0JBQ0RELE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0o7Z0JBQ0l6QixPQUFPVyxVQUFVLENBQUMsdUJBQXVCYix5REFBTUEsQ0FBQ2MsTUFBTSxDQUFDZSxnQkFBZ0IsRUFBRTtvQkFDckVDLFVBQVU7b0JBQ1ZDLE9BQU94QjtnQkFDWDtRQUNSO1FBQ0EsTUFBTUksYUFBYTtZQUNmcUIsV0FBVztZQUNYZixLQUFNLFlBQVksTUFBTVUsT0FBTyxTQUFTbkIsT0FBT1csU0FBUztZQUN4RGMsa0JBQWtCLENBQUNDLFNBQVNqQjtnQkFDeEIsSUFBSVQsT0FBT1csU0FBUyxLQUFLZixrQkFBa0I7b0JBQ3ZDTCwrREFBbUJBO2dCQUN2QjtnQkFDQSxPQUFPb0MsUUFBUUMsT0FBTyxDQUFDO1lBQzNCO1FBQ0o7UUFDQSxJQUFJNUIsT0FBT1ksYUFBYSxJQUFJLE1BQU07WUFDOUJULFdBQVcwQixJQUFJLEdBQUc7WUFDbEIxQixXQUFXQyxRQUFRLEdBQUdKLE9BQU9ZLGFBQWE7UUFDOUM7UUFDQSxPQUFPVDtJQUNYO0lBQ0FVLHNCQUFzQjtRQUNsQixPQUFRLElBQUksQ0FBQ0YsU0FBUyxLQUFLZjtJQUMvQjtBQUNKLEVBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuNy4wX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2luZnVyYS1wcm92aWRlci5qcz81OWNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgV2ViU29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi93ZWJzb2NrZXQtcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IFVybEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiO1xuY29uc3QgZGVmYXVsdFByb2plY3RJZCA9IFwiODQ4NDIwNzhiMDk5NDY2MzhjMDMxNTdmODM0MDUyMTNcIjtcbmV4cG9ydCBjbGFzcyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIFdlYlNvY2tldFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgSW5mdXJhUHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHByb3ZpZGVyLmNvbm5lY3Rpb247XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIklORlVSQSBXZWJTb2NrZXQgcHJvamVjdCBzZWNyZXRzIHVuc3VwcG9ydGVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIkluZnVyYVByb3ZpZGVyLmdldFdlYlNvY2tldFByb3ZpZGVyKClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKS5yZXBsYWNlKFwiL3YzL1wiLCBcIi93cy92My9cIik7XG4gICAgICAgIHN1cGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYXBpS2V5XCIsIHByb3ZpZGVyLnByb2plY3RJZCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvamVjdElkXCIsIHByb3ZpZGVyLnByb2plY3RJZCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvamVjdFNlY3JldFwiLCBwcm92aWRlci5wcm9qZWN0U2VjcmV0KTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnByb2plY3RJZCA9PT0gZGVmYXVsdFByb2plY3RJZCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEluZnVyYVByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBzdGF0aWMgZ2V0V2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEFwaUtleShhcGlLZXkpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5T2JqID0ge1xuICAgICAgICAgICAgYXBpS2V5OiBkZWZhdWx0UHJvamVjdElkLFxuICAgICAgICAgICAgcHJvamVjdElkOiBkZWZhdWx0UHJvamVjdElkLFxuICAgICAgICAgICAgcHJvamVjdFNlY3JldDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGlLZXlPYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYXBpS2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RJZCA9IGFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdFNlY3JldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RJZCkgPT09IFwic3RyaW5nXCIpLCBcInByb2plY3RTZWNyZXQgcmVxdWlyZXMgYSBwcm9qZWN0SWRcIiwgXCJwcm9qZWN0SWRcIiwgYXBpS2V5LnByb2plY3RJZCk7XG4gICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RTZWNyZXQpID09PSBcInN0cmluZ1wiKSwgXCJpbnZhbGlkIHByb2plY3RTZWNyZXRcIiwgXCJwcm9qZWN0U2VjcmV0XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0SWQgPSBhcGlLZXkucHJvamVjdElkO1xuICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RTZWNyZXQgPSBhcGlLZXkucHJvamVjdFNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdElkKSB7XG4gICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdElkID0gYXBpS2V5LnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBhcGlLZXlPYmouYXBpS2V5ID0gYXBpS2V5T2JqLnByb2plY3RJZDtcbiAgICAgICAgcmV0dXJuIGFwaUtleU9iajtcbiAgICB9XG4gICAgc3RhdGljIGdldFVybChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgbGV0IGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsgPyBuZXR3b3JrLm5hbWUgOiBcInVua25vd25cIikge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInJvcHN0ZW4uaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInJpbmtlYnkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJrb3Zhbi5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJnb2VybGkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNtdW1cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW11bWJhaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm9wdGltaXNtLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3B0aW1pc20ta292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJvcHRpbWlzbS1rb3Zhbi5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYml0cnVtLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW0tcmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYml0cnVtLXJpbmtlYnkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV0d29ya1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICBhbGxvd0d6aXA6IHRydWUsXG4gICAgICAgICAgICB1cmw6IChcImh0dHBzOi9cIiArIFwiL1wiICsgaG9zdCArIFwiL3YzL1wiICsgYXBpS2V5LnByb2plY3RJZCksXG4gICAgICAgICAgICB0aHJvdHRsZUNhbGxiYWNrOiAoYXR0ZW1wdCwgdXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFwaUtleS5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd1Rocm90dGxlTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXBpS2V5LnByb2plY3RTZWNyZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51c2VyID0gXCJcIjtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucGFzc3dvcmQgPSBhcGlLZXkucHJvamVjdFNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnByb2plY3RJZCA9PT0gZGVmYXVsdFByb2plY3RJZCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mdXJhLXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVSZWFkT25seSIsIldlYlNvY2tldFByb3ZpZGVyIiwic2hvd1Rocm90dGxlTWVzc2FnZSIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJVcmxKc29uUnBjUHJvdmlkZXIiLCJkZWZhdWx0UHJvamVjdElkIiwiSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIiLCJjb25zdHJ1Y3RvciIsIm5ldHdvcmsiLCJhcGlLZXkiLCJwcm92aWRlciIsIkluZnVyYVByb3ZpZGVyIiwiY29ubmVjdGlvbiIsInBhc3N3b3JkIiwidGhyb3dFcnJvciIsImVycm9ycyIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsInVybCIsInJlcGxhY2UiLCJwcm9qZWN0SWQiLCJwcm9qZWN0U2VjcmV0IiwiaXNDb21tdW5pdHlSZXNvdXJjZSIsImdldFdlYlNvY2tldFByb3ZpZGVyIiwiZ2V0QXBpS2V5IiwiYXBpS2V5T2JqIiwiYXNzZXJ0QXJndW1lbnQiLCJnZXRVcmwiLCJob3N0IiwibmFtZSIsIklOVkFMSURfQVJHVU1FTlQiLCJhcmd1bWVudCIsInZhbHVlIiwiYWxsb3dHemlwIiwidGhyb3R0bGVDYWxsYmFjayIsImF0dGVtcHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInVzZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/infura-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js":
/*!**********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IpcProvider: () => (/* binding */ IpcProvider)\n/* harmony export */ });\n\nconst IpcProvider = null;\n //# sourceMappingURL=ipc-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9pcGMtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFhO0FBQ2IsTUFBTUEsY0FBYztBQUNHLENBQ3ZCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9pcGMtcHJvdmlkZXIuanM/MDBjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IElwY1Byb3ZpZGVyID0gbnVsbDtcbmV4cG9ydCB7IElwY1Byb3ZpZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcGMtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIklwY1Byb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js ***!
  \*********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcBatchProvider: () => (/* binding */ JsonRpcBatchProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/properties */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/web */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+web@5.7.0/node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n\n\n\n// Experimental\nclass JsonRpcBatchProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider {\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: this._nextId++,\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        const inflightRequest = {\n            request,\n            resolve: null,\n            reject: null\n        };\n        const promise = new Promise((resolve, reject)=>{\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(()=>{\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                const request = batch.map((inflight)=>inflight.request);\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(request),\n                    provider: this\n                });\n                return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_2__.fetchJson)(this.connection, JSON.stringify(request)).then((result)=>{\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index)=>{\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, (error)=>{\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n                    batch.forEach((inflightRequest)=>{\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    }\n} //# sourceMappingURL=json-rpc-batch-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9qc29uLXJwYy1iYXRjaC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFEO0FBQ047QUFDTztBQUN0RCxlQUFlO0FBQ1IsTUFBTUcsNkJBQTZCRCwrREFBZUE7SUFDckRFLEtBQUtDLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ2pCLE1BQU1DLFVBQVU7WUFDWkYsUUFBUUE7WUFDUkMsUUFBUUE7WUFDUkUsSUFBSyxJQUFJLENBQUNDLE9BQU87WUFDakJDLFNBQVM7UUFDYjtRQUNBLElBQUksSUFBSSxDQUFDQyxhQUFhLElBQUksTUFBTTtZQUM1QixJQUFJLENBQUNBLGFBQWEsR0FBRyxFQUFFO1FBQzNCO1FBQ0EsTUFBTUMsa0JBQWtCO1lBQUVMO1lBQVNNLFNBQVM7WUFBTUMsUUFBUTtRQUFLO1FBQy9ELE1BQU1DLFVBQVUsSUFBSUMsUUFBUSxDQUFDSCxTQUFTQztZQUNsQ0YsZ0JBQWdCQyxPQUFPLEdBQUdBO1lBQzFCRCxnQkFBZ0JFLE1BQU0sR0FBR0E7UUFDN0I7UUFDQSxJQUFJLENBQUNILGFBQWEsQ0FBQ00sSUFBSSxDQUFDTDtRQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDTSx1QkFBdUIsRUFBRTtZQUMvQixzREFBc0Q7WUFDdEQsSUFBSSxDQUFDQSx1QkFBdUIsR0FBR0MsV0FBVztnQkFDdEMsc0RBQXNEO2dCQUN0RCx5QkFBeUI7Z0JBQ3pCLE1BQU1DLFFBQVEsSUFBSSxDQUFDVCxhQUFhO2dCQUNoQyxJQUFJLENBQUNBLGFBQWEsR0FBRztnQkFDckIsSUFBSSxDQUFDTyx1QkFBdUIsR0FBRztnQkFDL0IsMENBQTBDO2dCQUMxQyxNQUFNWCxVQUFVYSxNQUFNQyxHQUFHLENBQUMsQ0FBQ0MsV0FBYUEsU0FBU2YsT0FBTztnQkFDeEQsSUFBSSxDQUFDZ0IsSUFBSSxDQUFDLFNBQVM7b0JBQ2ZDLFFBQVE7b0JBQ1JqQixTQUFTUCxtRUFBUUEsQ0FBQ087b0JBQ2xCa0IsVUFBVSxJQUFJO2dCQUNsQjtnQkFDQSxPQUFPeEIsNkRBQVNBLENBQUMsSUFBSSxDQUFDeUIsVUFBVSxFQUFFQyxLQUFLQyxTQUFTLENBQUNyQixVQUFVc0IsSUFBSSxDQUFDLENBQUNDO29CQUM3RCxJQUFJLENBQUNQLElBQUksQ0FBQyxTQUFTO3dCQUNmQyxRQUFRO3dCQUNSakIsU0FBU0E7d0JBQ1R3QixVQUFVRDt3QkFDVkwsVUFBVSxJQUFJO29CQUNsQjtvQkFDQSw2REFBNkQ7b0JBQzdELHVDQUF1QztvQkFDdkNMLE1BQU1ZLE9BQU8sQ0FBQyxDQUFDcEIsaUJBQWlCcUI7d0JBQzVCLE1BQU1DLFVBQVVKLE1BQU0sQ0FBQ0csTUFBTTt3QkFDN0IsSUFBSUMsUUFBUUMsS0FBSyxFQUFFOzRCQUNmLE1BQU1BLFFBQVEsSUFBSUMsTUFBTUYsUUFBUUMsS0FBSyxDQUFDRSxPQUFPOzRCQUM3Q0YsTUFBTUcsSUFBSSxHQUFHSixRQUFRQyxLQUFLLENBQUNHLElBQUk7NEJBQy9CSCxNQUFNSSxJQUFJLEdBQUdMLFFBQVFDLEtBQUssQ0FBQ0ksSUFBSTs0QkFDL0IzQixnQkFBZ0JFLE1BQU0sQ0FBQ3FCO3dCQUMzQixPQUNLOzRCQUNEdkIsZ0JBQWdCQyxPQUFPLENBQUNxQixRQUFRSixNQUFNO3dCQUMxQztvQkFDSjtnQkFDSixHQUFHLENBQUNLO29CQUNBLElBQUksQ0FBQ1osSUFBSSxDQUFDLFNBQVM7d0JBQ2ZDLFFBQVE7d0JBQ1JXLE9BQU9BO3dCQUNQNUIsU0FBU0E7d0JBQ1RrQixVQUFVLElBQUk7b0JBQ2xCO29CQUNBTCxNQUFNWSxPQUFPLENBQUMsQ0FBQ3BCO3dCQUNYQSxnQkFBZ0JFLE1BQU0sQ0FBQ3FCO29CQUMzQjtnQkFDSjtZQUNKLEdBQUc7UUFDUDtRQUNBLE9BQU9wQjtJQUNYO0FBQ0osRUFDQSxtREFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vanNvbi1ycGMtYmF0Y2gtcHJvdmlkZXIuanM/YzU4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWVwQ29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBmZXRjaEpzb24gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd2ViXCI7XG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9qc29uLXJwYy1wcm92aWRlclwiO1xuLy8gRXhwZXJpbWVudGFsXG5leHBvcnQgY2xhc3MgSnNvblJwY0JhdGNoUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXIge1xuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdCYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQmF0Y2ggPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmZsaWdodFJlcXVlc3QgPSB7IHJlcXVlc3QsIHJlc29sdmU6IG51bGwsIHJlamVjdDogbnVsbCB9O1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdCYXRjaC5wdXNoKGluZmxpZ2h0UmVxdWVzdCk7XG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvcikge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYmF0Y2ggZm9yIG5leHQgZXZlbnQgbG9vcCArIHNob3J0IGR1cmF0aW9uXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQmF0Y2hBZ2dyZWdhdG9yID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRlaCBjdXJyZW50IGJhdGNoIGFuZCBjbGVhciBpdCwgc28gbmV3IHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgLy8gZ28gaW50byB0aGUgbmV4dCBiYXRjaFxuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5fcGVuZGluZ0JhdGNoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdCYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZXF1ZXN0IGFzIGFuIGFycmF5IG9mIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGJhdGNoLm1hcCgoaW5mbGlnaHQpID0+IGluZmxpZ2h0LnJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RCYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBkZWVwQ29weShyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hKc29uKHRoaXMuY29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIHJlc3VsdCwgZmVlZCBpdCB0byB0aGUgY29ycmVjdCBQcm9taXNlLCBkZXBlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gd2hldGhlciBpdCB3YXMgYSBzdWNjZXNzIG9yIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goKGluZmxpZ2h0UmVxdWVzdCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSByZXN1bHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBwYXlsb2FkLmVycm9yLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZXNvbHZlKHBheWxvYWQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBiYXRjaC5mb3JFYWNoKChpbmZsaWdodFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLXJwYy1iYXRjaC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiZGVlcENvcHkiLCJmZXRjaEpzb24iLCJKc29uUnBjUHJvdmlkZXIiLCJKc29uUnBjQmF0Y2hQcm92aWRlciIsInNlbmQiLCJtZXRob2QiLCJwYXJhbXMiLCJyZXF1ZXN0IiwiaWQiLCJfbmV4dElkIiwianNvbnJwYyIsIl9wZW5kaW5nQmF0Y2giLCJpbmZsaWdodFJlcXVlc3QiLCJyZXNvbHZlIiwicmVqZWN0IiwicHJvbWlzZSIsIlByb21pc2UiLCJwdXNoIiwiX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3IiLCJzZXRUaW1lb3V0IiwiYmF0Y2giLCJtYXAiLCJpbmZsaWdodCIsImVtaXQiLCJhY3Rpb24iLCJwcm92aWRlciIsImNvbm5lY3Rpb24iLCJKU09OIiwic3RyaW5naWZ5IiwidGhlbiIsInJlc3VsdCIsInJlc3BvbnNlIiwiZm9yRWFjaCIsImluZGV4IiwicGF5bG9hZCIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiY29kZSIsImRhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js":
/*!***************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcProvider: () => (/* binding */ JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* binding */ JsonRpcSigner)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+abstract-signer@5.7.0/node_modules/@ethersproject/abstract-signer/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/hash */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+hash@5.7.0/node_modules/@ethersproject/hash/lib.esm/typed-data.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/properties */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/strings */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+strings@5.7.0/node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/transactions */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/web */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+web@5.7.0/node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./base-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst errorGas = [\n    \"call\",\n    \"estimateGas\"\n];\nfunction spelunk(value, requireData) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\" && value.message.match(\"reverted\")) {\n        const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(value.data) ? value.data : null;\n        if (!requireData || data) {\n            return {\n                message: value.message,\n                data\n            };\n        }\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            const result = spelunk(value[key], requireData);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        } catch (error) {}\n    }\n    return null;\n}\nfunction checkError(method, error, params) {\n    const transaction = params.transaction || params.signedTransaction;\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) {\n            return result.data;\n        }\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\",\n            transaction,\n            error\n        });\n    }\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) {\n            result = spelunk(error, false);\n        }\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message,\n                method,\n                transaction,\n                error\n            });\n        }\n    }\n    // @TODO: Should we spelunk for message too?\n    let message = error.message;\n    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === \"string\") {\n        message = error.error.message;\n    } else if (typeof error.body === \"string\") {\n        message = error.body;\n    } else if (typeof error.responseText === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            error,\n            method,\n            transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error,\n            method,\n            transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nclass JsonRpcSigner extends _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__.Signer {\n    constructor(constructorGuard, provider, addressOrIndex){\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof addressOrIndex === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_index\", null);\n        } else if (typeof addressOrIndex === \"number\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_index\", addressOrIndex);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_address\", null);\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts)=>{\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);\n        const fromAddress = this.getAddress().then((address)=>{\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to)=>__awaiter(this, void 0, void 0, function*() {\n                    if (to == null) {\n                        return null;\n                    }\n                    const address = yield this.provider.resolveName(to);\n                    if (address == null) {\n                        logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                    }\n                    return address;\n                }));\n        }\n        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)({\n            tx: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender })=>{\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, {\n                from: true\n            });\n            return this.provider.send(\"eth_sendTransaction\", [\n                hexTx\n            ]).then((hash)=>{\n                return hash;\n            }, (error)=>{\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                        const tx = yield this.provider.getTransaction(hash);\n                        if (tx === null) {\n                            return undefined;\n                        }\n                        return this.provider._wrapTransaction(tx, hash, blockNumber);\n                    }), {\n                    oncePoll: this.provider\n                });\n            } catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const data = typeof message === \"string\" ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message;\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"personal_sign\", [\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data),\n                    address.toLowerCase()\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"signMessage\",\n                        from: address,\n                        message: data\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const data = typeof message === \"string\" ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message;\n            const address = yield this.getAddress();\n            try {\n                // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n                return yield this.provider.send(\"eth_sign\", [\n                    address.toLowerCase(),\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data)\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"_legacySignMessage\",\n                        from: address,\n                        message: data\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Populate any ENS names (in-place)\n            const populated = yield _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.resolveNames(domain, types, value, (name)=>{\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"eth_signTypedData_v4\", [\n                    address.toLowerCase(),\n                    JSON.stringify(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"_signTypedData\",\n                        from: address,\n                        message: {\n                            domain: populated.domain,\n                            types,\n                            value: populated.value\n                        }\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [\n                address.toLowerCase(),\n                password,\n                null\n            ]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash)=>{\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations)=>{\n                    return this.provider.waitForTransaction(hash, confirmations);\n                }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true,\n    data: true,\n    gasLimit: true,\n    gasPrice: true,\n    nonce: true,\n    to: true,\n    value: true,\n    type: true,\n    accessList: true,\n    maxFeePerGas: true,\n    maxPriorityFeePerGas: true\n};\nclass JsonRpcProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_8__.BaseProvider {\n    constructor(url, network){\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject)=>{\n                setTimeout(()=>{\n                    this.detectNetwork().then((network)=>{\n                        resolve(network);\n                    }, (error)=>{\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof url === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        } else {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"connection\", Object.freeze((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http://localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(()=>{\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            } catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                } catch (error) {}\n            }\n            if (chainId != null) {\n                const getNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(chainId).toNumber());\n                } catch (error) {\n                    return logger.throwError(\"could not detect network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts)=>{\n            return accounts.map((a)=>this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: this._nextId++,\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.deepCopy)(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = [\n            \"eth_chainId\",\n            \"eth_blockNumber\"\n        ].indexOf(method) >= 0;\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.fetchJson)(this.connection, JSON.stringify(request), getResult).then((result)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(()=>{\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch(method){\n            case \"getBlockNumber\":\n                return [\n                    \"eth_blockNumber\",\n                    []\n                ];\n            case \"getGasPrice\":\n                return [\n                    \"eth_gasPrice\",\n                    []\n                ];\n            case \"getBalance\":\n                return [\n                    \"eth_getBalance\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getTransactionCount\":\n                return [\n                    \"eth_getTransactionCount\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getCode\":\n                return [\n                    \"eth_getCode\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getStorageAt\":\n                return [\n                    \"eth_getStorageAt\",\n                    [\n                        getLowerCase(params.address),\n                        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexZeroPad)(params.position, 32),\n                        params.blockTag\n                    ]\n                ];\n            case \"sendTransaction\":\n                return [\n                    \"eth_sendRawTransaction\",\n                    [\n                        params.signedTransaction\n                    ]\n                ];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\n                        \"eth_getBlockByNumber\",\n                        [\n                            params.blockTag,\n                            !!params.includeTransactions\n                        ]\n                    ];\n                } else if (params.blockHash) {\n                    return [\n                        \"eth_getBlockByHash\",\n                        [\n                            params.blockHash,\n                            !!params.includeTransactions\n                        ]\n                    ];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\n                    \"eth_getTransactionByHash\",\n                    [\n                        params.transactionHash\n                    ]\n                ];\n            case \"getTransactionReceipt\":\n                return [\n                    \"eth_getTransactionReceipt\",\n                    [\n                        params.transactionHash\n                    ]\n                ];\n            case \"call\":\n                {\n                    const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"hexlifyTransaction\");\n                    return [\n                        \"eth_call\",\n                        [\n                            hexlifyTransaction(params.transaction, {\n                                from: true\n                            }),\n                            params.blockTag\n                        ]\n                    ];\n                }\n            case \"estimateGas\":\n                {\n                    const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"hexlifyTransaction\");\n                    return [\n                        \"eth_estimateGas\",\n                        [\n                            hexlifyTransaction(params.transaction, {\n                                from: true\n                            })\n                        ]\n                    ];\n                }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\n                    \"eth_getLogs\",\n                    [\n                        params.filter\n                    ]\n                ];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-1559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(params);\n                            params.transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NOT_IMPLEMENTED, {\n                    operation: method\n                });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            } catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [\n                    filterId\n                ]).then(function(hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [\n                            filterId\n                        ]);\n                        return;\n                    }\n                    setTimeout(function() {\n                        poll();\n                    }, 0);\n                    return null;\n                }).catch((error)=>{});\n            }\n            poll();\n            return filterId;\n        }).catch((error)=>{});\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(allowedTransactionKeys);\n        if (allowExtra) {\n            for(const key in allowExtra){\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.checkProperties)(transaction, allowed);\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\n            \"chainId\",\n            \"gasLimit\",\n            \"gasPrice\",\n            \"type\",\n            \"maxFeePerGas\",\n            \"maxPriorityFeePerGas\",\n            \"nonce\",\n            \"value\"\n        ].forEach(function(key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexValue)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(transaction[key]));\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\n            \"from\",\n            \"to\",\n            \"data\"\n        ].forEach(function(key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__.accessListify)(transaction.accessList);\n        }\n        return result;\n    }\n} //# sourceMappingURL=json-rpc-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9qc29uLXJwYy1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDd0Q7QUFDSDtBQUM2QjtBQUMx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RixJQUFJLENBQUMvQyxXQUFXLENBQUNQLElBQUk7WUFDdEQsSUFBSUEsUUFBUSxZQUFZO2dCQUNwQkEsTUFBTTtZQUNWO1lBQ0EvQixNQUFNLENBQUMrQixJQUFJLEdBQUd4QztRQUNsQjtRQUNBO1lBQUM7WUFBUTtZQUFNO1NBQU8sQ0FBQzRMLE9BQU8sQ0FBQyxTQUFVcEosR0FBRztZQUN4QyxJQUFJTyxXQUFXLENBQUNQLElBQUksSUFBSSxNQUFNO2dCQUMxQjtZQUNKO1lBQ0EvQixNQUFNLENBQUMrQixJQUFJLEdBQUd6Qiw2REFBT0EsQ0FBQ2dDLFdBQVcsQ0FBQ1AsSUFBSTtRQUMxQztRQUNBLElBQUlPLFlBQVl3RixVQUFVLEVBQUU7WUFDeEI5SCxNQUFNLENBQUMsYUFBYSxHQUFHa0IsMkVBQWFBLENBQUNvQixZQUFZd0YsVUFBVTtRQUMvRDtRQUNBLE9BQU85SDtJQUNYO0FBQ0osRUFDQSw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vanNvbi1ycGMtcHJvdmlkZXIuanM/MTU0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgU2lnbmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgaGV4bGlmeSwgaGV4VmFsdWUsIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBfVHlwZWREYXRhRW5jb2RlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oYXNoXCI7XG5pbXBvcnQgeyBjaGVja1Byb3BlcnRpZXMsIGRlZXBDb3B5LCBkZWZpbmVSZWFkT25seSwgZ2V0U3RhdGljLCByZXNvbHZlUHJvcGVydGllcywgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IGZldGNoSnNvbiwgcG9sbCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC93ZWJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEJhc2VQcm92aWRlciB9IGZyb20gXCIuL2Jhc2UtcHJvdmlkZXJcIjtcbmNvbnN0IGVycm9yR2FzID0gW1wiY2FsbFwiLCBcImVzdGltYXRlR2FzXCJdO1xuZnVuY3Rpb24gc3BlbHVuayh2YWx1ZSwgcmVxdWlyZURhdGEpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tZXNzYWdlLm1hdGNoKFwicmV2ZXJ0ZWRcIikpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGlzSGV4U3RyaW5nKHZhbHVlLmRhdGEpID8gdmFsdWUuZGF0YSA6IG51bGw7XG4gICAgICAgIGlmICghcmVxdWlyZURhdGEgfHwgZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogdmFsdWUubWVzc2FnZSwgZGF0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVuayh2YWx1ZVtrZXldLCByZXF1aXJlRGF0YSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlbHVuayhKU09OLnBhcnNlKHZhbHVlKSwgcmVxdWlyZURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2hlY2tFcnJvcihtZXRob2QsIGVycm9yLCBwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHBhcmFtcy50cmFuc2FjdGlvbiB8fCBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgLy8gVW5kbyB0aGUgXCJjb252ZW5pZW5jZVwiIHNvbWUgbm9kZXMgYXJlIGF0dGVtcHRpbmcgdG8gcHJldmVudCBiYWNrd2FyZHNcbiAgICAvLyBpbmNvbXBhdGliaWxpdHk7IG1heWJlIGZvciB2NiBjb25zaWRlciBmb3J3YXJkaW5nIHJldmVydHMgYXMgZXJyb3JzXG4gICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVuayhlcnJvciwgdHJ1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RoaW5nIGRlc2NyaXB0aXZlLi5cbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJldmVydCBkYXRhIGluIGNhbGwgZXhjZXB0aW9uOyBUcmFuc2FjdGlvbiByZXZlcnRlZCB3aXRob3V0IGEgcmVhc29uIHN0cmluZ1wiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICBkYXRhOiBcIjB4XCIsIHRyYW5zYWN0aW9uLCBlcnJvclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgIC8vIFRyeSB0byBmaW5kIHNvbWV0aGluZywgd2l0aCBhIHByZWZlcmVuY2Ugb24gU0VSVkVSX0VSUk9SIGJvZHlcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNwZWx1bmsoZXJyb3IuYm9keSwgZmFsc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNwZWx1bmsoZXJyb3IsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3VuZCBcInJldmVydGVkXCIsIHRoaXMgaXMgYSBDQUxMX0VYQ0VQVElPTlxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIiwgTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0Lm1lc3NhZ2UsIG1ldGhvZCwgdHJhbnNhY3Rpb24sIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAVE9ETzogU2hvdWxkIHdlIHNwZWx1bmsgZm9yIG1lc3NhZ2UgdG9vP1xuICAgIGxldCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IgJiYgZXJyb3IuZXJyb3IgJiYgdHlwZW9mIChlcnJvci5lcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IuZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChlcnJvci5ib2R5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IuYm9keTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChlcnJvci5yZXNwb25zZVRleHQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZVRleHQ7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSAobWVzc2FnZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBnYXMgKiBwcmljZSArIHZhbHVlICsgY29zdChkYXRhKVwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kc3xiYXNlIGZlZSBleGNlZWRzIGdhcyBsaW1pdC9pKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcIm5vbmNlIHRvbyBsb3dcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9ub25jZSAoaXMgKT90b28gbG93L2kpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIExvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCwge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9yZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZHx0cmFuc2FjdGlvbiBnYXMgcHJpY2UuKnRvbyBsb3cvaSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBMb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL29ubHkgcmVwbGF5LXByb3RlY3RlZC9pKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImxlZ2FjeSBwcmUtZWlwLTE1NSB0cmFuc2FjdGlvbnMgbm90IHN1cHBvcnRlZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnJvckdhcy5pbmRleE9mKG1ldGhvZCkgPj0gMCAmJiBtZXNzYWdlLm1hdGNoKC9nYXMgcmVxdWlyZWQgZXhjZWVkcyBhbGxvd2FuY2V8YWx3YXlzIGZhaWxpbmcgdHJhbnNhY3Rpb258ZXhlY3V0aW9uIHJldmVydGVkLykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZXN0aW1hdGUgZ2FzOyB0cmFuc2FjdGlvbiBtYXkgZmFpbCBvciBtYXkgcmVxdWlyZSBtYW51YWwgZ2FzIGxpbWl0XCIsIExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbn1cbmZ1bmN0aW9uIHRpbWVyKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlc3VsdChwYXlsb2FkKSB7XG4gICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcbiAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcbiAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkLnJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldExvd2VyQ2FzZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbmV4cG9ydCBjbGFzcyBKc29uUnBjU2lnbmVyIGV4dGVuZHMgU2lnbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBwcm92aWRlciwgYWRkcmVzc09ySW5kZXgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkbyBub3QgY2FsbCB0aGUgSnNvblJwY1NpZ25lciBjb25zdHJ1Y3RvciBkaXJlY3RseTsgdXNlIHByb3ZpZGVyLmdldFNpZ25lclwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgaWYgKGFkZHJlc3NPckluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3NPckluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FkZHJlc3NcIiwgdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzT3JJbmRleCkpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaW5kZXhcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2luZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FkZHJlc3NcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIGluZGV4XCIsIFwiYWRkcmVzc09ySW5kZXhcIiwgYWRkcmVzc09ySW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGFsdGVyIEpTT04tUlBDIFNpZ25lciBjb25uZWN0aW9uXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0VW5jaGVja2VkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVuY2hlY2tlZEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMucHJvdmlkZXIsIHRoaXMuX2FkZHJlc3MgfHwgdGhpcy5faW5kZXgpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICBpZiAodGhpcy5fYWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA8PSB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBhY2NvdW50ICNcIiArIHRoaXMuX2luZGV4LCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhY2NvdW50c1t0aGlzLl9pbmRleF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBmcm9tQWRkcmVzcyA9IHRoaXMuZ2V0QWRkcmVzcygpLnRoZW4oKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgZXN0aW1hdGUuZnJvbSA9IGZyb21BZGRyZXNzO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKGVzdGltYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24udG8pLnRoZW4oKHRvKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKHRvKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlZCBFTlMgbmFtZSByZXNvbHZlcyB0byBudWxsXCIsIFwidHgudG9cIiwgdG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdHg6IHJlc29sdmVQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgIHNlbmRlcjogZnJvbUFkZHJlc3NcbiAgICAgICAgfSkudGhlbigoeyB0eCwgc2VuZGVyIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHguZnJvbS50b0xvd2VyQ2FzZSgpICE9PSBzZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eC5mcm9tID0gc2VuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmNvbnN0cnVjdG9yLmhleGxpZnlUcmFuc2FjdGlvbih0eCwgeyBmcm9tOiB0cnVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgW2hleFR4XSkudGhlbigoaGFzaCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2VyIHJlamVjdGVkIHRyYW5zYWN0aW9uXCIsIExvZ2dlci5lcnJvcnMuQUNUSU9OX1JFSkVDVEVELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwic2VuZFRyYW5zYWN0aW9uXCIsIGVycm9yLCBoZXhUeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJzaWduaW5nIHRyYW5zYWN0aW9ucyBpcyB1bnN1cHBvcnRlZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnByb3ZpZGVyLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAvLyBTZW5kIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgICAgICAgICAvLyBmb3IgYSByZXNwb25zZSwgYW5kIHdlIG5lZWQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiwgc28gd2UgcG9sbFxuICAgICAgICAgICAgICAgIC8vIGZvciBpdDsgaXQgc2hvdWxkIHNob3cgdXAgdmVyeSBxdWlja2x5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMucHJvdmlkZXIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhtZXNzYWdlKSA6IG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbaGV4bGlmeShkYXRhKSwgYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgc2lnbmluZ1wiLCBMb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGF0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbGVnYWN5U2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhtZXNzYWdlKSA6IG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0pTT04tUlBDI2V0aF9zaWduXG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIGhleGxpZnkoZGF0YSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlciByZWplY3RlZCBzaWduaW5nXCIsIExvZ2dlci5lcnJvcnMuQUNUSU9OX1JFSkVDVEVELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiX2xlZ2FjeVNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGF0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgYW55IEVOUyBuYW1lcyAoaW4tcGxhY2UpXG4gICAgICAgICAgICBjb25zdCBwb3B1bGF0ZWQgPSB5aWVsZCBfVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHlwZWREYXRhX3Y0XCIsIFtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShfVHlwZWREYXRhRW5jb2Rlci5nZXRQYXlsb2FkKHBvcHVsYXRlZC5kb21haW4sIHR5cGVzLCBwb3B1bGF0ZWQudmFsdWUpKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2VyIHJlamVjdGVkIHNpZ25pbmdcIiwgTG9nZ2VyLmVycm9ycy5BQ1RJT05fUkVKRUNURUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJfc2lnblR5cGVkRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHsgZG9tYWluOiBwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgdmFsdWU6IHBvcHVsYXRlZC52YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVuY2hlY2tlZEpzb25ScGNTaWduZXIgZXh0ZW5kcyBKc29uUnBjU2lnbmVyIHtcbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKS50aGVuKChoYXNoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgbm9uY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZ2FzTGltaXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IDAsXG4gICAgICAgICAgICAgICAgZnJvbTogbnVsbCxcbiAgICAgICAgICAgICAgICB3YWl0OiAoY29uZmlybWF0aW9ucykgPT4geyByZXR1cm4gdGhpcy5wcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgY29uZmlybWF0aW9ucyk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG4gICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsIGFjY2Vzc0xpc3Q6IHRydWUsXG4gICAgbWF4RmVlUGVyR2FzOiB0cnVlLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJ1ZVxufTtcbmV4cG9ydCBjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaykge1xuICAgICAgICBsZXQgbmV0d29ya09yUmVhZHkgPSBuZXR3b3JrO1xuICAgICAgICAvLyBUaGUgbmV0d29yayBpcyB1bmtub3duLCBxdWVyeSB0aGUgSlNPTi1SUEMgZm9yIGl0XG4gICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXR3b3JrT3JSZWFkeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbigobmV0d29yaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG5ldHdvcmtPclJlYWR5KTtcbiAgICAgICAgLy8gRGVmYXVsdCBVUkxcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHVybCA9IGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImRlZmF1bHRVcmxcIikoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29ubmVjdGlvblwiLCBPYmplY3QuZnJlZXplKHNoYWxsb3dDb3B5KHVybCkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZXh0SWQgPSA0MjtcbiAgICB9XG4gICAgZ2V0IF9jYWNoZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TG9vcENhY2hlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TG9vcENhY2hlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TG9vcENhY2hlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcbiAgICB9XG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0pIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IHRoaXMuX3VuY2FjaGVkRGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhpcyBjYWNoZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdO1xuICAgIH1cbiAgICBfdW5jYWNoZWREZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGltZXIoMCk7XG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSB5aWVsZCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0geWllbGQgdGhpcy5zZW5kKFwibmV0X3ZlcnNpb25cIiwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldE5ldHdvcmsgPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXROZXR3b3JrXCIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXROZXR3b3JrKEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImludmFsaWROZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBcIm5vTmV0d29ya1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFNpZ25lcihhZGRyZXNzT3JJbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMsIGFkZHJlc3NPckluZGV4KTtcbiAgICB9XG4gICAgZ2V0VW5jaGVja2VkU2lnbmVyKGFkZHJlc3NPckluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNpZ25lcihhZGRyZXNzT3JJbmRleCkuY29ubmVjdFVuY2hlY2tlZCgpO1xuICAgIH1cbiAgICBsaXN0QWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pLnRoZW4oKGFjY291bnRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKGEpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgIHJlcXVlc3Q6IGRlZXBDb3B5KHJlcXVlc3QpLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIGNhbiBleHBhbmQgdGhpcyBpbiB0aGUgZnV0dXJlIHRvIGFueSBjYWxsLCBidXQgZm9yIG5vdyB0aGVzZVxuICAgICAgICAvLyBhcmUgdGhlIGJpZ2dlc3Qgd2lucyBhbmQgZG8gbm90IHJlcXVpcmUgYW55IHNlcmlhbGl6aW5nIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGNhY2hlID0gKFtcImV0aF9jaGFpbklkXCIsIFwiZXRoX2Jsb2NrTnVtYmVyXCJdLmluZGV4T2YobWV0aG9kKSA+PSAwKTtcbiAgICAgICAgaWYgKGNhY2hlICYmIHRoaXMuX2NhY2hlW21ldGhvZF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVttZXRob2RdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLCBnZXRSZXN1bHQpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENhY2hlIHRoZSBmZXRjaCwgYnV0IGNsZWFyIGl0IG9uIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gcmVzdWx0O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9ibG9ja051bWJlclwiLCBbXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dhc1ByaWNlXCIsIFtdXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCYWxhbmNlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRDb2RlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFN0b3JhZ2VBdFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgaGV4WmVyb1BhZChwYXJhbXMucG9zaXRpb24sIDMyKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwic2VuZFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiwgW3BhcmFtcy5zaWduZWRUcmFuc2FjdGlvbl1dO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldEJsb2NrQnlOdW1iZXJcIiwgW3BhcmFtcy5ibG9ja1RhZywgISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbXMuYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmxvY2tCeUhhc2hcIiwgW3BhcmFtcy5ibG9ja0hhc2gsICEhcGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnNdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsIFtwYXJhbXMudHJhbnNhY3Rpb25IYXNoXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9jYWxsXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSksIHBhcmFtcy5ibG9ja1RhZ11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9lc3RpbWF0ZUdhc1wiLCBbaGV4bGlmeVRyYW5zYWN0aW9uKHBhcmFtcy50cmFuc2FjdGlvbiwgeyBmcm9tOiB0cnVlIH0pXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyICYmIHBhcmFtcy5maWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShwYXJhbXMuZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldExvZ3NcIiwgW3BhcmFtcy5maWx0ZXJdXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlcmZvcm0obWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIExlZ2FjeSBuZXR3b3JrcyBkbyBub3QgbGlrZSB0aGUgdHlwZSBmaWVsZCBiZWluZyBwYXNzZWQgYWxvbmcgKHdoaWNoXG4gICAgICAgICAgICAvLyBpcyBmYWlyKSwgc28gd2UgZGVsZXRlIHR5cGUgaWYgaXQgaXMgMCBhbmQgYSBub24tRUlQLTE1NTkgbmV0d29ya1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIgfHwgbWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHBhcmFtcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAodHggJiYgdHgudHlwZSAhPSBudWxsICYmIEJpZ051bWJlci5mcm9tKHR4LnR5cGUpLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBFSVAtMTU1OSBwcm9wZXJ0aWVzLCBpdCBtaWdodCBiZSBub24tRUlQLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSB5aWVsZCB0aGlzLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyA9PSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBzaGFsbG93Q29weShwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50cmFuc2FjdGlvbiA9IHNoYWxsb3dDb3B5KHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLnRyYW5zYWN0aW9uLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5wcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIExvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5zZW5kKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrRXJyb3IobWV0aG9kLCBlcnJvciwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YWcgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFBlbmRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5fc3RhcnRFdmVudChldmVudCk7XG4gICAgfVxuICAgIF9zdGFydFBlbmRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgcGVuZGluZ0ZpbHRlciA9IHRoaXMuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIiwgW10pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gcGVuZGluZ0ZpbHRlcjtcbiAgICAgICAgcGVuZGluZ0ZpbHRlci50aGVuKGZ1bmN0aW9uIChmaWx0ZXJJZCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKS50aGVuKGZ1bmN0aW9uIChoYXNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBoYXNoZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGF0IHNvbWUgcG9pbnQuLi4gSG93PyBXaGVuP1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoLnRvTG93ZXJDYXNlKCldID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEgPSBzZXEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0VHJhbnNhY3Rpb24oaGFzaCkudGhlbihmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwicGVuZGluZ1wiLCB0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyKDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcG9sbCgpOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9sbCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgfVxuICAgIF9zdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIgJiYgdGhpcy5saXN0ZW5lckNvdW50KFwicGVuZGluZ1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0ZpbHRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX3N0b3BFdmVudChldmVudCk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgYW4gZXRoZXJzLmpzIHRyYW5zYWN0aW9uIGludG8gYSBKU09OLVJQQyB0cmFuc2FjdGlvblxuICAgIC8vICAtIGdhc0xpbWl0ID0+IGdhc1xuICAgIC8vICAtIEFsbCB2YWx1ZXMgaGV4bGlmaWVkXG4gICAgLy8gIC0gQWxsIG51bWVyaWMgdmFsdWVzIHplcm8tc3RyaXBlZFxuICAgIC8vICAtIEFsbCBhZGRyZXNzZXMgYXJlIGxvd2VyY2FzZWRcbiAgICAvLyBOT1RFOiBUaGlzIGFsbG93cyBhIFRyYW5zYWN0aW9uUmVxdWVzdCwgYnV0IGFsbCB2YWx1ZXMgc2hvdWxkIGJlIHJlc29sdmVkXG4gICAgLy8gICAgICAgYmVmb3JlIHRoaXMgaXMgY2FsbGVkXG4gICAgLy8gQFRPRE86IFRoaXMgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgYW5kIHByZXBhcmVSZXF1ZXN0XG4gICAgLy8gICAgICAgIHdpbGwgYmUgdGhlIHByZWZlcnJlZCBtZXRob2QgZm9yIHRoaXMuXG4gICAgc3RhdGljIGhleGxpZnlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgYWxsb3dFeHRyYSkge1xuICAgICAgICAvLyBDaGVjayBvbmx5IGFsbG93ZWQgcHJvcGVydGllcyBhcmUgZ2l2ZW5cbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNoYWxsb3dDb3B5KGFsbG93ZWRUcmFuc2FjdGlvbktleXMpO1xuICAgICAgICBpZiAoYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0V4dHJhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uLCBhbGxvd2VkKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIEpTT04tUlBDIG5vdyByZXF1aXJlcyBudW1lcmljIHZhbHVlcyB0byBiZSBcInF1YW50aXR5XCIgdmFsdWVzXG4gICAgICAgIFtcImNoYWluSWRcIiwgXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwidHlwZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhleFZhbHVlKEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uW2tleV0pKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZ2FzTGltaXRcIikge1xuICAgICAgICAgICAgICAgIGtleSA9IFwiZ2FzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgW1wiZnJvbVwiLCBcInRvXCIsIFwiZGF0YVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGhleGxpZnkodHJhbnNhY3Rpb25ba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9IGFjY2Vzc0xpc3RpZnkodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLXJwYy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiU2lnbmVyIiwiQmlnTnVtYmVyIiwiaGV4bGlmeSIsImhleFZhbHVlIiwiaGV4WmVyb1BhZCIsImlzSGV4U3RyaW5nIiwiX1R5cGVkRGF0YUVuY29kZXIiLCJjaGVja1Byb3BlcnRpZXMiLCJkZWVwQ29weSIsImRlZmluZVJlYWRPbmx5IiwiZ2V0U3RhdGljIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJzaGFsbG93Q29weSIsInRvVXRmOEJ5dGVzIiwiYWNjZXNzTGlzdGlmeSIsImZldGNoSnNvbiIsInBvbGwiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiQmFzZVByb3ZpZGVyIiwiZXJyb3JHYXMiLCJzcGVsdW5rIiwicmVxdWlyZURhdGEiLCJtZXNzYWdlIiwibWF0Y2giLCJkYXRhIiwia2V5IiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjaGVja0Vycm9yIiwibWV0aG9kIiwicGFyYW1zIiwidHJhbnNhY3Rpb24iLCJzaWduZWRUcmFuc2FjdGlvbiIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJDQUxMX0VYQ0VQVElPTiIsImJvZHkiLCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVCIsInJlYXNvbiIsImNvZGUiLCJTRVJWRVJfRVJST1IiLCJyZXNwb25zZVRleHQiLCJ0b0xvd2VyQ2FzZSIsIklOU1VGRklDSUVOVF9GVU5EUyIsIk5PTkNFX0VYUElSRUQiLCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsImluZGV4T2YiLCJ0aW1lciIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZ2V0UmVzdWx0IiwicGF5bG9hZCIsIkVycm9yIiwiZ2V0TG93ZXJDYXNlIiwiX2NvbnN0cnVjdG9yR3VhcmQiLCJKc29uUnBjU2lnbmVyIiwiY29uc3RydWN0b3IiLCJjb25zdHJ1Y3Rvckd1YXJkIiwicHJvdmlkZXIiLCJhZGRyZXNzT3JJbmRleCIsImZvcm1hdHRlciIsImFkZHJlc3MiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJjb25uZWN0Iiwib3BlcmF0aW9uIiwiY29ubmVjdFVuY2hlY2tlZCIsIlVuY2hlY2tlZEpzb25ScGNTaWduZXIiLCJfYWRkcmVzcyIsIl9pbmRleCIsImdldEFkZHJlc3MiLCJzZW5kIiwiYWNjb3VudHMiLCJsZW5ndGgiLCJzZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24iLCJmcm9tQWRkcmVzcyIsImdhc0xpbWl0IiwiZXN0aW1hdGUiLCJmcm9tIiwiZXN0aW1hdGVHYXMiLCJ0byIsInJlc29sdmVOYW1lIiwidHgiLCJzZW5kZXIiLCJoZXhUeCIsImhleGxpZnlUcmFuc2FjdGlvbiIsImhhc2giLCJBQ1RJT05fUkVKRUNURUQiLCJhY3Rpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJzZW5kVHJhbnNhY3Rpb24iLCJibG9ja051bWJlciIsIl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyIiwicG9sbGluZ0ludGVydmFsIiwiZ2V0VHJhbnNhY3Rpb24iLCJ1bmRlZmluZWQiLCJfd3JhcFRyYW5zYWN0aW9uIiwib25jZVBvbGwiLCJ0cmFuc2FjdGlvbkhhc2giLCJzaWduTWVzc2FnZSIsIl9sZWdhY3lTaWduTWVzc2FnZSIsIl9zaWduVHlwZWREYXRhIiwiZG9tYWluIiwidHlwZXMiLCJwb3B1bGF0ZWQiLCJyZXNvbHZlTmFtZXMiLCJuYW1lIiwic3RyaW5naWZ5IiwiZ2V0UGF5bG9hZCIsInVubG9jayIsInBhc3N3b3JkIiwibm9uY2UiLCJnYXNQcmljZSIsImNoYWluSWQiLCJjb25maXJtYXRpb25zIiwid2FpdCIsIndhaXRGb3JUcmFuc2FjdGlvbiIsImFsbG93ZWRUcmFuc2FjdGlvbktleXMiLCJ0eXBlIiwiYWNjZXNzTGlzdCIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiSnNvblJwY1Byb3ZpZGVyIiwidXJsIiwibmV0d29yayIsIm5ldHdvcmtPclJlYWR5IiwiZGV0ZWN0TmV0d29yayIsIk9iamVjdCIsImZyZWV6ZSIsIl9uZXh0SWQiLCJfY2FjaGUiLCJfZXZlbnRMb29wQ2FjaGUiLCJkZWZhdWx0VXJsIiwiX3VuY2FjaGVkRGV0ZWN0TmV0d29yayIsImdldE5ldHdvcmsiLCJ0b051bWJlciIsIk5FVFdPUktfRVJST1IiLCJldmVudCIsInNlcnZlckVycm9yIiwiZ2V0U2lnbmVyIiwiZ2V0VW5jaGVja2VkU2lnbmVyIiwibGlzdEFjY291bnRzIiwibWFwIiwiYSIsInJlcXVlc3QiLCJpZCIsImpzb25ycGMiLCJlbWl0IiwiY2FjaGUiLCJjb25uZWN0aW9uIiwicmVzcG9uc2UiLCJwcmVwYXJlUmVxdWVzdCIsImJsb2NrVGFnIiwicG9zaXRpb24iLCJpbmNsdWRlVHJhbnNhY3Rpb25zIiwiYmxvY2tIYXNoIiwiZmlsdGVyIiwicGVyZm9ybSIsImlzWmVybyIsImZlZURhdGEiLCJnZXRGZWVEYXRhIiwiYXJncyIsIk5PVF9JTVBMRU1FTlRFRCIsIl9zdGFydEV2ZW50IiwidGFnIiwiX3N0YXJ0UGVuZGluZyIsIl9wZW5kaW5nRmlsdGVyIiwic2VsZiIsInBlbmRpbmdGaWx0ZXIiLCJmaWx0ZXJJZCIsImhhc2hlcyIsInNlcSIsImZvckVhY2giLCJfZW1pdHRlZCIsImNhdGNoIiwiX3N0b3BFdmVudCIsImxpc3RlbmVyQ291bnQiLCJhbGxvd0V4dHJhIiwiYWxsb3dlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js":
/*!****************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NodesmithProvider: () => (/* binding */ NodesmithProvider)\n/* harmony export */ });\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* istanbul ignore file */ \n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\nclass NodesmithProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey && typeof apiKey !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n    static getUrl(network, apiKey) {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n        let host = null;\n        switch(network.name){\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return host + \"?apiKey=\" + apiKey;\n    }\n} //# sourceMappingURL=nodesmith-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9ub2Rlc21pdGgtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHdCQUF3QixHQUNYO0FBQ2dEO0FBQ2Q7QUFDVjtBQUNyQyxNQUFNRyxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDakMsc0RBQXNEO0FBQ3RELE1BQU1FLGdCQUFnQjtBQUNmLE1BQU1DLDBCQUEwQkwsc0VBQWtCQTtJQUNyRCxPQUFPTSxVQUFVQyxNQUFNLEVBQUU7UUFDckIsSUFBSUEsVUFBVSxPQUFRQSxXQUFZLFVBQVU7WUFDeENKLE9BQU9LLGtCQUFrQixDQUFDLGtCQUFrQixVQUFVRDtRQUMxRDtRQUNBLE9BQU9BLFVBQVVIO0lBQ3JCO0lBQ0EsT0FBT0ssT0FBT0MsT0FBTyxFQUFFSCxNQUFNLEVBQUU7UUFDM0JKLE9BQU9RLElBQUksQ0FBQztRQUNaLElBQUlDLE9BQU87UUFDWCxPQUFRRixRQUFRRyxJQUFJO1lBQ2hCLEtBQUs7Z0JBQ0RELE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0o7Z0JBQ0lULE9BQU9LLGtCQUFrQixDQUFDLHVCQUF1QixXQUFXTSxTQUFTLENBQUMsRUFBRTtRQUNoRjtRQUNBLE9BQVFGLE9BQU8sYUFBYUw7SUFDaEM7QUFDSixFQUNBLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9ub2Rlc21pdGgtcHJvdmlkZXIuanM/ODAwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBVcmxKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi91cmwtanNvbi1ycGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vIFNwZWNpYWwgQVBJIGtleSBwcm92aWRlZCBieSBOb2Rlc21pdGggZm9yIGV0aGVycy5qc1xuY29uc3QgZGVmYXVsdEFwaUtleSA9IFwiRVRIRVJTX0pTX1NIQVJFRFwiO1xuZXhwb3J0IGNsYXNzIE5vZGVzbWl0aFByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ICYmIHR5cGVvZiAoYXBpS2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXBpS2V5XCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwaUtleSB8fCBkZWZhdWx0QXBpS2V5O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VXJsKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBsb2dnZXIud2FybihcIk5vZGVTbWl0aCB3aWxsIGJlIGRpc2NvbnRpbnVlZCBvbiAyMDE5LTEyLTIwOyBwbGVhc2UgbWlncmF0ZSB0byBhbm90aGVyIHBsYXRmb3JtLlwiKTtcbiAgICAgICAgbGV0IGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9tYWlubmV0L2pzb25ycGNcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL3JvcHN0ZW4vanNvbnJwY1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpbmtlYnlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvcmlua2VieS9qc29ucnBjXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL2dvZXJsaS9qc29ucnBjXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEva292YW4vanNvbnJwY1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGhvc3QgKyBcIj9hcGlLZXk9XCIgKyBhcGlLZXkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vZGVzbWl0aC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiVXJsSnNvblJwY1Byb3ZpZGVyIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsImRlZmF1bHRBcGlLZXkiLCJOb2Rlc21pdGhQcm92aWRlciIsImdldEFwaUtleSIsImFwaUtleSIsInRocm93QXJndW1lbnRFcnJvciIsImdldFVybCIsIm5ldHdvcmsiLCJ3YXJuIiwiaG9zdCIsIm5hbWUiLCJhcmd1bWVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js":
/*!*************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PocketProvider: () => (/* binding */ PocketProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst defaultApplicationId = \"62e1ad51b37b8e00394bda3b\";\nclass PocketProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            applicationId: null,\n            loadBalancer: true,\n            applicationSecretKey: null\n        };\n        // Parse applicationId and applicationSecretKey\n        if (apiKey == null) {\n            apiKeyObj.applicationId = defaultApplicationId;\n        } else if (typeof apiKey === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n        } else if (apiKey.applicationSecretKey != null) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n        } else if (apiKey.applicationId) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n        } else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch(network ? network.name : \"unknown\"){\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"kovan\":\n                host = \"poa-kovan.gateway.pokt.network\";\n                break;\n            case \"matic\":\n                host = \"poly-mainnet.gateway.pokt.network\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai-rpc.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const url = `https:/\\/${host}/v1/lb/${apiKey.applicationId}`;\n        const connection = {\n            headers: {},\n            url\n        };\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return this.applicationId === defaultApplicationId;\n    }\n} //# sourceMappingURL=pocket-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9wb2NrZXQtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhO0FBQ2tDO0FBQ1Y7QUFDckMsTUFBTUUsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQzRCO0FBQzdELE1BQU1HLHVCQUF1QjtBQUN0QixNQUFNQyx1QkFBdUJGLHNFQUFrQkE7SUFDbEQsT0FBT0csVUFBVUMsTUFBTSxFQUFFO1FBQ3JCLE1BQU1DLFlBQVk7WUFDZEMsZUFBZTtZQUNmQyxjQUFjO1lBQ2RDLHNCQUFzQjtRQUMxQjtRQUNBLCtDQUErQztRQUMvQyxJQUFJSixVQUFVLE1BQU07WUFDaEJDLFVBQVVDLGFBQWEsR0FBR0w7UUFDOUIsT0FDSyxJQUFJLE9BQVFHLFdBQVksVUFBVTtZQUNuQ0MsVUFBVUMsYUFBYSxHQUFHRjtRQUM5QixPQUNLLElBQUlBLE9BQU9JLG9CQUFvQixJQUFJLE1BQU07WUFDMUNILFVBQVVDLGFBQWEsR0FBR0YsT0FBT0UsYUFBYTtZQUM5Q0QsVUFBVUcsb0JBQW9CLEdBQUdKLE9BQU9JLG9CQUFvQjtRQUNoRSxPQUNLLElBQUlKLE9BQU9FLGFBQWEsRUFBRTtZQUMzQkQsVUFBVUMsYUFBYSxHQUFHRixPQUFPRSxhQUFhO1FBQ2xELE9BQ0s7WUFDRFAsT0FBT1Usa0JBQWtCLENBQUMscUNBQXFDLFVBQVVMO1FBQzdFO1FBQ0EsT0FBT0M7SUFDWDtJQUNBLE9BQU9LLE9BQU9DLE9BQU8sRUFBRVAsTUFBTSxFQUFFO1FBQzNCLElBQUlRLE9BQU87UUFDWCxPQUFRRCxVQUFVQSxRQUFRRSxJQUFJLEdBQUc7WUFDN0IsS0FBSztnQkFDREQsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKO2dCQUNJYixPQUFPZSxVQUFVLENBQUMsdUJBQXVCakIseURBQU1BLENBQUNrQixNQUFNLENBQUNDLGdCQUFnQixFQUFFO29CQUNyRUMsVUFBVTtvQkFDVkMsT0FBT1A7Z0JBQ1g7UUFDUjtRQUNBLE1BQU1RLE1BQU0sQ0FBQyxTQUFTLEVBQUVQLEtBQUssT0FBTyxFQUFFUixPQUFPRSxhQUFhLENBQUMsQ0FBQztRQUM1RCxNQUFNYyxhQUFhO1lBQUVDLFNBQVMsQ0FBQztZQUFHRjtRQUFJO1FBQ3RDLElBQUlmLE9BQU9JLG9CQUFvQixJQUFJLE1BQU07WUFDckNZLFdBQVdFLElBQUksR0FBRztZQUNsQkYsV0FBV0csUUFBUSxHQUFHbkIsT0FBT0ksb0JBQW9CO1FBQ3JEO1FBQ0EsT0FBT1k7SUFDWDtJQUNBSSxzQkFBc0I7UUFDbEIsT0FBUSxJQUFJLENBQUNsQixhQUFhLEtBQUtMO0lBQ25DO0FBQ0osRUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vcG9ja2V0LXByb3ZpZGVyLmpzP2Q0ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBVcmxKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi91cmwtanNvbi1ycGMtcHJvdmlkZXJcIjtcbmNvbnN0IGRlZmF1bHRBcHBsaWNhdGlvbklkID0gXCI2MmUxYWQ1MWIzN2I4ZTAwMzk0YmRhM2JcIjtcbmV4cG9ydCBjbGFzcyBQb2NrZXRQcm92aWRlciBleHRlbmRzIFVybEpzb25ScGNQcm92aWRlciB7XG4gICAgc3RhdGljIGdldEFwaUtleShhcGlLZXkpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5T2JqID0ge1xuICAgICAgICAgICAgYXBwbGljYXRpb25JZDogbnVsbCxcbiAgICAgICAgICAgIGxvYWRCYWxhbmNlcjogdHJ1ZSxcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uU2VjcmV0S2V5OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFBhcnNlIGFwcGxpY2F0aW9uSWQgYW5kIGFwcGxpY2F0aW9uU2VjcmV0S2V5XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5T2JqLmFwcGxpY2F0aW9uSWQgPSBkZWZhdWx0QXBwbGljYXRpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGFwaUtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFwaUtleU9iai5hcHBsaWNhdGlvbklkID0gYXBpS2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwaUtleS5hcHBsaWNhdGlvblNlY3JldEtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcGlLZXlPYmouYXBwbGljYXRpb25JZCA9IGFwaUtleS5hcHBsaWNhdGlvbklkO1xuICAgICAgICAgICAgYXBpS2V5T2JqLmFwcGxpY2F0aW9uU2VjcmV0S2V5ID0gYXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwaUtleS5hcHBsaWNhdGlvbklkKSB7XG4gICAgICAgICAgICBhcGlLZXlPYmouYXBwbGljYXRpb25JZCA9IGFwaUtleS5hcHBsaWNhdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIFBvY2tldFByb3ZpZGVyIGFwaUtleVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcGlLZXlPYmo7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRVcmwobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGxldCBob3N0ID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChuZXR3b3JrID8gbmV0d29yay5uYW1lIDogXCJ1bmtub3duXCIpIHtcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtZ29lcmxpLmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLW1haW5uZXQuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJrb3ZhblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvYS1rb3Zhbi5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwicG9seS1tYWlubmV0LmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNtdW1cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW11bWJhaS1ycGMuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJpbmtlYnkuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJvcHN0ZW4uZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJuZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXR3b3JrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi9cXC8ke2hvc3R9L3YxL2xiLyR7YXBpS2V5LmFwcGxpY2F0aW9uSWR9YDtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHsgaGVhZGVyczoge30sIHVybCB9O1xuICAgICAgICBpZiAoYXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24udXNlciA9IFwiXCI7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnBhc3N3b3JkID0gYXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBwbGljYXRpb25JZCA9PT0gZGVmYXVsdEFwcGxpY2F0aW9uSWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvY2tldC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIlVybEpzb25ScGNQcm92aWRlciIsImRlZmF1bHRBcHBsaWNhdGlvbklkIiwiUG9ja2V0UHJvdmlkZXIiLCJnZXRBcGlLZXkiLCJhcGlLZXkiLCJhcGlLZXlPYmoiLCJhcHBsaWNhdGlvbklkIiwibG9hZEJhbGFuY2VyIiwiYXBwbGljYXRpb25TZWNyZXRLZXkiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJnZXRVcmwiLCJuZXR3b3JrIiwiaG9zdCIsIm5hbWUiLCJ0aHJvd0Vycm9yIiwiZXJyb3JzIiwiSU5WQUxJRF9BUkdVTUVOVCIsImFyZ3VtZW50IiwidmFsdWUiLCJ1cmwiLCJjb25uZWN0aW9uIiwiaGVhZGVycyIsInVzZXIiLCJwYXNzd29yZCIsImlzQ29tbXVuaXR5UmVzb3VyY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js ***!
  \*******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StaticJsonRpcProvider: () => (/* binding */ StaticJsonRpcProvider),\n/* harmony export */   UrlJsonRpcProvider: () => (/* binding */ UrlJsonRpcProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nclass StaticJsonRpcProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: {\n                get: ()=>super.detectNetwork\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nclass UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey){\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getNetwork\")(network);\n        apiKey = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getApiKey\")(apiKey);\n        const connection = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof apiKey === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"apiKey\", apiKey);\n        } else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key)=>{\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getSigner\"\n        });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n} //# sourceMappingURL=url-json-rpc-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS91cmwtanNvbi1ycGMtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDc0U7QUFDdkI7QUFDVjtBQUNyQyxNQUFNVyxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDcUI7QUFDdEQscUVBQXFFO0FBQ3JFLGtFQUFrRTtBQUNsRSx1RUFBdUU7QUFDdkUsaUNBQWlDO0FBQ2pDLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLGtCQUFrQjtBQUNsQix3RUFBd0U7QUFDeEUsd0VBQXdFO0FBQ3hFLG1CQUFtQjtBQUNaLE1BQU1HLDhCQUE4QkQsK0RBQWVBO0lBQ3RERSxnQkFBZ0I7UUFDWixNQUFNQyxTQUFTQyxPQUFPQyxNQUFNLENBQUMsTUFBTTtZQUMvQkgsZUFBZTtnQkFBRUksS0FBSyxJQUFNLEtBQUssQ0FBQ0o7WUFBYztRQUNwRDtRQUNBLE9BQU8xQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUkrQixVQUFVLElBQUksQ0FBQ0EsT0FBTztZQUMxQixJQUFJQSxXQUFXLE1BQU07Z0JBQ2pCQSxVQUFVLE1BQU1KLE9BQU9ELGFBQWEsQ0FBQ00sSUFBSSxDQUFDLElBQUk7Z0JBQzlDLElBQUksQ0FBQ0QsU0FBUztvQkFDVlIsT0FBT1UsVUFBVSxDQUFDLHVCQUF1QloseURBQU1BLENBQUNhLE1BQU0sQ0FBQ0MsYUFBYSxFQUFFLENBQUM7Z0JBQzNFO2dCQUNBLDJCQUEyQjtnQkFDM0IsSUFBSSxJQUFJLENBQUNDLFFBQVEsSUFBSSxNQUFNO29CQUN2QiwwQ0FBMEM7b0JBQzFDakIseUVBQWNBLENBQUMsSUFBSSxFQUFFLFlBQVlZO29CQUNqQyxJQUFJLENBQUNNLElBQUksQ0FBQyxXQUFXTixTQUFTO2dCQUNsQztZQUNKO1lBQ0EsT0FBT0E7UUFDWDtJQUNKO0FBQ0o7QUFDTyxNQUFNTywyQkFBMkJiO0lBQ3BDYyxZQUFZUixPQUFPLEVBQUVTLE1BQU0sQ0FBRTtRQUN6QmpCLE9BQU9rQixhQUFhLENBQUMsWUFBWUg7UUFDakMsb0NBQW9DO1FBQ3BDUCxVQUFVWCxvRUFBU0EsQ0FBQyxZQUFZLGNBQWNXO1FBQzlDUyxTQUFTcEIsb0VBQVNBLENBQUMsWUFBWSxhQUFhb0I7UUFDNUMsTUFBTUUsYUFBYXRCLG9FQUFTQSxDQUFDLFlBQVksVUFBVVcsU0FBU1M7UUFDNUQsS0FBSyxDQUFDRSxZQUFZWDtRQUNsQixJQUFJLE9BQVFTLFdBQVksVUFBVTtZQUM5QnJCLHlFQUFjQSxDQUFDLElBQUksRUFBRSxVQUFVcUI7UUFDbkMsT0FDSyxJQUFJQSxVQUFVLE1BQU07WUFDckJaLE9BQU9lLElBQUksQ0FBQ0gsUUFBUUksT0FBTyxDQUFDLENBQUNDO2dCQUN6QjFCLHlFQUFjQSxDQUFDLElBQUksRUFBRTBCLEtBQUtMLE1BQU0sQ0FBQ0ssSUFBSTtZQUN6QztRQUNKO0lBQ0o7SUFDQUMsZ0JBQWdCO1FBQ1p2QixPQUFPd0IsSUFBSSxDQUFDO0lBQ2hCO0lBQ0FDLHNCQUFzQjtRQUNsQixPQUFPO0lBQ1g7SUFDQUMsVUFBVUMsT0FBTyxFQUFFO1FBQ2YsT0FBTzNCLE9BQU9VLFVBQVUsQ0FBQyx5Q0FBeUNaLHlEQUFNQSxDQUFDYSxNQUFNLENBQUNpQixxQkFBcUIsRUFBRTtZQUFFQyxXQUFXO1FBQVk7SUFDcEk7SUFDQUMsZUFBZTtRQUNYLE9BQU83QyxRQUFRRCxPQUFPLENBQUMsRUFBRTtJQUM3QjtJQUNBLGlFQUFpRTtJQUNqRSxPQUFPK0MsVUFBVWQsTUFBTSxFQUFFO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQSx1RUFBdUU7SUFDdkUsNkVBQTZFO0lBQzdFLHdDQUF3QztJQUN4QyxPQUFPZSxPQUFPeEIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDM0IsT0FBT2pCLE9BQU9VLFVBQVUsQ0FBQyxxREFBcURaLHlEQUFNQSxDQUFDYSxNQUFNLENBQUNzQixlQUFlLEVBQUU7WUFDekdKLFdBQVc7UUFDZjtJQUNKO0FBQ0osRUFDQSxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vdXJsLWpzb24tcnBjLXByb3ZpZGVyLmpzPzg4NDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5LCBnZXRTdGF0aWMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjtcbi8vIEEgU3RhdGljSnNvblJwY1Byb3ZpZGVyIGlzIHVzZWZ1bCB3aGVuIHlvdSAqa25vdyogZm9yIGNlcnRhaW4gdGhhdFxuLy8gdGhlIGJhY2tlbmQgd2lsbCBuZXZlciBjaGFuZ2UsIGFzIGl0IG5ldmVyIGNhbGxzIGV0aF9jaGFpbklkIHRvXG4vLyB2ZXJpZnkgaXRzIGJhY2tlbmQuIEhvd2V2ZXIsIGlmIHRoZSBiYWNrZW5kIGRvZXMgY2hhbmdlLCB0aGUgZWZmZWN0c1xuLy8gYXJlIHVuZGVmaW5lZCBhbmQgbWF5IGluY2x1ZGU6XG4vLyAtIGluY29uc2lzdGVudCByZXN1bHRzXG4vLyAtIGxvY2tpbmcgdXAgdGhlIFVJXG4vLyAtIGJsb2NrIHNrZXcgd2FybmluZ3Ncbi8vIC0gd3JvbmcgcmVzdWx0c1xuLy8gSWYgdGhlIG5ldHdvcmsgaXMgbm90IGV4cGxpY2l0IChpLmUuIGF1dG8tZGV0ZWN0aW9uIGlzIGV4cGVjdGVkKSwgdGhlXG4vLyBub2RlIE1VU1QgYmUgcnVubmluZyBhbmQgYXZhaWxhYmxlIHRvIHJlc3BvbmQgdG8gcmVxdWVzdHMgQkVGT1JFIHRoaXNcbi8vIGlzIGluc3RhbnRpYXRlZC5cbmV4cG9ydCBjbGFzcyBTdGF0aWNKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXIge1xuICAgIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgZGV0ZWN0TmV0d29yazogeyBnZXQ6ICgpID0+IHN1cGVyLmRldGVjdE5ldHdvcmsgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCBfc3VwZXIuZGV0ZWN0TmV0d29yay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghbmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vIG5ldHdvcmsgZGV0ZWN0ZWRcIiwgTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHN0aWxsIG5vdCBzZXQsIHNldCBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBzdGF0aWMgbmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IFwiYW55XCJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFVybEpzb25ScGNQcm92aWRlciBleHRlbmRzIFN0YXRpY0pzb25ScGNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KG5ldy50YXJnZXQsIFVybEpzb25ScGNQcm92aWRlcik7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgTmV0d29yayBhbmQgQVBJIEtleVxuICAgICAgICBuZXR3b3JrID0gZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0TmV0d29ya1wiKShuZXR3b3JrKTtcbiAgICAgICAgYXBpS2V5ID0gZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0QXBpS2V5XCIpKGFwaUtleSk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXRVcmxcIikobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgbmV0d29yayk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFwaUtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFwaUtleSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywga2V5LCBhcGlLZXlba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3RhcnRQZW5kaW5nKCkge1xuICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkc6IEFQSSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHBlbmRpbmcgZmlsdGVyc1wiKTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJBUEkgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzaWduaW5nXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJnZXRTaWduZXJcIiB9KTtcbiAgICB9XG4gICAgbGlzdEFjY291bnRzKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGEgZGVmYXVsdEFwaUtleSBpZiBudWxsLCBvdGhlcndpc2UgdmFsaWRhdGUgdGhlIEFQSSBrZXlcbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xuICAgICAgICByZXR1cm4gYXBpS2V5O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB1cmwgb3IgY29ubmVjdGlvbiBmb3IgdGhlIGdpdmVuIG5ldHdvcmsgYW5kIEFQSSBrZXkuIFRoZVxuICAgIC8vIEFQSSBrZXkgd2lsbCBoYXZlIGJlZW4gc2FuaXRpemVkIGJ5IHRoZSBnZXRBcGlLZXkgZmlyc3QsIHNvIGFueSB2YWxpZGF0aW9uXG4gICAgLy8gb3IgdHJhbnNmb3JtYXRpb25zIGNhbiBiZSBkb25lIHRoZXJlLlxuICAgIHN0YXRpYyBnZXRVcmwobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcIm5vdCBpbXBsZW1lbnRlZDsgc3ViLWNsYXNzZXMgbXVzdCBvdmVycmlkZSBnZXRVcmxcIiwgTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRVcmxcIlxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmwtanNvbi1ycGMtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsImRlZmluZVJlYWRPbmx5IiwiZ2V0U3RhdGljIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIkpzb25ScGNQcm92aWRlciIsIlN0YXRpY0pzb25ScGNQcm92aWRlciIsImRldGVjdE5ldHdvcmsiLCJfc3VwZXIiLCJPYmplY3QiLCJjcmVhdGUiLCJnZXQiLCJuZXR3b3JrIiwiY2FsbCIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJVTktOT1dOX0VSUk9SIiwiX25ldHdvcmsiLCJlbWl0IiwiVXJsSnNvblJwY1Byb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJhcGlLZXkiLCJjaGVja0Fic3RyYWN0IiwiY29ubmVjdGlvbiIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiX3N0YXJ0UGVuZGluZyIsIndhcm4iLCJpc0NvbW11bml0eVJlc291cmNlIiwiZ2V0U2lnbmVyIiwiYWRkcmVzcyIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsImxpc3RBY2NvdW50cyIsImdldEFwaUtleSIsImdldFVybCIsIk5PVF9JTVBMRU1FTlRFRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/web3-provider.js":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/web3-provider.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Web3Provider: () => (/* binding */ Web3Provider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nlet _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    const fetcher = \"Web3LegacyFetcher\";\n    return function(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: _nextId++,\n            jsonrpc: \"2.0\"\n        };\n        return new Promise((resolve, reject)=>{\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(request),\n                provider: this\n            });\n            sendFunc(request, (error, response)=>{\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n                    return reject(error);\n                }\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    error.code = response.error.code;\n                    error.data = response.error.data;\n                    return reject(error);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function(method, params) {\n        if (params == null) {\n            params = [];\n        }\n        const request = {\n            method,\n            params\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(request),\n            provider: this\n        });\n        return provider.request(request).then((response)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n            return response;\n        }, (error)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n            throw error;\n        });\n    };\n}\nclass Web3Provider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider {\n    constructor(provider, network){\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        let path = null;\n        let jsonRpcFetchFunc = null;\n        let subprovider = null;\n        if (typeof provider === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        } else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            } else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            } else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            } else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        super(path, network);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"provider\", subprovider);\n    }\n    send(method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n} //# sourceMappingURL=web3-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS93ZWIzLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWE7QUFDd0Q7QUFDdEI7QUFDVjtBQUNyQyxNQUFNSSxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDcUI7QUFDdEQsSUFBSUcsVUFBVTtBQUNkLFNBQVNDLHVCQUF1QkMsUUFBUSxFQUFFQyxRQUFRO0lBQzlDLE1BQU1DLFVBQVU7SUFDaEIsT0FBTyxTQUFVQyxNQUFNLEVBQUVDLE1BQU07UUFDM0IsTUFBTUMsVUFBVTtZQUNaRixRQUFRQTtZQUNSQyxRQUFRQTtZQUNSRSxJQUFLUjtZQUNMUyxTQUFTO1FBQ2I7UUFDQSxPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekIsSUFBSSxDQUFDQyxJQUFJLENBQUMsU0FBUztnQkFDZkMsUUFBUTtnQkFDUlY7Z0JBQ0FHLFNBQVNiLG1FQUFRQSxDQUFDYTtnQkFDbEJMLFVBQVUsSUFBSTtZQUNsQjtZQUNBQyxTQUFTSSxTQUFTLENBQUNRLE9BQU9DO2dCQUN0QixJQUFJRCxPQUFPO29CQUNQLElBQUksQ0FBQ0YsSUFBSSxDQUFDLFNBQVM7d0JBQ2ZDLFFBQVE7d0JBQ1JWO3dCQUNBVzt3QkFDQVI7d0JBQ0FMLFVBQVUsSUFBSTtvQkFDbEI7b0JBQ0EsT0FBT1UsT0FBT0c7Z0JBQ2xCO2dCQUNBLElBQUksQ0FBQ0YsSUFBSSxDQUFDLFNBQVM7b0JBQ2ZDLFFBQVE7b0JBQ1JWO29CQUNBRztvQkFDQVM7b0JBQ0FkLFVBQVUsSUFBSTtnQkFDbEI7Z0JBQ0EsSUFBSWMsU0FBU0QsS0FBSyxFQUFFO29CQUNoQixNQUFNQSxRQUFRLElBQUlFLE1BQU1ELFNBQVNELEtBQUssQ0FBQ0csT0FBTztvQkFDOUNILE1BQU1JLElBQUksR0FBR0gsU0FBU0QsS0FBSyxDQUFDSSxJQUFJO29CQUNoQ0osTUFBTUssSUFBSSxHQUFHSixTQUFTRCxLQUFLLENBQUNLLElBQUk7b0JBQ2hDLE9BQU9SLE9BQU9HO2dCQUNsQjtnQkFDQUosUUFBUUssU0FBU0ssTUFBTTtZQUMzQjtRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVNDLG9CQUFvQnBCLFFBQVE7SUFDakMsT0FBTyxTQUFVRyxNQUFNLEVBQUVDLE1BQU07UUFDM0IsSUFBSUEsVUFBVSxNQUFNO1lBQ2hCQSxTQUFTLEVBQUU7UUFDZjtRQUNBLE1BQU1DLFVBQVU7WUFBRUY7WUFBUUM7UUFBTztRQUNqQyxJQUFJLENBQUNPLElBQUksQ0FBQyxTQUFTO1lBQ2ZDLFFBQVE7WUFDUlYsU0FBUztZQUNURyxTQUFTYixtRUFBUUEsQ0FBQ2E7WUFDbEJMLFVBQVUsSUFBSTtRQUNsQjtRQUNBLE9BQU9BLFNBQVNLLE9BQU8sQ0FBQ0EsU0FBU2dCLElBQUksQ0FBQyxDQUFDUDtZQUNuQyxJQUFJLENBQUNILElBQUksQ0FBQyxTQUFTO2dCQUNmQyxRQUFRO2dCQUNSVixTQUFTO2dCQUNURztnQkFDQVM7Z0JBQ0FkLFVBQVUsSUFBSTtZQUNsQjtZQUNBLE9BQU9jO1FBQ1gsR0FBRyxDQUFDRDtZQUNBLElBQUksQ0FBQ0YsSUFBSSxDQUFDLFNBQVM7Z0JBQ2ZDLFFBQVE7Z0JBQ1JWLFNBQVM7Z0JBQ1RHO2dCQUNBUTtnQkFDQWIsVUFBVSxJQUFJO1lBQ2xCO1lBQ0EsTUFBTWE7UUFDVjtJQUNKO0FBQ0o7QUFDTyxNQUFNUyxxQkFBcUJ6QiwrREFBZUE7SUFDN0MwQixZQUFZdkIsUUFBUSxFQUFFd0IsT0FBTyxDQUFFO1FBQzNCLElBQUl4QixZQUFZLE1BQU07WUFDbEJKLE9BQU82QixrQkFBa0IsQ0FBQyxvQkFBb0IsWUFBWXpCO1FBQzlEO1FBQ0EsSUFBSTBCLE9BQU87UUFDWCxJQUFJQyxtQkFBbUI7UUFDdkIsSUFBSUMsY0FBYztRQUNsQixJQUFJLE9BQVE1QixhQUFjLFlBQVk7WUFDbEMwQixPQUFPO1lBQ1BDLG1CQUFtQjNCO1FBQ3ZCLE9BQ0s7WUFDRDBCLE9BQU8xQixTQUFTNkIsSUFBSSxJQUFJN0IsU0FBUzBCLElBQUksSUFBSTtZQUN6QyxJQUFJLENBQUNBLFFBQVExQixTQUFTOEIsVUFBVSxFQUFFO2dCQUM5QkosT0FBTztZQUNYO1lBQ0FFLGNBQWM1QjtZQUNkLElBQUlBLFNBQVNLLE9BQU8sRUFBRTtnQkFDbEIsSUFBSXFCLFNBQVMsSUFBSTtvQkFDYkEsT0FBTztnQkFDWDtnQkFDQUMsbUJBQW1CUCxvQkFBb0JwQjtZQUMzQyxPQUNLLElBQUlBLFNBQVMrQixTQUFTLEVBQUU7Z0JBQ3pCSixtQkFBbUI1Qix1QkFBdUJDLFVBQVVBLFNBQVMrQixTQUFTLENBQUNDLElBQUksQ0FBQ2hDO1lBQ2hGLE9BQ0ssSUFBSUEsU0FBU2lDLElBQUksRUFBRTtnQkFDcEJOLG1CQUFtQjVCLHVCQUF1QkMsVUFBVUEsU0FBU2lDLElBQUksQ0FBQ0QsSUFBSSxDQUFDaEM7WUFDM0UsT0FDSztnQkFDREosT0FBTzZCLGtCQUFrQixDQUFDLHdCQUF3QixZQUFZekI7WUFDbEU7WUFDQSxJQUFJLENBQUMwQixNQUFNO2dCQUNQQSxPQUFPO1lBQ1g7UUFDSjtRQUNBLEtBQUssQ0FBQ0EsTUFBTUY7UUFDWi9CLHlFQUFjQSxDQUFDLElBQUksRUFBRSxvQkFBb0JrQztRQUN6Q2xDLHlFQUFjQSxDQUFDLElBQUksRUFBRSxZQUFZbUM7SUFDckM7SUFDQUssS0FBSzlCLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ2pCLE9BQU8sSUFBSSxDQUFDdUIsZ0JBQWdCLENBQUN4QixRQUFRQztJQUN6QztBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGV0aGVyc3Byb2plY3QrcHJvdmlkZXJzQDUuNy4wX2J1ZmZlcnV0aWxANC4wLjcvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3dlYjMtcHJvdmlkZXIuanM/YTZlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGRlZXBDb3B5LCBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9qc29uLXJwYy1wcm92aWRlclwiO1xubGV0IF9uZXh0SWQgPSAxO1xuZnVuY3Rpb24gYnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlciwgc2VuZEZ1bmMpIHtcbiAgICBjb25zdCBmZXRjaGVyID0gXCJXZWIzTGVnYWN5RmV0Y2hlclwiO1xuICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogKF9uZXh0SWQrKyksXG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBmZXRjaGVyLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGRlZXBDb3B5KHJlcXVlc3QpLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbmRGdW5jKHJlcXVlc3QsIChlcnJvciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICBmZXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocmVzcG9uc2UuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSByZXNwb25zZS5lcnJvci5jb2RlO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gcmVzcG9uc2UuZXJyb3IuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFaXAxMTkzRmV0Y2hlcihwcm92aWRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyBtZXRob2QsIHBhcmFtcyB9O1xuICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgZmV0Y2hlcjogXCJFaXAxMTkzRmV0Y2hlclwiLFxuICAgICAgICAgICAgcmVxdWVzdDogZGVlcENvcHkocmVxdWVzdCksXG4gICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnJlcXVlc3QocmVxdWVzdCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBmZXRjaGVyOiBcIkVpcDExOTNGZXRjaGVyXCIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXI6IFwiRWlwMTE5M0ZldGNoZXJcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0IGNsYXNzIFdlYjNQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIG5ldHdvcmspIHtcbiAgICAgICAgaWYgKHByb3ZpZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXRoID0gbnVsbDtcbiAgICAgICAgbGV0IGpzb25ScGNGZXRjaEZ1bmMgPSBudWxsO1xuICAgICAgICBsZXQgc3VicHJvdmlkZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIChwcm92aWRlcikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcGF0aCA9IFwidW5rbm93bjpcIjtcbiAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBwcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSBwcm92aWRlci5ob3N0IHx8IHByb3ZpZGVyLnBhdGggfHwgXCJcIjtcbiAgICAgICAgICAgIGlmICghcGF0aCAmJiBwcm92aWRlci5pc01ldGFNYXNrKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IFwibWV0YW1hc2tcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIucmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBcImVpcC0xMTkzOlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRFaXAxMTkzRmV0Y2hlcihwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci5zZW5kQXN5bmMpIHtcbiAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlciwgcHJvdmlkZXIuc2VuZEFzeW5jLmJpbmQocHJvdmlkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnNlbmQpIHtcbiAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlciwgcHJvdmlkZXIuc2VuZC5iaW5kKHByb3ZpZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhdGgsIG5ldHdvcmspO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImpzb25ScGNGZXRjaEZ1bmNcIiwganNvblJwY0ZldGNoRnVuYyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgc3VicHJvdmlkZXIpO1xuICAgIH1cbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzb25ScGNGZXRjaEZ1bmMobWV0aG9kLCBwYXJhbXMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYjMtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbImRlZXBDb3B5IiwiZGVmaW5lUmVhZE9ubHkiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiSnNvblJwY1Byb3ZpZGVyIiwiX25leHRJZCIsImJ1aWxkV2ViM0xlZ2FjeUZldGNoZXIiLCJwcm92aWRlciIsInNlbmRGdW5jIiwiZmV0Y2hlciIsIm1ldGhvZCIsInBhcmFtcyIsInJlcXVlc3QiLCJpZCIsImpzb25ycGMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVtaXQiLCJhY3Rpb24iLCJlcnJvciIsInJlc3BvbnNlIiwiRXJyb3IiLCJtZXNzYWdlIiwiY29kZSIsImRhdGEiLCJyZXN1bHQiLCJidWlsZEVpcDExOTNGZXRjaGVyIiwidGhlbiIsIldlYjNQcm92aWRlciIsImNvbnN0cnVjdG9yIiwibmV0d29yayIsInRocm93QXJndW1lbnRFcnJvciIsInBhdGgiLCJqc29uUnBjRmV0Y2hGdW5jIiwic3VicHJvdmlkZXIiLCJob3N0IiwiaXNNZXRhTWFzayIsInNlbmRBc3luYyIsImJpbmQiLCJzZW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/web3-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js":
/*!****************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketProvider: () => (/* binding */ WebSocketProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n/* harmony import */ var _ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ws */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ws.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */ let NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nclass WebSocketProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\n    constructor(url, network){\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof url === \"string\") {\n            super(url, network);\n        } else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof url === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_websocket\", new _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket(this.connection.url));\n        } else {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_websocket\", url);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_requests\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_subs\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_subIds\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = ()=>{\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id)=>{\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent)=>{\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                } else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, \"code\", result.error.code || null);\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, \"response\", data);\n                    } else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            } else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            } else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(()=>{\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() {\n        return this._websocket;\n    }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject)=>{\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = {\n                callback,\n                payload\n            };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws://localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param)=>{\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = {\n                tag,\n                processFunc\n            };\n        });\n    }\n    _startEvent(event) {\n        switch(event.type){\n            case \"block\":\n                this._subscribe(\"block\", [\n                    \"newHeads\"\n                ], (result)=>{\n                    const blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__.BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\n                    \"newPendingTransactions\"\n                ], (result)=>{\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\n                    \"logs\",\n                    this._getFilter(event.filter)\n                ], (result)=>{\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\":\n                {\n                    const emitReceipt = (event)=>{\n                        const hash = event.hash;\n                        this.getTransactionReceipt(hash).then((receipt)=>{\n                            if (!receipt) {\n                                return;\n                            }\n                            this.emit(hash, receipt);\n                        });\n                    };\n                    // In case it is already mined\n                    emitReceipt(event);\n                    // To keep things simple, we start up a single newHeads subscription\n                    // to keep an eye out for transactions we are watching for.\n                    // Starting a subscription for an event (i.e. \"tx\") that is already\n                    // running is (basically) a nop.\n                    this._subscribe(\"tx\", [\n                        \"newHeads\"\n                    ], (result)=>{\n                        this._events.filter((e)=>e.type === \"tx\").forEach(emitReceipt);\n                    });\n                    break;\n                }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e)=>e.type === \"tx\").length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId)=>{\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [\n                subId\n            ]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket.CONNECTING) {\n                yield new Promise((resolve)=>{\n                    this.websocket.onopen = function() {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function() {\n                        resolve(false);\n                    };\n                });\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n} //# sourceMappingURL=websocket-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS93ZWJzb2NrZXQtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ3FEO0FBQ007QUFDTDtBQUNyQjtBQUNj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QSxLQUFLLEdBQUc7WUFDdEMsc0NBQXNDO1lBQ3RDO1FBQ0o7UUFDQSxNQUFNRixRQUFRLElBQUksQ0FBQ0YsT0FBTyxDQUFDSCxJQUFJO1FBQy9CLElBQUksQ0FBQ0ssT0FBTztZQUNSO1FBQ0o7UUFDQSxPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDSCxJQUFJO1FBQ3hCSyxNQUFNNUUsSUFBSSxDQUFDLENBQUM0RTtZQUNSLElBQUksQ0FBQyxJQUFJLENBQUMxQixLQUFLLENBQUMwQixNQUFNLEVBQUU7Z0JBQ3BCO1lBQ0o7WUFDQSxPQUFPLElBQUksQ0FBQzFCLEtBQUssQ0FBQzBCLE1BQU07WUFDeEIsSUFBSSxDQUFDL0MsSUFBSSxDQUFDLG1CQUFtQjtnQkFBQytDO2FBQU07UUFDeEM7SUFDSjtJQUNBdUIsVUFBVTtRQUNOLE9BQU9wSCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLDJEQUEyRDtZQUMzRCxJQUFJLElBQUksQ0FBQ3VDLFNBQVMsQ0FBQzhFLFVBQVUsS0FBSy9GLDBDQUFTQSxDQUFDZ0csVUFBVSxFQUFFO2dCQUNwRCxNQUFPLElBQUk5RyxRQUFRLENBQUNEO29CQUNoQixJQUFJLENBQUNnQyxTQUFTLENBQUNDLE1BQU0sR0FBRzt3QkFDcEJqQyxRQUFRO29CQUNaO29CQUNBLElBQUksQ0FBQ2dDLFNBQVMsQ0FBQ2dGLE9BQU8sR0FBRzt3QkFDckJoSCxRQUFRO29CQUNaO2dCQUNKO1lBQ0o7WUFDQSxTQUFTO1lBQ1QsZ0ZBQWdGO1lBQ2hGLElBQUksQ0FBQ2dDLFNBQVMsQ0FBQ2lGLEtBQUssQ0FBQztRQUN6QjtJQUNKO0FBQ0osRUFDQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZXRoZXJzcHJvamVjdCtwcm92aWRlcnNANS43LjBfYnVmZmVydXRpbEA0LjAuNy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd2Vic29ja2V0LXByb3ZpZGVyLmpzP2FlN2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL2pzb24tcnBjLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBXZWJTb2NrZXQgfSBmcm9tIFwiLi93c1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuLyoqXG4gKiAgTm90ZXM6XG4gKlxuICogIFRoaXMgcHJvdmlkZXIgZGlmZmVycyBhIGJpdCBmcm9tIHRoZSBwb2xsaW5nIHByb3ZpZGVycy4gT25lIG1haW5cbiAqICBkaWZmZXJlbmNlIGlzIGhvdyBpdCBoYW5kbGVzIGNvbnNpc3RlbmN5LiBUaGUgcG9sbGluZyBwcm92aWRlcnNcbiAqICB3aWxsIHN0YWxsIHJlc3BvbnNlcyB0byBlbnN1cmUgYSBjb25zaXN0ZW50IHN0YXRlLCB3aGlsZSB0aGlzXG4gKiAgV2ViU29ja2V0IHByb3ZpZGVyIGFzc3VtZXMgdGhlIGNvbm5lY3RlZCBiYWNrZW5kIHdpbGwgbWFuYWdlIHRoaXMuXG4gKlxuICogIEZvciBleGFtcGxlLCBpZiBhIHBvbGxpbmcgcHJvdmlkZXIgZW1pdHMgYW4gZXZlbnQgd2hpY2ggaW5kaWNhdGVzXG4gKiAgdGhlIGV2ZW50IG9jY3VycmVkIGluIGJsb2NraGFzaCBYWFgsIGEgY2FsbCB0byBmZXRjaCB0aGF0IGJsb2NrIGJ5XG4gKiAgaXRzIGhhc2ggWFhYLCBpZiBub3QgcHJlc2VudCB3aWxsIHJldHJ5IHVudGlsIGl0IGlzIHByZXNlbnQuIFRoaXNcbiAqICBjYW4gb2NjdXIgd2hlbiBxdWVyeWluZyBhIHBvb2wgb2Ygbm9kZXMgdGhhdCBhcmUgbWlsZGx5IG91dCBvZiBzeW5jXG4gKiAgd2l0aCBlYWNoIG90aGVyLlxuICovXG5sZXQgTmV4dElkID0gMTtcbi8vIEZvciBtb3JlIGluZm8gYWJvdXQgdGhlIFJlYWwtdGltZSBFdmVudCBBUEkgc2VlOlxuLy8gICBodHRwczovL2dldGguZXRoZXJldW0ub3JnL2RvY3MvcnBjL3B1YnN1YlxuZXhwb3J0IGNsYXNzIFdlYlNvY2tldFByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmspIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGFkZGVkIGluIHRoZSBmdXR1cmU7IHBsZWFzZSBvcGVuIGFuIGlzc3VlIHRvIGV4cGVkaXRlXG4gICAgICAgIGlmIChuZXR3b3JrID09PSBcImFueVwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIldlYlNvY2tldFByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJ2FueScgbmV0d29yayB5ZXRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV0d29yazphbnlcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgc3VwZXIodXJsLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyKFwiX3dlYnNvY2tldFwiLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSAtMTtcbiAgICAgICAgdGhpcy5fd3NSZWFkeSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl93ZWJzb2NrZXRcIiwgbmV3IFdlYlNvY2tldCh0aGlzLmNvbm5lY3Rpb24udXJsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl93ZWJzb2NrZXRcIiwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9yZXF1ZXN0c1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3N1YnNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9zdWJJZHNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9kZXRlY3ROZXR3b3JrXCIsIHN1cGVyLmRldGVjdE5ldHdvcmsoKSk7XG4gICAgICAgIC8vIFN0YWxsIHNlbmRpbmcgcmVxdWVzdHMgdW50aWwgdGhlIHNvY2tldCBpcyBvcGVuLi4uXG4gICAgICAgIHRoaXMud2Vic29ja2V0Lm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dzUmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcmVxdWVzdHMpLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZCh0aGlzLl9yZXF1ZXN0c1tpZF0ucGF5bG9hZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQub25tZXNzYWdlID0gKG1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG1lc3NhZ2VFdmVudC5kYXRhO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gU3RyaW5nKHJlc3VsdC5pZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3JlcXVlc3RzW2lkXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcmVxdWVzdHNbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhudWxsLCByZXN1bHQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBKU09OLnBhcnNlKHJlcXVlc3QucGF5bG9hZCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkoZXJyb3IsIFwiY29kZVwiLCByZXN1bHQuZXJyb3IuY29kZSB8fCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KGVycm9yLCBcInJlc3BvbnNlXCIsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJ1bmtub3duIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3IsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogSlNPTi5wYXJzZShyZXF1ZXN0LnBheWxvYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0Lm1ldGhvZCA9PT0gXCJldGhfc3Vic2NyaXB0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBTdWJzY3JpcHRpb24uLi5cbiAgICAgICAgICAgICAgICBjb25zdCBzdWIgPSB0aGlzLl9zdWJzW3Jlc3VsdC5wYXJhbXMuc3Vic2NyaXB0aW9uXTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcy5lbWl0LmFwcGx5KHRoaXMsICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnByb2Nlc3NGdW5jKHJlc3VsdC5wYXJhbXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ0aGlzIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBUaGlzIFByb3ZpZGVyIGRvZXMgbm90IGFjdHVhbGx5IHBvbGwsIGJ1dCB3ZSB3YW50IHRvIHRyaWdnZXJcbiAgICAgICAgLy8gcG9sbCBldmVudHMgZm9yIHRoaW5ncyB0aGF0IGRlcGVuZCBvbiB0aGVtIChsaWtlIHN0YWxsaW5nIGZvclxuICAgICAgICAvLyBibG9jayBhbmQgdHJhbnNhY3Rpb24gbG9va3VwcylcbiAgICAgICAgY29uc3QgZmF1eFBvbGwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJwb2xsXCIpO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgaWYgKGZhdXhQb2xsLnVucmVmKSB7XG4gICAgICAgICAgICBmYXV4UG9sbC51bnJlZigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENhbm5vdCBuYXJyb3cgdGhlIHR5cGUgb2YgX3dlYnNvY2tldCwgYXMgdGhhdCBpcyBub3QgYmFja3dhcmRzIGNvbXBhdGlibGVcbiAgICAvLyBzbyB3ZSBhZGQgYSBnZXR0ZXIgYW5kIGxldCB0aGUgV2ViU29ja2V0IGJlIGEgcHVibGljIEFQSS5cbiAgICBnZXQgd2Vic29ja2V0KCkgeyByZXR1cm4gdGhpcy5fd2Vic29ja2V0OyB9XG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RldGVjdE5ldHdvcms7XG4gICAgfVxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXNldEV2ZW50c0Jsb2NrKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHJlc2V0IGV2ZW50cyBibG9jayBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc2V0RXZlbnRCbG9ja1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHNldCBwb2xsaW5nIGludGVydmFsIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2V0UG9sbGluZ0ludGVydmFsXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvbGwoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldCBwb2xsaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBzZXQgcG9sbGluZyBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByaWQgPSBOZXh0SWQrKztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgIGlkOiByaWQsXG4gICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBKU09OLnBhcnNlKHBheWxvYWQpLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzW1N0cmluZyhyaWQpXSA9IHsgY2FsbGJhY2ssIHBheWxvYWQgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93c1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBkZWZhdWx0VXJsKCkge1xuICAgICAgICByZXR1cm4gXCJ3czovXFwvbG9jYWxob3N0Ojg1NDZcIjtcbiAgICB9XG4gICAgX3N1YnNjcmliZSh0YWcsIHBhcmFtLCBwcm9jZXNzRnVuYykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHN1YklkUHJvbWlzZSA9IHRoaXMuX3N1Yklkc1t0YWddO1xuICAgICAgICAgICAgaWYgKHN1YklkUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViSWRQcm9taXNlID0gUHJvbWlzZS5hbGwocGFyYW0pLnRoZW4oKHBhcmFtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQoXCJldGhfc3Vic2NyaWJlXCIsIHBhcmFtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJJZHNbdGFnXSA9IHN1YklkUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1YklkID0geWllbGQgc3ViSWRQcm9taXNlO1xuICAgICAgICAgICAgdGhpcy5fc3Vic1tzdWJJZF0gPSB7IHRhZywgcHJvY2Vzc0Z1bmMgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKFwiYmxvY2tcIiwgW1wibmV3SGVhZHNcIl0sIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBCaWdOdW1iZXIuZnJvbShyZXN1bHQubnVtYmVyKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImJsb2NrXCIsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKFwicGVuZGluZ1wiLCBbXCJuZXdQZW5kaW5nVHJhbnNhY3Rpb25zXCJdLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInBlbmRpbmdcIiwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLCBbXCJsb2dzXCIsIHRoaXMuX2dldEZpbHRlcihldmVudC5maWx0ZXIpXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlbW92ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnQuZmlsdGVyLCB0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidHhcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtaXRSZWNlaXB0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBldmVudC5oYXNoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKS50aGVuKChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoaGFzaCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBpdCBpcyBhbHJlYWR5IG1pbmVkXG4gICAgICAgICAgICAgICAgZW1pdFJlY2VpcHQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIFRvIGtlZXAgdGhpbmdzIHNpbXBsZSwgd2Ugc3RhcnQgdXAgYSBzaW5nbGUgbmV3SGVhZHMgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgLy8gdG8ga2VlcCBhbiBleWUgb3V0IGZvciB0cmFuc2FjdGlvbnMgd2UgYXJlIHdhdGNoaW5nIGZvci5cbiAgICAgICAgICAgICAgICAvLyBTdGFydGluZyBhIHN1YnNjcmlwdGlvbiBmb3IgYW4gZXZlbnQgKGkuZS4gXCJ0eFwiKSB0aGF0IGlzIGFscmVhZHlcbiAgICAgICAgICAgICAgICAvLyBydW5uaW5nIGlzIChiYXNpY2FsbHkpIGEgbm9wLlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcInR4XCIsIFtcIm5ld0hlYWRzXCJdLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5maWx0ZXIoKGUpID0+IChlLnR5cGUgPT09IFwidHhcIikpLmZvckVhY2goZW1pdFJlY2VpcHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90aGluZyBpcyBuZWVkZWRcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgY2FzZSBcInBvbGxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ3aWxsUG9sbFwiOlxuICAgICAgICAgICAgY2FzZSBcImRpZFBvbGxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVuaGFuZGxlZDpcIiwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgbGV0IHRhZyA9IGV2ZW50LnRhZztcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwidHhcIikge1xuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyB0cmFuc2FjdGlvbiBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuZmlsdGVyKChlKSA9PiAoZS50eXBlID09PSBcInR4XCIpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWcgPSBcInR4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KGV2ZW50LmV2ZW50KSkge1xuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJJZCA9IHRoaXMuX3N1Yklkc1t0YWddO1xuICAgICAgICBpZiAoIXN1YklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuX3N1Yklkc1t0YWddO1xuICAgICAgICBzdWJJZC50aGVuKChzdWJJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdWJzW3N1YklkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzW3N1YklkXTtcbiAgICAgICAgICAgIHRoaXMuc2VuZChcImV0aF91bnN1YnNjcmliZVwiLCBbc3ViSWRdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBXYWl0IHVudGlsIHdlIGhhdmUgY29ubmVjdGVkIGJlZm9yZSB0cnlpbmcgdG8gZGlzY29ubmVjdFxuICAgICAgICAgICAgaWYgKHRoaXMud2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5ndXBcbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQjU3RhdHVzX2NvZGVzXG4gICAgICAgICAgICB0aGlzLndlYnNvY2tldC5jbG9zZSgxMDAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Vic29ja2V0LXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJCaWdOdW1iZXIiLCJkZWZpbmVSZWFkT25seSIsIkpzb25ScGNQcm92aWRlciIsIldlYlNvY2tldCIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJOZXh0SWQiLCJXZWJTb2NrZXRQcm92aWRlciIsImNvbnN0cnVjdG9yIiwidXJsIiwibmV0d29yayIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJvcGVyYXRpb24iLCJfcG9sbGluZ0ludGVydmFsIiwiX3dzUmVhZHkiLCJjb25uZWN0aW9uIiwiZGV0ZWN0TmV0d29yayIsIndlYnNvY2tldCIsIm9ub3BlbiIsIk9iamVjdCIsImtleXMiLCJfcmVxdWVzdHMiLCJmb3JFYWNoIiwiaWQiLCJzZW5kIiwicGF5bG9hZCIsIm9ubWVzc2FnZSIsIm1lc3NhZ2VFdmVudCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJTdHJpbmciLCJyZXF1ZXN0IiwidW5kZWZpbmVkIiwiY2FsbGJhY2siLCJlbWl0IiwiYWN0aW9uIiwicmVzcG9uc2UiLCJwcm92aWRlciIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiY29kZSIsIm1ldGhvZCIsInN1YiIsIl9zdWJzIiwicGFyYW1zIiwic3Vic2NyaXB0aW9uIiwicHJvY2Vzc0Z1bmMiLCJjb25zb2xlIiwid2FybiIsImZhdXhQb2xsIiwic2V0SW50ZXJ2YWwiLCJ1bnJlZiIsIl93ZWJzb2NrZXQiLCJfZGV0ZWN0TmV0d29yayIsInBvbGxpbmdJbnRlcnZhbCIsInJlc2V0RXZlbnRzQmxvY2siLCJibG9ja051bWJlciIsInBvbGwiLCJwb2xsaW5nIiwicmlkIiwic3RyaW5naWZ5IiwianNvbnJwYyIsImRlZmF1bHRVcmwiLCJfc3Vic2NyaWJlIiwidGFnIiwicGFyYW0iLCJzdWJJZFByb21pc2UiLCJfc3ViSWRzIiwiYWxsIiwic3ViSWQiLCJfc3RhcnRFdmVudCIsImV2ZW50IiwidHlwZSIsImZyb20iLCJudW1iZXIiLCJ0b051bWJlciIsIl9lbWl0dGVkIiwiYmxvY2siLCJfZ2V0RmlsdGVyIiwiZmlsdGVyIiwicmVtb3ZlZCIsImZvcm1hdHRlciIsImZpbHRlckxvZyIsImVtaXRSZWNlaXB0IiwiaGFzaCIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsInJlY2VpcHQiLCJfZXZlbnRzIiwibG9nIiwiX3N0b3BFdmVudCIsImxlbmd0aCIsImxpc3RlbmVyQ291bnQiLCJkZXN0cm95IiwicmVhZHlTdGF0ZSIsIkNPTk5FQ1RJTkciLCJvbmVycm9yIiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ws.js":
/*!************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ws.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocket: () => (/* binding */ WS)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n} catch (error) {\n    const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n    WS = function() {\n        logger.throwError(\"WebSockets not supported in this environment\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\n //# sourceMappingURL=ws.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS93cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUNrQztBQUNWO0FBQ3JDLElBQUlFLEtBQUs7QUFDVCxJQUFJO0lBQ0FBLEtBQUtDO0lBQ0wsSUFBSUQsTUFBTSxNQUFNO1FBQ1osTUFBTSxJQUFJRSxNQUFNO0lBQ3BCO0FBQ0osRUFDQSxPQUFPQyxPQUFPO0lBQ1YsTUFBTUMsU0FBUyxJQUFJTix5REFBTUEsQ0FBQ0MsNkNBQU9BO0lBQ2pDQyxLQUFLO1FBQ0RJLE9BQU9DLFVBQVUsQ0FBQyxnREFBZ0RQLHlEQUFNQSxDQUFDUSxNQUFNLENBQUNDLHFCQUFxQixFQUFFO1lBQ25HQyxXQUFXO1FBQ2Y7SUFDSjtBQUNKO0FBQ0Esb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUNLLENBQzNCLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BldGhlcnNwcm9qZWN0K3Byb3ZpZGVyc0A1LjcuMF9idWZmZXJ1dGlsQDQuMC43L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS93cy5qcz81YzBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5sZXQgV1MgPSBudWxsO1xudHJ5IHtcbiAgICBXUyA9IFdlYlNvY2tldDtcbiAgICBpZiAoV1MgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmplY3QgcGxlYXNlXCIpO1xuICAgIH1cbn1cbmNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4gICAgV1MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiV2ViU29ja2V0cyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgV2ViU29ja2V0KClcIlxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLy9leHBvcnQgZGVmYXVsdCBXUztcbi8vbW9kdWxlLmV4cG9ydHMgPSBXUztcbmV4cG9ydCB7IFdTIGFzIFdlYlNvY2tldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3MuanMubWFwIl0sIm5hbWVzIjpbIkxvZ2dlciIsInZlcnNpb24iLCJXUyIsIldlYlNvY2tldCIsIkVycm9yIiwiZXJyb3IiLCJsb2dnZXIiLCJ0aHJvd0Vycm9yIiwiZXJyb3JzIiwiVU5TVVBQT1JURURfT1BFUkFUSU9OIiwib3BlcmF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@ethersproject+providers@5.7.0_bufferutil@4.0.7/node_modules/@ethersproject/providers/lib.esm/ws.js\n");

/***/ })

};
;