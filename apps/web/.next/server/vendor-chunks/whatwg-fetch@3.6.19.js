"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/whatwg-fetch@3.6.19";
exports.ids = ["vendor-chunks/whatwg-fetch@3.6.19"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/whatwg-fetch@3.6.19/node_modules/whatwg-fetch/fetch.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/whatwg-fetch@3.6.19/node_modules/whatwg-fetch/fetch.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMException: () => (/* binding */ DOMException),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   Response: () => (/* binding */ Response),\n/* harmony export */   fetch: () => (/* binding */ fetch)\n/* harmony export */ });\n/* eslint-disable no-prototype-builtins */ var g = typeof globalThis !== \"undefined\" && globalThis || typeof self !== \"undefined\" && self || // eslint-disable-next-line no-undef\ntypeof global !== \"undefined\" && global || {};\nvar support = {\n    searchParams: \"URLSearchParams\" in g,\n    iterable: \"Symbol\" in g && \"iterator\" in Symbol,\n    blob: \"FileReader\" in g && \"Blob\" in g && function() {\n        try {\n            new Blob();\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }(),\n    formData: \"FormData\" in g,\n    arrayBuffer: \"ArrayBuffer\" in g\n};\nfunction isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj);\n}\nif (support.arrayBuffer) {\n    var viewClasses = [\n        \"[object Int8Array]\",\n        \"[object Uint8Array]\",\n        \"[object Uint8ClampedArray]\",\n        \"[object Int16Array]\",\n        \"[object Uint16Array]\",\n        \"[object Int32Array]\",\n        \"[object Uint32Array]\",\n        \"[object Float32Array]\",\n        \"[object Float64Array]\"\n    ];\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n    };\n}\nfunction normalizeName(name) {\n    if (typeof name !== \"string\") {\n        name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === \"\") {\n        throw new TypeError('Invalid character in header field name: \"' + name + '\"');\n    }\n    return name.toLowerCase();\n}\nfunction normalizeValue(value) {\n    if (typeof value !== \"string\") {\n        value = String(value);\n    }\n    return value;\n}\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n    var iterator = {\n        next: function() {\n            var value = items.shift();\n            return {\n                done: value === undefined,\n                value: value\n            };\n        }\n    };\n    if (support.iterable) {\n        iterator[Symbol.iterator] = function() {\n            return iterator;\n        };\n    }\n    return iterator;\n}\nfunction Headers(headers) {\n    this.map = {};\n    if (headers instanceof Headers) {\n        headers.forEach(function(value, name) {\n            this.append(name, value);\n        }, this);\n    } else if (Array.isArray(headers)) {\n        headers.forEach(function(header) {\n            if (header.length != 2) {\n                throw new TypeError(\"Headers constructor: expected name/value pair to be length 2, found\" + header.length);\n            }\n            this.append(header[0], header[1]);\n        }, this);\n    } else if (headers) {\n        Object.getOwnPropertyNames(headers).forEach(function(name) {\n            this.append(name, headers[name]);\n        }, this);\n    }\n}\nHeaders.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + \", \" + value : value;\n};\nHeaders.prototype[\"delete\"] = function(name) {\n    delete this.map[normalizeName(name)];\n};\nHeaders.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null;\n};\nHeaders.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name));\n};\nHeaders.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n};\nHeaders.prototype.forEach = function(callback, thisArg) {\n    for(var name in this.map){\n        if (this.map.hasOwnProperty(name)) {\n            callback.call(thisArg, this.map[name], name, this);\n        }\n    }\n};\nHeaders.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n        items.push(name);\n    });\n    return iteratorFor(items);\n};\nHeaders.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n        items.push(value);\n    });\n    return iteratorFor(items);\n};\nHeaders.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n        items.push([\n            name,\n            value\n        ]);\n    });\n    return iteratorFor(items);\n};\nif (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n}\nfunction consumed(body) {\n    if (body._noBody) return;\n    if (body.bodyUsed) {\n        return Promise.reject(new TypeError(\"Already read\"));\n    }\n    body.bodyUsed = true;\n}\nfunction fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n        reader.onload = function() {\n            resolve(reader.result);\n        };\n        reader.onerror = function() {\n            reject(reader.error);\n        };\n    });\n}\nfunction readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise;\n}\nfunction readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);\n    var encoding = match ? match[1] : \"utf-8\";\n    reader.readAsText(blob, encoding);\n    return promise;\n}\nfunction readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n    for(var i = 0; i < view.length; i++){\n        chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join(\"\");\n}\nfunction bufferClone(buf) {\n    if (buf.slice) {\n        return buf.slice(0);\n    } else {\n        var view = new Uint8Array(buf.byteLength);\n        view.set(new Uint8Array(buf));\n        return view.buffer;\n    }\n}\nfunction Body() {\n    this.bodyUsed = false;\n    this._initBody = function(body) {\n        /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */ // eslint-disable-next-line no-self-assign\n        this.bodyUsed = this.bodyUsed;\n        this._bodyInit = body;\n        if (!body) {\n            this._noBody = true;\n            this._bodyText = \"\";\n        } else if (typeof body === \"string\") {\n            this._bodyText = body;\n        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n            this._bodyBlob = body;\n        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n            this._bodyFormData = body;\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n            this._bodyText = body.toString();\n        } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n            this._bodyArrayBuffer = bufferClone(body.buffer);\n            // IE 10-11 can't handle a DataView body.\n            this._bodyInit = new Blob([\n                this._bodyArrayBuffer\n            ]);\n        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n            this._bodyArrayBuffer = bufferClone(body);\n        } else {\n            this._bodyText = body = Object.prototype.toString.call(body);\n        }\n        if (!this.headers.get(\"content-type\")) {\n            if (typeof body === \"string\") {\n                this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\");\n            } else if (this._bodyBlob && this._bodyBlob.type) {\n                this.headers.set(\"content-type\", this._bodyBlob.type);\n            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n                this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n            }\n        }\n    };\n    if (support.blob) {\n        this.blob = function() {\n            var rejected = consumed(this);\n            if (rejected) {\n                return rejected;\n            }\n            if (this._bodyBlob) {\n                return Promise.resolve(this._bodyBlob);\n            } else if (this._bodyArrayBuffer) {\n                return Promise.resolve(new Blob([\n                    this._bodyArrayBuffer\n                ]));\n            } else if (this._bodyFormData) {\n                throw new Error(\"could not read FormData body as blob\");\n            } else {\n                return Promise.resolve(new Blob([\n                    this._bodyText\n                ]));\n            }\n        };\n    }\n    this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n            var isConsumed = consumed(this);\n            if (isConsumed) {\n                return isConsumed;\n            } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n                return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));\n            } else {\n                return Promise.resolve(this._bodyArrayBuffer);\n            }\n        } else if (support.blob) {\n            return this.blob().then(readBlobAsArrayBuffer);\n        } else {\n            throw new Error(\"could not read as ArrayBuffer\");\n        }\n    };\n    this.text = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n            return rejected;\n        }\n        if (this._bodyBlob) {\n            return readBlobAsText(this._bodyBlob);\n        } else if (this._bodyArrayBuffer) {\n            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n        } else if (this._bodyFormData) {\n            throw new Error(\"could not read FormData body as text\");\n        } else {\n            return Promise.resolve(this._bodyText);\n        }\n    };\n    if (support.formData) {\n        this.formData = function() {\n            return this.text().then(decode);\n        };\n    }\n    this.json = function() {\n        return this.text().then(JSON.parse);\n    };\n    return this;\n}\n// HTTP methods whose capitalization should be normalized\nvar methods = [\n    \"CONNECT\",\n    \"DELETE\",\n    \"GET\",\n    \"HEAD\",\n    \"OPTIONS\",\n    \"PATCH\",\n    \"POST\",\n    \"PUT\",\n    \"TRACE\"\n];\nfunction normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method;\n}\nfunction Request(input, options) {\n    if (!(this instanceof Request)) {\n        throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n    }\n    options = options || {};\n    var body = options.body;\n    if (input instanceof Request) {\n        if (input.bodyUsed) {\n            throw new TypeError(\"Already read\");\n        }\n        this.url = input.url;\n        this.credentials = input.credentials;\n        if (!options.headers) {\n            this.headers = new Headers(input.headers);\n        }\n        this.method = input.method;\n        this.mode = input.mode;\n        this.signal = input.signal;\n        if (!body && input._bodyInit != null) {\n            body = input._bodyInit;\n            input.bodyUsed = true;\n        }\n    } else {\n        this.url = String(input);\n    }\n    this.credentials = options.credentials || this.credentials || \"same-origin\";\n    if (options.headers || !this.headers) {\n        this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || \"GET\");\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal || function() {\n        if (\"AbortController\" in g) {\n            var ctrl = new AbortController();\n            return ctrl.signal;\n        }\n    }();\n    this.referrer = null;\n    if ((this.method === \"GET\" || this.method === \"HEAD\") && body) {\n        throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n    }\n    this._initBody(body);\n    if (this.method === \"GET\" || this.method === \"HEAD\") {\n        if (options.cache === \"no-store\" || options.cache === \"no-cache\") {\n            // Search for a '_' parameter in the query string\n            var reParamSearch = /([?&])_=[^&]*/;\n            if (reParamSearch.test(this.url)) {\n                // If it already exists then set the value with the current time\n                this.url = this.url.replace(reParamSearch, \"$1_=\" + new Date().getTime());\n            } else {\n                // Otherwise add a new '_' parameter to the end with the current time\n                var reQueryString = /\\?/;\n                this.url += (reQueryString.test(this.url) ? \"&\" : \"?\") + \"_=\" + new Date().getTime();\n            }\n        }\n    }\n}\nRequest.prototype.clone = function() {\n    return new Request(this, {\n        body: this._bodyInit\n    });\n};\nfunction decode(body) {\n    var form = new FormData();\n    body.trim().split(\"&\").forEach(function(bytes) {\n        if (bytes) {\n            var split = bytes.split(\"=\");\n            var name = split.shift().replace(/\\+/g, \" \");\n            var value = split.join(\"=\").replace(/\\+/g, \" \");\n            form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n    });\n    return form;\n}\nfunction parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, \" \");\n    // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n    // https://github.com/github/fetch/issues/748\n    // https://github.com/zloirock/core-js/issues/751\n    preProcessedHeaders.split(\"\\r\").map(function(header) {\n        return header.indexOf(\"\\n\") === 0 ? header.substr(1, header.length) : header;\n    }).forEach(function(line) {\n        var parts = line.split(\":\");\n        var key = parts.shift().trim();\n        if (key) {\n            var value = parts.join(\":\").trim();\n            try {\n                headers.append(key, value);\n            } catch (error) {\n                console.warn(\"Response \" + error.message);\n            }\n        }\n    });\n    return headers;\n}\nBody.call(Request.prototype);\nfunction Response(bodyInit, options) {\n    if (!(this instanceof Response)) {\n        throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n    }\n    if (!options) {\n        options = {};\n    }\n    this.type = \"default\";\n    this.status = options.status === undefined ? 200 : options.status;\n    if (this.status < 200 || this.status > 599) {\n        throw new RangeError(\"Failed to construct 'Response': The status provided (0) is outside the range [200, 599].\");\n    }\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = options.statusText === undefined ? \"\" : \"\" + options.statusText;\n    this.headers = new Headers(options.headers);\n    this.url = options.url || \"\";\n    this._initBody(bodyInit);\n}\nBody.call(Response.prototype);\nResponse.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n        status: this.status,\n        statusText: this.statusText,\n        headers: new Headers(this.headers),\n        url: this.url\n    });\n};\nResponse.error = function() {\n    var response = new Response(null, {\n        status: 200,\n        statusText: \"\"\n    });\n    response.status = 0;\n    response.type = \"error\";\n    return response;\n};\nvar redirectStatuses = [\n    301,\n    302,\n    303,\n    307,\n    308\n];\nResponse.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n        throw new RangeError(\"Invalid status code\");\n    }\n    return new Response(null, {\n        status: status,\n        headers: {\n            location: url\n        }\n    });\n};\nvar DOMException = g.DOMException;\ntry {\n    new DOMException();\n} catch (err) {\n    DOMException = function(message, name) {\n        this.message = message;\n        this.name = name;\n        var error = Error(message);\n        this.stack = error.stack;\n    };\n    DOMException.prototype = Object.create(Error.prototype);\n    DOMException.prototype.constructor = DOMException;\n}\nfunction fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n        var request = new Request(input, init);\n        if (request.signal && request.signal.aborted) {\n            return reject(new DOMException(\"Aborted\", \"AbortError\"));\n        }\n        var xhr = new XMLHttpRequest();\n        function abortXhr() {\n            xhr.abort();\n        }\n        xhr.onload = function() {\n            var options = {\n                statusText: xhr.statusText,\n                headers: parseHeaders(xhr.getAllResponseHeaders() || \"\")\n            };\n            // This check if specifically for when a user fetches a file locally from the file system\n            // Only if the status is out of a normal range\n            if (request.url.startsWith(\"file://\") && (xhr.status < 200 || xhr.status > 599)) {\n                options.status = 200;\n            } else {\n                options.status = xhr.status;\n            }\n            options.url = \"responseURL\" in xhr ? xhr.responseURL : options.headers.get(\"X-Request-URL\");\n            var body = \"response\" in xhr ? xhr.response : xhr.responseText;\n            setTimeout(function() {\n                resolve(new Response(body, options));\n            }, 0);\n        };\n        xhr.onerror = function() {\n            setTimeout(function() {\n                reject(new TypeError(\"Network request failed\"));\n            }, 0);\n        };\n        xhr.ontimeout = function() {\n            setTimeout(function() {\n                reject(new TypeError(\"Network request timed out\"));\n            }, 0);\n        };\n        xhr.onabort = function() {\n            setTimeout(function() {\n                reject(new DOMException(\"Aborted\", \"AbortError\"));\n            }, 0);\n        };\n        function fixUrl(url) {\n            try {\n                return url === \"\" && g.location.href ? g.location.href : url;\n            } catch (e) {\n                return url;\n            }\n        }\n        xhr.open(request.method, fixUrl(request.url), true);\n        if (request.credentials === \"include\") {\n            xhr.withCredentials = true;\n        } else if (request.credentials === \"omit\") {\n            xhr.withCredentials = false;\n        }\n        if (\"responseType\" in xhr) {\n            if (support.blob) {\n                xhr.responseType = \"blob\";\n            } else if (support.arrayBuffer) {\n                xhr.responseType = \"arraybuffer\";\n            }\n        }\n        if (init && typeof init.headers === \"object\" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {\n            var names = [];\n            Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n                names.push(normalizeName(name));\n                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));\n            });\n            request.headers.forEach(function(value, name) {\n                if (names.indexOf(name) === -1) {\n                    xhr.setRequestHeader(name, value);\n                }\n            });\n        } else {\n            request.headers.forEach(function(value, name) {\n                xhr.setRequestHeader(name, value);\n            });\n        }\n        if (request.signal) {\n            request.signal.addEventListener(\"abort\", abortXhr);\n            xhr.onreadystatechange = function() {\n                // DONE (success or failure)\n                if (xhr.readyState === 4) {\n                    request.signal.removeEventListener(\"abort\", abortXhr);\n                }\n            };\n        }\n        xhr.send(typeof request._bodyInit === \"undefined\" ? null : request._bodyInit);\n    });\n}\nfetch.polyfill = true;\nif (!g.fetch) {\n    g.fetch = fetch;\n    g.Headers = Headers;\n    g.Request = Request;\n    g.Response = Response;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3doYXR3Zy1mZXRjaEAzLjYuMTkvbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHdDQUF3QyxHQUN4QyxJQUFJQSxJQUNGLE9BQVFDLGVBQWUsZUFBZUEsY0FDckMsT0FBT0MsU0FBUyxlQUFlQSxRQUNoQyxvQ0FBb0M7QUFDbkMsT0FBT0MsV0FBVyxlQUFlQSxVQUNsQyxDQUFDO0FBRUgsSUFBSUMsVUFBVTtJQUNaQyxjQUFjLHFCQUFxQkw7SUFDbkNNLFVBQVUsWUFBWU4sS0FBSyxjQUFjTztJQUN6Q0MsTUFDRSxnQkFBZ0JSLEtBQ2hCLFVBQVVBLEtBQ1Y7UUFDRSxJQUFJO1lBQ0YsSUFBSVM7WUFDSixPQUFPO1FBQ1QsRUFBRSxPQUFPQyxHQUFHO1lBQ1YsT0FBTztRQUNUO0lBQ0Y7SUFDRkMsVUFBVSxjQUFjWDtJQUN4QlksYUFBYSxpQkFBaUJaO0FBQ2hDO0FBRUEsU0FBU2EsV0FBV0MsR0FBRztJQUNyQixPQUFPQSxPQUFPQyxTQUFTQyxTQUFTLENBQUNDLGFBQWEsQ0FBQ0g7QUFDakQ7QUFFQSxJQUFJVixRQUFRUSxXQUFXLEVBQUU7SUFDdkIsSUFBSU0sY0FBYztRQUNoQjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUVELElBQUlDLG9CQUNGQyxZQUFZQyxNQUFNLElBQ2xCLFNBQVNQLEdBQUc7UUFDVixPQUFPQSxPQUFPSSxZQUFZSSxPQUFPLENBQUNDLE9BQU9QLFNBQVMsQ0FBQ1EsUUFBUSxDQUFDQyxJQUFJLENBQUNYLFFBQVEsQ0FBQztJQUM1RTtBQUNKO0FBRUEsU0FBU1ksY0FBY0MsSUFBSTtJQUN6QixJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUM1QkEsT0FBT0MsT0FBT0Q7SUFDaEI7SUFDQSxJQUFJLDZCQUE2QkUsSUFBSSxDQUFDRixTQUFTQSxTQUFTLElBQUk7UUFDMUQsTUFBTSxJ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LE1BQU1NO1lBQzdCO1FBQ0Y7UUFFQSxJQUFJeUksUUFBUTNDLE1BQU0sRUFBRTtZQUNsQjJDLFFBQVEzQyxNQUFNLENBQUMrRCxnQkFBZ0IsQ0FBQyxTQUFTaEI7WUFFekNGLElBQUltQixrQkFBa0IsR0FBRztnQkFDdkIsNEJBQTRCO2dCQUM1QixJQUFJbkIsSUFBSW9CLFVBQVUsS0FBSyxHQUFHO29CQUN4QnRCLFFBQVEzQyxNQUFNLENBQUNrRSxtQkFBbUIsQ0FBQyxTQUFTbkI7Z0JBQzlDO1lBQ0Y7UUFDRjtRQUVBRixJQUFJc0IsSUFBSSxDQUFDLE9BQU94QixRQUFRdkUsU0FBUyxLQUFLLGNBQWMsT0FBT3VFLFFBQVF2RSxTQUFTO0lBQzlFO0FBQ0Y7QUFFQXFFLE1BQU0yQixRQUFRLEdBQUc7QUFFakIsSUFBSSxDQUFDbk0sRUFBRXdLLEtBQUssRUFBRTtJQUNaeEssRUFBRXdLLEtBQUssR0FBR0E7SUFDVnhLLEVBQUV5QyxPQUFPLEdBQUdBO0lBQ1p6QyxFQUFFeUgsT0FBTyxHQUFHQTtJQUNaekgsRUFBRXlKLFFBQVEsR0FBR0E7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3doYXR3Zy1mZXRjaEAzLjYuMTkvbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcz9hZmMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xudmFyIGcgPVxuICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMpIHx8XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpIHx8XG4gIHt9XG5cbnZhciBzdXBwb3J0ID0ge1xuICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIGcsXG4gIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBnICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICBibG9iOlxuICAgICdGaWxlUmVhZGVyJyBpbiBnICYmXG4gICAgJ0Jsb2InIGluIGcgJiZcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIGcsXG4gIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIGdcbn1cblxuZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG59XG5cbmlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICBdXG5cbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gIH1cbiAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH4hXS9pLnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZTogXCInICsgbmFtZSArICdcIicpXG4gIH1cbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKVxuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3Jcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICB0aGlzLm1hcCA9IHt9XG5cbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICBpZiAoaGVhZGVyLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlcnMgY29uc3RydWN0b3I6IGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQnICsgaGVhZGVyLmxlbmd0aClcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICB9LCB0aGlzKVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdXG4gIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbkhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2gobmFtZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaXRlbXMucHVzaCh2YWx1ZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5pZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xufVxuXG5mdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gIGlmIChib2R5Ll9ub0JvZHkpIHJldHVyblxuICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgfVxuICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgfVxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHZhciBtYXRjaCA9IC9jaGFyc2V0PShbQS1aYS16MC05Xy1dKykvLmV4ZWMoYmxvYi50eXBlKVxuICB2YXIgZW5jb2RpbmcgPSBtYXRjaCA/IG1hdGNoWzFdIDogJ3V0Zi04J1xuICByZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZylcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgaWYgKGJ1Zi5zbGljZSkge1xuICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gIH1cbn1cblxuZnVuY3Rpb24gQm9keSgpIHtcbiAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgLypcbiAgICAgIGZldGNoLW1vY2sgd3JhcHMgdGhlIFJlc3BvbnNlIG9iamVjdCBpbiBhbiBFUzYgUHJveHkgdG9cbiAgICAgIHByb3ZpZGUgdXNlZnVsIHRlc3QgaGFybmVzcyBmZWF0dXJlcyBzdWNoIGFzIGZsdXNoLiBIb3dldmVyLCBvblxuICAgICAgRVM1IGJyb3dzZXJzIHdpdGhvdXQgZmV0Y2ggb3IgUHJveHkgc3VwcG9ydCBwb2xseWZpbGxzIG11c3QgYmUgdXNlZDtcbiAgICAgIHRoZSBwcm94eS1wb2xseWZpbGwgaXMgdW5hYmxlIHRvIHByb3h5IGFuIGF0dHJpYnV0ZSB1bmxlc3MgaXQgZXhpc3RzXG4gICAgICBvbiB0aGUgb2JqZWN0IGJlZm9yZSB0aGUgUHJveHkgaXMgY3JlYXRlZC4gVGhpcyBjaGFuZ2UgZW5zdXJlc1xuICAgICAgUmVzcG9uc2UuYm9keVVzZWQgZXhpc3RzIG9uIHRoZSBpbnN0YW5jZSwgd2hpbGUgbWFpbnRhaW5pbmcgdGhlXG4gICAgICBzZW1hbnRpYyBvZiBzZXR0aW5nIFJlcXVlc3QuYm9keVVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgX2luaXRCb2R5IGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIHRoaXMuYm9keVVzZWQgPSB0aGlzLmJvZHlVc2VkXG4gICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aGlzLl9ub0JvZHkgPSB0cnVlO1xuICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBpc0NvbnN1bWVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChpc0NvbnN1bWVkKSB7XG4gICAgICAgIHJldHVybiBpc0NvbnN1bWVkXG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQgKyB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBhcyBBcnJheUJ1ZmZlcicpXG4gICAgfVxuICB9XG5cbiAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3RlZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxudmFyIG1ldGhvZHMgPSBbJ0NPTk5FQ1QnLCAnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUEFUQ0gnLCAnUE9TVCcsICdQVVQnLCAnVFJBQ0UnXVxuXG5mdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgfVxuICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsXG4gICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpXG4gIH1cblxuICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbidcbiAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB9XG4gIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbCB8fCAoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnQWJvcnRDb250cm9sbGVyJyBpbiBnKSB7XG4gICAgICB2YXIgY3RybCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHJldHVybiBjdHJsLnNpZ25hbDtcbiAgICB9XG4gIH0oKSk7XG4gIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgfVxuICB0aGlzLl9pbml0Qm9keShib2R5KVxuXG4gIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgIGlmIChvcHRpb25zLmNhY2hlID09PSAnbm8tc3RvcmUnIHx8IG9wdGlvbnMuY2FjaGUgPT09ICduby1jYWNoZScpIHtcbiAgICAgIC8vIFNlYXJjaCBmb3IgYSAnXycgcGFyYW1ldGVyIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgIHZhciByZVBhcmFtU2VhcmNoID0gLyhbPyZdKV89W14mXSovXG4gICAgICBpZiAocmVQYXJhbVNlYXJjaC50ZXN0KHRoaXMudXJsKSkge1xuICAgICAgICAvLyBJZiBpdCBhbHJlYWR5IGV4aXN0cyB0aGVuIHNldCB0aGUgdmFsdWUgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHRoaXMudXJsID0gdGhpcy51cmwucmVwbGFjZShyZVBhcmFtU2VhcmNoLCAnJDFfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBhZGQgYSBuZXcgJ18nIHBhcmFtZXRlciB0byB0aGUgZW5kIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB2YXIgcmVRdWVyeVN0cmluZyA9IC9cXD8vXG4gICAgICAgIHRoaXMudXJsICs9IChyZVF1ZXJ5U3RyaW5nLnRlc3QodGhpcy51cmwpID8gJyYnIDogJz8nKSArICdfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBib2R5XG4gICAgLnRyaW0oKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBmb3JtXG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpXG4gIC8vIEF2b2lkaW5nIHNwbGl0IHZpYSByZWdleCB0byB3b3JrIGFyb3VuZCBhIGNvbW1vbiBJRTExIGJ1ZyB3aXRoIHRoZSBjb3JlLWpzIDMuNi4wIHJlZ2V4IHBvbHlmaWxsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvaXNzdWVzLzc0OFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNzUxXG4gIHByZVByb2Nlc3NlZEhlYWRlcnNcbiAgICAuc3BsaXQoJ1xccicpXG4gICAgLm1hcChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHJldHVybiBoZWFkZXIuaW5kZXhPZignXFxuJykgPT09IDAgPyBoZWFkZXIuc3Vic3RyKDEsIGhlYWRlci5sZW5ndGgpIDogaGVhZGVyXG4gICAgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Jlc3BvbnNlICcgKyBlcnJvci5tZXNzYWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG5leHBvcnQgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1c1xuICBpZiAodGhpcy5zdGF0dXMgPCAyMDAgfHwgdGhpcy5zdGF0dXMgPiA1OTkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Jlc3BvbnNlJzogVGhlIHN0YXR1cyBwcm92aWRlZCAoMCkgaXMgb3V0c2lkZSB0aGUgcmFuZ2UgWzIwMCwgNTk5XS5cIilcbiAgfVxuICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiAnJyArIG9wdGlvbnMuc3RhdHVzVGV4dFxuICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG59XG5cbkJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cblJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICB1cmw6IHRoaXMudXJsXG4gIH0pXG59XG5cblJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAyMDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgcmVzcG9uc2Uuc3RhdHVzID0gMFxuICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxudmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cblJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxufVxuXG5leHBvcnQgdmFyIERPTUV4Y2VwdGlvbiA9IGcuRE9NRXhjZXB0aW9uXG50cnkge1xuICBuZXcgRE9NRXhjZXB0aW9uKClcbn0gY2F0Y2ggKGVycikge1xuICBET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKVxuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFja1xuICB9XG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERPTUV4Y2VwdGlvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgeGhyLmFib3J0KClcbiAgICB9XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICB9XG4gICAgICAvLyBUaGlzIGNoZWNrIGlmIHNwZWNpZmljYWxseSBmb3Igd2hlbiBhIHVzZXIgZmV0Y2hlcyBhIGZpbGUgbG9jYWxseSBmcm9tIHRoZSBmaWxlIHN5c3RlbVxuICAgICAgLy8gT25seSBpZiB0aGUgc3RhdHVzIGlzIG91dCBvZiBhIG5vcm1hbCByYW5nZVxuICAgICAgaWYgKHJlcXVlc3QudXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSAmJiAoeGhyLnN0YXR1cyA8IDIwMCB8fCB4aHIuc3RhdHVzID4gNTk5KSkge1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IDIwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgdGltZWQgb3V0JykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFVybCh1cmwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cmwgPT09ICcnICYmIGcubG9jYXRpb24uaHJlZiA/IGcubG9jYXRpb24uaHJlZiA6IHVybFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdXJsXG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIGZpeFVybChyZXF1ZXN0LnVybCksIHRydWUpXG5cbiAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKSB7XG4gICAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHN1cHBvcnQuYXJyYXlCdWZmZXJcbiAgICAgICkge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbml0ICYmIHR5cGVvZiBpbml0LmhlYWRlcnMgPT09ICdvYmplY3QnICYmICEoaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycyB8fCAoZy5IZWFkZXJzICYmIGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIGcuSGVhZGVycykpKSB7XG4gICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaXQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWVzLnB1c2gobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgbm9ybWFsaXplVmFsdWUoaW5pdC5oZWFkZXJzW25hbWVdKSlcbiAgICAgIH0pXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcblxuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICB9KVxufVxuXG5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcblxuaWYgKCFnLmZldGNoKSB7XG4gIGcuZmV0Y2ggPSBmZXRjaFxuICBnLkhlYWRlcnMgPSBIZWFkZXJzXG4gIGcuUmVxdWVzdCA9IFJlcXVlc3RcbiAgZy5SZXNwb25zZSA9IFJlc3BvbnNlXG59XG4iXSwibmFtZXMiOlsiZyIsImdsb2JhbFRoaXMiLCJzZWxmIiwiZ2xvYmFsIiwic3VwcG9ydCIsInNlYXJjaFBhcmFtcyIsIml0ZXJhYmxlIiwiU3ltYm9sIiwiYmxvYiIsIkJsb2IiLCJlIiwiZm9ybURhdGEiLCJhcnJheUJ1ZmZlciIsImlzRGF0YVZpZXciLCJvYmoiLCJEYXRhVmlldyIsInByb3RvdHlwZSIsImlzUHJvdG90eXBlT2YiLCJ2aWV3Q2xhc3NlcyIsImlzQXJyYXlCdWZmZXJWaWV3IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJpbmRleE9mIiwiT2JqZWN0IiwidG9TdHJpbmciLCJjYWxsIiwibm9ybWFsaXplTmFtZSIsIm5hbWUiLCJTdHJpbmciLCJ0ZXN0IiwiVHlwZUVycm9yIiwidG9Mb3dlckNhc2UiLCJub3JtYWxpemVWYWx1ZSIsInZhbHVlIiwiaXRlcmF0b3JGb3IiLCJpdGVtcyIsIml0ZXJhdG9yIiwibmV4dCIsInNoaWZ0IiwiZG9uZSIsInVuZGVmaW5lZCIsIkhlYWRlcnMiLCJoZWFkZXJzIiwibWFwIiwiZm9yRWFjaCIsImFwcGVuZCIsIkFycmF5IiwiaXNBcnJheSIsImhlYWRlciIsImxlbmd0aCIsImdldE93blByb3BlcnR5TmFtZXMiLCJvbGRWYWx1ZSIsImdldCIsImhhcyIsImhhc093blByb3BlcnR5Iiwic2V0IiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwia2V5cyIsInB1c2giLCJ2YWx1ZXMiLCJlbnRyaWVzIiwiY29uc3VtZWQiLCJib2R5IiwiX25vQm9keSIsImJvZHlVc2VkIiwiUHJvbWlzZSIsInJlamVjdCIsImZpbGVSZWFkZXJSZWFkeSIsInJlYWRlciIsInJlc29sdmUiLCJvbmxvYWQiLCJyZXN1bHQiLCJvbmVycm9yIiwiZXJyb3IiLCJyZWFkQmxvYkFzQXJyYXlCdWZmZXIiLCJGaWxlUmVhZGVyIiwicHJvbWlzZSIsInJlYWRBc0FycmF5QnVmZmVyIiwicmVhZEJsb2JBc1RleHQiLCJtYXRjaCIsImV4ZWMiLCJ0eXBlIiwiZW5jb2RpbmciLCJyZWFkQXNUZXh0IiwicmVhZEFycmF5QnVmZmVyQXNUZXh0IiwiYnVmIiwidmlldyIsIlVpbnQ4QXJyYXkiLCJjaGFycyIsImkiLCJmcm9tQ2hhckNvZGUiLCJqb2luIiwiYnVmZmVyQ2xvbmUiLCJzbGljZSIsImJ5dGVMZW5ndGgiLCJidWZmZXIiLCJCb2R5IiwiX2luaXRCb2R5IiwiX2JvZHlJbml0IiwiX2JvZHlUZXh0IiwiX2JvZHlCbG9iIiwiRm9ybURhdGEiLCJfYm9keUZvcm1EYXRhIiwiVVJMU2VhcmNoUGFyYW1zIiwiX2JvZHlBcnJheUJ1ZmZlciIsInJlamVjdGVkIiwiRXJyb3IiLCJpc0NvbnN1bWVkIiwiYnl0ZU9mZnNldCIsInRoZW4iLCJ0ZXh0IiwiZGVjb2RlIiwianNvbiIsIkpTT04iLCJwYXJzZSIsIm1ldGhvZHMiLCJub3JtYWxpemVNZXRob2QiLCJtZXRob2QiLCJ1cGNhc2VkIiwidG9VcHBlckNhc2UiLCJSZXF1ZXN0IiwiaW5wdXQiLCJvcHRpb25zIiwidXJsIiwiY3JlZGVudGlhbHMiLCJtb2RlIiwic2lnbmFsIiwiY3RybCIsIkFib3J0Q29udHJvbGxlciIsInJlZmVycmVyIiwiY2FjaGUiLCJyZVBhcmFtU2VhcmNoIiwicmVwbGFjZSIsIkRhdGUiLCJnZXRUaW1lIiwicmVRdWVyeVN0cmluZyIsImNsb25lIiwiZm9ybSIsInRyaW0iLCJzcGxpdCIsImJ5dGVzIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyc2VIZWFkZXJzIiwicmF3SGVhZGVycyIsInByZVByb2Nlc3NlZEhlYWRlcnMiLCJzdWJzdHIiLCJsaW5lIiwicGFydHMiLCJrZXkiLCJjb25zb2xlIiwid2FybiIsIm1lc3NhZ2UiLCJSZXNwb25zZSIsImJvZHlJbml0Iiwic3RhdHVzIiwiUmFuZ2VFcnJvciIsIm9rIiwic3RhdHVzVGV4dCIsInJlc3BvbnNlIiwicmVkaXJlY3RTdGF0dXNlcyIsInJlZGlyZWN0IiwibG9jYXRpb24iLCJET01FeGNlcHRpb24iLCJlcnIiLCJzdGFjayIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiZmV0Y2giLCJpbml0IiwicmVxdWVzdCIsImFib3J0ZWQiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsImFib3J0WGhyIiwiYWJvcnQiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzdGFydHNXaXRoIiwicmVzcG9uc2VVUkwiLCJyZXNwb25zZVRleHQiLCJzZXRUaW1lb3V0Iiwib250aW1lb3V0Iiwib25hYm9ydCIsImZpeFVybCIsImhyZWYiLCJvcGVuIiwid2l0aENyZWRlbnRpYWxzIiwicmVzcG9uc2VUeXBlIiwibmFtZXMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2VuZCIsInBvbHlmaWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/whatwg-fetch@3.6.19/node_modules/whatwg-fetch/fetch.js\n");

/***/ })

};
;