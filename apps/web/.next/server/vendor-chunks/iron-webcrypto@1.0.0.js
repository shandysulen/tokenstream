"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iron-webcrypto@1.0.0";
exports.ids = ["vendor-chunks/iron-webcrypto@1.0.0"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/iron-webcrypto@1.0.0/node_modules/iron-webcrypto/dist/index.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/iron-webcrypto@1.0.0/node_modules/iron-webcrypto/dist/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   algorithms: () => (/* binding */ algorithms),\n/* harmony export */   base64urlDecode: () => (/* binding */ base64urlDecode),\n/* harmony export */   base64urlEncode: () => (/* binding */ base64urlEncode),\n/* harmony export */   bufferToString: () => (/* binding */ bufferToString),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generateKey: () => (/* binding */ generateKey),\n/* harmony export */   hmacWithPassword: () => (/* binding */ hmacWithPassword),\n/* harmony export */   macFormatVersion: () => (/* binding */ macFormatVersion),\n/* harmony export */   macPrefix: () => (/* binding */ macPrefix),\n/* harmony export */   randomBits: () => (/* binding */ randomBits),\n/* harmony export */   seal: () => (/* binding */ seal),\n/* harmony export */   stringToBuffer: () => (/* binding */ stringToBuffer),\n/* harmony export */   unseal: () => (/* binding */ unseal)\n/* harmony export */ });\n// node_modules/.pnpm/@smithy+util-base64@2.0.0/node_modules/@smithy/util-base64/dist-es/constants.browser.js\nvar alphabetByEncoding = {};\nvar alphabetByValue = new Array(64);\nfor(let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++){\n    const char = String.fromCharCode(i + start);\n    alphabetByEncoding[char] = i;\n    alphabetByValue[i] = char;\n}\nfor(let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++){\n    const char = String.fromCharCode(i + start);\n    const index = i + 26;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nfor(let i = 0; i < 10; i++){\n    alphabetByEncoding[i.toString(10)] = i + 52;\n    const char = i.toString(10);\n    const index = i + 52;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\n// node_modules/.pnpm/@smithy+util-base64@2.0.0/node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js\nvar fromBase64 = (input)=>{\n    let totalByteLength = input.length / 4 * 3;\n    if (input.slice(-2) === \"==\") {\n        totalByteLength -= 2;\n    } else if (input.slice(-1) === \"=\") {\n        totalByteLength--;\n    }\n    const out = new ArrayBuffer(totalByteLength);\n    const dataView = new DataView(out);\n    for(let i = 0; i < input.length; i += 4){\n        let bits = 0;\n        let bitLength = 0;\n        for(let j = i, limit = i + 3; j <= limit; j++){\n            if (input[j] !== \"=\") {\n                if (!(input[j] in alphabetByEncoding)) {\n                    throw new TypeError(`Invalid character ${input[j]} in base64 string.`);\n                }\n                bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n                bitLength += bitsPerLetter;\n            } else {\n                bits >>= bitsPerLetter;\n            }\n        }\n        const chunkOffset = i / 4 * 3;\n        bits >>= bitLength % bitsPerByte;\n        const byteLength = Math.floor(bitLength / bitsPerByte);\n        for(let k = 0; k < byteLength; k++){\n            const offset = (byteLength - k - 1) * bitsPerByte;\n            dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n        }\n    }\n    return new Uint8Array(out);\n};\n// node_modules/.pnpm/@smithy+util-base64@2.0.0/node_modules/@smithy/util-base64/dist-es/toBase64.browser.js\nfunction toBase64(input) {\n    let str = \"\";\n    for(let i = 0; i < input.length; i += 3){\n        let bits = 0;\n        let bitLength = 0;\n        for(let j = i, limit = Math.min(i + 3, input.length); j < limit; j++){\n            bits |= input[j] << (limit - j - 1) * bitsPerByte;\n            bitLength += bitsPerByte;\n        }\n        const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n        bits <<= bitClusterCount * bitsPerLetter - bitLength;\n        for(let k = 1; k <= bitClusterCount; k++){\n            const offset = (bitClusterCount - k) * bitsPerLetter;\n            str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n        }\n        str += \"==\".slice(0, 4 - bitClusterCount);\n    }\n    return str;\n}\n// src/index.ts\nvar stringToBuffer = (value)=>{\n    return new TextEncoder().encode(value);\n};\nvar bufferToString = (value)=>{\n    return new TextDecoder().decode(value);\n};\nvar base64urlEncode = (value)=>toBase64(typeof value === \"string\" ? stringToBuffer(value) : value).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\nvar base64urlDecode = (value)=>fromBase64(value.replace(/-/g, \"+\").replace(/_/g, \"/\") + Array((4 - value.length % 4) % 4 + 1).join(\"=\"));\nvar defaults = {\n    encryption: {\n        saltBits: 256,\n        algorithm: \"aes-256-cbc\",\n        iterations: 1,\n        minPasswordlength: 32\n    },\n    integrity: {\n        saltBits: 256,\n        algorithm: \"sha256\",\n        iterations: 1,\n        minPasswordlength: 32\n    },\n    ttl: 0,\n    timestampSkewSec: 60,\n    localtimeOffsetMsec: 0\n};\nvar clone = (options)=>({\n        ...options,\n        encryption: {\n            ...options.encryption\n        },\n        integrity: {\n            ...options.integrity\n        }\n    });\nvar algorithms = {\n    \"aes-128-ctr\": {\n        keyBits: 128,\n        ivBits: 128,\n        name: \"AES-CTR\"\n    },\n    \"aes-256-cbc\": {\n        keyBits: 256,\n        ivBits: 128,\n        name: \"AES-CBC\"\n    },\n    sha256: {\n        keyBits: 256,\n        name: \"SHA-256\"\n    }\n};\nvar macFormatVersion = \"2\";\nvar macPrefix = `Fe26.${macFormatVersion}`;\nvar randomBytes = (_crypto, size)=>{\n    const bytes = new Uint8Array(size);\n    _crypto.getRandomValues(bytes);\n    return bytes;\n};\nvar randomBits = (_crypto, bits)=>{\n    if (bits < 1) throw Error(\"Invalid random bits count\");\n    const bytes = Math.ceil(bits / 8);\n    return randomBytes(_crypto, bytes);\n};\nvar pbkdf2 = async (_crypto, password, salt, iterations, keyLength, hash)=>{\n    const passwordBuffer = stringToBuffer(password);\n    const importedKey = await _crypto.subtle.importKey(\"raw\", passwordBuffer, \"PBKDF2\", false, [\n        \"deriveBits\"\n    ]);\n    const saltBuffer = stringToBuffer(salt);\n    const params = {\n        name: \"PBKDF2\",\n        hash,\n        salt: saltBuffer,\n        iterations\n    };\n    const derivation = await _crypto.subtle.deriveBits(params, importedKey, keyLength * 8);\n    return derivation;\n};\nvar generateKey = async (_crypto, password, options)=>{\n    var _a;\n    if (!(password == null ? void 0 : password.length)) throw new Error(\"Empty password\");\n    if (options == null || typeof options !== \"object\") throw new Error(\"Bad options\");\n    if (!(options.algorithm in algorithms)) throw new Error(`Unknown algorithm: ${options.algorithm}`);\n    const algorithm = algorithms[options.algorithm];\n    const result = {};\n    const hmac = (_a = options.hmac) != null ? _a : false;\n    const id = hmac ? {\n        name: \"HMAC\",\n        hash: algorithm.name\n    } : {\n        name: algorithm.name\n    };\n    const usage = hmac ? [\n        \"sign\",\n        \"verify\"\n    ] : [\n        \"encrypt\",\n        \"decrypt\"\n    ];\n    if (typeof password === \"string\") {\n        if (password.length < options.minPasswordlength) throw new Error(`Password string too short (min ${options.minPasswordlength} characters required)`);\n        let { salt = \"\" } = options;\n        if (!salt) {\n            const { saltBits = 0 } = options;\n            if (!saltBits) throw new Error(\"Missing salt and saltBits options\");\n            const randomSalt = randomBits(_crypto, saltBits);\n            salt = [\n                ...new Uint8Array(randomSalt)\n            ].map((x)=>x.toString(16).padStart(2, \"0\")).join(\"\");\n        }\n        const derivedKey = await pbkdf2(_crypto, password, salt, options.iterations, algorithm.keyBits / 8, \"SHA-1\");\n        const importedEncryptionKey = await _crypto.subtle.importKey(\"raw\", derivedKey, id, false, usage);\n        result.key = importedEncryptionKey;\n        result.salt = salt;\n    } else {\n        if (password.length < algorithm.keyBits / 8) throw new Error(\"Key buffer (password) too small\");\n        result.key = await _crypto.subtle.importKey(\"raw\", password, id, false, usage);\n        result.salt = \"\";\n    }\n    if (options.iv) result.iv = options.iv;\n    else if (\"ivBits\" in algorithm) result.iv = randomBits(_crypto, algorithm.ivBits);\n    return result;\n};\nvar encrypt = async (_crypto, password, options, data)=>{\n    const key = await generateKey(_crypto, password, options);\n    const textBuffer = stringToBuffer(data);\n    const encrypted = await _crypto.subtle.encrypt({\n        name: algorithms[options.algorithm].name,\n        iv: key.iv\n    }, key.key, textBuffer);\n    return {\n        encrypted: new Uint8Array(encrypted),\n        key\n    };\n};\nvar decrypt = async (_crypto, password, options, data)=>{\n    const key = await generateKey(_crypto, password, options);\n    const decrypted = await _crypto.subtle.decrypt({\n        name: algorithms[options.algorithm].name,\n        iv: key.iv\n    }, key.key, typeof data === \"string\" ? stringToBuffer(data) : data);\n    return bufferToString(new Uint8Array(decrypted));\n};\nvar hmacWithPassword = async (_crypto, password, options, data)=>{\n    const key = await generateKey(_crypto, password, {\n        ...options,\n        hmac: true\n    });\n    const textBuffer = stringToBuffer(data);\n    const signed = await _crypto.subtle.sign({\n        name: \"HMAC\"\n    }, key.key, textBuffer);\n    const digest = base64urlEncode(new Uint8Array(signed));\n    return {\n        digest,\n        salt: key.salt\n    };\n};\nvar normalizePassword = (password)=>{\n    if (typeof password === \"string\" || password instanceof Uint8Array) return {\n        encryption: password,\n        integrity: password\n    };\n    if (\"secret\" in password) return {\n        id: password.id,\n        encryption: password.secret,\n        integrity: password.secret\n    };\n    return {\n        id: password.id,\n        encryption: password.encryption,\n        integrity: password.integrity\n    };\n};\nvar seal = async (_crypto, object, password, options)=>{\n    if (!password) throw Error(\"Empty password\");\n    const opts = clone(options);\n    const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n    const objectString = JSON.stringify(object);\n    const pass = normalizePassword(password);\n    const { id = \"\" } = pass;\n    if (id && !/^\\w+$/.test(id)) throw new Error(\"Invalid password id\");\n    const { encrypted, key } = await encrypt(_crypto, pass.encryption, opts.encryption, objectString);\n    const encryptedB64 = base64urlEncode(new Uint8Array(encrypted));\n    const iv = base64urlEncode(key.iv);\n    const expiration = opts.ttl ? now + opts.ttl : \"\";\n    const macBaseString = `${macPrefix}*${id}*${key.salt}*${iv}*${encryptedB64}*${expiration}`;\n    const mac = await hmacWithPassword(_crypto, pass.integrity, opts.integrity, macBaseString);\n    const sealed = `${macBaseString}*${mac.salt}*${mac.digest}`;\n    return sealed;\n};\nvar fixedTimeComparison = (a, b)=>{\n    let mismatch = a.length === b.length ? 0 : 1;\n    if (mismatch) b = a;\n    for(let i = 0; i < a.length; i += 1)mismatch |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    return mismatch === 0;\n};\nvar unseal = async (_crypto, sealed, password, options)=>{\n    if (!password) throw Error(\"Empty password\");\n    const opts = clone(options);\n    const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n    const parts = sealed.split(\"*\");\n    if (parts.length !== 8) throw new Error(\"Incorrect number of sealed components\");\n    const prefix = parts[0];\n    let passwordId = parts[1];\n    const encryptionSalt = parts[2];\n    const encryptionIv = parts[3];\n    const encryptedB64 = parts[4];\n    const expiration = parts[5];\n    const hmacSalt = parts[6];\n    const hmac = parts[7];\n    const macBaseString = `${prefix}*${passwordId}*${encryptionSalt}*${encryptionIv}*${encryptedB64}*${expiration}`;\n    if (macPrefix !== prefix) throw new Error(\"Wrong mac prefix\");\n    if (expiration) {\n        if (!/^\\d+$/.exec(expiration)) throw new Error(\"Invalid expiration\");\n        const exp = parseInt(expiration, 10);\n        if (exp <= now - opts.timestampSkewSec * 1e3) throw new Error(\"Expired seal\");\n    }\n    if (typeof password === \"undefined\" || typeof password === \"string\" && password.length === 0) throw new Error(\"Empty password\");\n    let pass = \"\";\n    passwordId = passwordId || \"default\";\n    if (typeof password === \"string\" || password instanceof Uint8Array) pass = password;\n    else if (!(passwordId in password)) throw new Error(`Cannot find password: ${passwordId}`);\n    else pass = password[passwordId];\n    pass = normalizePassword(pass);\n    const macOptions = opts.integrity;\n    macOptions.salt = hmacSalt;\n    const mac = await hmacWithPassword(_crypto, pass.integrity, macOptions, macBaseString);\n    if (!fixedTimeComparison(mac.digest, hmac)) throw new Error(\"Bad hmac value\");\n    const encrypted = base64urlDecode(encryptedB64);\n    const decryptOptions = opts.encryption;\n    decryptOptions.salt = encryptionSalt;\n    decryptOptions.iv = base64urlDecode(encryptionIv);\n    const decrypted = await decrypt(_crypto, pass.encryption, decryptOptions, encrypted);\n    if (decrypted) return JSON.parse(decrypted);\n    return null;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lyb24td2ViY3J5cHRvQDEuMC4wL25vZGVfbW9kdWxlcy9pcm9uLXdlYmNyeXB0by9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2R0FBNkc7QUFDN0csSUFBSUEscUJBQXFCLENBQUM7QUFDMUIsSUFBSUMsa0JBQWtCLElBQUlDLE1BQU07QUFDaEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLFFBQVEsSUFBSUMsVUFBVSxDQUFDLElBQUlDLFFBQVEsSUFBSUQsVUFBVSxDQUFDLElBQUlGLElBQUlDLFNBQVNFLE9BQU9ILElBQUs7SUFDN0YsTUFBTUksT0FBT0MsT0FBT0MsWUFBWSxDQUFDTixJQUFJQztJQUNyQ0osa0JBQWtCLENBQUNPLEtBQUssR0FBR0o7SUFDM0JGLGVBQWUsQ0FBQ0UsRUFBRSxHQUFHSTtBQUN2QjtBQUNBLElBQUssSUFBSUosSUFBSSxHQUFHQyxRQUFRLElBQUlDLFVBQVUsQ0FBQyxJQUFJQyxRQUFRLElBQUlELFVBQVUsQ0FBQyxJQUFJRixJQUFJQyxTQUFTRSxPQUFPSCxJQUFLO0lBQzdGLE1BQU1JLE9BQU9DLE9BQU9DLFlBQVksQ0FBQ04sSUFBSUM7SUFDckMsTUFBTU0sUUFBUVAsSUFBSTtJQUNsQkgsa0JBQWtCLENBQUNPLEtBQUssR0FBR0c7SUFDM0JULGVBQWUsQ0FBQ1MsTUFBTSxHQUFHSDtBQUMzQjtBQUNBLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7SUFDM0JILGtCQUFrQixDQUFDRyxFQUFFUSxRQUFRLENBQUMsSUFBSSxHQUFHUixJQUFJO0lBQ3pDLE1BQU1JLE9BQU9KLEVBQUVRLFFBQVEsQ0FBQztJQUN4QixNQUFNRCxRQUFRUCxJQUFJO0lBQ2xCSCxrQkFBa0IsQ0FBQ08sS0FBSyxHQUFHRztJQUMzQlQsZUFBZSxDQUFDUyxNQUFNLEdBQUdIO0FBQzNCO0FBQ0FQLGtCQUFrQixDQUFDLElBQUks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TUQsS0FBSzNELGdCQUFnQixHQUFHLEtBQ3ZDLE1BQU0sSUFBSWlCLE1BQU07SUFDcEI7SUFDQSxJQUFJLE9BQU9FLGFBQWEsZUFBZSxPQUFPQSxhQUFhLFlBQVlBLFNBQVM3RCxNQUFNLEtBQUssR0FDekYsTUFBTSxJQUFJMkQsTUFBTTtJQUNsQixJQUFJZ0QsT0FBTztJQUNYZSxhQUFhQSxjQUFjO0lBQzNCLElBQUksT0FBTzdELGFBQWEsWUFBWUEsb0JBQW9CNUMsWUFDdEQwRixPQUFPOUM7U0FDSixJQUFJLENBQUU2RCxDQUFBQSxjQUFjN0QsUUFBTyxHQUM5QixNQUFNLElBQUlGLE1BQU0sQ0FBQyxzQkFBc0IsRUFBRStELFdBQVcsQ0FBQztTQUVyRGYsT0FBTzlDLFFBQVEsQ0FBQzZELFdBQVc7SUFDN0JmLE9BQU9WLGtCQUFrQlU7SUFDekIsTUFBTXNCLGFBQWE1QixLQUFLN0QsU0FBUztJQUNqQ3lGLFdBQVduRSxJQUFJLEdBQUcrRDtJQUNsQixNQUFNYixNQUFNLE1BQU1uQixpQkFBaUJ2QyxTQUFTcUQsS0FBS25FLFNBQVMsRUFBRXlGLFlBQVlsQjtJQUN4RSxJQUFJLENBQUNHLG9CQUFvQkYsSUFBSWhCLE1BQU0sRUFBRXBCLE9BQ25DLE1BQU0sSUFBSWpCLE1BQU07SUFDbEIsTUFBTStCLFlBQVkxRCxnQkFBZ0I2RTtJQUNsQyxNQUFNcUIsaUJBQWlCN0IsS0FBS2xFLFVBQVU7SUFDdEMrRixlQUFlcEUsSUFBSSxHQUFHNkQ7SUFDdEJPLGVBQWU1QyxFQUFFLEdBQUd0RCxnQkFBZ0I0RjtJQUNwQyxNQUFNaEMsWUFBWSxNQUFNRCxRQUFRckMsU0FBU3FELEtBQUt4RSxVQUFVLEVBQUUrRixnQkFBZ0J4QztJQUMxRSxJQUFJRSxXQUNGLE9BQU9hLEtBQUswQixLQUFLLENBQUN2QztJQUNwQixPQUFPO0FBQ1Q7QUFFaU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcm9uLXdlYmNyeXB0b0AxLjAuMC9ub2RlX21vZHVsZXMvaXJvbi13ZWJjcnlwdG8vZGlzdC9pbmRleC5qcz9kZjAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9Ac21pdGh5K3V0aWwtYmFzZTY0QDIuMC4wL25vZGVfbW9kdWxlcy9Ac21pdGh5L3V0aWwtYmFzZTY0L2Rpc3QtZXMvY29uc3RhbnRzLmJyb3dzZXIuanNcbnZhciBhbHBoYWJldEJ5RW5jb2RpbmcgPSB7fTtcbnZhciBhbHBoYWJldEJ5VmFsdWUgPSBuZXcgQXJyYXkoNjQpO1xuZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gXCJBXCIuY2hhckNvZGVBdCgwKSwgbGltaXQgPSBcIlpcIi5jaGFyQ29kZUF0KDApOyBpICsgc3RhcnQgPD0gbGltaXQ7IGkrKykge1xuICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgc3RhcnQpO1xuICBhbHBoYWJldEJ5RW5jb2RpbmdbY2hhcl0gPSBpO1xuICBhbHBoYWJldEJ5VmFsdWVbaV0gPSBjaGFyO1xufVxuZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gXCJhXCIuY2hhckNvZGVBdCgwKSwgbGltaXQgPSBcInpcIi5jaGFyQ29kZUF0KDApOyBpICsgc3RhcnQgPD0gbGltaXQ7IGkrKykge1xuICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgc3RhcnQpO1xuICBjb25zdCBpbmRleCA9IGkgKyAyNjtcbiAgYWxwaGFiZXRCeUVuY29kaW5nW2NoYXJdID0gaW5kZXg7XG4gIGFscGhhYmV0QnlWYWx1ZVtpbmRleF0gPSBjaGFyO1xufVxuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gIGFscGhhYmV0QnlFbmNvZGluZ1tpLnRvU3RyaW5nKDEwKV0gPSBpICsgNTI7XG4gIGNvbnN0IGNoYXIgPSBpLnRvU3RyaW5nKDEwKTtcbiAgY29uc3QgaW5kZXggPSBpICsgNTI7XG4gIGFscGhhYmV0QnlFbmNvZGluZ1tjaGFyXSA9IGluZGV4O1xuICBhbHBoYWJldEJ5VmFsdWVbaW5kZXhdID0gY2hhcjtcbn1cbmFscGhhYmV0QnlFbmNvZGluZ1tcIitcIl0gPSA2MjtcbmFscGhhYmV0QnlWYWx1ZVs2Ml0gPSBcIitcIjtcbmFscGhhYmV0QnlFbmNvZGluZ1tcIi9cIl0gPSA2MztcbmFscGhhYmV0QnlWYWx1ZVs2M10gPSBcIi9cIjtcbnZhciBiaXRzUGVyTGV0dGVyID0gNjtcbnZhciBiaXRzUGVyQnl0ZSA9IDg7XG52YXIgbWF4TGV0dGVyVmFsdWUgPSA2MztcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BzbWl0aHkrdXRpbC1iYXNlNjRAMi4wLjAvbm9kZV9tb2R1bGVzL0BzbWl0aHkvdXRpbC1iYXNlNjQvZGlzdC1lcy9mcm9tQmFzZTY0LmJyb3dzZXIuanNcbnZhciBmcm9tQmFzZTY0ID0gKGlucHV0KSA9PiB7XG4gIGxldCB0b3RhbEJ5dGVMZW5ndGggPSBpbnB1dC5sZW5ndGggLyA0ICogMztcbiAgaWYgKGlucHV0LnNsaWNlKC0yKSA9PT0gXCI9PVwiKSB7XG4gICAgdG90YWxCeXRlTGVuZ3RoIC09IDI7XG4gIH0gZWxzZSBpZiAoaW5wdXQuc2xpY2UoLTEpID09PSBcIj1cIikge1xuICAgIHRvdGFsQnl0ZUxlbmd0aC0tO1xuICB9XG4gIGNvbnN0IG91dCA9IG5ldyBBcnJheUJ1ZmZlcih0b3RhbEJ5dGVMZW5ndGgpO1xuICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhvdXQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSA0KSB7XG4gICAgbGV0IGJpdHMgPSAwO1xuICAgIGxldCBiaXRMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGogPSBpLCBsaW1pdCA9IGkgKyAzOyBqIDw9IGxpbWl0OyBqKyspIHtcbiAgICAgIGlmIChpbnB1dFtqXSAhPT0gXCI9XCIpIHtcbiAgICAgICAgaWYgKCEoaW5wdXRbal0gaW4gYWxwaGFiZXRCeUVuY29kaW5nKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyICR7aW5wdXRbal19IGluIGJhc2U2NCBzdHJpbmcuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYml0cyB8PSBhbHBoYWJldEJ5RW5jb2RpbmdbaW5wdXRbal1dIDw8IChsaW1pdCAtIGopICogYml0c1BlckxldHRlcjtcbiAgICAgICAgYml0TGVuZ3RoICs9IGJpdHNQZXJMZXR0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaXRzID4+PSBiaXRzUGVyTGV0dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaHVua09mZnNldCA9IGkgLyA0ICogMztcbiAgICBiaXRzID4+PSBiaXRMZW5ndGggJSBiaXRzUGVyQnl0ZTtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gTWF0aC5mbG9vcihiaXRMZW5ndGggLyBiaXRzUGVyQnl0ZSk7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBieXRlTGVuZ3RoOyBrKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChieXRlTGVuZ3RoIC0gayAtIDEpICogYml0c1BlckJ5dGU7XG4gICAgICBkYXRhVmlldy5zZXRVaW50OChjaHVua09mZnNldCArIGssIChiaXRzICYgMjU1IDw8IG9mZnNldCkgPj4gb2Zmc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG91dCk7XG59O1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vQHNtaXRoeSt1dGlsLWJhc2U2NEAyLjAuMC9ub2RlX21vZHVsZXMvQHNtaXRoeS91dGlsLWJhc2U2NC9kaXN0LWVzL3RvQmFzZTY0LmJyb3dzZXIuanNcbmZ1bmN0aW9uIHRvQmFzZTY0KGlucHV0KSB7XG4gIGxldCBzdHIgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAzKSB7XG4gICAgbGV0IGJpdHMgPSAwO1xuICAgIGxldCBiaXRMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGogPSBpLCBsaW1pdCA9IE1hdGgubWluKGkgKyAzLCBpbnB1dC5sZW5ndGgpOyBqIDwgbGltaXQ7IGorKykge1xuICAgICAgYml0cyB8PSBpbnB1dFtqXSA8PCAobGltaXQgLSBqIC0gMSkgKiBiaXRzUGVyQnl0ZTtcbiAgICAgIGJpdExlbmd0aCArPSBiaXRzUGVyQnl0ZTtcbiAgICB9XG4gICAgY29uc3QgYml0Q2x1c3RlckNvdW50ID0gTWF0aC5jZWlsKGJpdExlbmd0aCAvIGJpdHNQZXJMZXR0ZXIpO1xuICAgIGJpdHMgPDw9IGJpdENsdXN0ZXJDb3VudCAqIGJpdHNQZXJMZXR0ZXIgLSBiaXRMZW5ndGg7XG4gICAgZm9yIChsZXQgayA9IDE7IGsgPD0gYml0Q2x1c3RlckNvdW50OyBrKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChiaXRDbHVzdGVyQ291bnQgLSBrKSAqIGJpdHNQZXJMZXR0ZXI7XG4gICAgICBzdHIgKz0gYWxwaGFiZXRCeVZhbHVlWyhiaXRzICYgbWF4TGV0dGVyVmFsdWUgPDwgb2Zmc2V0KSA+PiBvZmZzZXRdO1xuICAgIH1cbiAgICBzdHIgKz0gXCI9PVwiLnNsaWNlKDAsIDQgLSBiaXRDbHVzdGVyQ291bnQpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHN0cmluZ1RvQnVmZmVyID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xufTtcbnZhciBidWZmZXJUb1N0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbn07XG52YXIgYmFzZTY0dXJsRW5jb2RlID0gKHZhbHVlKSA9PiB0b0Jhc2U2NCh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0J1ZmZlcih2YWx1ZSkgOiB2YWx1ZSkucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLz0vZywgXCJcIik7XG52YXIgYmFzZTY0dXJsRGVjb2RlID0gKHZhbHVlKSA9PiBmcm9tQmFzZTY0KFxuICB2YWx1ZS5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKSArIEFycmF5KCg0IC0gdmFsdWUubGVuZ3RoICUgNCkgJSA0ICsgMSkuam9pbihcIj1cIilcbik7XG52YXIgZGVmYXVsdHMgPSB7XG4gIGVuY3J5cHRpb246IHsgc2FsdEJpdHM6IDI1NiwgYWxnb3JpdGhtOiBcImFlcy0yNTYtY2JjXCIsIGl0ZXJhdGlvbnM6IDEsIG1pblBhc3N3b3JkbGVuZ3RoOiAzMiB9LFxuICBpbnRlZ3JpdHk6IHsgc2FsdEJpdHM6IDI1NiwgYWxnb3JpdGhtOiBcInNoYTI1NlwiLCBpdGVyYXRpb25zOiAxLCBtaW5QYXNzd29yZGxlbmd0aDogMzIgfSxcbiAgdHRsOiAwLFxuICB0aW1lc3RhbXBTa2V3U2VjOiA2MCxcbiAgbG9jYWx0aW1lT2Zmc2V0TXNlYzogMFxufTtcbnZhciBjbG9uZSA9IChvcHRpb25zKSA9PiAoe1xuICAuLi5vcHRpb25zLFxuICBlbmNyeXB0aW9uOiB7IC4uLm9wdGlvbnMuZW5jcnlwdGlvbiB9LFxuICBpbnRlZ3JpdHk6IHsgLi4ub3B0aW9ucy5pbnRlZ3JpdHkgfVxufSk7XG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgXCJhZXMtMTI4LWN0clwiOiB7IGtleUJpdHM6IDEyOCwgaXZCaXRzOiAxMjgsIG5hbWU6IFwiQUVTLUNUUlwiIH0sXG4gIFwiYWVzLTI1Ni1jYmNcIjogeyBrZXlCaXRzOiAyNTYsIGl2Qml0czogMTI4LCBuYW1lOiBcIkFFUy1DQkNcIiB9LFxuICBzaGEyNTY6IHsga2V5Qml0czogMjU2LCBuYW1lOiBcIlNIQS0yNTZcIiB9XG59O1xudmFyIG1hY0Zvcm1hdFZlcnNpb24gPSBcIjJcIjtcbnZhciBtYWNQcmVmaXggPSBgRmUyNi4ke21hY0Zvcm1hdFZlcnNpb259YDtcbnZhciByYW5kb21CeXRlcyA9IChfY3J5cHRvLCBzaXplKSA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgcmV0dXJuIGJ5dGVzO1xufTtcbnZhciByYW5kb21CaXRzID0gKF9jcnlwdG8sIGJpdHMpID0+IHtcbiAgaWYgKGJpdHMgPCAxKVxuICAgIHRocm93IEVycm9yKFwiSW52YWxpZCByYW5kb20gYml0cyBjb3VudFwiKTtcbiAgY29uc3QgYnl0ZXMgPSBNYXRoLmNlaWwoYml0cyAvIDgpO1xuICByZXR1cm4gcmFuZG9tQnl0ZXMoX2NyeXB0bywgYnl0ZXMpO1xufTtcbnZhciBwYmtkZjIgPSBhc3luYyAoX2NyeXB0bywgcGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleUxlbmd0aCwgaGFzaCkgPT4ge1xuICBjb25zdCBwYXNzd29yZEJ1ZmZlciA9IHN0cmluZ1RvQnVmZmVyKHBhc3N3b3JkKTtcbiAgY29uc3QgaW1wb3J0ZWRLZXkgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgcGFzc3dvcmRCdWZmZXIsIFwiUEJLREYyXCIsIGZhbHNlLCBbXG4gICAgXCJkZXJpdmVCaXRzXCJcbiAgXSk7XG4gIGNvbnN0IHNhbHRCdWZmZXIgPSBzdHJpbmdUb0J1ZmZlcihzYWx0KTtcbiAgY29uc3QgcGFyYW1zID0geyBuYW1lOiBcIlBCS0RGMlwiLCBoYXNoLCBzYWx0OiBzYWx0QnVmZmVyLCBpdGVyYXRpb25zIH07XG4gIGNvbnN0IGRlcml2YXRpb24gPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKHBhcmFtcywgaW1wb3J0ZWRLZXksIGtleUxlbmd0aCAqIDgpO1xuICByZXR1cm4gZGVyaXZhdGlvbjtcbn07XG52YXIgZ2VuZXJhdGVLZXkgPSBhc3luYyAoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMpID0+IHtcbiAgdmFyIF9hO1xuICBpZiAoIShwYXNzd29yZCA9PSBudWxsID8gdm9pZCAwIDogcGFzc3dvcmQubGVuZ3RoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBwYXNzd29yZFwiKTtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgb3B0aW9uc1wiKTtcbiAgaWYgKCEob3B0aW9ucy5hbGdvcml0aG0gaW4gYWxnb3JpdGhtcykpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFsZ29yaXRobTogJHtvcHRpb25zLmFsZ29yaXRobX1gKTtcbiAgY29uc3QgYWxnb3JpdGhtID0gYWxnb3JpdGhtc1tvcHRpb25zLmFsZ29yaXRobV07XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBobWFjID0gKF9hID0gb3B0aW9ucy5obWFjKSAhPSBudWxsID8gX2EgOiBmYWxzZTtcbiAgY29uc3QgaWQgPSBobWFjID8geyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogYWxnb3JpdGhtLm5hbWUgfSA6IHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfTtcbiAgY29uc3QgdXNhZ2UgPSBobWFjID8gW1wic2lnblwiLCBcInZlcmlmeVwiXSA6IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCJdO1xuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IG9wdGlvbnMubWluUGFzc3dvcmRsZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQYXNzd29yZCBzdHJpbmcgdG9vIHNob3J0IChtaW4gJHtvcHRpb25zLm1pblBhc3N3b3JkbGVuZ3RofSBjaGFyYWN0ZXJzIHJlcXVpcmVkKWBcbiAgICAgICk7XG4gICAgbGV0IHsgc2FsdCA9IFwiXCIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFzYWx0KSB7XG4gICAgICBjb25zdCB7IHNhbHRCaXRzID0gMCB9ID0gb3B0aW9ucztcbiAgICAgIGlmICghc2FsdEJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc2FsdCBhbmQgc2FsdEJpdHMgb3B0aW9uc1wiKTtcbiAgICAgIGNvbnN0IHJhbmRvbVNhbHQgPSByYW5kb21CaXRzKF9jcnlwdG8sIHNhbHRCaXRzKTtcbiAgICAgIHNhbHQgPSBbLi4ubmV3IFVpbnQ4QXJyYXkocmFuZG9tU2FsdCldLm1hcCgoeCkgPT4geC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gYXdhaXQgcGJrZGYyKFxuICAgICAgX2NyeXB0byxcbiAgICAgIHBhc3N3b3JkLFxuICAgICAgc2FsdCxcbiAgICAgIG9wdGlvbnMuaXRlcmF0aW9ucyxcbiAgICAgIGFsZ29yaXRobS5rZXlCaXRzIC8gOCxcbiAgICAgIFwiU0hBLTFcIlxuICAgICk7XG4gICAgY29uc3QgaW1wb3J0ZWRFbmNyeXB0aW9uS2V5ID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgXCJyYXdcIixcbiAgICAgIGRlcml2ZWRLZXksXG4gICAgICBpZCxcbiAgICAgIGZhbHNlLFxuICAgICAgdXNhZ2VcbiAgICApO1xuICAgIHJlc3VsdC5rZXkgPSBpbXBvcnRlZEVuY3J5cHRpb25LZXk7XG4gICAgcmVzdWx0LnNhbHQgPSBzYWx0O1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXNzd29yZC5sZW5ndGggPCBhbGdvcml0aG0ua2V5Qml0cyAvIDgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgYnVmZmVyIChwYXNzd29yZCkgdG9vIHNtYWxsXCIpO1xuICAgIHJlc3VsdC5rZXkgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgcGFzc3dvcmQsIGlkLCBmYWxzZSwgdXNhZ2UpO1xuICAgIHJlc3VsdC5zYWx0ID0gXCJcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5pdilcbiAgICByZXN1bHQuaXYgPSBvcHRpb25zLml2O1xuICBlbHNlIGlmIChcIml2Qml0c1wiIGluIGFsZ29yaXRobSlcbiAgICByZXN1bHQuaXYgPSByYW5kb21CaXRzKF9jcnlwdG8sIGFsZ29yaXRobS5pdkJpdHMpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBlbmNyeXB0ID0gYXN5bmMgKF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGtleSA9IGF3YWl0IGdlbmVyYXRlS2V5KF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zKTtcbiAgY29uc3QgdGV4dEJ1ZmZlciA9IHN0cmluZ1RvQnVmZmVyKGRhdGEpO1xuICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5lbmNyeXB0KFxuICAgIHsgbmFtZTogYWxnb3JpdGhtc1tvcHRpb25zLmFsZ29yaXRobV0ubmFtZSwgaXY6IGtleS5pdiB9LFxuICAgIGtleS5rZXksXG4gICAgdGV4dEJ1ZmZlclxuICApO1xuICByZXR1cm4geyBlbmNyeXB0ZWQ6IG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZCksIGtleSB9O1xufTtcbnZhciBkZWNyeXB0ID0gYXN5bmMgKF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGtleSA9IGF3YWl0IGdlbmVyYXRlS2V5KF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zKTtcbiAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuZGVjcnlwdChcbiAgICB7IG5hbWU6IGFsZ29yaXRobXNbb3B0aW9ucy5hbGdvcml0aG1dLm5hbWUsIGl2OiBrZXkuaXYgfSxcbiAgICBrZXkua2V5LFxuICAgIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9CdWZmZXIoZGF0YSkgOiBkYXRhXG4gICk7XG4gIHJldHVybiBidWZmZXJUb1N0cmluZyhuZXcgVWludDhBcnJheShkZWNyeXB0ZWQpKTtcbn07XG52YXIgaG1hY1dpdGhQYXNzd29yZCA9IGFzeW5jIChfY3J5cHRvLCBwYXNzd29yZCwgb3B0aW9ucywgZGF0YSkgPT4ge1xuICBjb25zdCBrZXkgPSBhd2FpdCBnZW5lcmF0ZUtleShfY3J5cHRvLCBwYXNzd29yZCwgeyAuLi5vcHRpb25zLCBobWFjOiB0cnVlIH0pO1xuICBjb25zdCB0ZXh0QnVmZmVyID0gc3RyaW5nVG9CdWZmZXIoZGF0YSk7XG4gIGNvbnN0IHNpZ25lZCA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLnNpZ24oeyBuYW1lOiBcIkhNQUNcIiB9LCBrZXkua2V5LCB0ZXh0QnVmZmVyKTtcbiAgY29uc3QgZGlnZXN0ID0gYmFzZTY0dXJsRW5jb2RlKG5ldyBVaW50OEFycmF5KHNpZ25lZCkpO1xuICByZXR1cm4geyBkaWdlc3QsIHNhbHQ6IGtleS5zYWx0IH07XG59O1xudmFyIG5vcm1hbGl6ZVBhc3N3b3JkID0gKHBhc3N3b3JkKSA9PiB7XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIgfHwgcGFzc3dvcmQgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgIHJldHVybiB7IGVuY3J5cHRpb246IHBhc3N3b3JkLCBpbnRlZ3JpdHk6IHBhc3N3b3JkIH07XG4gIGlmIChcInNlY3JldFwiIGluIHBhc3N3b3JkKVxuICAgIHJldHVybiB7IGlkOiBwYXNzd29yZC5pZCwgZW5jcnlwdGlvbjogcGFzc3dvcmQuc2VjcmV0LCBpbnRlZ3JpdHk6IHBhc3N3b3JkLnNlY3JldCB9O1xuICByZXR1cm4geyBpZDogcGFzc3dvcmQuaWQsIGVuY3J5cHRpb246IHBhc3N3b3JkLmVuY3J5cHRpb24sIGludGVncml0eTogcGFzc3dvcmQuaW50ZWdyaXR5IH07XG59O1xudmFyIHNlYWwgPSBhc3luYyAoX2NyeXB0bywgb2JqZWN0LCBwYXNzd29yZCwgb3B0aW9ucykgPT4ge1xuICBpZiAoIXBhc3N3b3JkKVxuICAgIHRocm93IEVycm9yKFwiRW1wdHkgcGFzc3dvcmRcIik7XG4gIGNvbnN0IG9wdHMgPSBjbG9uZShvcHRpb25zKTtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKSArIChvcHRzLmxvY2FsdGltZU9mZnNldE1zZWMgfHwgMCk7XG4gIGNvbnN0IG9iamVjdFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iamVjdCk7XG4gIGNvbnN0IHBhc3MgPSBub3JtYWxpemVQYXNzd29yZChwYXNzd29yZCk7XG4gIGNvbnN0IHsgaWQgPSBcIlwiIH0gPSBwYXNzO1xuICBpZiAoaWQgJiYgIS9eXFx3KyQvLnRlc3QoaWQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFzc3dvcmQgaWRcIik7XG4gIGNvbnN0IHsgZW5jcnlwdGVkLCBrZXkgfSA9IGF3YWl0IGVuY3J5cHQoX2NyeXB0bywgcGFzcy5lbmNyeXB0aW9uLCBvcHRzLmVuY3J5cHRpb24sIG9iamVjdFN0cmluZyk7XG4gIGNvbnN0IGVuY3J5cHRlZEI2NCA9IGJhc2U2NHVybEVuY29kZShuZXcgVWludDhBcnJheShlbmNyeXB0ZWQpKTtcbiAgY29uc3QgaXYgPSBiYXNlNjR1cmxFbmNvZGUoa2V5Lml2KTtcbiAgY29uc3QgZXhwaXJhdGlvbiA9IG9wdHMudHRsID8gbm93ICsgb3B0cy50dGwgOiBcIlwiO1xuICBjb25zdCBtYWNCYXNlU3RyaW5nID0gYCR7bWFjUHJlZml4fSoke2lkfSoke2tleS5zYWx0fSoke2l2fSoke2VuY3J5cHRlZEI2NH0qJHtleHBpcmF0aW9ufWA7XG4gIGNvbnN0IG1hYyA9IGF3YWl0IGhtYWNXaXRoUGFzc3dvcmQoX2NyeXB0bywgcGFzcy5pbnRlZ3JpdHksIG9wdHMuaW50ZWdyaXR5LCBtYWNCYXNlU3RyaW5nKTtcbiAgY29uc3Qgc2VhbGVkID0gYCR7bWFjQmFzZVN0cmluZ30qJHttYWMuc2FsdH0qJHttYWMuZGlnZXN0fWA7XG4gIHJldHVybiBzZWFsZWQ7XG59O1xudmFyIGZpeGVkVGltZUNvbXBhcmlzb24gPSAoYSwgYikgPT4ge1xuICBsZXQgbWlzbWF0Y2ggPSBhLmxlbmd0aCA9PT0gYi5sZW5ndGggPyAwIDogMTtcbiAgaWYgKG1pc21hdGNoKVxuICAgIGIgPSBhO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpXG4gICAgbWlzbWF0Y2ggfD0gYS5jaGFyQ29kZUF0KGkpIF4gYi5jaGFyQ29kZUF0KGkpO1xuICByZXR1cm4gbWlzbWF0Y2ggPT09IDA7XG59O1xudmFyIHVuc2VhbCA9IGFzeW5jIChfY3J5cHRvLCBzZWFsZWQsIHBhc3N3b3JkLCBvcHRpb25zKSA9PiB7XG4gIGlmICghcGFzc3dvcmQpXG4gICAgdGhyb3cgRXJyb3IoXCJFbXB0eSBwYXNzd29yZFwiKTtcbiAgY29uc3Qgb3B0cyA9IGNsb25lKG9wdGlvbnMpO1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpICsgKG9wdHMubG9jYWx0aW1lT2Zmc2V0TXNlYyB8fCAwKTtcbiAgY29uc3QgcGFydHMgPSBzZWFsZWQuc3BsaXQoXCIqXCIpO1xuICBpZiAocGFydHMubGVuZ3RoICE9PSA4KVxuICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2Ygc2VhbGVkIGNvbXBvbmVudHNcIik7XG4gIGNvbnN0IHByZWZpeCA9IHBhcnRzWzBdO1xuICBsZXQgcGFzc3dvcmRJZCA9IHBhcnRzWzFdO1xuICBjb25zdCBlbmNyeXB0aW9uU2FsdCA9IHBhcnRzWzJdO1xuICBjb25zdCBlbmNyeXB0aW9uSXYgPSBwYXJ0c1szXTtcbiAgY29uc3QgZW5jcnlwdGVkQjY0ID0gcGFydHNbNF07XG4gIGNvbnN0IGV4cGlyYXRpb24gPSBwYXJ0c1s1XTtcbiAgY29uc3QgaG1hY1NhbHQgPSBwYXJ0c1s2XTtcbiAgY29uc3QgaG1hYyA9IHBhcnRzWzddO1xuICBjb25zdCBtYWNCYXNlU3RyaW5nID0gYCR7cHJlZml4fSoke3Bhc3N3b3JkSWR9KiR7ZW5jcnlwdGlvblNhbHR9KiR7ZW5jcnlwdGlvbkl2fSoke2VuY3J5cHRlZEI2NH0qJHtleHBpcmF0aW9ufWA7XG4gIGlmIChtYWNQcmVmaXggIT09IHByZWZpeClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBtYWMgcHJlZml4XCIpO1xuICBpZiAoZXhwaXJhdGlvbikge1xuICAgIGlmICghL15cXGQrJC8uZXhlYyhleHBpcmF0aW9uKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZXhwaXJhdGlvblwiKTtcbiAgICBjb25zdCBleHAgPSBwYXJzZUludChleHBpcmF0aW9uLCAxMCk7XG4gICAgaWYgKGV4cCA8PSBub3cgLSBvcHRzLnRpbWVzdGFtcFNrZXdTZWMgKiAxZTMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBpcmVkIHNlYWxcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIgJiYgcGFzc3dvcmQubGVuZ3RoID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IHBhc3N3b3JkXCIpO1xuICBsZXQgcGFzcyA9IFwiXCI7XG4gIHBhc3N3b3JkSWQgPSBwYXNzd29yZElkIHx8IFwiZGVmYXVsdFwiO1xuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSBcInN0cmluZ1wiIHx8IHBhc3N3b3JkIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICBwYXNzID0gcGFzc3dvcmQ7XG4gIGVsc2UgaWYgKCEocGFzc3dvcmRJZCBpbiBwYXNzd29yZCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBwYXNzd29yZDogJHtwYXNzd29yZElkfWApO1xuICBlbHNlXG4gICAgcGFzcyA9IHBhc3N3b3JkW3Bhc3N3b3JkSWRdO1xuICBwYXNzID0gbm9ybWFsaXplUGFzc3dvcmQocGFzcyk7XG4gIGNvbnN0IG1hY09wdGlvbnMgPSBvcHRzLmludGVncml0eTtcbiAgbWFjT3B0aW9ucy5zYWx0ID0gaG1hY1NhbHQ7XG4gIGNvbnN0IG1hYyA9IGF3YWl0IGhtYWNXaXRoUGFzc3dvcmQoX2NyeXB0bywgcGFzcy5pbnRlZ3JpdHksIG1hY09wdGlvbnMsIG1hY0Jhc2VTdHJpbmcpO1xuICBpZiAoIWZpeGVkVGltZUNvbXBhcmlzb24obWFjLmRpZ2VzdCwgaG1hYykpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIGhtYWMgdmFsdWVcIik7XG4gIGNvbnN0IGVuY3J5cHRlZCA9IGJhc2U2NHVybERlY29kZShlbmNyeXB0ZWRCNjQpO1xuICBjb25zdCBkZWNyeXB0T3B0aW9ucyA9IG9wdHMuZW5jcnlwdGlvbjtcbiAgZGVjcnlwdE9wdGlvbnMuc2FsdCA9IGVuY3J5cHRpb25TYWx0O1xuICBkZWNyeXB0T3B0aW9ucy5pdiA9IGJhc2U2NHVybERlY29kZShlbmNyeXB0aW9uSXYpO1xuICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBkZWNyeXB0KF9jcnlwdG8sIHBhc3MuZW5jcnlwdGlvbiwgZGVjcnlwdE9wdGlvbnMsIGVuY3J5cHRlZCk7XG4gIGlmIChkZWNyeXB0ZWQpXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjcnlwdGVkKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgeyBhbGdvcml0aG1zLCBiYXNlNjR1cmxEZWNvZGUsIGJhc2U2NHVybEVuY29kZSwgYnVmZmVyVG9TdHJpbmcsIGNsb25lLCBkZWNyeXB0LCBkZWZhdWx0cywgZW5jcnlwdCwgZ2VuZXJhdGVLZXksIGhtYWNXaXRoUGFzc3dvcmQsIG1hY0Zvcm1hdFZlcnNpb24sIG1hY1ByZWZpeCwgcmFuZG9tQml0cywgc2VhbCwgc3RyaW5nVG9CdWZmZXIsIHVuc2VhbCB9O1xuIl0sIm5hbWVzIjpbImFscGhhYmV0QnlFbmNvZGluZyIsImFscGhhYmV0QnlWYWx1ZSIsIkFycmF5IiwiaSIsInN0YXJ0IiwiY2hhckNvZGVBdCIsImxpbWl0IiwiY2hhciIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImluZGV4IiwidG9TdHJpbmciLCJiaXRzUGVyTGV0dGVyIiwiYml0c1BlckJ5dGUiLCJtYXhMZXR0ZXJWYWx1ZSIsImZyb21CYXNlNjQiLCJpbnB1dCIsInRvdGFsQnl0ZUxlbmd0aCIsImxlbmd0aCIsInNsaWNlIiwib3V0IiwiQXJyYXlCdWZmZXIiLCJkYXRhVmlldyIsIkRhdGFWaWV3IiwiYml0cyIsImJpdExlbmd0aCIsImoiLCJUeXBlRXJyb3IiLCJjaHVua09mZnNldCIsImJ5dGVMZW5ndGgiLCJNYXRoIiwiZmxvb3IiLCJrIiwib2Zmc2V0Iiwic2V0VWludDgiLCJVaW50OEFycmF5IiwidG9CYXNlNjQiLCJzdHIiLCJtaW4iLCJiaXRDbHVzdGVyQ291bnQiLCJjZWlsIiwic3RyaW5nVG9CdWZmZXIiLCJ2YWx1ZSIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiYnVmZmVyVG9TdHJpbmciLCJUZXh0RGVjb2RlciIsImRlY29kZSIsImJhc2U2NHVybEVuY29kZSIsInJlcGxhY2UiLCJiYXNlNjR1cmxEZWNvZGUiLCJqb2luIiwiZGVmYXVsdHMiLCJlbmNyeXB0aW9uIiwic2FsdEJpdHMiLCJhbGdvcml0aG0iLCJpdGVyYXRpb25zIiwibWluUGFzc3dvcmRsZW5ndGgiLCJpbnRlZ3JpdHkiLCJ0dGwiLCJ0aW1lc3RhbXBTa2V3U2VjIiwibG9jYWx0aW1lT2Zmc2V0TXNlYyIsImNsb25lIiwib3B0aW9ucyIsImFsZ29yaXRobXMiLCJrZXlCaXRzIiwiaXZCaXRzIiwibmFtZSIsInNoYTI1NiIsIm1hY0Zvcm1hdFZlcnNpb24iLCJtYWNQcmVmaXgiLCJyYW5kb21CeXRlcyIsIl9jcnlwdG8iLCJzaXplIiwiYnl0ZXMiLCJnZXRSYW5kb21WYWx1ZXMiLCJyYW5kb21CaXRzIiwiRXJyb3IiLCJwYmtkZjIiLCJwYXNzd29yZCIsInNhbHQiLCJrZXlMZW5ndGgiLCJoYXNoIiwicGFzc3dvcmRCdWZmZXIiLCJpbXBvcnRlZEtleSIsInN1YnRsZSIsImltcG9ydEtleSIsInNhbHRCdWZmZXIiLCJwYXJhbXMiLCJkZXJpdmF0aW9uIiwiZGVyaXZlQml0cyIsImdlbmVyYXRlS2V5IiwiX2EiLCJyZXN1bHQiLCJobWFjIiwiaWQiLCJ1c2FnZSIsInJhbmRvbVNhbHQiLCJtYXAiLCJ4IiwicGFkU3RhcnQiLCJkZXJpdmVkS2V5IiwiaW1wb3J0ZWRFbmNyeXB0aW9uS2V5Iiwia2V5IiwiaXYiLCJlbmNyeXB0IiwiZGF0YSIsInRleHRCdWZmZXIiLCJlbmNyeXB0ZWQiLCJkZWNyeXB0IiwiZGVjcnlwdGVkIiwiaG1hY1dpdGhQYXNzd29yZCIsInNpZ25lZCIsInNpZ24iLCJkaWdlc3QiLCJub3JtYWxpemVQYXNzd29yZCIsInNlY3JldCIsInNlYWwiLCJvYmplY3QiLCJvcHRzIiwibm93IiwiRGF0ZSIsIm9iamVjdFN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXNzIiwidGVzdCIsImVuY3J5cHRlZEI2NCIsImV4cGlyYXRpb24iLCJtYWNCYXNlU3RyaW5nIiwibWFjIiwic2VhbGVkIiwiZml4ZWRUaW1lQ29tcGFyaXNvbiIsImEiLCJiIiwibWlzbWF0Y2giLCJ1bnNlYWwiLCJwYXJ0cyIsInNwbGl0IiwicHJlZml4IiwicGFzc3dvcmRJZCIsImVuY3J5cHRpb25TYWx0IiwiZW5jcnlwdGlvbkl2IiwiaG1hY1NhbHQiLCJleGVjIiwiZXhwIiwicGFyc2VJbnQiLCJtYWNPcHRpb25zIiwiZGVjcnlwdE9wdGlvbnMiLCJwYXJzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/iron-webcrypto@1.0.0/node_modules/iron-webcrypto/dist/index.js\n");

/***/ })

};
;