/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/apg-js@4.2.1";
exports.ids = ["vendor-chunks/apg-js@4.2.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/api.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/api.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is Application Programming Interface (API) for **APG** - the ABNF Parser Generator.\n//\n// *Note on teminology.*\n// APG is a parser generator.\n// However, it really only generates a \"grammar object\" (see below) from the defining SABNF grammar.\n// The generated parser is incomplete at this stage.\n// Remaining, it is the job of the user to develop the generated parser from the grammar object and the **APG** Library (**apg-lib**).\n//\n// The following terminology my help clear up any confusion between the idea of a \"generated parser\" versus a \"generated grammar object\".\n\n// - The generating parser: **APG** is an **APG** parser (yes, there is a circular dependence between **apg-api** and **apg-lib**). We'll call it the generating parser.\n// - The target parser: **APG**'s goal is to generate a parser. We'll call it the target parser.\n// - The target grammar: this is the (ASCII) SABNF grammar defining the target parser.\n// - The target grammar object: **APG** parses the SABNF grammar and generates the JavaScript source for a target grammar object constructor function\n// and/or an actual grammar object.\n// - The final target parser: The user then develops the final target parser using the generated target grammar\n// object and the **APG** parsing library, **apg-lib**.\n// Throws execeptions on fatal errors.\n//\n// src: the input SABNF grammar<br>\n// may be one of:\n// - Buffer of bytes\n// - JavaScript string\n// - Array of integer character codes\nmodule.exports = function api(src) {\n  const { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n  const thisFileName = 'api.js: ';\n  const thisObject = this;\n\n  /* PRIVATE PROPERTIES */\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const converter = __webpack_require__(/*! ../apg-conv-api/converter */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/converter.js\");\n  const scanner = __webpack_require__(/*! ./scanner */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner.js\");\n  const parser = new (__webpack_require__(/*! ./parser */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/parser.js\"))();\n  const { attributes, showAttributes, showAttributeErrors, showRuleDependencies } = __webpack_require__(/*! ./attributes */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/attributes.js\");\n  const showRules = __webpack_require__(/*! ./show-rules */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/show-rules.js\");\n\n  /* PRIVATE MEMBERS (FUNCTIONS) */\n  /* Convert a phrase (array of character codes) to HTML. */\n  const abnfToHtml = function abnfToHtml(chars, beg, len) {\n    const NORMAL = 0;\n    const CONTROL = 1;\n    const INVALID = 2;\n    const CONTROL_BEG = `<span class=\"${apglib.style.CLASS_CTRLCHAR}\">`;\n    const CONTROL_END = '</span>';\n    const INVALID_BEG = `<span class=\"${apglib.style.CLASS_NOMATCH}\">`;\n    const INVALID_END = '</span>';\n    let end;\n    let html = '';\n    const TRUE = true;\n    while (TRUE) {\n      if (!Array.isArray(chars) || chars.length === 0) {\n        break;\n      }\n      if (typeof beg !== 'number') {\n        throw new Error('abnfToHtml: beg must be type number');\n      }\n      if (beg >= chars.length) {\n        break;\n      }\n      if (typeof len !== 'number' || beg + len >= chars.length) {\n        end = chars.length;\n      } else {\n        end = beg + len;\n      }\n      let state = NORMAL;\n      for (let i = beg; i < end; i += 1) {\n        const ch = chars[i];\n        if (ch >= 32 && ch <= 126) {\n          /* normal - printable ASCII characters */\n          if (state === CONTROL) {\n            html += CONTROL_END;\n            state = NORMAL;\n          } else if (state === INVALID) {\n            html += INVALID_END;\n            state = NORMAL;\n          }\n          /* handle reserved HTML entity characters */\n          switch (ch) {\n            case 32:\n              html += '&nbsp;';\n              break;\n            case 60:\n              html += '&lt;';\n              break;\n            case 62:\n              html += '&gt;';\n              break;\n            case 38:\n              html += '&amp;';\n              break;\n            case 34:\n              html += '&quot;';\n              break;\n            case 39:\n              html += '&#039;';\n              break;\n            case 92:\n              html += '&#092;';\n              break;\n            default:\n              html += String.fromCharCode(ch);\n              break;\n          }\n        } else if (ch === 9 || ch === 10 || ch === 13) {\n          /* control characters */\n          if (state === NORMAL) {\n            html += CONTROL_BEG;\n            state = CONTROL;\n          } else if (state === INVALID) {\n            html += INVALID_END + CONTROL_BEG;\n            state = CONTROL;\n          }\n          if (ch === 9) {\n            html += 'TAB';\n          }\n          if (ch === 10) {\n            html += 'LF';\n          }\n          if (ch === 13) {\n            html += 'CR';\n          }\n        } else {\n          /* invalid characters */\n          if (state === NORMAL) {\n            html += INVALID_BEG;\n            state = INVALID;\n          } else if (state === CONTROL) {\n            html += CONTROL_END + INVALID_BEG;\n            state = INVALID;\n          }\n          /* display character as hexadecimal value */\n          html += `\\\\x${apglib.utils.charToHex(ch)}`;\n        }\n      }\n      if (state === INVALID) {\n        html += INVALID_END;\n      }\n      if (state === CONTROL) {\n        html += CONTROL_END;\n      }\n      break;\n    }\n    return html;\n  };\n  /* Convert a phrase (array of character codes) to ASCII text. */\n  const abnfToAscii = function abnfToAscii(chars, beg, len) {\n    let str = '';\n    for (let i = beg; i < beg + len; i += 1) {\n      const ch = chars[i];\n      if (ch >= 32 && ch <= 126) {\n        str += String.fromCharCode(ch);\n      } else {\n        switch (ch) {\n          case 9:\n            str += '\\\\t';\n            break;\n          case 10:\n            str += '\\\\n';\n            break;\n          case 13:\n            str += '\\\\r';\n            break;\n          default:\n            str += '\\\\unknown';\n            break;\n        }\n      }\n    }\n    return str;\n  };\n  /* translate lines (SABNF grammar) to ASCII text */\n  const linesToAscii = function linesToAscii(lines) {\n    let str = 'Annotated Input Grammar';\n    lines.forEach((val) => {\n      str += '\\n';\n      str += `line no: ${val.lineNo}`;\n      str += ` : char index: ${val.beginChar}`;\n      str += ` : length: ${val.length}`;\n      str += ` : abnf: ${abnfToAscii(thisObject.chars, val.beginChar, val.length)}`;\n    });\n    str += '\\n';\n    return str;\n  };\n  /* translate lines (SABNF grammar) to HTML */\n  const linesToHtml = function linesToHtml(lines) {\n    let html = '';\n    html += `<table class=\"${apglib.style.CLASS_GRAMMAR}\">\\n`;\n    const title = 'Annotated Input Grammar';\n    html += `<caption>${title}</caption>\\n`;\n    html += '<tr>';\n    html += '<th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th>';\n    html += '</tr>\\n';\n    lines.forEach((val) => {\n      html += '<tr>';\n      html += `<td>${val.lineNo}`;\n      html += `</td><td>${val.beginChar}`;\n      html += `</td><td>${val.length}`;\n      html += `</td><td>${abnfToHtml(thisObject.chars, val.beginChar, val.length)}`;\n      html += '</td>';\n      html += '</tr>\\n';\n    });\n\n    html += '</table>\\n';\n    return html;\n  };\n  /* Format the error messages to HTML, for page display. */\n  const errorsToHtml = function errorsToHtml(errors, lines, chars, title) {\n    const [style] = apglib;\n    let html = '';\n    const errorArrow = `<span class=\"${style.CLASS_NOMATCH}\">&raquo;</span>`;\n    html += `<p><table class=\"${style.CLASS_GRAMMAR}\">\\n`;\n    if (title && typeof title === 'string') {\n      html += `<caption>${title}</caption>\\n`;\n    }\n    html += '<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\\n';\n    errors.forEach((val) => {\n      let line;\n      let relchar;\n      let beg;\n      let end;\n      let text;\n      let prefix = '';\n      let suffix = '';\n      if (lines.length === 0) {\n        text = errorArrow;\n        relchar = 0;\n      } else {\n        line = lines[val.line];\n        beg = line.beginChar;\n        if (val.char > beg) {\n          prefix = abnfToHtml(chars, beg, val.char - beg);\n        }\n        beg = val.char;\n        end = line.beginChar + line.length;\n        if (beg < end) {\n          suffix = abnfToHtml(chars, beg, end - beg);\n        }\n        text = prefix + errorArrow + suffix;\n        relchar = val.char - line.beginChar;\n        html += '<tr>';\n        html += `<td>${val.line}</td><td>${line.beginChar}</td><td>${relchar}</td><td>${text}</td>`;\n        html += '</tr>\\n';\n        html += '<tr>';\n        html += `<td colspan=\"3\"></td><td>&uarr;:&nbsp;${apglib.utils.stringToAsciiHtml(val.msg)}</td>`;\n        html += '</tr>\\n';\n      }\n    });\n    html += '</table></p>\\n';\n    return html;\n  };\n  /* Display an array of errors in ASCII text */\n  const errorsToAscii = function errorsToAscii(errors, lines, chars) {\n    let str;\n    let line;\n    let beg;\n    let len;\n    str = '';\n    errors.forEach((error) => {\n      line = lines[error.line];\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      beg = line.beginChar;\n      len = error.char - line.beginChar;\n      str += abnfToAscii(chars, beg, len);\n      str += ' >> ';\n      beg = error.char;\n      len = line.beginChar + line.length - error.char;\n      str += abnfToAscii(chars, beg, len);\n      str += '\\n';\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      str += 'error: ';\n      str += error.msg;\n      str += '\\n';\n    });\n    return str;\n  };\n  let isScanned = false;\n  let isParsed = false;\n  let isTranslated = false;\n  let haveAttributes = false;\n  let attributeErrors = 0;\n  let lineMap;\n\n  /* PUBLIC PROPERTIES */\n  // The input SABNF grammar as a JavaScript string.\n  // this.sabnf;\n  // The input SABNF grammar as an array of character codes.\n  // this.chars;\n  // An array of line objects, defining each line of the input SABNF grammar\n  // - lineNo : the zero-based line number\n  // - beginChar : offset (into `this.chars`) of the first character in the line\n  // - length : the number of characters in the line\n  // - textLength : the number of characters of text in the line, excluding the line ending characters\n  // - endType : \"CRLF\", \"LF\", \"CR\" or \"none\" if the last line has no line ending characters\n  // - invalidChars : `true` if the line contains invalid characters, `false` otherwise\n  // this.lines;\n  // An array of rule names and data.\n  // - name : the rule name\n  // - lower : the rule name in lower case\n  // - index : the index of the rule (ordered by appearance in SABNF grammar)\n  // - isBkr : `true` if this rule has been back referenced, `false` otherwise\n  // - opcodes : array of opcodes for this rule\n  // - attrs : the rule attributes\n  // - ctrl : system data\n  // this.rules;\n  // An array of UDT names and data.\n  // this.udts;\n  // An array of errors, if any.\n  // - line : the line number containing the error\n  // - char : the character offset of the error\n  // - msg : the error message\n  this.errors = [];\n\n  /* CONSTRUCTOR */\n  if (Buffer.isBuffer(src)) {\n    this.chars = converter.decode('BINARY', src);\n  } else if (Array.isArray(src)) {\n    this.chars = src.slice();\n  } else if (typeof src === 'string') {\n    this.chars = converter.decode('STRING', src);\n  } else {\n    throw new Error(`${thisFileName}input source is not a string, byte Buffer or character array`);\n  }\n  this.sabnf = converter.encode('STRING', this.chars);\n\n  /* PUBLIC MEMBERS (FUNCTIONS) */\n  // Scan the input SABNF grammar for invalid characters and catalog the lines via `this.lines`.\n  // - strict : (optional) if `true`, all lines, including the last must end with CRLF (\\r\\n),\n  // if `false` (in any JavaScript sense) then line endings may be any mix of CRLF, LF, CR, or end-of-file.\n  // - trace (*) : (optional) a parser trace object, which will trace the parser that does the scan\n  this.scan = function scan(strict, trace) {\n    this.lines = scanner(this.chars, this.errors, strict, trace);\n    isScanned = true;\n  };\n  // Parse the input SABNF grammar for correct syntax.\n  // - strict : (optional) if `true`, the input grammar must be strict ABNF, conforming to [RFC 5234](https://tools.ietf.org/html/rfc5234)\n  // and [RFC 7405](https://tools.ietf.org/html/rfc7405). No superset features allowed.\n  // - trace (\\*) : (optional) a parser trace object, which will trace the syntax parser\n  //\n  // <i>(*)NOTE: the trace option was used primarily during development.\n  // Error detection and reporting is now fairly robust and tracing should be unnecessary. Use at your own peril.</i>\n  this.parse = function parse(strict, trace) {\n    if (!isScanned) {\n      throw new Error(`${thisFileName}grammar not scanned`);\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict, trace);\n    isParsed = true;\n  };\n  // Translate the SABNF grammar syntax into the opcodes that will guide the parser for this grammar.\n  this.translate = function translate() {\n    if (!isParsed) {\n      throw new Error(`${thisFileName}grammar not scanned and parsed`);\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length === 0) {\n      this.rules = ret.rules;\n      this.udts = ret.udts;\n      lineMap = ret.lineMap;\n      isTranslated = true;\n    }\n  };\n  // Compute the attributes of each rule.\n  this.attributes = function attrs() {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n    return attributeErrors;\n  };\n  // This function will perform the full suite of steps required to generate a parser grammar object\n  // from the input SABNF grammar.\n  this.generate = function generate(strict) {\n    this.lines = scanner(this.chars, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length) {\n      return;\n    }\n    this.rules = ret.rules;\n    this.udts = ret.udts;\n    lineMap = ret.lineMap;\n\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n  };\n  // Display the rules.\n  // Must scan, parse and translate before calling this function, otherwise there are no rules to display.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  this.displayRules = function displayRules(order = 'index') {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    return showRules(this.rules, this.udts, order);\n  };\n  // Display the rule dependencies.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // Otherwise the rule dependencies are not known.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  this.displayRuleDependencies = function displayRuleDependencies(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showRuleDependencies(order);\n  };\n  // Display the attributes.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, type order (default)\n  this.displayAttributes = function displayAttributes(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      showAttributeErrors(order);\n    }\n    return showAttributes(order);\n  };\n  this.displayAttributeErrors = function displayAttributeErrors() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showAttributeErrors();\n  };\n  // Returns a parser grammar object constructor function as a JavaScript string.\n  // This object can then be used to construct a parser.\n  this.toSource = function toSource(name) {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateSource(this.chars, this.lines, this.rules, this.udts, name);\n  };\n  // Returns a parser grammar object.\n  // This grammar object may be used by the application to construct a parser.\n  this.toObject = function toObject() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateObject(this.sabnf, this.rules, this.udts);\n  };\n  // Display errors in text format, suitable for `console.log()`.\n  this.errorsToAscii = function errorsToAsciiFunc() {\n    return errorsToAscii(this.errors, this.lines, this.chars);\n  };\n  // Display errors in HTML format, suitable for web page display.\n  // (`apg-lib.css` required for proper styling)\n  this.errorsToHtml = function errorsToHtmlFunc(title) {\n    return errorsToHtml(this.errors, this.lines, this.chars, title);\n  };\n  // Generate an annotated the SABNF grammar display in text format.\n  this.linesToAscii = function linesToAsciiFunc() {\n    return linesToAscii(this.lines);\n  };\n  // Generate an annotated the SABNF grammar display in HTML format.\n  // (`apg-lib.css` required for proper styling)\n  this.linesToHtml = function linesToHtmlFunc() {\n    return linesToHtml(this.lines);\n  };\n  // This function was only used by apg.html which has been abandoned.\n  /*\n    this.getAttributesObject = function () {\n        return null;\n    };\n    */\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw0SEFBeUI7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsZ0lBQTJCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHlHQUFXO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLHVHQUFVO0FBQ3hDLFVBQVUsd0VBQXdFLEVBQUUsbUJBQU8sQ0FBQywrR0FBYztBQUMxRyxvQkFBb0IsbUJBQU8sQ0FBQywrR0FBYzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0EseUJBQXlCLGFBQWEsaURBQWlELGlCQUFpQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYSxpREFBaUQsaUJBQWlCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvYXBpLmpzPzk3M2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgaXMgQXBwbGljYXRpb24gUHJvZ3JhbW1pbmcgSW50ZXJmYWNlIChBUEkpIGZvciAqKkFQRyoqIC0gdGhlIEFCTkYgUGFyc2VyIEdlbmVyYXRvci5cbi8vXG4vLyAqTm90ZSBvbiB0ZW1pbm9sb2d5Lipcbi8vIEFQRyBpcyBhIHBhcnNlciBnZW5lcmF0b3IuXG4vLyBIb3dldmVyLCBpdCByZWFsbHkgb25seSBnZW5lcmF0ZXMgYSBcImdyYW1tYXIgb2JqZWN0XCIgKHNlZSBiZWxvdykgZnJvbSB0aGUgZGVmaW5pbmcgU0FCTkYgZ3JhbW1hci5cbi8vIFRoZSBnZW5lcmF0ZWQgcGFyc2VyIGlzIGluY29tcGxldGUgYXQgdGhpcyBzdGFnZS5cbi8vIFJlbWFpbmluZywgaXQgaXMgdGhlIGpvYiBvZiB0aGUgdXNlciB0byBkZXZlbG9wIHRoZSBnZW5lcmF0ZWQgcGFyc2VyIGZyb20gdGhlIGdyYW1tYXIgb2JqZWN0IGFuZCB0aGUgKipBUEcqKiBMaWJyYXJ5ICgqKmFwZy1saWIqKikuXG4vL1xuLy8gVGhlIGZvbGxvd2luZyB0ZXJtaW5vbG9neSBteSBoZWxwIGNsZWFyIHVwIGFueSBjb25mdXNpb24gYmV0d2VlbiB0aGUgaWRlYSBvZiBhIFwiZ2VuZXJhdGVkIHBhcnNlclwiIHZlcnN1cyBhIFwiZ2VuZXJhdGVkIGdyYW1tYXIgb2JqZWN0XCIuXG5cbi8vIC0gVGhlIGdlbmVyYXRpbmcgcGFyc2VyOiAqKkFQRyoqIGlzIGFuICoqQVBHKiogcGFyc2VyICh5ZXMsIHRoZXJlIGlzIGEgY2lyY3VsYXIgZGVwZW5kZW5jZSBiZXR3ZWVuICoqYXBnLWFwaSoqIGFuZCAqKmFwZy1saWIqKikuIFdlJ2xsIGNhbGwgaXQgdGhlIGdlbmVyYXRpbmcgcGFyc2VyLlxuLy8gLSBUaGUgdGFyZ2V0IHBhcnNlcjogKipBUEcqKidzIGdvYWwgaXMgdG8gZ2VuZXJhdGUgYSBwYXJzZXIuIFdlJ2xsIGNhbGwgaXQgdGhlIHRhcmdldCBwYXJzZXIuXG4vLyAtIFRoZSB0YXJnZXQgZ3JhbW1hcjogdGhpcyBpcyB0aGUgKEFTQ0lJKSBTQUJORiBncmFtbWFyIGRlZmluaW5nIHRoZSB0YXJnZXQgcGFyc2VyLlxuLy8gLSBUaGUgdGFyZ2V0IGdyYW1tYXIgb2JqZWN0OiAqKkFQRyoqIHBhcnNlcyB0aGUgU0FCTkYgZ3JhbW1hciBhbmQgZ2VuZXJhdGVzIHRoZSBKYXZhU2NyaXB0IHNvdXJjZSBmb3IgYSB0YXJnZXQgZ3JhbW1hciBvYmplY3QgY29uc3RydWN0b3IgZnVuY3Rpb25cbi8vIGFuZC9vciBhbiBhY3R1YWwgZ3JhbW1hciBvYmplY3QuXG4vLyAtIFRoZSBmaW5hbCB0YXJnZXQgcGFyc2VyOiBUaGUgdXNlciB0aGVuIGRldmVsb3BzIHRoZSBmaW5hbCB0YXJnZXQgcGFyc2VyIHVzaW5nIHRoZSBnZW5lcmF0ZWQgdGFyZ2V0IGdyYW1tYXJcbi8vIG9iamVjdCBhbmQgdGhlICoqQVBHKiogcGFyc2luZyBsaWJyYXJ5LCAqKmFwZy1saWIqKi5cbi8vIFRocm93cyBleGVjZXB0aW9ucyBvbiBmYXRhbCBlcnJvcnMuXG4vL1xuLy8gc3JjOiB0aGUgaW5wdXQgU0FCTkYgZ3JhbW1hcjxicj5cbi8vIG1heSBiZSBvbmUgb2Y6XG4vLyAtIEJ1ZmZlciBvZiBieXRlc1xuLy8gLSBKYXZhU2NyaXB0IHN0cmluZ1xuLy8gLSBBcnJheSBvZiBpbnRlZ2VyIGNoYXJhY3RlciBjb2Rlc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcGkoc3JjKSB7XG4gIGNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKTtcbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ2FwaS5qczogJztcbiAgY29uc3QgdGhpc09iamVjdCA9IHRoaXM7XG5cbiAgLyogUFJJVkFURSBQUk9QRVJUSUVTICovXG4gIGNvbnN0IGFwZ2xpYiA9IHJlcXVpcmUoJy4uL2FwZy1saWIvbm9kZS1leHBvcnRzJyk7XG4gIGNvbnN0IGNvbnZlcnRlciA9IHJlcXVpcmUoJy4uL2FwZy1jb252LWFwaS9jb252ZXJ0ZXInKTtcbiAgY29uc3Qgc2Nhbm5lciA9IHJlcXVpcmUoJy4vc2Nhbm5lcicpO1xuICBjb25zdCBwYXJzZXIgPSBuZXcgKHJlcXVpcmUoJy4vcGFyc2VyJykpKCk7XG4gIGNvbnN0IHsgYXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVFcnJvcnMsIHNob3dSdWxlRGVwZW5kZW5jaWVzIH0gPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcbiAgY29uc3Qgc2hvd1J1bGVzID0gcmVxdWlyZSgnLi9zaG93LXJ1bGVzJyk7XG5cbiAgLyogUFJJVkFURSBNRU1CRVJTIChGVU5DVElPTlMpICovXG4gIC8qIENvbnZlcnQgYSBwaHJhc2UgKGFycmF5IG9mIGNoYXJhY3RlciBjb2RlcykgdG8gSFRNTC4gKi9cbiAgY29uc3QgYWJuZlRvSHRtbCA9IGZ1bmN0aW9uIGFibmZUb0h0bWwoY2hhcnMsIGJlZywgbGVuKSB7XG4gICAgY29uc3QgTk9STUFMID0gMDtcbiAgICBjb25zdCBDT05UUk9MID0gMTtcbiAgICBjb25zdCBJTlZBTElEID0gMjtcbiAgICBjb25zdCBDT05UUk9MX0JFRyA9IGA8c3BhbiBjbGFzcz1cIiR7YXBnbGliLnN0eWxlLkNMQVNTX0NUUkxDSEFSfVwiPmA7XG4gICAgY29uc3QgQ09OVFJPTF9FTkQgPSAnPC9zcGFuPic7XG4gICAgY29uc3QgSU5WQUxJRF9CRUcgPSBgPHNwYW4gY2xhc3M9XCIke2FwZ2xpYi5zdHlsZS5DTEFTU19OT01BVENIfVwiPmA7XG4gICAgY29uc3QgSU5WQUxJRF9FTkQgPSAnPC9zcGFuPic7XG4gICAgbGV0IGVuZDtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpIHx8IGNoYXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYmVnICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FibmZUb0h0bWw6IGJlZyBtdXN0IGJlIHR5cGUgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmVnID49IGNoYXJzLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGVuICE9PSAnbnVtYmVyJyB8fCBiZWcgKyBsZW4gPj0gY2hhcnMubGVuZ3RoKSB7XG4gICAgICAgIGVuZCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IGJlZyArIGxlbjtcbiAgICAgIH1cbiAgICAgIGxldCBzdGF0ZSA9IE5PUk1BTDtcbiAgICAgIGZvciAobGV0IGkgPSBiZWc7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaCA9IGNoYXJzW2ldO1xuICAgICAgICBpZiAoY2ggPj0gMzIgJiYgY2ggPD0gMTI2KSB7XG4gICAgICAgICAgLyogbm9ybWFsIC0gcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnMgKi9cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IENPTlRST0wpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gQ09OVFJPTF9FTkQ7XG4gICAgICAgICAgICBzdGF0ZSA9IE5PUk1BTDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBJTlZBTElEKSB7XG4gICAgICAgICAgICBodG1sICs9IElOVkFMSURfRU5EO1xuICAgICAgICAgICAgc3RhdGUgPSBOT1JNQUw7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGhhbmRsZSByZXNlcnZlZCBIVE1MIGVudGl0eSBjaGFyYWN0ZXJzICovXG4gICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJm5ic3A7JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYwOlxuICAgICAgICAgICAgICBodG1sICs9ICcmbHQ7JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgICAgICBodG1sICs9ICcmZ3Q7JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICBodG1sICs9ICcmYW1wOyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJnF1b3Q7JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICBodG1sICs9ICcmIzAzOTsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyYjMDkyOyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaHRtbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSA5IHx8IGNoID09PSAxMCB8fCBjaCA9PT0gMTMpIHtcbiAgICAgICAgICAvKiBjb250cm9sIGNoYXJhY3RlcnMgKi9cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IE5PUk1BTCkge1xuICAgICAgICAgICAgaHRtbCArPSBDT05UUk9MX0JFRztcbiAgICAgICAgICAgIHN0YXRlID0gQ09OVFJPTDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBJTlZBTElEKSB7XG4gICAgICAgICAgICBodG1sICs9IElOVkFMSURfRU5EICsgQ09OVFJPTF9CRUc7XG4gICAgICAgICAgICBzdGF0ZSA9IENPTlRST0w7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaCA9PT0gOSkge1xuICAgICAgICAgICAgaHRtbCArPSAnVEFCJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoID09PSAxMCkge1xuICAgICAgICAgICAgaHRtbCArPSAnTEYnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2ggPT09IDEzKSB7XG4gICAgICAgICAgICBodG1sICs9ICdDUic7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIGludmFsaWQgY2hhcmFjdGVycyAqL1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gTk9STUFMKSB7XG4gICAgICAgICAgICBodG1sICs9IElOVkFMSURfQkVHO1xuICAgICAgICAgICAgc3RhdGUgPSBJTlZBTElEO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IENPTlRST0wpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gQ09OVFJPTF9FTkQgKyBJTlZBTElEX0JFRztcbiAgICAgICAgICAgIHN0YXRlID0gSU5WQUxJRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogZGlzcGxheSBjaGFyYWN0ZXIgYXMgaGV4YWRlY2ltYWwgdmFsdWUgKi9cbiAgICAgICAgICBodG1sICs9IGBcXFxceCR7YXBnbGliLnV0aWxzLmNoYXJUb0hleChjaCl9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSBJTlZBTElEKSB7XG4gICAgICAgIGh0bWwgKz0gSU5WQUxJRF9FTkQ7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IENPTlRST0wpIHtcbiAgICAgICAgaHRtbCArPSBDT05UUk9MX0VORDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogQ29udmVydCBhIHBocmFzZSAoYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzKSB0byBBU0NJSSB0ZXh0LiAqL1xuICBjb25zdCBhYm5mVG9Bc2NpaSA9IGZ1bmN0aW9uIGFibmZUb0FzY2lpKGNoYXJzLCBiZWcsIGxlbikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gYmVnOyBpIDwgYmVnICsgbGVuOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGNoID0gY2hhcnNbaV07XG4gICAgICBpZiAoY2ggPj0gMzIgJiYgY2ggPD0gMTI2KSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcXFx0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcXFxyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcXFx1bmtub3duJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIC8qIHRyYW5zbGF0ZSBsaW5lcyAoU0FCTkYgZ3JhbW1hcikgdG8gQVNDSUkgdGV4dCAqL1xuICBjb25zdCBsaW5lc1RvQXNjaWkgPSBmdW5jdGlvbiBsaW5lc1RvQXNjaWkobGluZXMpIHtcbiAgICBsZXQgc3RyID0gJ0Fubm90YXRlZCBJbnB1dCBHcmFtbWFyJztcbiAgICBsaW5lcy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgIHN0ciArPSBgbGluZSBubzogJHt2YWwubGluZU5vfWA7XG4gICAgICBzdHIgKz0gYCA6IGNoYXIgaW5kZXg6ICR7dmFsLmJlZ2luQ2hhcn1gO1xuICAgICAgc3RyICs9IGAgOiBsZW5ndGg6ICR7dmFsLmxlbmd0aH1gO1xuICAgICAgc3RyICs9IGAgOiBhYm5mOiAke2FibmZUb0FzY2lpKHRoaXNPYmplY3QuY2hhcnMsIHZhbC5iZWdpbkNoYXIsIHZhbC5sZW5ndGgpfWA7XG4gICAgfSk7XG4gICAgc3RyICs9ICdcXG4nO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIC8qIHRyYW5zbGF0ZSBsaW5lcyAoU0FCTkYgZ3JhbW1hcikgdG8gSFRNTCAqL1xuICBjb25zdCBsaW5lc1RvSHRtbCA9IGZ1bmN0aW9uIGxpbmVzVG9IdG1sKGxpbmVzKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9IGA8dGFibGUgY2xhc3M9XCIke2FwZ2xpYi5zdHlsZS5DTEFTU19HUkFNTUFSfVwiPlxcbmA7XG4gICAgY29uc3QgdGl0bGUgPSAnQW5ub3RhdGVkIElucHV0IEdyYW1tYXInO1xuICAgIGh0bWwgKz0gYDxjYXB0aW9uPiR7dGl0bGV9PC9jYXB0aW9uPlxcbmA7XG4gICAgaHRtbCArPSAnPHRyPic7XG4gICAgaHRtbCArPSAnPHRoPmxpbmU8YnI+bm8uPC90aD48dGg+Zmlyc3Q8YnI+Y2hhcjwvdGg+PHRoPjxicj5sZW5ndGg8L3RoPjx0aD48YnI+dGV4dDwvdGg+JztcbiAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgbGluZXMuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICBodG1sICs9ICc8dHI+JztcbiAgICAgIGh0bWwgKz0gYDx0ZD4ke3ZhbC5saW5lTm99YDtcbiAgICAgIGh0bWwgKz0gYDwvdGQ+PHRkPiR7dmFsLmJlZ2luQ2hhcn1gO1xuICAgICAgaHRtbCArPSBgPC90ZD48dGQ+JHt2YWwubGVuZ3RofWA7XG4gICAgICBodG1sICs9IGA8L3RkPjx0ZD4ke2FibmZUb0h0bWwodGhpc09iamVjdC5jaGFycywgdmFsLmJlZ2luQ2hhciwgdmFsLmxlbmd0aCl9YDtcbiAgICAgIGh0bWwgKz0gJzwvdGQ+JztcbiAgICAgIGh0bWwgKz0gJzwvdHI+XFxuJztcbiAgICB9KTtcblxuICAgIGh0bWwgKz0gJzwvdGFibGU+XFxuJztcbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogRm9ybWF0IHRoZSBlcnJvciBtZXNzYWdlcyB0byBIVE1MLCBmb3IgcGFnZSBkaXNwbGF5LiAqL1xuICBjb25zdCBlcnJvcnNUb0h0bWwgPSBmdW5jdGlvbiBlcnJvcnNUb0h0bWwoZXJyb3JzLCBsaW5lcywgY2hhcnMsIHRpdGxlKSB7XG4gICAgY29uc3QgW3N0eWxlXSA9IGFwZ2xpYjtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGNvbnN0IGVycm9yQXJyb3cgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+JnJhcXVvOzwvc3Bhbj5gO1xuICAgIGh0bWwgKz0gYDxwPjx0YWJsZSBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfR1JBTU1BUn1cIj5cXG5gO1xuICAgIGlmICh0aXRsZSAmJiB0eXBlb2YgdGl0bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBodG1sICs9IGA8Y2FwdGlvbj4ke3RpdGxlfTwvY2FwdGlvbj5cXG5gO1xuICAgIH1cbiAgICBodG1sICs9ICc8dHI+PHRoPmxpbmU8YnI+bm8uPC90aD48dGg+bGluZTxicj5vZmZzZXQ8L3RoPjx0aD5lcnJvcjxicj5vZmZzZXQ8L3RoPjx0aD48YnI+dGV4dDwvdGg+PC90cj5cXG4nO1xuICAgIGVycm9ycy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgIGxldCBsaW5lO1xuICAgICAgbGV0IHJlbGNoYXI7XG4gICAgICBsZXQgYmVnO1xuICAgICAgbGV0IGVuZDtcbiAgICAgIGxldCB0ZXh0O1xuICAgICAgbGV0IHByZWZpeCA9ICcnO1xuICAgICAgbGV0IHN1ZmZpeCA9ICcnO1xuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0ZXh0ID0gZXJyb3JBcnJvdztcbiAgICAgICAgcmVsY2hhciA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lID0gbGluZXNbdmFsLmxpbmVdO1xuICAgICAgICBiZWcgPSBsaW5lLmJlZ2luQ2hhcjtcbiAgICAgICAgaWYgKHZhbC5jaGFyID4gYmVnKSB7XG4gICAgICAgICAgcHJlZml4ID0gYWJuZlRvSHRtbChjaGFycywgYmVnLCB2YWwuY2hhciAtIGJlZyk7XG4gICAgICAgIH1cbiAgICAgICAgYmVnID0gdmFsLmNoYXI7XG4gICAgICAgIGVuZCA9IGxpbmUuYmVnaW5DaGFyICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGlmIChiZWcgPCBlbmQpIHtcbiAgICAgICAgICBzdWZmaXggPSBhYm5mVG9IdG1sKGNoYXJzLCBiZWcsIGVuZCAtIGJlZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IHByZWZpeCArIGVycm9yQXJyb3cgKyBzdWZmaXg7XG4gICAgICAgIHJlbGNoYXIgPSB2YWwuY2hhciAtIGxpbmUuYmVnaW5DaGFyO1xuICAgICAgICBodG1sICs9ICc8dHI+JztcbiAgICAgICAgaHRtbCArPSBgPHRkPiR7dmFsLmxpbmV9PC90ZD48dGQ+JHtsaW5lLmJlZ2luQ2hhcn08L3RkPjx0ZD4ke3JlbGNoYXJ9PC90ZD48dGQ+JHt0ZXh0fTwvdGQ+YDtcbiAgICAgICAgaHRtbCArPSAnPC90cj5cXG4nO1xuICAgICAgICBodG1sICs9ICc8dHI+JztcbiAgICAgICAgaHRtbCArPSBgPHRkIGNvbHNwYW49XCIzXCI+PC90ZD48dGQ+JnVhcnI7OiZuYnNwOyR7YXBnbGliLnV0aWxzLnN0cmluZ1RvQXNjaWlIdG1sKHZhbC5tc2cpfTwvdGQ+YDtcbiAgICAgICAgaHRtbCArPSAnPC90cj5cXG4nO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGh0bWwgKz0gJzwvdGFibGU+PC9wPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIERpc3BsYXkgYW4gYXJyYXkgb2YgZXJyb3JzIGluIEFTQ0lJIHRleHQgKi9cbiAgY29uc3QgZXJyb3JzVG9Bc2NpaSA9IGZ1bmN0aW9uIGVycm9yc1RvQXNjaWkoZXJyb3JzLCBsaW5lcywgY2hhcnMpIHtcbiAgICBsZXQgc3RyO1xuICAgIGxldCBsaW5lO1xuICAgIGxldCBiZWc7XG4gICAgbGV0IGxlbjtcbiAgICBzdHIgPSAnJztcbiAgICBlcnJvcnMuZm9yRWFjaCgoZXJyb3IpID0+IHtcbiAgICAgIGxpbmUgPSBsaW5lc1tlcnJvci5saW5lXTtcbiAgICAgIHN0ciArPSBgJHtsaW5lLmxpbmVOb306IGA7XG4gICAgICBzdHIgKz0gYCR7bGluZS5iZWdpbkNoYXJ9OiBgO1xuICAgICAgc3RyICs9IGAke2Vycm9yLmNoYXIgLSBsaW5lLmJlZ2luQ2hhcn06IGA7XG4gICAgICBiZWcgPSBsaW5lLmJlZ2luQ2hhcjtcbiAgICAgIGxlbiA9IGVycm9yLmNoYXIgLSBsaW5lLmJlZ2luQ2hhcjtcbiAgICAgIHN0ciArPSBhYm5mVG9Bc2NpaShjaGFycywgYmVnLCBsZW4pO1xuICAgICAgc3RyICs9ICcgPj4gJztcbiAgICAgIGJlZyA9IGVycm9yLmNoYXI7XG4gICAgICBsZW4gPSBsaW5lLmJlZ2luQ2hhciArIGxpbmUubGVuZ3RoIC0gZXJyb3IuY2hhcjtcbiAgICAgIHN0ciArPSBhYm5mVG9Bc2NpaShjaGFycywgYmVnLCBsZW4pO1xuICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgc3RyICs9IGAke2xpbmUubGluZU5vfTogYDtcbiAgICAgIHN0ciArPSBgJHtsaW5lLmJlZ2luQ2hhcn06IGA7XG4gICAgICBzdHIgKz0gYCR7ZXJyb3IuY2hhciAtIGxpbmUuYmVnaW5DaGFyfTogYDtcbiAgICAgIHN0ciArPSAnZXJyb3I6ICc7XG4gICAgICBzdHIgKz0gZXJyb3IubXNnO1xuICAgICAgc3RyICs9ICdcXG4nO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIGxldCBpc1NjYW5uZWQgPSBmYWxzZTtcbiAgbGV0IGlzUGFyc2VkID0gZmFsc2U7XG4gIGxldCBpc1RyYW5zbGF0ZWQgPSBmYWxzZTtcbiAgbGV0IGhhdmVBdHRyaWJ1dGVzID0gZmFsc2U7XG4gIGxldCBhdHRyaWJ1dGVFcnJvcnMgPSAwO1xuICBsZXQgbGluZU1hcDtcblxuICAvKiBQVUJMSUMgUFJPUEVSVElFUyAqL1xuICAvLyBUaGUgaW5wdXQgU0FCTkYgZ3JhbW1hciBhcyBhIEphdmFTY3JpcHQgc3RyaW5nLlxuICAvLyB0aGlzLnNhYm5mO1xuICAvLyBUaGUgaW5wdXQgU0FCTkYgZ3JhbW1hciBhcyBhbiBhcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMuXG4gIC8vIHRoaXMuY2hhcnM7XG4gIC8vIEFuIGFycmF5IG9mIGxpbmUgb2JqZWN0cywgZGVmaW5pbmcgZWFjaCBsaW5lIG9mIHRoZSBpbnB1dCBTQUJORiBncmFtbWFyXG4gIC8vIC0gbGluZU5vIDogdGhlIHplcm8tYmFzZWQgbGluZSBudW1iZXJcbiAgLy8gLSBiZWdpbkNoYXIgOiBvZmZzZXQgKGludG8gYHRoaXMuY2hhcnNgKSBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBsaW5lXG4gIC8vIC0gbGVuZ3RoIDogdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRoZSBsaW5lXG4gIC8vIC0gdGV4dExlbmd0aCA6IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBvZiB0ZXh0IGluIHRoZSBsaW5lLCBleGNsdWRpbmcgdGhlIGxpbmUgZW5kaW5nIGNoYXJhY3RlcnNcbiAgLy8gLSBlbmRUeXBlIDogXCJDUkxGXCIsIFwiTEZcIiwgXCJDUlwiIG9yIFwibm9uZVwiIGlmIHRoZSBsYXN0IGxpbmUgaGFzIG5vIGxpbmUgZW5kaW5nIGNoYXJhY3RlcnNcbiAgLy8gLSBpbnZhbGlkQ2hhcnMgOiBgdHJ1ZWAgaWYgdGhlIGxpbmUgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzLCBgZmFsc2VgIG90aGVyd2lzZVxuICAvLyB0aGlzLmxpbmVzO1xuICAvLyBBbiBhcnJheSBvZiBydWxlIG5hbWVzIGFuZCBkYXRhLlxuICAvLyAtIG5hbWUgOiB0aGUgcnVsZSBuYW1lXG4gIC8vIC0gbG93ZXIgOiB0aGUgcnVsZSBuYW1lIGluIGxvd2VyIGNhc2VcbiAgLy8gLSBpbmRleCA6IHRoZSBpbmRleCBvZiB0aGUgcnVsZSAob3JkZXJlZCBieSBhcHBlYXJhbmNlIGluIFNBQk5GIGdyYW1tYXIpXG4gIC8vIC0gaXNCa3IgOiBgdHJ1ZWAgaWYgdGhpcyBydWxlIGhhcyBiZWVuIGJhY2sgcmVmZXJlbmNlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAgLy8gLSBvcGNvZGVzIDogYXJyYXkgb2Ygb3Bjb2RlcyBmb3IgdGhpcyBydWxlXG4gIC8vIC0gYXR0cnMgOiB0aGUgcnVsZSBhdHRyaWJ1dGVzXG4gIC8vIC0gY3RybCA6IHN5c3RlbSBkYXRhXG4gIC8vIHRoaXMucnVsZXM7XG4gIC8vIEFuIGFycmF5IG9mIFVEVCBuYW1lcyBhbmQgZGF0YS5cbiAgLy8gdGhpcy51ZHRzO1xuICAvLyBBbiBhcnJheSBvZiBlcnJvcnMsIGlmIGFueS5cbiAgLy8gLSBsaW5lIDogdGhlIGxpbmUgbnVtYmVyIGNvbnRhaW5pbmcgdGhlIGVycm9yXG4gIC8vIC0gY2hhciA6IHRoZSBjaGFyYWN0ZXIgb2Zmc2V0IG9mIHRoZSBlcnJvclxuICAvLyAtIG1zZyA6IHRoZSBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZXJyb3JzID0gW107XG5cbiAgLyogQ09OU1RSVUNUT1IgKi9cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzcmMpKSB7XG4gICAgdGhpcy5jaGFycyA9IGNvbnZlcnRlci5kZWNvZGUoJ0JJTkFSWScsIHNyYyk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgdGhpcy5jaGFycyA9IHNyYy5zbGljZSgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5jaGFycyA9IGNvbnZlcnRlci5kZWNvZGUoJ1NUUklORycsIHNyYyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1pbnB1dCBzb3VyY2UgaXMgbm90IGEgc3RyaW5nLCBieXRlIEJ1ZmZlciBvciBjaGFyYWN0ZXIgYXJyYXlgKTtcbiAgfVxuICB0aGlzLnNhYm5mID0gY29udmVydGVyLmVuY29kZSgnU1RSSU5HJywgdGhpcy5jaGFycyk7XG5cbiAgLyogUFVCTElDIE1FTUJFUlMgKEZVTkNUSU9OUykgKi9cbiAgLy8gU2NhbiB0aGUgaW5wdXQgU0FCTkYgZ3JhbW1hciBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzIGFuZCBjYXRhbG9nIHRoZSBsaW5lcyB2aWEgYHRoaXMubGluZXNgLlxuICAvLyAtIHN0cmljdCA6IChvcHRpb25hbCkgaWYgYHRydWVgLCBhbGwgbGluZXMsIGluY2x1ZGluZyB0aGUgbGFzdCBtdXN0IGVuZCB3aXRoIENSTEYgKFxcclxcbiksXG4gIC8vIGlmIGBmYWxzZWAgKGluIGFueSBKYXZhU2NyaXB0IHNlbnNlKSB0aGVuIGxpbmUgZW5kaW5ncyBtYXkgYmUgYW55IG1peCBvZiBDUkxGLCBMRiwgQ1IsIG9yIGVuZC1vZi1maWxlLlxuICAvLyAtIHRyYWNlICgqKSA6IChvcHRpb25hbCkgYSBwYXJzZXIgdHJhY2Ugb2JqZWN0LCB3aGljaCB3aWxsIHRyYWNlIHRoZSBwYXJzZXIgdGhhdCBkb2VzIHRoZSBzY2FuXG4gIHRoaXMuc2NhbiA9IGZ1bmN0aW9uIHNjYW4oc3RyaWN0LCB0cmFjZSkge1xuICAgIHRoaXMubGluZXMgPSBzY2FubmVyKHRoaXMuY2hhcnMsIHRoaXMuZXJyb3JzLCBzdHJpY3QsIHRyYWNlKTtcbiAgICBpc1NjYW5uZWQgPSB0cnVlO1xuICB9O1xuICAvLyBQYXJzZSB0aGUgaW5wdXQgU0FCTkYgZ3JhbW1hciBmb3IgY29ycmVjdCBzeW50YXguXG4gIC8vIC0gc3RyaWN0IDogKG9wdGlvbmFsKSBpZiBgdHJ1ZWAsIHRoZSBpbnB1dCBncmFtbWFyIG11c3QgYmUgc3RyaWN0IEFCTkYsIGNvbmZvcm1pbmcgdG8gW1JGQyA1MjM0XShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTIzNClcbiAgLy8gYW5kIFtSRkMgNzQwNV0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc0MDUpLiBObyBzdXBlcnNldCBmZWF0dXJlcyBhbGxvd2VkLlxuICAvLyAtIHRyYWNlIChcXCopIDogKG9wdGlvbmFsKSBhIHBhcnNlciB0cmFjZSBvYmplY3QsIHdoaWNoIHdpbGwgdHJhY2UgdGhlIHN5bnRheCBwYXJzZXJcbiAgLy9cbiAgLy8gPGk+KCopTk9URTogdGhlIHRyYWNlIG9wdGlvbiB3YXMgdXNlZCBwcmltYXJpbHkgZHVyaW5nIGRldmVsb3BtZW50LlxuICAvLyBFcnJvciBkZXRlY3Rpb24gYW5kIHJlcG9ydGluZyBpcyBub3cgZmFpcmx5IHJvYnVzdCBhbmQgdHJhY2luZyBzaG91bGQgYmUgdW5uZWNlc3NhcnkuIFVzZSBhdCB5b3VyIG93biBwZXJpbC48L2k+XG4gIHRoaXMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShzdHJpY3QsIHRyYWNlKSB7XG4gICAgaWYgKCFpc1NjYW5uZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Z3JhbW1hciBub3Qgc2Nhbm5lZGApO1xuICAgIH1cbiAgICBwYXJzZXIuc3ludGF4KHRoaXMuY2hhcnMsIHRoaXMubGluZXMsIHRoaXMuZXJyb3JzLCBzdHJpY3QsIHRyYWNlKTtcbiAgICBpc1BhcnNlZCA9IHRydWU7XG4gIH07XG4gIC8vIFRyYW5zbGF0ZSB0aGUgU0FCTkYgZ3JhbW1hciBzeW50YXggaW50byB0aGUgb3Bjb2RlcyB0aGF0IHdpbGwgZ3VpZGUgdGhlIHBhcnNlciBmb3IgdGhpcyBncmFtbWFyLlxuICB0aGlzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIHRyYW5zbGF0ZSgpIHtcbiAgICBpZiAoIWlzUGFyc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWdyYW1tYXIgbm90IHNjYW5uZWQgYW5kIHBhcnNlZGApO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSBwYXJzZXIuc2VtYW50aWModGhpcy5jaGFycywgdGhpcy5saW5lcywgdGhpcy5lcnJvcnMpO1xuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucnVsZXMgPSByZXQucnVsZXM7XG4gICAgICB0aGlzLnVkdHMgPSByZXQudWR0cztcbiAgICAgIGxpbmVNYXAgPSByZXQubGluZU1hcDtcbiAgICAgIGlzVHJhbnNsYXRlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuICAvLyBDb21wdXRlIHRoZSBhdHRyaWJ1dGVzIG9mIGVhY2ggcnVsZS5cbiAgdGhpcy5hdHRyaWJ1dGVzID0gZnVuY3Rpb24gYXR0cnMoKSB7XG4gICAgaWYgKCFpc1RyYW5zbGF0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Z3JhbW1hciBub3Qgc2Nhbm5lZCwgcGFyc2VkIGFuZCB0cmFuc2xhdGVkYCk7XG4gICAgfVxuICAgIGF0dHJpYnV0ZUVycm9ycyA9IGF0dHJpYnV0ZXModGhpcy5ydWxlcywgdGhpcy51ZHRzLCBsaW5lTWFwLCB0aGlzLmVycm9ycyk7XG4gICAgaGF2ZUF0dHJpYnV0ZXMgPSB0cnVlO1xuICAgIHJldHVybiBhdHRyaWJ1dGVFcnJvcnM7XG4gIH07XG4gIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBwZXJmb3JtIHRoZSBmdWxsIHN1aXRlIG9mIHN0ZXBzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIGEgcGFyc2VyIGdyYW1tYXIgb2JqZWN0XG4gIC8vIGZyb20gdGhlIGlucHV0IFNBQk5GIGdyYW1tYXIuXG4gIHRoaXMuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShzdHJpY3QpIHtcbiAgICB0aGlzLmxpbmVzID0gc2Nhbm5lcih0aGlzLmNoYXJzLCB0aGlzLmVycm9ycywgc3RyaWN0KTtcbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcnNlci5zeW50YXgodGhpcy5jaGFycywgdGhpcy5saW5lcywgdGhpcy5lcnJvcnMsIHN0cmljdCk7XG4gICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSBwYXJzZXIuc2VtYW50aWModGhpcy5jaGFycywgdGhpcy5saW5lcywgdGhpcy5lcnJvcnMpO1xuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ydWxlcyA9IHJldC5ydWxlcztcbiAgICB0aGlzLnVkdHMgPSByZXQudWR0cztcbiAgICBsaW5lTWFwID0gcmV0LmxpbmVNYXA7XG5cbiAgICBhdHRyaWJ1dGVFcnJvcnMgPSBhdHRyaWJ1dGVzKHRoaXMucnVsZXMsIHRoaXMudWR0cywgbGluZU1hcCwgdGhpcy5lcnJvcnMpO1xuICAgIGhhdmVBdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgfTtcbiAgLy8gRGlzcGxheSB0aGUgcnVsZXMuXG4gIC8vIE11c3Qgc2NhbiwgcGFyc2UgYW5kIHRyYW5zbGF0ZSBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLCBvdGhlcndpc2UgdGhlcmUgYXJlIG5vIHJ1bGVzIHRvIGRpc3BsYXkuXG4gIC8vIC0gb3JkZXJcbiAgLy8gICAgICAtIFwiaW5kZXhcIiBvciBcImlcIiwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIC8vICAgICAgLSBcImFscGhhXCIgb3IgXCJhXCIsIGFscGhhYmV0aWNhbCBvcmRlclxuICAvLyAgICAgIC0gbm9uZSBvZiBhYm92ZSwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIHRoaXMuZGlzcGxheVJ1bGVzID0gZnVuY3Rpb24gZGlzcGxheVJ1bGVzKG9yZGVyID0gJ2luZGV4Jykge1xuICAgIGlmICghaXNUcmFuc2xhdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWdyYW1tYXIgbm90IHNjYW5uZWQsIHBhcnNlZCBhbmQgdHJhbnNsYXRlZGApO1xuICAgIH1cbiAgICByZXR1cm4gc2hvd1J1bGVzKHRoaXMucnVsZXMsIHRoaXMudWR0cywgb3JkZXIpO1xuICB9O1xuICAvLyBEaXNwbGF5IHRoZSBydWxlIGRlcGVuZGVuY2llcy5cbiAgLy8gTXVzdCBzY2FuLCBwYXJzZSwgdHJhbnNsYXRlIGFuZCBjb21wdXRlIGF0dHJpYnV0ZXMgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBydWxlIGRlcGVuZGVuY2llcyBhcmUgbm90IGtub3duLlxuICAvLyAtIG9yZGVyXG4gIC8vICAgICAgLSBcImluZGV4XCIgb3IgXCJpXCIsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICAvLyAgICAgIC0gXCJhbHBoYVwiIG9yIFwiYVwiLCBhbHBoYWJldGljYWwgb3JkZXJcbiAgLy8gICAgICAtIFwidHlwZVwiIG9yIFwidFwiLCBvcmRlcmVkIGJ5IHR5cGUgKGFscGhhYmV0aWNhbCB3aXRoaW4gZWFjaCB0eXBlL2dyb3VwKVxuICAvLyAgICAgIC0gbm9uZSBvZiBhYm92ZSwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIHRoaXMuZGlzcGxheVJ1bGVEZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiBkaXNwbGF5UnVsZURlcGVuZGVuY2llcyhvcmRlciA9ICdpbmRleCcpIHtcbiAgICBpZiAoIWhhdmVBdHRyaWJ1dGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfW5vIGF0dHJpYnV0ZXMgLSBtdXN0IGJlIHByZWNlZWRlZCBieSBjYWxsIHRvIGF0dHJpYnV0ZXMoKWApO1xuICAgIH1cbiAgICByZXR1cm4gc2hvd1J1bGVEZXBlbmRlbmNpZXMob3JkZXIpO1xuICB9O1xuICAvLyBEaXNwbGF5IHRoZSBhdHRyaWJ1dGVzLlxuICAvLyBNdXN0IHNjYW4sIHBhcnNlLCB0cmFuc2xhdGUgYW5kIGNvbXB1dGUgYXR0cmlidXRlcyBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAvLyAtIG9yZGVyXG4gIC8vICAgICAgLSBcImluZGV4XCIgb3IgXCJpXCIsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICAvLyAgICAgIC0gXCJhbHBoYVwiIG9yIFwiYVwiLCBhbHBoYWJldGljYWwgb3JkZXJcbiAgLy8gICAgICAtIFwidHlwZVwiIG9yIFwidFwiLCBvcmRlcmVkIGJ5IHR5cGUgKGFscGhhYmV0aWNhbCB3aXRoaW4gZWFjaCB0eXBlL2dyb3VwKVxuICAvLyAgICAgIC0gbm9uZSBvZiBhYm92ZSwgdHlwZSBvcmRlciAoZGVmYXVsdClcbiAgdGhpcy5kaXNwbGF5QXR0cmlidXRlcyA9IGZ1bmN0aW9uIGRpc3BsYXlBdHRyaWJ1dGVzKG9yZGVyID0gJ2luZGV4Jykge1xuICAgIGlmICghaGF2ZUF0dHJpYnV0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9bm8gYXR0cmlidXRlcyAtIG11c3QgYmUgcHJlY2VlZGVkIGJ5IGNhbGwgdG8gYXR0cmlidXRlcygpYCk7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVFcnJvcnMpIHtcbiAgICAgIHNob3dBdHRyaWJ1dGVFcnJvcnMob3JkZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc2hvd0F0dHJpYnV0ZXMob3JkZXIpO1xuICB9O1xuICB0aGlzLmRpc3BsYXlBdHRyaWJ1dGVFcnJvcnMgPSBmdW5jdGlvbiBkaXNwbGF5QXR0cmlidXRlRXJyb3JzKCkge1xuICAgIGlmICghaGF2ZUF0dHJpYnV0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9bm8gYXR0cmlidXRlcyAtIG11c3QgYmUgcHJlY2VlZGVkIGJ5IGNhbGwgdG8gYXR0cmlidXRlcygpYCk7XG4gICAgfVxuICAgIHJldHVybiBzaG93QXR0cmlidXRlRXJyb3JzKCk7XG4gIH07XG4gIC8vIFJldHVybnMgYSBwYXJzZXIgZ3JhbW1hciBvYmplY3QgY29uc3RydWN0b3IgZnVuY3Rpb24gYXMgYSBKYXZhU2NyaXB0IHN0cmluZy5cbiAgLy8gVGhpcyBvYmplY3QgY2FuIHRoZW4gYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBwYXJzZXIuXG4gIHRoaXMudG9Tb3VyY2UgPSBmdW5jdGlvbiB0b1NvdXJjZShuYW1lKSB7XG4gICAgaWYgKCFoYXZlQXR0cmlidXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jYW4ndCBnZW5lcmF0ZSBwYXJzZXIgc291cmNlIC0gbXVzdCBiZSBwcmVjZWVkZWQgYnkgY2FsbCB0byBhdHRyaWJ1dGVzKClgKTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZUVycm9ycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jYW4ndCBnZW5lcmF0ZSBwYXJzZXIgc291cmNlIC0gYXR0cmlidXRlcyBoYXZlICR7YXR0cmlidXRlRXJyb3JzfSBlcnJvcnNgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5nZW5lcmF0ZVNvdXJjZSh0aGlzLmNoYXJzLCB0aGlzLmxpbmVzLCB0aGlzLnJ1bGVzLCB0aGlzLnVkdHMsIG5hbWUpO1xuICB9O1xuICAvLyBSZXR1cm5zIGEgcGFyc2VyIGdyYW1tYXIgb2JqZWN0LlxuICAvLyBUaGlzIGdyYW1tYXIgb2JqZWN0IG1heSBiZSB1c2VkIGJ5IHRoZSBhcHBsaWNhdGlvbiB0byBjb25zdHJ1Y3QgYSBwYXJzZXIuXG4gIHRoaXMudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICBpZiAoIWhhdmVBdHRyaWJ1dGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNhbid0IGdlbmVyYXRlIHBhcnNlciBzb3VyY2UgLSBtdXN0IGJlIHByZWNlZWRlZCBieSBjYWxsIHRvIGF0dHJpYnV0ZXMoKWApO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlRXJyb3JzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNhbid0IGdlbmVyYXRlIHBhcnNlciBzb3VyY2UgLSBhdHRyaWJ1dGVzIGhhdmUgJHthdHRyaWJ1dGVFcnJvcnN9IGVycm9yc2ApO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmdlbmVyYXRlT2JqZWN0KHRoaXMuc2FibmYsIHRoaXMucnVsZXMsIHRoaXMudWR0cyk7XG4gIH07XG4gIC8vIERpc3BsYXkgZXJyb3JzIGluIHRleHQgZm9ybWF0LCBzdWl0YWJsZSBmb3IgYGNvbnNvbGUubG9nKClgLlxuICB0aGlzLmVycm9yc1RvQXNjaWkgPSBmdW5jdGlvbiBlcnJvcnNUb0FzY2lpRnVuYygpIHtcbiAgICByZXR1cm4gZXJyb3JzVG9Bc2NpaSh0aGlzLmVycm9ycywgdGhpcy5saW5lcywgdGhpcy5jaGFycyk7XG4gIH07XG4gIC8vIERpc3BsYXkgZXJyb3JzIGluIEhUTUwgZm9ybWF0LCBzdWl0YWJsZSBmb3Igd2ViIHBhZ2UgZGlzcGxheS5cbiAgLy8gKGBhcGctbGliLmNzc2AgcmVxdWlyZWQgZm9yIHByb3BlciBzdHlsaW5nKVxuICB0aGlzLmVycm9yc1RvSHRtbCA9IGZ1bmN0aW9uIGVycm9yc1RvSHRtbEZ1bmModGl0bGUpIHtcbiAgICByZXR1cm4gZXJyb3JzVG9IdG1sKHRoaXMuZXJyb3JzLCB0aGlzLmxpbmVzLCB0aGlzLmNoYXJzLCB0aXRsZSk7XG4gIH07XG4gIC8vIEdlbmVyYXRlIGFuIGFubm90YXRlZCB0aGUgU0FCTkYgZ3JhbW1hciBkaXNwbGF5IGluIHRleHQgZm9ybWF0LlxuICB0aGlzLmxpbmVzVG9Bc2NpaSA9IGZ1bmN0aW9uIGxpbmVzVG9Bc2NpaUZ1bmMoKSB7XG4gICAgcmV0dXJuIGxpbmVzVG9Bc2NpaSh0aGlzLmxpbmVzKTtcbiAgfTtcbiAgLy8gR2VuZXJhdGUgYW4gYW5ub3RhdGVkIHRoZSBTQUJORiBncmFtbWFyIGRpc3BsYXkgaW4gSFRNTCBmb3JtYXQuXG4gIC8vIChgYXBnLWxpYi5jc3NgIHJlcXVpcmVkIGZvciBwcm9wZXIgc3R5bGluZylcbiAgdGhpcy5saW5lc1RvSHRtbCA9IGZ1bmN0aW9uIGxpbmVzVG9IdG1sRnVuYygpIHtcbiAgICByZXR1cm4gbGluZXNUb0h0bWwodGhpcy5saW5lcyk7XG4gIH07XG4gIC8vIFRoaXMgZnVuY3Rpb24gd2FzIG9ubHkgdXNlZCBieSBhcGcuaHRtbCB3aGljaCBoYXMgYmVlbiBhYmFuZG9uZWQuXG4gIC8qXG4gICAgdGhpcy5nZXRBdHRyaWJ1dGVzT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgICovXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/api.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/attributes.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/attributes.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable class-methods-use-this */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Attributes Validation\n//\n// It is well known that recursive-descent parsers will fail if a rule is left recursive.\n// Besides left recursion, there are a couple of other fatal attributes that need to be disclosed as well.\n// There are several non-fatal attributes that are of interest also.\n// This module will determine six different attributes listed here with simple examples.\n//\n// **fatal attributes**<br>\n// left recursion<br>\n// S = S \"x\" / \"y\"\n//\n// cyclic<br>\n// S = S\n//\n// infinite<br>\n// S = \"y\" S\n//\n// **non-fatal attributes** (but nice to know)<br>\n// nested recursion<br>\n// S = \"a\" S \"b\" / \"y\"\n//\n// right recursion<br>\n// S = \"x\" S / \"y\"\n//\n// empty string<br>\n// S = \"x\" S / \"\"\n//\n// Note that these are “aggregate” attributes, in that if the attribute is true it only means that it can be true,\n// not that it will always be true for every input string.\n// In the simple examples above the attributes may be obvious and definite – always true or false.\n// However, for a large grammar with possibly hundreds of rules and parse tree branches,\n// it can be obscure which branches lead to which attributes.\n// Furthermore, different input strings will lead the parser down different branches.\n// One input string may parse perfectly while another will hit a left-recursive branch and bottom out the call stack.\n//\n// It is for this reason that the APG parser generator computes these attributes.\n// When using the API the attributes call is optional but generating a parser without checking the attributes - proceed at your own peril.\n//\n// Additionally, the attribute phase will identify rule dependencies and mutually-recursive groups. For example,\n//\n// S = \"a\" A \"b\" / \"y\"<br>\n// A = \"x\"\n//\n// S is dependent on A but A is not dependent on S.\n//\n// S = \"a\" A \"b\" / \"c\"<br>\n// A = \"x\" S \"y\" / \"z\"\n//\n// S and A are dependent on one another and are mutually recursive.\nmodule.exports = (function exportAttributes() {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const { ruleAttributes, showAttributes, showAttributeErrors } = __webpack_require__(/*! ./rule-attributes */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-attributes.js\");\n  const { ruleDependencies, showRuleDependencies } = __webpack_require__(/*! ./rule-dependencies */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-dependencies.js\");\n  class State {\n    constructor(rules, udts) {\n      this.rules = rules;\n      this.udts = udts;\n      this.ruleCount = rules.length;\n      this.udtCount = udts.length;\n      this.startRule = 0;\n      this.dependenciesComplete = false;\n      this.attributesComplete = false;\n      this.isMutuallyRecursive = false;\n      this.ruleIndexes = this.indexArray(this.ruleCount);\n      this.ruleAlphaIndexes = this.indexArray(this.ruleCount);\n      this.ruleTypeIndexes = this.indexArray(this.ruleCount);\n      this.udtIndexes = this.indexArray(this.udtCount);\n      this.udtAlphaIndexes = this.indexArray(this.udtCount);\n      this.attrsErrorCount = 0;\n      this.attrs = [];\n      this.attrsErrors = [];\n      this.attrsWorking = [];\n      this.ruleDeps = [];\n      for (let i = 0; i < this.ruleCount; i += 1) {\n        this.attrs.push(this.attrGen(this.rules[i]));\n        this.attrsWorking.push(this.attrGen(this.rules[i]));\n        this.ruleDeps.push(this.rdGen(rules[i], this.ruleCount, this.udtCount));\n      }\n      this.compRulesAlpha = this.compRulesAlpha.bind(this);\n      this.compUdtsAlpha = this.compUdtsAlpha.bind(this);\n      this.compRulesType = this.compRulesType.bind(this);\n      this.compRulesGroup = this.compRulesGroup.bind(this);\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrGen(rule) {\n      return {\n        left: false,\n        nested: false,\n        right: false,\n        empty: false,\n        finite: false,\n        cyclic: false,\n        leaf: false,\n        isOpen: false,\n        isComplete: false,\n        rule,\n      };\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrInit(attr) {\n      attr.left = false;\n      attr.nested = false;\n      attr.right = false;\n      attr.empty = false;\n      attr.finite = false;\n      attr.cyclic = false;\n      attr.leaf = false;\n      attr.isOpen = false;\n      attr.isComplete = false;\n    }\n\n    attrCopy(dst, src) {\n      dst.left = src.left;\n      dst.nested = src.nested;\n      dst.right = src.right;\n      dst.empty = src.empty;\n      dst.finite = src.finite;\n      dst.cyclic = src.cyclic;\n      dst.leaf = src.leaf;\n      dst.isOpen = src.isOpen;\n      dst.isComplete = src.isComplete;\n      dst.rule = src.rule;\n    }\n\n    rdGen(rule, ruleCount, udtCount) {\n      const ret = {\n        rule,\n        recursiveType: id.ATTR_N,\n        groupNumber: -1,\n        refersTo: this.falseArray(ruleCount),\n        refersToUdt: this.falseArray(udtCount),\n        referencedBy: this.falseArray(ruleCount),\n      };\n      return ret;\n    }\n\n    typeToString(recursiveType) {\n      switch (recursiveType) {\n        case id.ATTR_N:\n          return ' N';\n        case id.ATTR_R:\n          return ' R';\n        case id.ATTR_MR:\n          return 'MR';\n        default:\n          return 'UNKNOWN';\n      }\n    }\n\n    falseArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(false);\n        }\n      }\n      return ret;\n    }\n\n    falsifyArray(a) {\n      for (let i = 0; i < a.length; i += 1) {\n        a[i] = false;\n      }\n    }\n\n    indexArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(i);\n        }\n      }\n      return ret;\n    }\n\n    compRulesAlpha(left, right) {\n      if (this.rules[left].lower < this.rules[right].lower) {\n        return -1;\n      }\n      if (this.rules[left].lower > this.rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compUdtsAlpha(left, right) {\n      if (this.udts[left].lower < this.udts[right].lower) {\n        return -1;\n      }\n      if (this.udts[left].lower > this.udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesType(left, right) {\n      if (this.ruleDeps[left].recursiveType < this.ruleDeps[right].recursiveType) {\n        return -1;\n      }\n      if (this.ruleDeps[left].recursiveType > this.ruleDeps[right].recursiveType) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesGroup(left, right) {\n      if (this.ruleDeps[left].recursiveType === id.ATTR_MR && this.ruleDeps[right].recursiveType === id.ATTR_MR) {\n        if (this.ruleDeps[left].groupNumber < this.ruleDeps[right].groupNumber) {\n          return -1;\n        }\n        if (this.ruleDeps[left].groupNumber > this.ruleDeps[right].groupNumber) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n  }\n  // eslint-disable-next-line no-unused-vars\n  const attributes = function attributes(rules = [], udts = [], lineMap = [], errors = []) {\n    // let i = 0;\n    // Initialize the state. The state of the computation get passed around to multiple functions in multiple files.\n    const state = new State(rules, udts);\n\n    // Determine all rule dependencies\n    //  - which rules each rule refers to\n    //  - which rules reference each rule\n    ruleDependencies(state);\n\n    // Determine the attributes for each rule.\n    ruleAttributes(state);\n    if (state.attrsErrorCount) {\n      errors.push({ line: 0, char: 0, msg: `${state.attrsErrorCount} attribute errors` });\n    }\n\n    // Return the number of attribute errors to the caller.\n    return state.attrsErrorCount;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { attributes, showAttributes, showAttributeErrors, showRuleDependencies };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2F0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsMEhBQXdCO0FBQzdDLFVBQVUsc0RBQXNELEVBQUUsbUJBQU8sQ0FBQyx5SEFBbUI7QUFDN0YsVUFBVSx5Q0FBeUMsRUFBRSxtQkFBTyxDQUFDLDZIQUFxQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQix1QkFBdUIsbUJBQW1CO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvYXR0cmlidXRlcy5qcz8zYTcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIEF0dHJpYnV0ZXMgVmFsaWRhdGlvblxuLy9cbi8vIEl0IGlzIHdlbGwga25vd24gdGhhdCByZWN1cnNpdmUtZGVzY2VudCBwYXJzZXJzIHdpbGwgZmFpbCBpZiBhIHJ1bGUgaXMgbGVmdCByZWN1cnNpdmUuXG4vLyBCZXNpZGVzIGxlZnQgcmVjdXJzaW9uLCB0aGVyZSBhcmUgYSBjb3VwbGUgb2Ygb3RoZXIgZmF0YWwgYXR0cmlidXRlcyB0aGF0IG5lZWQgdG8gYmUgZGlzY2xvc2VkIGFzIHdlbGwuXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBub24tZmF0YWwgYXR0cmlidXRlcyB0aGF0IGFyZSBvZiBpbnRlcmVzdCBhbHNvLlxuLy8gVGhpcyBtb2R1bGUgd2lsbCBkZXRlcm1pbmUgc2l4IGRpZmZlcmVudCBhdHRyaWJ1dGVzIGxpc3RlZCBoZXJlIHdpdGggc2ltcGxlIGV4YW1wbGVzLlxuLy9cbi8vICoqZmF0YWwgYXR0cmlidXRlcyoqPGJyPlxuLy8gbGVmdCByZWN1cnNpb248YnI+XG4vLyBTID0gUyBcInhcIiAvIFwieVwiXG4vL1xuLy8gY3ljbGljPGJyPlxuLy8gUyA9IFNcbi8vXG4vLyBpbmZpbml0ZTxicj5cbi8vIFMgPSBcInlcIiBTXG4vL1xuLy8gKipub24tZmF0YWwgYXR0cmlidXRlcyoqIChidXQgbmljZSB0byBrbm93KTxicj5cbi8vIG5lc3RlZCByZWN1cnNpb248YnI+XG4vLyBTID0gXCJhXCIgUyBcImJcIiAvIFwieVwiXG4vL1xuLy8gcmlnaHQgcmVjdXJzaW9uPGJyPlxuLy8gUyA9IFwieFwiIFMgLyBcInlcIlxuLy9cbi8vIGVtcHR5IHN0cmluZzxicj5cbi8vIFMgPSBcInhcIiBTIC8gXCJcIlxuLy9cbi8vIE5vdGUgdGhhdCB0aGVzZSBhcmUg4oCcYWdncmVnYXRl4oCdIGF0dHJpYnV0ZXMsIGluIHRoYXQgaWYgdGhlIGF0dHJpYnV0ZSBpcyB0cnVlIGl0IG9ubHkgbWVhbnMgdGhhdCBpdCBjYW4gYmUgdHJ1ZSxcbi8vIG5vdCB0aGF0IGl0IHdpbGwgYWx3YXlzIGJlIHRydWUgZm9yIGV2ZXJ5IGlucHV0IHN0cmluZy5cbi8vIEluIHRoZSBzaW1wbGUgZXhhbXBsZXMgYWJvdmUgdGhlIGF0dHJpYnV0ZXMgbWF5IGJlIG9idmlvdXMgYW5kIGRlZmluaXRlIOKAkyBhbHdheXMgdHJ1ZSBvciBmYWxzZS5cbi8vIEhvd2V2ZXIsIGZvciBhIGxhcmdlIGdyYW1tYXIgd2l0aCBwb3NzaWJseSBodW5kcmVkcyBvZiBydWxlcyBhbmQgcGFyc2UgdHJlZSBicmFuY2hlcyxcbi8vIGl0IGNhbiBiZSBvYnNjdXJlIHdoaWNoIGJyYW5jaGVzIGxlYWQgdG8gd2hpY2ggYXR0cmlidXRlcy5cbi8vIEZ1cnRoZXJtb3JlLCBkaWZmZXJlbnQgaW5wdXQgc3RyaW5ncyB3aWxsIGxlYWQgdGhlIHBhcnNlciBkb3duIGRpZmZlcmVudCBicmFuY2hlcy5cbi8vIE9uZSBpbnB1dCBzdHJpbmcgbWF5IHBhcnNlIHBlcmZlY3RseSB3aGlsZSBhbm90aGVyIHdpbGwgaGl0IGEgbGVmdC1yZWN1cnNpdmUgYnJhbmNoIGFuZCBib3R0b20gb3V0IHRoZSBjYWxsIHN0YWNrLlxuLy9cbi8vIEl0IGlzIGZvciB0aGlzIHJlYXNvbiB0aGF0IHRoZSBBUEcgcGFyc2VyIGdlbmVyYXRvciBjb21wdXRlcyB0aGVzZSBhdHRyaWJ1dGVzLlxuLy8gV2hlbiB1c2luZyB0aGUgQVBJIHRoZSBhdHRyaWJ1dGVzIGNhbGwgaXMgb3B0aW9uYWwgYnV0IGdlbmVyYXRpbmcgYSBwYXJzZXIgd2l0aG91dCBjaGVja2luZyB0aGUgYXR0cmlidXRlcyAtIHByb2NlZWQgYXQgeW91ciBvd24gcGVyaWwuXG4vL1xuLy8gQWRkaXRpb25hbGx5LCB0aGUgYXR0cmlidXRlIHBoYXNlIHdpbGwgaWRlbnRpZnkgcnVsZSBkZXBlbmRlbmNpZXMgYW5kIG11dHVhbGx5LXJlY3Vyc2l2ZSBncm91cHMuIEZvciBleGFtcGxlLFxuLy9cbi8vIFMgPSBcImFcIiBBIFwiYlwiIC8gXCJ5XCI8YnI+XG4vLyBBID0gXCJ4XCJcbi8vXG4vLyBTIGlzIGRlcGVuZGVudCBvbiBBIGJ1dCBBIGlzIG5vdCBkZXBlbmRlbnQgb24gUy5cbi8vXG4vLyBTID0gXCJhXCIgQSBcImJcIiAvIFwiY1wiPGJyPlxuLy8gQSA9IFwieFwiIFMgXCJ5XCIgLyBcInpcIlxuLy9cbi8vIFMgYW5kIEEgYXJlIGRlcGVuZGVudCBvbiBvbmUgYW5vdGhlciBhbmQgYXJlIG11dHVhbGx5IHJlY3Vyc2l2ZS5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIGV4cG9ydEF0dHJpYnV0ZXMoKSB7XG4gIGNvbnN0IGlkID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9pZGVudGlmaWVycycpO1xuICBjb25zdCB7IHJ1bGVBdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZUVycm9ycyB9ID0gcmVxdWlyZSgnLi9ydWxlLWF0dHJpYnV0ZXMnKTtcbiAgY29uc3QgeyBydWxlRGVwZW5kZW5jaWVzLCBzaG93UnVsZURlcGVuZGVuY2llcyB9ID0gcmVxdWlyZSgnLi9ydWxlLWRlcGVuZGVuY2llcycpO1xuICBjbGFzcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IocnVsZXMsIHVkdHMpIHtcbiAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgIHRoaXMudWR0cyA9IHVkdHM7XG4gICAgICB0aGlzLnJ1bGVDb3VudCA9IHJ1bGVzLmxlbmd0aDtcbiAgICAgIHRoaXMudWR0Q291bnQgPSB1ZHRzLmxlbmd0aDtcbiAgICAgIHRoaXMuc3RhcnRSdWxlID0gMDtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICB0aGlzLmlzTXV0dWFsbHlSZWN1cnNpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMucnVsZUluZGV4ZXMgPSB0aGlzLmluZGV4QXJyYXkodGhpcy5ydWxlQ291bnQpO1xuICAgICAgdGhpcy5ydWxlQWxwaGFJbmRleGVzID0gdGhpcy5pbmRleEFycmF5KHRoaXMucnVsZUNvdW50KTtcbiAgICAgIHRoaXMucnVsZVR5cGVJbmRleGVzID0gdGhpcy5pbmRleEFycmF5KHRoaXMucnVsZUNvdW50KTtcbiAgICAgIHRoaXMudWR0SW5kZXhlcyA9IHRoaXMuaW5kZXhBcnJheSh0aGlzLnVkdENvdW50KTtcbiAgICAgIHRoaXMudWR0QWxwaGFJbmRleGVzID0gdGhpcy5pbmRleEFycmF5KHRoaXMudWR0Q291bnQpO1xuICAgICAgdGhpcy5hdHRyc0Vycm9yQ291bnQgPSAwO1xuICAgICAgdGhpcy5hdHRycyA9IFtdO1xuICAgICAgdGhpcy5hdHRyc0Vycm9ycyA9IFtdO1xuICAgICAgdGhpcy5hdHRyc1dvcmtpbmcgPSBbXTtcbiAgICAgIHRoaXMucnVsZURlcHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICB0aGlzLmF0dHJzLnB1c2godGhpcy5hdHRyR2VuKHRoaXMucnVsZXNbaV0pKTtcbiAgICAgICAgdGhpcy5hdHRyc1dvcmtpbmcucHVzaCh0aGlzLmF0dHJHZW4odGhpcy5ydWxlc1tpXSkpO1xuICAgICAgICB0aGlzLnJ1bGVEZXBzLnB1c2godGhpcy5yZEdlbihydWxlc1tpXSwgdGhpcy5ydWxlQ291bnQsIHRoaXMudWR0Q291bnQpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29tcFJ1bGVzQWxwaGEgPSB0aGlzLmNvbXBSdWxlc0FscGhhLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNvbXBVZHRzQWxwaGEgPSB0aGlzLmNvbXBVZHRzQWxwaGEuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY29tcFJ1bGVzVHlwZSA9IHRoaXMuY29tcFJ1bGVzVHlwZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5jb21wUnVsZXNHcm91cCA9IHRoaXMuY29tcFJ1bGVzR3JvdXAuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGF0dHJHZW4ocnVsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgIG5lc3RlZDogZmFsc2UsXG4gICAgICAgIHJpZ2h0OiBmYWxzZSxcbiAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICBmaW5pdGU6IGZhbHNlLFxuICAgICAgICBjeWNsaWM6IGZhbHNlLFxuICAgICAgICBsZWFmOiBmYWxzZSxcbiAgICAgICAgaXNPcGVuOiBmYWxzZSxcbiAgICAgICAgaXNDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIHJ1bGUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgYXR0ckluaXQoYXR0cikge1xuICAgICAgYXR0ci5sZWZ0ID0gZmFsc2U7XG4gICAgICBhdHRyLm5lc3RlZCA9IGZhbHNlO1xuICAgICAgYXR0ci5yaWdodCA9IGZhbHNlO1xuICAgICAgYXR0ci5lbXB0eSA9IGZhbHNlO1xuICAgICAgYXR0ci5maW5pdGUgPSBmYWxzZTtcbiAgICAgIGF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgICBhdHRyLmxlYWYgPSBmYWxzZTtcbiAgICAgIGF0dHIuaXNPcGVuID0gZmFsc2U7XG4gICAgICBhdHRyLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBhdHRyQ29weShkc3QsIHNyYykge1xuICAgICAgZHN0LmxlZnQgPSBzcmMubGVmdDtcbiAgICAgIGRzdC5uZXN0ZWQgPSBzcmMubmVzdGVkO1xuICAgICAgZHN0LnJpZ2h0ID0gc3JjLnJpZ2h0O1xuICAgICAgZHN0LmVtcHR5ID0gc3JjLmVtcHR5O1xuICAgICAgZHN0LmZpbml0ZSA9IHNyYy5maW5pdGU7XG4gICAgICBkc3QuY3ljbGljID0gc3JjLmN5Y2xpYztcbiAgICAgIGRzdC5sZWFmID0gc3JjLmxlYWY7XG4gICAgICBkc3QuaXNPcGVuID0gc3JjLmlzT3BlbjtcbiAgICAgIGRzdC5pc0NvbXBsZXRlID0gc3JjLmlzQ29tcGxldGU7XG4gICAgICBkc3QucnVsZSA9IHNyYy5ydWxlO1xuICAgIH1cblxuICAgIHJkR2VuKHJ1bGUsIHJ1bGVDb3VudCwgdWR0Q291bnQpIHtcbiAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgcnVsZSxcbiAgICAgICAgcmVjdXJzaXZlVHlwZTogaWQuQVRUUl9OLFxuICAgICAgICBncm91cE51bWJlcjogLTEsXG4gICAgICAgIHJlZmVyc1RvOiB0aGlzLmZhbHNlQXJyYXkocnVsZUNvdW50KSxcbiAgICAgICAgcmVmZXJzVG9VZHQ6IHRoaXMuZmFsc2VBcnJheSh1ZHRDb3VudCksXG4gICAgICAgIHJlZmVyZW5jZWRCeTogdGhpcy5mYWxzZUFycmF5KHJ1bGVDb3VudCksXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICB0eXBlVG9TdHJpbmcocmVjdXJzaXZlVHlwZSkge1xuICAgICAgc3dpdGNoIChyZWN1cnNpdmVUeXBlKSB7XG4gICAgICAgIGNhc2UgaWQuQVRUUl9OOlxuICAgICAgICAgIHJldHVybiAnIE4nO1xuICAgICAgICBjYXNlIGlkLkFUVFJfUjpcbiAgICAgICAgICByZXR1cm4gJyBSJztcbiAgICAgICAgY2FzZSBpZC5BVFRSX01SOlxuICAgICAgICAgIHJldHVybiAnTVInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAnVU5LTk9XTic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmFsc2VBcnJheShsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHJldC5wdXNoKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmYWxzaWZ5QXJyYXkoYSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFbaV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleEFycmF5KGxlbmd0aCkge1xuICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY29tcFJ1bGVzQWxwaGEobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmICh0aGlzLnJ1bGVzW2xlZnRdLmxvd2VyIDwgdGhpcy5ydWxlc1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucnVsZXNbbGVmdF0ubG93ZXIgPiB0aGlzLnJ1bGVzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbXBVZHRzQWxwaGEobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmICh0aGlzLnVkdHNbbGVmdF0ubG93ZXIgPCB0aGlzLnVkdHNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVkdHNbbGVmdF0ubG93ZXIgPiB0aGlzLnVkdHNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29tcFJ1bGVzVHlwZShsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKHRoaXMucnVsZURlcHNbbGVmdF0ucmVjdXJzaXZlVHlwZSA8IHRoaXMucnVsZURlcHNbcmlnaHRdLnJlY3Vyc2l2ZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucnVsZURlcHNbbGVmdF0ucmVjdXJzaXZlVHlwZSA+IHRoaXMucnVsZURlcHNbcmlnaHRdLnJlY3Vyc2l2ZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBjb21wUnVsZXNHcm91cChsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKHRoaXMucnVsZURlcHNbbGVmdF0ucmVjdXJzaXZlVHlwZSA9PT0gaWQuQVRUUl9NUiAmJiB0aGlzLnJ1bGVEZXBzW3JpZ2h0XS5yZWN1cnNpdmVUeXBlID09PSBpZC5BVFRSX01SKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bGVEZXBzW2xlZnRdLmdyb3VwTnVtYmVyIDwgdGhpcy5ydWxlRGVwc1tyaWdodF0uZ3JvdXBOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVsZURlcHNbbGVmdF0uZ3JvdXBOdW1iZXIgPiB0aGlzLnJ1bGVEZXBzW3JpZ2h0XS5ncm91cE51bWJlcikge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBhdHRyaWJ1dGVzKHJ1bGVzID0gW10sIHVkdHMgPSBbXSwgbGluZU1hcCA9IFtdLCBlcnJvcnMgPSBbXSkge1xuICAgIC8vIGxldCBpID0gMDtcbiAgICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS4gVGhlIHN0YXRlIG9mIHRoZSBjb21wdXRhdGlvbiBnZXQgcGFzc2VkIGFyb3VuZCB0byBtdWx0aXBsZSBmdW5jdGlvbnMgaW4gbXVsdGlwbGUgZmlsZXMuXG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUocnVsZXMsIHVkdHMpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGFsbCBydWxlIGRlcGVuZGVuY2llc1xuICAgIC8vICAtIHdoaWNoIHJ1bGVzIGVhY2ggcnVsZSByZWZlcnMgdG9cbiAgICAvLyAgLSB3aGljaCBydWxlcyByZWZlcmVuY2UgZWFjaCBydWxlXG4gICAgcnVsZURlcGVuZGVuY2llcyhzdGF0ZSk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGF0dHJpYnV0ZXMgZm9yIGVhY2ggcnVsZS5cbiAgICBydWxlQXR0cmlidXRlcyhzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmF0dHJzRXJyb3JDb3VudCkge1xuICAgICAgZXJyb3JzLnB1c2goeyBsaW5lOiAwLCBjaGFyOiAwLCBtc2c6IGAke3N0YXRlLmF0dHJzRXJyb3JDb3VudH0gYXR0cmlidXRlIGVycm9yc2AgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgYXR0cmlidXRlIGVycm9ycyB0byB0aGUgY2FsbGVyLlxuICAgIHJldHVybiBzdGF0ZS5hdHRyc0Vycm9yQ291bnQ7XG4gIH07XG5cbiAgLyogRGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IC0gc2VlIE1ETiBXZWIgRG9jcyAqL1xuICByZXR1cm4geyBhdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZUVycm9ycywgc2hvd1J1bGVEZXBlbmRlbmNpZXMgfTtcbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/attributes.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/parser.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/parser.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module converts an input SABNF grammar text file into a\n// grammar object that can be used with `apg-lib` in an application parser.\n// **apg** is, in fact itself, an ABNF parser that generates an SABNF parser.\n// It is based on the grammar<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`.<br>\n// In its syntax phase, **apg** analyzes the user's input SABNF grammar for correct syntax, generating an AST as it goes.\n// In its semantic phase, **apg** translates the AST to generate the parser for the input grammar.\nmodule.exports = function exportParser() {\n  const thisFileName = 'parser: ';\n  const ApgLib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = ApgLib.ids;\n  const syn = new (__webpack_require__(/*! ./syntax-callbacks */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/syntax-callbacks.js\"))();\n  const sem = new (__webpack_require__(/*! ./semantic-callbacks */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/semantic-callbacks.js\"))();\n  const sabnfGrammar = new (__webpack_require__(/*! ./sabnf-grammar */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/sabnf-grammar.js\"))();\n  // eslint-disable-next-line new-cap\n  const parser = new ApgLib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new ApgLib.ast();\n  parser.callbacks = syn.callbacks;\n  parser.ast.callbacks = sem.callbacks;\n\n  /* find the line containing the given character index */\n  const findLine = function findLine(lines, charIndex, charLength) {\n    if (charIndex < 0 || charIndex >= charLength) {\n      /* return error if out of range */\n      return -1;\n    }\n    for (let i = 0; i < lines.length; i += 1) {\n      if (charIndex >= lines[i].beginChar && charIndex < lines[i].beginChar + lines[i].length) {\n        return i;\n      }\n    }\n    /* should never reach here */\n    return -1;\n  };\n  const translateIndex = function translateIndex(map, index) {\n    let ret = -1;\n    if (index < map.length) {\n      for (let i = index; i < map.length; i += 1) {\n        if (map[i] !== null) {\n          ret = map[i];\n          break;\n        }\n      }\n    }\n    return ret;\n  };\n  /* helper function when removing redundant opcodes */\n  const reduceOpcodes = function reduceOpcodes(rules) {\n    rules.forEach((rule) => {\n      const opcodes = [];\n      const map = [];\n      let reducedIndex = 0;\n      rule.opcodes.forEach((op) => {\n        if (op.type === id.ALT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.CAT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.REP && op.min === 1 && op.max === 1) {\n          map.push(null);\n        } else {\n          map.push(reducedIndex);\n          opcodes.push(op);\n          reducedIndex += 1;\n        }\n      });\n      map.push(reducedIndex);\n      /* translate original opcode indexes to the reduced set. */\n      opcodes.forEach((op) => {\n        if (op.type === id.ALT || op.type === id.CAT) {\n          for (let i = 0; i < op.children.length; i += 1) {\n            op.children[i] = translateIndex(map, op.children[i]);\n          }\n        }\n      });\n      rule.opcodes = opcodes;\n    });\n  };\n  /* Parse the grammar - the syntax phase. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.syntax = function syntax(chars, lines, errors, strict, trace) {\n    if (trace) {\n      if (trace.traceObject !== 'traceObject') {\n        throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n      }\n      parser.trace = trace;\n    }\n    const data = {};\n    data.errors = errors;\n    data.strict = !!strict;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    data.ruleCount = 0;\n    const result = parser.parse(sabnfGrammar, 'file', chars, data);\n    if (!result.success) {\n      errors.push({\n        line: 0,\n        char: 0,\n        msg: 'syntax analysis of input grammar failed',\n      });\n    }\n  };\n  /* Parse the grammar - the semantic phase, translates the AST. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.semantic = function semantic(chars, lines, errors) {\n    const data = {};\n    data.errors = errors;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    parser.ast.translate(data);\n    if (errors.length) {\n      return null;\n    }\n    /* Remove unneeded operators. */\n    /* ALT operators with a single alternate */\n    /* CAT operators with a single phrase to concatenate */\n    /* REP(1,1) operators (`1*1RuleName` or `1RuleName` is the same as just `RuleName`.) */\n    reduceOpcodes(data.rules);\n    return {\n      rules: data.rules,\n      udts: data.udts,\n      lineMap: data.rulesLineMap,\n    };\n  };\n  // Generate a grammar constructor function.\n  // An object instantiated from this constructor is used with the `apg-lib` `parser()` function.\n  this.generateSource = function generateSource(chars, lines, rules, udts, name) {\n    let source = '';\n    let i;\n    let bkrname;\n    let bkrlower;\n    let opcodeCount = 0;\n    let charCodeMin = Infinity;\n    let charCodeMax = 0;\n    const ruleNames = [];\n    const udtNames = [];\n    let alt = 0;\n    let cat = 0;\n    let rnm = 0;\n    let udt = 0;\n    let rep = 0;\n    let and = 0;\n    let not = 0;\n    let tls = 0;\n    let tbs = 0;\n    let trg = 0;\n    let bkr = 0;\n    let bka = 0;\n    let bkn = 0;\n    let abg = 0;\n    let aen = 0;\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n      opcodeCount += rule.opcodes.length;\n      rule.opcodes.forEach((op) => {\n        switch (op.type) {\n          case id.ALT:\n            alt += 1;\n            break;\n          case id.CAT:\n            cat += 1;\n            break;\n          case id.RNM:\n            rnm += 1;\n            break;\n          case id.UDT:\n            udt += 1;\n            break;\n          case id.REP:\n            rep += 1;\n            break;\n          case id.AND:\n            and += 1;\n            break;\n          case id.NOT:\n            not += 1;\n            break;\n          case id.BKA:\n            bka += 1;\n            break;\n          case id.BKN:\n            bkn += 1;\n            break;\n          case id.BKR:\n            bkr += 1;\n            break;\n          case id.ABG:\n            abg += 1;\n            break;\n          case id.AEN:\n            aen += 1;\n            break;\n          case id.TLS:\n            tls += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TBS:\n            tbs += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TRG:\n            trg += 1;\n            if (op.min < charCodeMin) {\n              charCodeMin = op.min;\n            }\n            if (op.max > charCodeMax) {\n              charCodeMax = op.max;\n            }\n            break;\n          default:\n            throw new Error('generateSource: unrecognized opcode');\n        }\n      });\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    let funcname = 'module.exports';\n    if (name && typeof name === 'string') {\n      funcname = `let ${name}`;\n    }\n    source += '// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\\n';\n    source += '//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\\n';\n    source += '//\\n';\n    source += '// Generated by apg-js, Version 4.2.1 [apg-js](https://github.com/ldthomas/apg-js)\\n';\n    source += `${funcname} = function grammar(){\\n`;\n    source += '  // ```\\n';\n    source += '  // SUMMARY\\n';\n    source += `  //      rules = ${rules.length}\\n`;\n    source += `  //       udts = ${udts.length}\\n`;\n    source += `  //    opcodes = ${opcodeCount}\\n`;\n    source += '  //        ---   ABNF original opcodes\\n';\n    source += `  //        ALT = ${alt}\\n`;\n    source += `  //        CAT = ${cat}\\n`;\n    source += `  //        REP = ${rep}\\n`;\n    source += `  //        RNM = ${rnm}\\n`;\n    source += `  //        TLS = ${tls}\\n`;\n    source += `  //        TBS = ${tbs}\\n`;\n    source += `  //        TRG = ${trg}\\n`;\n    source += '  //        ---   SABNF superset opcodes\\n';\n    source += `  //        UDT = ${udt}\\n`;\n    source += `  //        AND = ${and}\\n`;\n    source += `  //        NOT = ${not}\\n`;\n    source += `  //        BKA = ${bka}\\n`;\n    source += `  //        BKN = ${bkn}\\n`;\n    source += `  //        BKR = ${bkr}\\n`;\n    source += `  //        ABG = ${abg}\\n`;\n    source += `  //        AEN = ${aen}\\n`;\n    source += '  // characters = [';\n    if (tls + tbs + trg === 0) {\n      source += ' none defined ]';\n    } else {\n      source += `${charCodeMin} - ${charCodeMax}]`;\n    }\n    if (udt > 0) {\n      source += ' + user defined';\n    }\n    source += '\\n';\n    source += '  // ```\\n';\n    source += '  /* OBJECT IDENTIFIER (for internal parser use) */\\n';\n    source += \"  this.grammarObject = 'grammarObject';\\n\";\n    source += '\\n';\n    source += '  /* RULES */\\n';\n    source += '  this.rules = [];\\n';\n    rules.forEach((rule, ii) => {\n      let thisRule = '  this.rules[';\n      thisRule += ii;\n      thisRule += \"] = {name: '\";\n      thisRule += rule.name;\n      thisRule += \"', lower: '\";\n      thisRule += rule.lower;\n      thisRule += \"', index: \";\n      thisRule += rule.index;\n      thisRule += ', isBkr: ';\n      thisRule += rule.isBkr;\n      thisRule += '};\\n';\n      source += thisRule;\n    });\n    source += '\\n';\n    source += '  /* UDTS */\\n';\n    source += '  this.udts = [];\\n';\n    if (udts.length > 0) {\n      udts.forEach((udtFunc, ii) => {\n        let thisUdt = '  this.udts[';\n        thisUdt += ii;\n        thisUdt += \"] = {name: '\";\n        thisUdt += udtFunc.name;\n        thisUdt += \"', lower: '\";\n        thisUdt += udtFunc.lower;\n        thisUdt += \"', index: \";\n        thisUdt += udtFunc.index;\n        thisUdt += ', empty: ';\n        thisUdt += udtFunc.empty;\n        thisUdt += ', isBkr: ';\n        thisUdt += udtFunc.isBkr;\n        thisUdt += '};\\n';\n        source += thisUdt;\n      });\n    }\n    source += '\\n';\n    source += '  /* OPCODES */\\n';\n    rules.forEach((rule, ruleIndex) => {\n      if (ruleIndex > 0) {\n        source += '\\n';\n      }\n      source += `  /* ${rule.name} */\\n`;\n      source += `  this.rules[${ruleIndex}].opcodes = [];\\n`;\n      rule.opcodes.forEach((op, opIndex) => {\n        let prefix;\n        switch (op.type) {\n          case id.ALT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, children: [${op.children.toString()}]};// ALT\\n`;\n            break;\n          case id.CAT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, children: [${op.children.toString()}]};// CAT\\n`;\n            break;\n          case id.RNM:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}};// RNM(${\n              rules[op.index].name\n            })\\n`;\n            break;\n          case id.BKR:\n            if (op.index >= rules.length) {\n              bkrname = udts[op.index - rules.length].name;\n              bkrlower = udts[op.index - rules.length].lower;\n            } else {\n              bkrname = rules[op.index].name;\n              bkrlower = rules[op.index].lower;\n            }\n            prefix = '%i';\n            if (op.bkrCase === id.BKR_MODE_CS) {\n              prefix = '%s';\n            }\n            if (op.bkrMode === id.BKR_MODE_UM) {\n              prefix += '%u';\n            } else {\n              prefix += '%p';\n            }\n            bkrname = prefix + bkrname;\n            source +=\n              `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}, lower: '${bkrlower}'` +\n              `, bkrCase: ${op.bkrCase}, bkrMode: ${op.bkrMode}};// BKR(\\\\${bkrname})\\n`;\n            break;\n          case id.UDT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, empty: ${op.empty}, index: ${\n              op.index\n            }};// UDT(${udts[op.index].name})\\n`;\n            break;\n          case id.REP:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// REP\\n`;\n            break;\n          case id.AND:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AND\\n`;\n            break;\n          case id.NOT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// NOT\\n`;\n            break;\n          case id.ABG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// ABG(%^)\\n`;\n            break;\n          case id.AEN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AEN(%$)\\n`;\n            break;\n          case id.BKA:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKA\\n`;\n            break;\n          case id.BKN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKN\\n`;\n            break;\n          case id.TLS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, string: [${op.string.toString()}]};// TLS\\n`;\n            break;\n          case id.TBS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${\n              op.type\n            }, string: [${op.string.toString()}]};// TBS\\n`;\n            break;\n          case id.TRG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// TRG\\n`;\n            break;\n          default:\n            throw new Error('parser.js: ~143: unrecognized opcode');\n        }\n      });\n    });\n    source += '\\n';\n    source += '  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\\n';\n    source += '  this.toString = function toString(){\\n';\n    source += '    let str = \"\";\\n';\n    let str;\n    lines.forEach((line) => {\n      const end = line.beginChar + line.length;\n      str = '';\n      source += '    str += \"';\n      for (let ii = line.beginChar; ii < end; ii += 1) {\n        switch (chars[ii]) {\n          case 9:\n            str = ' ';\n            break;\n          case 10:\n            str = '\\\\n';\n            break;\n          case 13:\n            str = '\\\\r';\n            break;\n          case 34:\n            str = '\\\\\"';\n            break;\n          case 92:\n            str = '\\\\\\\\';\n            break;\n          default:\n            str = String.fromCharCode(chars[ii]);\n            break;\n        }\n        source += str;\n      }\n      source += '\";\\n';\n    });\n    source += '    return str;\\n';\n    source += '  }\\n';\n    source += '}\\n';\n    return source;\n  };\n  // Generate a grammar file object.\n  // Returns the same object as instantiating the constructor function returned by<br>\n  // `this.generateSource()`.<br>\n  this.generateObject = function generateObject(stringArg, rules, udts) {\n    const obj = {};\n    const ruleNames = [];\n    const udtNames = [];\n    const string = stringArg.slice(0);\n    obj.grammarObject = 'grammarObject';\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    obj.callbacks = [];\n    ruleNames.forEach((name) => {\n      obj.callbacks[name] = false;\n    });\n    if (udts.length > 0) {\n      udtNames.forEach((name) => {\n        obj.callbacks[name] = false;\n      });\n    }\n    obj.rules = rules;\n    obj.udts = udts;\n    obj.toString = function toStringFunc() {\n      return string;\n    };\n    return obj;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDRIQUF5QjtBQUNsRDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLDJIQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQywrSEFBc0I7QUFDakQsNEJBQTRCLG1CQUFPLENBQUMscUhBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUs7QUFDTDtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMLDhCQUE4QjtBQUM5QixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3BhcnNlci5qcz8wMWVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGNvbnZlcnRzIGFuIGlucHV0IFNBQk5GIGdyYW1tYXIgdGV4dCBmaWxlIGludG8gYVxuLy8gZ3JhbW1hciBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGBhcGctbGliYCBpbiBhbiBhcHBsaWNhdGlvbiBwYXJzZXIuXG4vLyAqKmFwZyoqIGlzLCBpbiBmYWN0IGl0c2VsZiwgYW4gQUJORiBwYXJzZXIgdGhhdCBnZW5lcmF0ZXMgYW4gU0FCTkYgcGFyc2VyLlxuLy8gSXQgaXMgYmFzZWQgb24gdGhlIGdyYW1tYXI8YnI+XG4vLyBgLi9kaXN0L2FibmYtZm9yLXNhYm5mLWdyYW1tYXIuYm5mYC48YnI+XG4vLyBJbiBpdHMgc3ludGF4IHBoYXNlLCAqKmFwZyoqIGFuYWx5emVzIHRoZSB1c2VyJ3MgaW5wdXQgU0FCTkYgZ3JhbW1hciBmb3IgY29ycmVjdCBzeW50YXgsIGdlbmVyYXRpbmcgYW4gQVNUIGFzIGl0IGdvZXMuXG4vLyBJbiBpdHMgc2VtYW50aWMgcGhhc2UsICoqYXBnKiogdHJhbnNsYXRlcyB0aGUgQVNUIHRvIGdlbmVyYXRlIHRoZSBwYXJzZXIgZm9yIHRoZSBpbnB1dCBncmFtbWFyLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHBvcnRQYXJzZXIoKSB7XG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdwYXJzZXI6ICc7XG4gIGNvbnN0IEFwZ0xpYiA9IHJlcXVpcmUoJy4uL2FwZy1saWIvbm9kZS1leHBvcnRzJyk7XG4gIGNvbnN0IGlkID0gQXBnTGliLmlkcztcbiAgY29uc3Qgc3luID0gbmV3IChyZXF1aXJlKCcuL3N5bnRheC1jYWxsYmFja3MnKSkoKTtcbiAgY29uc3Qgc2VtID0gbmV3IChyZXF1aXJlKCcuL3NlbWFudGljLWNhbGxiYWNrcycpKSgpO1xuICBjb25zdCBzYWJuZkdyYW1tYXIgPSBuZXcgKHJlcXVpcmUoJy4vc2FibmYtZ3JhbW1hcicpKSgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICBjb25zdCBwYXJzZXIgPSBuZXcgQXBnTGliLnBhcnNlcigpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICBwYXJzZXIuYXN0ID0gbmV3IEFwZ0xpYi5hc3QoKTtcbiAgcGFyc2VyLmNhbGxiYWNrcyA9IHN5bi5jYWxsYmFja3M7XG4gIHBhcnNlci5hc3QuY2FsbGJhY2tzID0gc2VtLmNhbGxiYWNrcztcblxuICAvKiBmaW5kIHRoZSBsaW5lIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGNoYXJhY3RlciBpbmRleCAqL1xuICBjb25zdCBmaW5kTGluZSA9IGZ1bmN0aW9uIGZpbmRMaW5lKGxpbmVzLCBjaGFySW5kZXgsIGNoYXJMZW5ndGgpIHtcbiAgICBpZiAoY2hhckluZGV4IDwgMCB8fCBjaGFySW5kZXggPj0gY2hhckxlbmd0aCkge1xuICAgICAgLyogcmV0dXJuIGVycm9yIGlmIG91dCBvZiByYW5nZSAqL1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoY2hhckluZGV4ID49IGxpbmVzW2ldLmJlZ2luQ2hhciAmJiBjaGFySW5kZXggPCBsaW5lc1tpXS5iZWdpbkNoYXIgKyBsaW5lc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIHNob3VsZCBuZXZlciByZWFjaCBoZXJlICovXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuICBjb25zdCB0cmFuc2xhdGVJbmRleCA9IGZ1bmN0aW9uIHRyYW5zbGF0ZUluZGV4KG1hcCwgaW5kZXgpIHtcbiAgICBsZXQgcmV0ID0gLTE7XG4gICAgaWYgKGluZGV4IDwgbWFwLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgbWFwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChtYXBbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICByZXQgPSBtYXBbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgLyogaGVscGVyIGZ1bmN0aW9uIHdoZW4gcmVtb3ZpbmcgcmVkdW5kYW50IG9wY29kZXMgKi9cbiAgY29uc3QgcmVkdWNlT3Bjb2RlcyA9IGZ1bmN0aW9uIHJlZHVjZU9wY29kZXMocnVsZXMpIHtcbiAgICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICBjb25zdCBvcGNvZGVzID0gW107XG4gICAgICBjb25zdCBtYXAgPSBbXTtcbiAgICAgIGxldCByZWR1Y2VkSW5kZXggPSAwO1xuICAgICAgcnVsZS5vcGNvZGVzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgIGlmIChvcC50eXBlID09PSBpZC5BTFQgJiYgb3AuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbWFwLnB1c2gobnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3AudHlwZSA9PT0gaWQuQ0FUICYmIG9wLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG1hcC5wdXNoKG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09IGlkLlJFUCAmJiBvcC5taW4gPT09IDEgJiYgb3AubWF4ID09PSAxKSB7XG4gICAgICAgICAgbWFwLnB1c2gobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFwLnB1c2gocmVkdWNlZEluZGV4KTtcbiAgICAgICAgICBvcGNvZGVzLnB1c2gob3ApO1xuICAgICAgICAgIHJlZHVjZWRJbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG1hcC5wdXNoKHJlZHVjZWRJbmRleCk7XG4gICAgICAvKiB0cmFuc2xhdGUgb3JpZ2luYWwgb3Bjb2RlIGluZGV4ZXMgdG8gdGhlIHJlZHVjZWQgc2V0LiAqL1xuICAgICAgb3Bjb2Rlcy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICBpZiAob3AudHlwZSA9PT0gaWQuQUxUIHx8IG9wLnR5cGUgPT09IGlkLkNBVCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3AuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9wLmNoaWxkcmVuW2ldID0gdHJhbnNsYXRlSW5kZXgobWFwLCBvcC5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJ1bGUub3Bjb2RlcyA9IG9wY29kZXM7XG4gICAgfSk7XG4gIH07XG4gIC8qIFBhcnNlIHRoZSBncmFtbWFyIC0gdGhlIHN5bnRheCBwaGFzZS4gKi9cbiAgLyogU0FCTkYgZ3JhbW1hciBzeW50YXggZXJyb3JzIGFyZSBjYXVnaHQgYW5kIHJlcG9ydGVkIGhlcmUuICovXG4gIHRoaXMuc3ludGF4ID0gZnVuY3Rpb24gc3ludGF4KGNoYXJzLCBsaW5lcywgZXJyb3JzLCBzdHJpY3QsIHRyYWNlKSB7XG4gICAgaWYgKHRyYWNlKSB7XG4gICAgICBpZiAodHJhY2UudHJhY2VPYmplY3QgIT09ICd0cmFjZU9iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0aGlzRmlsZU5hbWV9dHJhY2UgYXJndW1lbnQgaXMgbm90IGEgdHJhY2Ugb2JqZWN0YCk7XG4gICAgICB9XG4gICAgICBwYXJzZXIudHJhY2UgPSB0cmFjZTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGRhdGEuZXJyb3JzID0gZXJyb3JzO1xuICAgIGRhdGEuc3RyaWN0ID0gISFzdHJpY3Q7XG4gICAgZGF0YS5saW5lcyA9IGxpbmVzO1xuICAgIGRhdGEuZmluZExpbmUgPSBmaW5kTGluZTtcbiAgICBkYXRhLmNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgIGRhdGEucnVsZUNvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2Uoc2FibmZHcmFtbWFyLCAnZmlsZScsIGNoYXJzLCBkYXRhKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIGxpbmU6IDAsXG4gICAgICAgIGNoYXI6IDAsXG4gICAgICAgIG1zZzogJ3N5bnRheCBhbmFseXNpcyBvZiBpbnB1dCBncmFtbWFyIGZhaWxlZCcsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qIFBhcnNlIHRoZSBncmFtbWFyIC0gdGhlIHNlbWFudGljIHBoYXNlLCB0cmFuc2xhdGVzIHRoZSBBU1QuICovXG4gIC8qIFNBQk5GIGdyYW1tYXIgc3ludGF4IGVycm9ycyBhcmUgY2F1Z2h0IGFuZCByZXBvcnRlZCBoZXJlLiAqL1xuICB0aGlzLnNlbWFudGljID0gZnVuY3Rpb24gc2VtYW50aWMoY2hhcnMsIGxpbmVzLCBlcnJvcnMpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZGF0YS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgZGF0YS5saW5lcyA9IGxpbmVzO1xuICAgIGRhdGEuZmluZExpbmUgPSBmaW5kTGluZTtcbiAgICBkYXRhLmNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgIHBhcnNlci5hc3QudHJhbnNsYXRlKGRhdGEpO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyogUmVtb3ZlIHVubmVlZGVkIG9wZXJhdG9ycy4gKi9cbiAgICAvKiBBTFQgb3BlcmF0b3JzIHdpdGggYSBzaW5nbGUgYWx0ZXJuYXRlICovXG4gICAgLyogQ0FUIG9wZXJhdG9ycyB3aXRoIGEgc2luZ2xlIHBocmFzZSB0byBjb25jYXRlbmF0ZSAqL1xuICAgIC8qIFJFUCgxLDEpIG9wZXJhdG9ycyAoYDEqMVJ1bGVOYW1lYCBvciBgMVJ1bGVOYW1lYCBpcyB0aGUgc2FtZSBhcyBqdXN0IGBSdWxlTmFtZWAuKSAqL1xuICAgIHJlZHVjZU9wY29kZXMoZGF0YS5ydWxlcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJ1bGVzOiBkYXRhLnJ1bGVzLFxuICAgICAgdWR0czogZGF0YS51ZHRzLFxuICAgICAgbGluZU1hcDogZGF0YS5ydWxlc0xpbmVNYXAsXG4gICAgfTtcbiAgfTtcbiAgLy8gR2VuZXJhdGUgYSBncmFtbWFyIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAvLyBBbiBvYmplY3QgaW5zdGFudGlhdGVkIGZyb20gdGhpcyBjb25zdHJ1Y3RvciBpcyB1c2VkIHdpdGggdGhlIGBhcGctbGliYCBgcGFyc2VyKClgIGZ1bmN0aW9uLlxuICB0aGlzLmdlbmVyYXRlU291cmNlID0gZnVuY3Rpb24gZ2VuZXJhdGVTb3VyY2UoY2hhcnMsIGxpbmVzLCBydWxlcywgdWR0cywgbmFtZSkge1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBsZXQgaTtcbiAgICBsZXQgYmtybmFtZTtcbiAgICBsZXQgYmtybG93ZXI7XG4gICAgbGV0IG9wY29kZUNvdW50ID0gMDtcbiAgICBsZXQgY2hhckNvZGVNaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgY2hhckNvZGVNYXggPSAwO1xuICAgIGNvbnN0IHJ1bGVOYW1lcyA9IFtdO1xuICAgIGNvbnN0IHVkdE5hbWVzID0gW107XG4gICAgbGV0IGFsdCA9IDA7XG4gICAgbGV0IGNhdCA9IDA7XG4gICAgbGV0IHJubSA9IDA7XG4gICAgbGV0IHVkdCA9IDA7XG4gICAgbGV0IHJlcCA9IDA7XG4gICAgbGV0IGFuZCA9IDA7XG4gICAgbGV0IG5vdCA9IDA7XG4gICAgbGV0IHRscyA9IDA7XG4gICAgbGV0IHRicyA9IDA7XG4gICAgbGV0IHRyZyA9IDA7XG4gICAgbGV0IGJrciA9IDA7XG4gICAgbGV0IGJrYSA9IDA7XG4gICAgbGV0IGJrbiA9IDA7XG4gICAgbGV0IGFiZyA9IDA7XG4gICAgbGV0IGFlbiA9IDA7XG4gICAgcnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgcnVsZU5hbWVzLnB1c2gocnVsZS5sb3dlcik7XG4gICAgICBvcGNvZGVDb3VudCArPSBydWxlLm9wY29kZXMubGVuZ3RoO1xuICAgICAgcnVsZS5vcGNvZGVzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICAgICAgYWx0ICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgICAgIGNhdCArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgICAgICBybm0gKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVURUOlxuICAgICAgICAgICAgdWR0ICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgICAgIHJlcCArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5BTkQ6XG4gICAgICAgICAgICBhbmQgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuTk9UOlxuICAgICAgICAgICAgbm90ICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkJLQTpcbiAgICAgICAgICAgIGJrYSArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5CS046XG4gICAgICAgICAgICBia24gKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICAgICAgYmtyICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFCRzpcbiAgICAgICAgICAgIGFiZyArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5BRU46XG4gICAgICAgICAgICBhZW4gKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVExTOlxuICAgICAgICAgICAgdGxzICs9IDE7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3Auc3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5zdHJpbmdbaV0gPCBjaGFyQ29kZU1pbikge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlTWluID0gb3Auc3RyaW5nW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvcC5zdHJpbmdbaV0gPiBjaGFyQ29kZU1heCkge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlTWF4ID0gb3Auc3RyaW5nW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRCUzpcbiAgICAgICAgICAgIHRicyArPSAxO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9wLnN0cmluZy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAob3Auc3RyaW5nW2ldIDwgY2hhckNvZGVNaW4pIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZU1pbiA9IG9wLnN0cmluZ1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3Auc3RyaW5nW2ldID4gY2hhckNvZGVNYXgpIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZU1heCA9IG9wLnN0cmluZ1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgICAgICB0cmcgKz0gMTtcbiAgICAgICAgICAgIGlmIChvcC5taW4gPCBjaGFyQ29kZU1pbikge1xuICAgICAgICAgICAgICBjaGFyQ29kZU1pbiA9IG9wLm1pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcC5tYXggPiBjaGFyQ29kZU1heCkge1xuICAgICAgICAgICAgICBjaGFyQ29kZU1heCA9IG9wLm1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRlU291cmNlOiB1bnJlY29nbml6ZWQgb3Bjb2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJ1bGVOYW1lcy5zb3J0KCk7XG4gICAgaWYgKHVkdHMubGVuZ3RoID4gMCkge1xuICAgICAgdWR0cy5mb3JFYWNoKCh1ZHRGdW5jKSA9PiB7XG4gICAgICAgIHVkdE5hbWVzLnB1c2godWR0RnVuYy5sb3dlcik7XG4gICAgICB9KTtcbiAgICAgIHVkdE5hbWVzLnNvcnQoKTtcbiAgICB9XG4gICAgbGV0IGZ1bmNuYW1lID0gJ21vZHVsZS5leHBvcnRzJztcbiAgICBpZiAobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZ1bmNuYW1lID0gYGxldCAke25hbWV9YDtcbiAgICB9XG4gICAgc291cmNlICs9ICcvLyBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMyBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkPGJyPlxcbic7XG4gICAgc291cmNlICs9ICcvLyAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpPGJyPlxcbic7XG4gICAgc291cmNlICs9ICcvL1xcbic7XG4gICAgc291cmNlICs9ICcvLyBHZW5lcmF0ZWQgYnkgYXBnLWpzLCBWZXJzaW9uIDQuMi4xIFthcGctanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMpXFxuJztcbiAgICBzb3VyY2UgKz0gYCR7ZnVuY25hbWV9ID0gZnVuY3Rpb24gZ3JhbW1hcigpe1xcbmA7XG4gICAgc291cmNlICs9ICcgIC8vIGBgYFxcbic7XG4gICAgc291cmNlICs9ICcgIC8vIFNVTU1BUllcXG4nO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgIHJ1bGVzID0gJHtydWxlcy5sZW5ndGh9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgdWR0cyA9ICR7dWR0cy5sZW5ndGh9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgb3Bjb2RlcyA9ICR7b3Bjb2RlQ291bnR9XFxuYDtcbiAgICBzb3VyY2UgKz0gJyAgLy8gICAgICAgIC0tLSAgIEFCTkYgb3JpZ2luYWwgb3Bjb2Rlc1xcbic7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBBTFQgPSAke2FsdH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQ0FUID0gJHtjYXR9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIFJFUCA9ICR7cmVwfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBSTk0gPSAke3JubX1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgVExTID0gJHt0bHN9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIFRCUyA9ICR7dGJzfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBUUkcgPSAke3RyZ31cXG5gO1xuICAgIHNvdXJjZSArPSAnICAvLyAgICAgICAgLS0tICAgU0FCTkYgc3VwZXJzZXQgb3Bjb2Rlc1xcbic7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBVRFQgPSAke3VkdH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQU5EID0gJHthbmR9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIE5PVCA9ICR7bm90fVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBCS0EgPSAke2JrYX1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQktOID0gJHtia259XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIEJLUiA9ICR7YmtyfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBBQkcgPSAke2FiZ31cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQUVOID0gJHthZW59XFxuYDtcbiAgICBzb3VyY2UgKz0gJyAgLy8gY2hhcmFjdGVycyA9IFsnO1xuICAgIGlmICh0bHMgKyB0YnMgKyB0cmcgPT09IDApIHtcbiAgICAgIHNvdXJjZSArPSAnIG5vbmUgZGVmaW5lZCBdJztcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlICs9IGAke2NoYXJDb2RlTWlufSAtICR7Y2hhckNvZGVNYXh9XWA7XG4gICAgfVxuICAgIGlmICh1ZHQgPiAwKSB7XG4gICAgICBzb3VyY2UgKz0gJyArIHVzZXIgZGVmaW5lZCc7XG4gICAgfVxuICAgIHNvdXJjZSArPSAnXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLy8gYGBgXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLyogT0JKRUNUIElERU5USUZJRVIgKGZvciBpbnRlcm5hbCBwYXJzZXIgdXNlKSAqL1xcbic7XG4gICAgc291cmNlICs9IFwiICB0aGlzLmdyYW1tYXJPYmplY3QgPSAnZ3JhbW1hck9iamVjdCc7XFxuXCI7XG4gICAgc291cmNlICs9ICdcXG4nO1xuICAgIHNvdXJjZSArPSAnICAvKiBSVUxFUyAqL1xcbic7XG4gICAgc291cmNlICs9ICcgIHRoaXMucnVsZXMgPSBbXTtcXG4nO1xuICAgIHJ1bGVzLmZvckVhY2goKHJ1bGUsIGlpKSA9PiB7XG4gICAgICBsZXQgdGhpc1J1bGUgPSAnICB0aGlzLnJ1bGVzWyc7XG4gICAgICB0aGlzUnVsZSArPSBpaTtcbiAgICAgIHRoaXNSdWxlICs9IFwiXSA9IHtuYW1lOiAnXCI7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLm5hbWU7XG4gICAgICB0aGlzUnVsZSArPSBcIicsIGxvd2VyOiAnXCI7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLmxvd2VyO1xuICAgICAgdGhpc1J1bGUgKz0gXCInLCBpbmRleDogXCI7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLmluZGV4O1xuICAgICAgdGhpc1J1bGUgKz0gJywgaXNCa3I6ICc7XG4gICAgICB0aGlzUnVsZSArPSBydWxlLmlzQmtyO1xuICAgICAgdGhpc1J1bGUgKz0gJ307XFxuJztcbiAgICAgIHNvdXJjZSArPSB0aGlzUnVsZTtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gJ1xcbic7XG4gICAgc291cmNlICs9ICcgIC8qIFVEVFMgKi9cXG4nO1xuICAgIHNvdXJjZSArPSAnICB0aGlzLnVkdHMgPSBbXTtcXG4nO1xuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdHMuZm9yRWFjaCgodWR0RnVuYywgaWkpID0+IHtcbiAgICAgICAgbGV0IHRoaXNVZHQgPSAnICB0aGlzLnVkdHNbJztcbiAgICAgICAgdGhpc1VkdCArPSBpaTtcbiAgICAgICAgdGhpc1VkdCArPSBcIl0gPSB7bmFtZTogJ1wiO1xuICAgICAgICB0aGlzVWR0ICs9IHVkdEZ1bmMubmFtZTtcbiAgICAgICAgdGhpc1VkdCArPSBcIicsIGxvd2VyOiAnXCI7XG4gICAgICAgIHRoaXNVZHQgKz0gdWR0RnVuYy5sb3dlcjtcbiAgICAgICAgdGhpc1VkdCArPSBcIicsIGluZGV4OiBcIjtcbiAgICAgICAgdGhpc1VkdCArPSB1ZHRGdW5jLmluZGV4O1xuICAgICAgICB0aGlzVWR0ICs9ICcsIGVtcHR5OiAnO1xuICAgICAgICB0aGlzVWR0ICs9IHVkdEZ1bmMuZW1wdHk7XG4gICAgICAgIHRoaXNVZHQgKz0gJywgaXNCa3I6ICc7XG4gICAgICAgIHRoaXNVZHQgKz0gdWR0RnVuYy5pc0JrcjtcbiAgICAgICAgdGhpc1VkdCArPSAnfTtcXG4nO1xuICAgICAgICBzb3VyY2UgKz0gdGhpc1VkdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzb3VyY2UgKz0gJ1xcbic7XG4gICAgc291cmNlICs9ICcgIC8qIE9QQ09ERVMgKi9cXG4nO1xuICAgIHJ1bGVzLmZvckVhY2goKHJ1bGUsIHJ1bGVJbmRleCkgPT4ge1xuICAgICAgaWYgKHJ1bGVJbmRleCA+IDApIHtcbiAgICAgICAgc291cmNlICs9ICdcXG4nO1xuICAgICAgfVxuICAgICAgc291cmNlICs9IGAgIC8qICR7cnVsZS5uYW1lfSAqL1xcbmA7XG4gICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXMgPSBbXTtcXG5gO1xuICAgICAgcnVsZS5vcGNvZGVzLmZvckVhY2goKG9wLCBvcEluZGV4KSA9PiB7XG4gICAgICAgIGxldCBwcmVmaXg7XG4gICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7XG4gICAgICAgICAgICAgIG9wLnR5cGVcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbJHtvcC5jaGlsZHJlbi50b1N0cmluZygpfV19Oy8vIEFMVFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke1xuICAgICAgICAgICAgICBvcC50eXBlXG4gICAgICAgICAgICB9LCBjaGlsZHJlbjogWyR7b3AuY2hpbGRyZW4udG9TdHJpbmcoKX1dfTsvLyBDQVRcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfSwgaW5kZXg6ICR7b3AuaW5kZXh9fTsvLyBSTk0oJHtcbiAgICAgICAgICAgICAgcnVsZXNbb3AuaW5kZXhdLm5hbWVcbiAgICAgICAgICAgIH0pXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICAgICAgaWYgKG9wLmluZGV4ID49IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBia3JuYW1lID0gdWR0c1tvcC5pbmRleCAtIHJ1bGVzLmxlbmd0aF0ubmFtZTtcbiAgICAgICAgICAgICAgYmtybG93ZXIgPSB1ZHRzW29wLmluZGV4IC0gcnVsZXMubGVuZ3RoXS5sb3dlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJrcm5hbWUgPSBydWxlc1tvcC5pbmRleF0ubmFtZTtcbiAgICAgICAgICAgICAgYmtybG93ZXIgPSBydWxlc1tvcC5pbmRleF0ubG93ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmaXggPSAnJWknO1xuICAgICAgICAgICAgaWYgKG9wLmJrckNhc2UgPT09IGlkLkJLUl9NT0RFX0NTKSB7XG4gICAgICAgICAgICAgIHByZWZpeCA9ICclcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3AuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfVU0pIHtcbiAgICAgICAgICAgICAgcHJlZml4ICs9ICcldSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcmVmaXggKz0gJyVwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJrcm5hbWUgPSBwcmVmaXggKyBia3JuYW1lO1xuICAgICAgICAgICAgc291cmNlICs9XG4gICAgICAgICAgICAgIGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX0sIGluZGV4OiAke29wLmluZGV4fSwgbG93ZXI6ICcke2Jrcmxvd2VyfSdgICtcbiAgICAgICAgICAgICAgYCwgYmtyQ2FzZTogJHtvcC5ia3JDYXNlfSwgYmtyTW9kZTogJHtvcC5ia3JNb2RlfX07Ly8gQktSKFxcXFwke2Jrcm5hbWV9KVxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlVEVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9LCBlbXB0eTogJHtvcC5lbXB0eX0sIGluZGV4OiAke1xuICAgICAgICAgICAgICBvcC5pbmRleFxuICAgICAgICAgICAgfX07Ly8gVURUKCR7dWR0c1tvcC5pbmRleF0ubmFtZX0pXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuUkVQOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX0sIG1pbjogJHtvcC5taW59LCBtYXg6ICR7b3AubWF4fX07Ly8gUkVQXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQU5EOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX19Oy8vIEFORFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLk5PVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9fTsvLyBOT1RcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5BQkc6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfX07Ly8gQUJHKCVeKVxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFFTjpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9fTsvLyBBRU4oJSQpXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktBOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX19Oy8vIEJLQVxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkJLTjpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9fTsvLyBCS05cXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtcbiAgICAgICAgICAgICAgb3AudHlwZVxuICAgICAgICAgICAgfSwgc3RyaW5nOiBbJHtvcC5zdHJpbmcudG9TdHJpbmcoKX1dfTsvLyBUTFNcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UQlM6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtcbiAgICAgICAgICAgICAgb3AudHlwZVxuICAgICAgICAgICAgfSwgc3RyaW5nOiBbJHtvcC5zdHJpbmcudG9TdHJpbmcoKX1dfTsvLyBUQlNcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfSwgbWluOiAke29wLm1pbn0sIG1heDogJHtvcC5tYXh9fTsvLyBUUkdcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyc2VyLmpzOiB+MTQzOiB1bnJlY29nbml6ZWQgb3Bjb2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSAnXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLy8gVGhlIGB0b1N0cmluZygpYCBmdW5jdGlvbiB3aWxsIGRpc3BsYXkgdGhlIG9yaWdpbmFsIGdyYW1tYXIgZmlsZShzKSB0aGF0IHByb2R1Y2VkIHRoZXNlIG9wY29kZXMuXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XFxuJztcbiAgICBzb3VyY2UgKz0gJyAgICBsZXQgc3RyID0gXCJcIjtcXG4nO1xuICAgIGxldCBzdHI7XG4gICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgY29uc3QgZW5kID0gbGluZS5iZWdpbkNoYXIgKyBsaW5lLmxlbmd0aDtcbiAgICAgIHN0ciA9ICcnO1xuICAgICAgc291cmNlICs9ICcgICAgc3RyICs9IFwiJztcbiAgICAgIGZvciAobGV0IGlpID0gbGluZS5iZWdpbkNoYXI7IGlpIDwgZW5kOyBpaSArPSAxKSB7XG4gICAgICAgIHN3aXRjaCAoY2hhcnNbaWldKSB7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgc3RyID0gJyAnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHN0ciA9ICdcXFxcbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgc3RyID0gJ1xcXFxyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBzdHIgPSAnXFxcXFwiJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAgICBzdHIgPSAnXFxcXFxcXFwnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcnNbaWldKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSArPSBzdHI7XG4gICAgICB9XG4gICAgICBzb3VyY2UgKz0gJ1wiO1xcbic7XG4gICAgfSk7XG4gICAgc291cmNlICs9ICcgICAgcmV0dXJuIHN0cjtcXG4nO1xuICAgIHNvdXJjZSArPSAnICB9XFxuJztcbiAgICBzb3VyY2UgKz0gJ31cXG4nO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH07XG4gIC8vIEdlbmVyYXRlIGEgZ3JhbW1hciBmaWxlIG9iamVjdC5cbiAgLy8gUmV0dXJucyB0aGUgc2FtZSBvYmplY3QgYXMgaW5zdGFudGlhdGluZyB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24gcmV0dXJuZWQgYnk8YnI+XG4gIC8vIGB0aGlzLmdlbmVyYXRlU291cmNlKClgLjxicj5cbiAgdGhpcy5nZW5lcmF0ZU9iamVjdCA9IGZ1bmN0aW9uIGdlbmVyYXRlT2JqZWN0KHN0cmluZ0FyZywgcnVsZXMsIHVkdHMpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb25zdCBydWxlTmFtZXMgPSBbXTtcbiAgICBjb25zdCB1ZHROYW1lcyA9IFtdO1xuICAgIGNvbnN0IHN0cmluZyA9IHN0cmluZ0FyZy5zbGljZSgwKTtcbiAgICBvYmouZ3JhbW1hck9iamVjdCA9ICdncmFtbWFyT2JqZWN0JztcbiAgICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICBydWxlTmFtZXMucHVzaChydWxlLmxvd2VyKTtcbiAgICB9KTtcbiAgICBydWxlTmFtZXMuc29ydCgpO1xuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdHMuZm9yRWFjaCgodWR0RnVuYykgPT4ge1xuICAgICAgICB1ZHROYW1lcy5wdXNoKHVkdEZ1bmMubG93ZXIpO1xuICAgICAgfSk7XG4gICAgICB1ZHROYW1lcy5zb3J0KCk7XG4gICAgfVxuICAgIG9iai5jYWxsYmFja3MgPSBbXTtcbiAgICBydWxlTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgb2JqLmNhbGxiYWNrc1tuYW1lXSA9IGZhbHNlO1xuICAgIH0pO1xuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgb2JqLmNhbGxiYWNrc1tuYW1lXSA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIG9iai5ydWxlcyA9IHJ1bGVzO1xuICAgIG9iai51ZHRzID0gdWR0cztcbiAgICBvYmoudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZ0Z1bmMoKSB7XG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/parser.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-attributes.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-attributes.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module does the heavy lifting for attribute generation.\nmodule.exports = (function exportRuleAttributes() {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const thisFile = 'rule-attributes.js';\n  let state = null;\n  function isEmptyOnly(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return false;\n    }\n    return attr.empty;\n  }\n  function isRecursive(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return true;\n    }\n    return false;\n  }\n  function isCatNested(attrs, count) {\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    /* 1. if any child is nested, CAT is nested */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].nested) {\n        return true;\n      }\n    }\n    /* 2.) the left-most right recursive child\n               is followed by at least one non-empty child */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].right && !attrs[i].leaf) {\n        for (j = i + 1; j < count; j += 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 3.) the right-most left recursive child\n               is preceded by at least one non-empty child */\n    for (i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].left && !attrs[i].leaf) {\n        for (j = i - 1; j >= 0; j -= 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 4. there is at lease one recursive child between\n              the left-most and right-most non-recursive, non-empty children */\n    for (i = 0; i < count; i += 1) {\n      if (!attrs[i].empty && !isRecursive(attrs[i])) {\n        for (j = i + 1; j < count; j += 1) {\n          if (isRecursive(attrs[j])) {\n            for (k = j + 1; k < count; k += 1) {\n              if (!attrs[k].empty && !isRecursive(attrs[k])) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /* none of the above */\n    return false;\n  }\n  function isCatCyclic(attrs, count) {\n    /* if all children are cyclic, CAT is cyclic */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].cyclic) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatLeft(attrs, count) {\n    /* if the left-most non-empty is left, CAT is left */\n    for (let i = 0; i < count; i += 1) {\n      if (attrs[i].left) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false; /* all left-most are empty */\n  }\n  function isCatRight(attrs, count) {\n    /* if the right-most non-empty is right, CAT is right */\n    for (let i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].right) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false;\n  }\n  function isCatEmpty(attrs, count) {\n    /* if all children are empty, CAT is empty */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].empty) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatFinite(attrs, count) {\n    /* if all children are finite, CAT is finite */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].finite) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function cat(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opCat = opcodes[opIndex];\n    const count = opCat.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opCat.children[i], childAttrs[i]);\n    }\n    iAttr.left = isCatLeft(childAttrs, count);\n    iAttr.right = isCatRight(childAttrs, count);\n    iAttr.nested = isCatNested(childAttrs, count);\n    iAttr.empty = isCatEmpty(childAttrs, count);\n    iAttr.finite = isCatFinite(childAttrs, count);\n    iAttr.cyclic = isCatCyclic(childAttrs, count);\n  }\n  function alt(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opAlt = opcodes[opIndex];\n    const count = opAlt.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opAlt.children[i], childAttrs[i]);\n    }\n\n    /* if any child attribute is true, ALT is true */\n    iAttr.left = false;\n    iAttr.right = false;\n    iAttr.nested = false;\n    iAttr.empty = false;\n    iAttr.finite = false;\n    iAttr.cyclic = false;\n    for (i = 0; i < count; i += 1) {\n      if (childAttrs[i].left) {\n        iAttr.left = true;\n      }\n      if (childAttrs[i].nested) {\n        iAttr.nested = true;\n      }\n      if (childAttrs[i].right) {\n        iAttr.right = true;\n      }\n      if (childAttrs[i].empty) {\n        iAttr.empty = true;\n      }\n      if (childAttrs[i].finite) {\n        iAttr.finite = true;\n      }\n      if (childAttrs[i].cyclic) {\n        iAttr.cyclic = true;\n      }\n    }\n  }\n  function bkr(stateArg, opcodes, opIndex, iAttr) {\n    const opBkr = opcodes[opIndex];\n    if (opBkr.index >= stateArg.ruleCount) {\n      /* use UDT values */\n      iAttr.empty = stateArg.udts[opBkr.index - stateArg.ruleCount].empty;\n      iAttr.finite = true;\n    } else {\n      /* use the empty and finite values from the back referenced rule */\n      // eslint-disable-next-line no-use-before-define\n      ruleAttrsEval(stateArg, opBkr.index, iAttr);\n\n      /* however, this is a terminal node like TLS */\n      iAttr.left = false;\n      iAttr.nested = false;\n      iAttr.right = false;\n      iAttr.cyclic = false;\n    }\n  }\n\n  function opEval(stateArg, opcodes, opIndex, iAttr) {\n    stateArg.attrInit(iAttr);\n    const opi = opcodes[opIndex];\n    switch (opi.type) {\n      case id.ALT:\n        alt(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.CAT:\n        cat(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.REP:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        if (opi.min === 0) {\n          iAttr.empty = true;\n          iAttr.finite = true;\n        }\n        break;\n      case id.RNM:\n        // eslint-disable-next-line no-use-before-define\n        ruleAttrsEval(stateArg, opcodes[opIndex].index, iAttr);\n        break;\n      case id.BKR:\n        bkr(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.AND:\n      case id.NOT:\n      case id.BKA:\n      case id.BKN:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        iAttr.empty = true;\n        break;\n      case id.TLS:\n        iAttr.empty = !opcodes[opIndex].string.length;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.TBS:\n      case id.TRG:\n        iAttr.empty = false;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.UDT:\n        iAttr.empty = opi.empty;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.ABG:\n      case id.AEN:\n        iAttr.empty = true;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      default:\n        throw new Error(`unknown opcode type: ${opi}`);\n    }\n  }\n  // The main logic for handling rules that:\n  //  - have already be evaluated\n  //  - have not been evaluated and is the first occurrence on this branch\n  //  - second occurrence on this branch for the start rule\n  //  - second occurrence on this branch for non-start rules\n  function ruleAttrsEval(stateArg, ruleIndex, iAttr) {\n    const attri = stateArg.attrsWorking[ruleIndex];\n    if (attri.isComplete) {\n      /* just use the completed values */\n      stateArg.attrCopy(iAttr, attri);\n    } else if (!attri.isOpen) {\n      /* open the rule and traverse it */\n      attri.isOpen = true;\n      opEval(stateArg, attri.rule.opcodes, 0, iAttr);\n      /* complete this rule's attributes */\n      attri.left = iAttr.left;\n      attri.right = iAttr.right;\n      attri.nested = iAttr.nested;\n      attri.empty = iAttr.empty;\n      attri.finite = iAttr.finite;\n      attri.cyclic = iAttr.cyclic;\n      attri.leaf = false;\n      attri.isOpen = false;\n      attri.isComplete = true;\n    } else if (ruleIndex === stateArg.startRule) {\n      /* use recursive leaf values */\n      if (ruleIndex === stateArg.startRule) {\n        iAttr.left = true;\n        iAttr.right = true;\n        iAttr.cyclic = true;\n        iAttr.leaf = true;\n      }\n    } else {\n      /* non-start rule terminal leaf */\n      iAttr.finite = true;\n    }\n  }\n  // The main driver for the attribute generation.\n  const ruleAttributes = (stateArg) => {\n    state = stateArg;\n    let i = 0;\n    let j = 0;\n    const iAttr = state.attrGen();\n    for (i = 0; i < state.ruleCount; i += 1) {\n      /* initialize working attributes */\n      for (j = 0; j < state.ruleCount; j += 1) {\n        state.attrInit(state.attrsWorking[j]);\n      }\n      state.startRule = i;\n      ruleAttrsEval(state, i, iAttr);\n\n      /* save off the working attributes for this rule */\n      state.attrCopy(state.attrs[i], state.attrsWorking[i]);\n    }\n    state.attributesComplete = true;\n    let attri = null;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      attri = state.attrs[i];\n      if (attri.left || !attri.finite || attri.cyclic) {\n        const temp = state.attrGen(attri.rule);\n        state.attrCopy(temp, attri);\n        state.attrsErrors.push(temp);\n        state.attrsErrorCount += 1;\n      }\n    }\n  };\n  const truth = (val) => (val ? 't' : 'f');\n  const tError = (val) => (val ? 'e' : 'f');\n  const fError = (val) => (val ? 't' : 'e');\n  const showAttr = (seq, index, attr, dep) => {\n    let str = `${seq}:${index}:`;\n    str += `${tError(attr.left)} `;\n    str += `${truth(attr.nested)} `;\n    str += `${truth(attr.right)} `;\n    str += `${tError(attr.cyclic)} `;\n    str += `${fError(attr.finite)} `;\n    str += `${truth(attr.empty)}:`;\n    str += `${state.typeToString(dep.recursiveType)}:`;\n    str += dep.recursiveType === id.ATTR_MR ? dep.groupNumber : '-';\n    str += `:${attr.rule.name}\\n`;\n    return str;\n  };\n\n  const showLegend = () => {\n    let str = 'LEGEND - t=true, f=false, e=error\\n';\n    str += 'sequence:rule index:left nested right cyclic finite empty:type:group number:rule name\\n';\n    return str;\n  };\n  const showAttributeErrors = () => {\n    let attri = null;\n    let depi = null;\n    let str = '';\n    str += 'RULE ATTRIBUTES WITH ERRORS\\n';\n    str += showLegend();\n    if (state.attrsErrorCount) {\n      for (let i = 0; i < state.attrsErrorCount; i += 1) {\n        attri = state.attrsErrors[i];\n        depi = state.ruleDeps[attri.rule.index];\n        str += showAttr(i, attri.rule.index, attri, depi);\n      }\n    } else {\n      str += '<none>\\n';\n    }\n    return str;\n  };\n\n  const show = (type) => {\n    let i = 0;\n    let ii = 0;\n    let attri = null;\n    let depi = null;\n    let str = '';\n    let { ruleIndexes } = state;\n    // let udtIndexes = state.udtIndexes;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    }\n    /* show all attributes */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      ii = ruleIndexes[i];\n      attri = state.attrs[ii];\n      depi = state.ruleDeps[ii];\n      str += showAttr(i, ii, attri, depi);\n    }\n    return str;\n  };\n\n  // Display the rule attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showAttributes = (order = 'index') => {\n    if (!state.attributesComplete) {\n      throw new Error(`${thisFile}:showAttributes: attributes not available`);\n    }\n    let str = '';\n    const leader = 'RULE ATTRIBUTES\\n';\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += leader;\n      str += showLegend();\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += leader;\n      str += showLegend();\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += leader;\n      str += showLegend();\n      str += show();\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleAttributes, showAttributes, showAttributeErrors };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtYXR0cmlidXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsMEhBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJLEdBQUcsTUFBTTtBQUM5QixjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLHNDQUFzQztBQUNwRDtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvcnVsZS1hdHRyaWJ1dGVzLmpzPzcwZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgZG9lcyB0aGUgaGVhdnkgbGlmdGluZyBmb3IgYXR0cmlidXRlIGdlbmVyYXRpb24uXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBleHBvcnRSdWxlQXR0cmlidXRlcygpIHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuLi9hcGctbGliL2lkZW50aWZpZXJzJyk7XG4gIGNvbnN0IHRoaXNGaWxlID0gJ3J1bGUtYXR0cmlidXRlcy5qcyc7XG4gIGxldCBzdGF0ZSA9IG51bGw7XG4gIGZ1bmN0aW9uIGlzRW1wdHlPbmx5KGF0dHIpIHtcbiAgICBpZiAoYXR0ci5sZWZ0IHx8IGF0dHIubmVzdGVkIHx8IGF0dHIucmlnaHQgfHwgYXR0ci5jeWNsaWMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHIuZW1wdHk7XG4gIH1cbiAgZnVuY3Rpb24gaXNSZWN1cnNpdmUoYXR0cikge1xuICAgIGlmIChhdHRyLmxlZnQgfHwgYXR0ci5uZXN0ZWQgfHwgYXR0ci5yaWdodCB8fCBhdHRyLmN5Y2xpYykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpc0NhdE5lc3RlZChhdHRycywgY291bnQpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBrID0gMDtcbiAgICAvKiAxLiBpZiBhbnkgY2hpbGQgaXMgbmVzdGVkLCBDQVQgaXMgbmVzdGVkICovXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmIChhdHRyc1tpXS5uZXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIDIuKSB0aGUgbGVmdC1tb3N0IHJpZ2h0IHJlY3Vyc2l2ZSBjaGlsZFxuICAgICAgICAgICAgICAgaXMgZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIG5vbi1lbXB0eSBjaGlsZCAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoYXR0cnNbaV0ucmlnaHQgJiYgIWF0dHJzW2ldLmxlYWYpIHtcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBjb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKCFpc0VtcHR5T25seShhdHRyc1tqXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiAzLikgdGhlIHJpZ2h0LW1vc3QgbGVmdCByZWN1cnNpdmUgY2hpbGRcbiAgICAgICAgICAgICAgIGlzIHByZWNlZGVkIGJ5IGF0IGxlYXN0IG9uZSBub24tZW1wdHkgY2hpbGQgKi9cbiAgICBmb3IgKGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAoYXR0cnNbaV0ubGVmdCAmJiAhYXR0cnNbaV0ubGVhZikge1xuICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqIC09IDEpIHtcbiAgICAgICAgICBpZiAoIWlzRW1wdHlPbmx5KGF0dHJzW2pdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIDQuIHRoZXJlIGlzIGF0IGxlYXNlIG9uZSByZWN1cnNpdmUgY2hpbGQgYmV0d2VlblxuICAgICAgICAgICAgICB0aGUgbGVmdC1tb3N0IGFuZCByaWdodC1tb3N0IG5vbi1yZWN1cnNpdmUsIG5vbi1lbXB0eSBjaGlsZHJlbiAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoIWF0dHJzW2ldLmVtcHR5ICYmICFpc1JlY3Vyc2l2ZShhdHRyc1tpXSkpIHtcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBjb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKGlzUmVjdXJzaXZlKGF0dHJzW2pdKSkge1xuICAgICAgICAgICAgZm9yIChrID0gaiArIDE7IGsgPCBjb3VudDsgayArPSAxKSB7XG4gICAgICAgICAgICAgIGlmICghYXR0cnNba10uZW1wdHkgJiYgIWlzUmVjdXJzaXZlKGF0dHJzW2tdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogbm9uZSBvZiB0aGUgYWJvdmUgKi9cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gaXNDYXRDeWNsaWMoYXR0cnMsIGNvdW50KSB7XG4gICAgLyogaWYgYWxsIGNoaWxkcmVuIGFyZSBjeWNsaWMsIENBVCBpcyBjeWNsaWMgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmICghYXR0cnNbaV0uY3ljbGljKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gaXNDYXRMZWZ0KGF0dHJzLCBjb3VudCkge1xuICAgIC8qIGlmIHRoZSBsZWZ0LW1vc3Qgbm9uLWVtcHR5IGlzIGxlZnQsIENBVCBpcyBsZWZ0ICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoYXR0cnNbaV0ubGVmdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cnNbaV0uZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLyoga2VlcCBsb29raW5nICovXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTsgLyogYWxsIGxlZnQtbW9zdCBhcmUgZW1wdHkgKi9cbiAgfVxuICBmdW5jdGlvbiBpc0NhdFJpZ2h0KGF0dHJzLCBjb3VudCkge1xuICAgIC8qIGlmIHRoZSByaWdodC1tb3N0IG5vbi1lbXB0eSBpcyByaWdodCwgQ0FUIGlzIHJpZ2h0ICovXG4gICAgZm9yIChsZXQgaSA9IGNvdW50IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmIChhdHRyc1tpXS5yaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cnNbaV0uZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLyoga2VlcCBsb29raW5nICovXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpc0NhdEVtcHR5KGF0dHJzLCBjb3VudCkge1xuICAgIC8qIGlmIGFsbCBjaGlsZHJlbiBhcmUgZW1wdHksIENBVCBpcyBlbXB0eSAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKCFhdHRyc1tpXS5lbXB0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2F0RmluaXRlKGF0dHJzLCBjb3VudCkge1xuICAgIC8qIGlmIGFsbCBjaGlsZHJlbiBhcmUgZmluaXRlLCBDQVQgaXMgZmluaXRlICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoIWF0dHJzW2ldLmZpbml0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGNhdChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3Qgb3BDYXQgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IGNvdW50ID0gb3BDYXQuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgLyogZ2VuZXJhdGUgYW4gZW1wdHkgYXJyYXkgb2YgY2hpbGQgYXR0cmlidXRlcyAqL1xuICAgIGNvbnN0IGNoaWxkQXR0cnMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgY2hpbGRBdHRycy5wdXNoKHN0YXRlQXJnLmF0dHJHZW4oKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIG9wRXZhbChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BDYXQuY2hpbGRyZW5baV0sIGNoaWxkQXR0cnNbaV0pO1xuICAgIH1cbiAgICBpQXR0ci5sZWZ0ID0gaXNDYXRMZWZ0KGNoaWxkQXR0cnMsIGNvdW50KTtcbiAgICBpQXR0ci5yaWdodCA9IGlzQ2F0UmlnaHQoY2hpbGRBdHRycywgY291bnQpO1xuICAgIGlBdHRyLm5lc3RlZCA9IGlzQ2F0TmVzdGVkKGNoaWxkQXR0cnMsIGNvdW50KTtcbiAgICBpQXR0ci5lbXB0eSA9IGlzQ2F0RW1wdHkoY2hpbGRBdHRycywgY291bnQpO1xuICAgIGlBdHRyLmZpbml0ZSA9IGlzQ2F0RmluaXRlKGNoaWxkQXR0cnMsIGNvdW50KTtcbiAgICBpQXR0ci5jeWNsaWMgPSBpc0NhdEN5Y2xpYyhjaGlsZEF0dHJzLCBjb3VudCk7XG4gIH1cbiAgZnVuY3Rpb24gYWx0KHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4LCBpQXR0cikge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBvcEFsdCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgY29uc3QgY291bnQgPSBvcEFsdC5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAvKiBnZW5lcmF0ZSBhbiBlbXB0eSBhcnJheSBvZiBjaGlsZCBhdHRyaWJ1dGVzICovXG4gICAgY29uc3QgY2hpbGRBdHRycyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBjaGlsZEF0dHJzLnB1c2goc3RhdGVBcmcuYXR0ckdlbigpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgb3BFdmFsKHN0YXRlQXJnLCBvcGNvZGVzLCBvcEFsdC5jaGlsZHJlbltpXSwgY2hpbGRBdHRyc1tpXSk7XG4gICAgfVxuXG4gICAgLyogaWYgYW55IGNoaWxkIGF0dHJpYnV0ZSBpcyB0cnVlLCBBTFQgaXMgdHJ1ZSAqL1xuICAgIGlBdHRyLmxlZnQgPSBmYWxzZTtcbiAgICBpQXR0ci5yaWdodCA9IGZhbHNlO1xuICAgIGlBdHRyLm5lc3RlZCA9IGZhbHNlO1xuICAgIGlBdHRyLmVtcHR5ID0gZmFsc2U7XG4gICAgaUF0dHIuZmluaXRlID0gZmFsc2U7XG4gICAgaUF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmIChjaGlsZEF0dHJzW2ldLmxlZnQpIHtcbiAgICAgICAgaUF0dHIubGVmdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRBdHRyc1tpXS5uZXN0ZWQpIHtcbiAgICAgICAgaUF0dHIubmVzdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEF0dHJzW2ldLnJpZ2h0KSB7XG4gICAgICAgIGlBdHRyLnJpZ2h0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEF0dHJzW2ldLmVtcHR5KSB7XG4gICAgICAgIGlBdHRyLmVtcHR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEF0dHJzW2ldLmZpbml0ZSkge1xuICAgICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkQXR0cnNbaV0uY3ljbGljKSB7XG4gICAgICAgIGlBdHRyLmN5Y2xpYyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJrcihzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpIHtcbiAgICBjb25zdCBvcEJrciA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgaWYgKG9wQmtyLmluZGV4ID49IHN0YXRlQXJnLnJ1bGVDb3VudCkge1xuICAgICAgLyogdXNlIFVEVCB2YWx1ZXMgKi9cbiAgICAgIGlBdHRyLmVtcHR5ID0gc3RhdGVBcmcudWR0c1tvcEJrci5pbmRleCAtIHN0YXRlQXJnLnJ1bGVDb3VudF0uZW1wdHk7XG4gICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiB1c2UgdGhlIGVtcHR5IGFuZCBmaW5pdGUgdmFsdWVzIGZyb20gdGhlIGJhY2sgcmVmZXJlbmNlZCBydWxlICovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIHJ1bGVBdHRyc0V2YWwoc3RhdGVBcmcsIG9wQmtyLmluZGV4LCBpQXR0cik7XG5cbiAgICAgIC8qIGhvd2V2ZXIsIHRoaXMgaXMgYSB0ZXJtaW5hbCBub2RlIGxpa2UgVExTICovXG4gICAgICBpQXR0ci5sZWZ0ID0gZmFsc2U7XG4gICAgICBpQXR0ci5uZXN0ZWQgPSBmYWxzZTtcbiAgICAgIGlBdHRyLnJpZ2h0ID0gZmFsc2U7XG4gICAgICBpQXR0ci5jeWNsaWMgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvcEV2YWwoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKSB7XG4gICAgc3RhdGVBcmcuYXR0ckluaXQoaUF0dHIpO1xuICAgIGNvbnN0IG9waSA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3dpdGNoIChvcGkudHlwZSkge1xuICAgICAgY2FzZSBpZC5BTFQ6XG4gICAgICAgIGFsdChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuQ0FUOlxuICAgICAgICBjYXQoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgb3BFdmFsKHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4ICsgMSwgaUF0dHIpO1xuICAgICAgICBpZiAob3BpLm1pbiA9PT0gMCkge1xuICAgICAgICAgIGlBdHRyLmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBydWxlQXR0cnNFdmFsKHN0YXRlQXJnLCBvcGNvZGVzW29wSW5kZXhdLmluZGV4LCBpQXR0cik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgIGJrcihzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuQU5EOlxuICAgICAgY2FzZSBpZC5OT1Q6XG4gICAgICBjYXNlIGlkLkJLQTpcbiAgICAgIGNhc2UgaWQuQktOOlxuICAgICAgICBvcEV2YWwoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXggKyAxLCBpQXR0cik7XG4gICAgICAgIGlBdHRyLmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLlRMUzpcbiAgICAgICAgaUF0dHIuZW1wdHkgPSAhb3Bjb2Rlc1tvcEluZGV4XS5zdHJpbmcubGVuZ3RoO1xuICAgICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgICAgICBpQXR0ci5jeWNsaWMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLlRCUzpcbiAgICAgIGNhc2UgaWQuVFJHOlxuICAgICAgICBpQXR0ci5lbXB0eSA9IGZhbHNlO1xuICAgICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgICAgICBpQXR0ci5jeWNsaWMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLlVEVDpcbiAgICAgICAgaUF0dHIuZW1wdHkgPSBvcGkuZW1wdHk7XG4gICAgICAgIGlBdHRyLmZpbml0ZSA9IHRydWU7XG4gICAgICAgIGlBdHRyLmN5Y2xpYyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuQUJHOlxuICAgICAgY2FzZSBpZC5BRU46XG4gICAgICAgIGlBdHRyLmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIG9wY29kZSB0eXBlOiAke29waX1gKTtcbiAgICB9XG4gIH1cbiAgLy8gVGhlIG1haW4gbG9naWMgZm9yIGhhbmRsaW5nIHJ1bGVzIHRoYXQ6XG4gIC8vICAtIGhhdmUgYWxyZWFkeSBiZSBldmFsdWF0ZWRcbiAgLy8gIC0gaGF2ZSBub3QgYmVlbiBldmFsdWF0ZWQgYW5kIGlzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9uIHRoaXMgYnJhbmNoXG4gIC8vICAtIHNlY29uZCBvY2N1cnJlbmNlIG9uIHRoaXMgYnJhbmNoIGZvciB0aGUgc3RhcnQgcnVsZVxuICAvLyAgLSBzZWNvbmQgb2NjdXJyZW5jZSBvbiB0aGlzIGJyYW5jaCBmb3Igbm9uLXN0YXJ0IHJ1bGVzXG4gIGZ1bmN0aW9uIHJ1bGVBdHRyc0V2YWwoc3RhdGVBcmcsIHJ1bGVJbmRleCwgaUF0dHIpIHtcbiAgICBjb25zdCBhdHRyaSA9IHN0YXRlQXJnLmF0dHJzV29ya2luZ1tydWxlSW5kZXhdO1xuICAgIGlmIChhdHRyaS5pc0NvbXBsZXRlKSB7XG4gICAgICAvKiBqdXN0IHVzZSB0aGUgY29tcGxldGVkIHZhbHVlcyAqL1xuICAgICAgc3RhdGVBcmcuYXR0ckNvcHkoaUF0dHIsIGF0dHJpKTtcbiAgICB9IGVsc2UgaWYgKCFhdHRyaS5pc09wZW4pIHtcbiAgICAgIC8qIG9wZW4gdGhlIHJ1bGUgYW5kIHRyYXZlcnNlIGl0ICovXG4gICAgICBhdHRyaS5pc09wZW4gPSB0cnVlO1xuICAgICAgb3BFdmFsKHN0YXRlQXJnLCBhdHRyaS5ydWxlLm9wY29kZXMsIDAsIGlBdHRyKTtcbiAgICAgIC8qIGNvbXBsZXRlIHRoaXMgcnVsZSdzIGF0dHJpYnV0ZXMgKi9cbiAgICAgIGF0dHJpLmxlZnQgPSBpQXR0ci5sZWZ0O1xuICAgICAgYXR0cmkucmlnaHQgPSBpQXR0ci5yaWdodDtcbiAgICAgIGF0dHJpLm5lc3RlZCA9IGlBdHRyLm5lc3RlZDtcbiAgICAgIGF0dHJpLmVtcHR5ID0gaUF0dHIuZW1wdHk7XG4gICAgICBhdHRyaS5maW5pdGUgPSBpQXR0ci5maW5pdGU7XG4gICAgICBhdHRyaS5jeWNsaWMgPSBpQXR0ci5jeWNsaWM7XG4gICAgICBhdHRyaS5sZWFmID0gZmFsc2U7XG4gICAgICBhdHRyaS5pc09wZW4gPSBmYWxzZTtcbiAgICAgIGF0dHJpLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAocnVsZUluZGV4ID09PSBzdGF0ZUFyZy5zdGFydFJ1bGUpIHtcbiAgICAgIC8qIHVzZSByZWN1cnNpdmUgbGVhZiB2YWx1ZXMgKi9cbiAgICAgIGlmIChydWxlSW5kZXggPT09IHN0YXRlQXJnLnN0YXJ0UnVsZSkge1xuICAgICAgICBpQXR0ci5sZWZ0ID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIucmlnaHQgPSB0cnVlO1xuICAgICAgICBpQXR0ci5jeWNsaWMgPSB0cnVlO1xuICAgICAgICBpQXR0ci5sZWFmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogbm9uLXN0YXJ0IHJ1bGUgdGVybWluYWwgbGVhZiAqL1xuICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gVGhlIG1haW4gZHJpdmVyIGZvciB0aGUgYXR0cmlidXRlIGdlbmVyYXRpb24uXG4gIGNvbnN0IHJ1bGVBdHRyaWJ1dGVzID0gKHN0YXRlQXJnKSA9PiB7XG4gICAgc3RhdGUgPSBzdGF0ZUFyZztcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGNvbnN0IGlBdHRyID0gc3RhdGUuYXR0ckdlbigpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgLyogaW5pdGlhbGl6ZSB3b3JraW5nIGF0dHJpYnV0ZXMgKi9cbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS5ydWxlQ291bnQ7IGogKz0gMSkge1xuICAgICAgICBzdGF0ZS5hdHRySW5pdChzdGF0ZS5hdHRyc1dvcmtpbmdbal0pO1xuICAgICAgfVxuICAgICAgc3RhdGUuc3RhcnRSdWxlID0gaTtcbiAgICAgIHJ1bGVBdHRyc0V2YWwoc3RhdGUsIGksIGlBdHRyKTtcblxuICAgICAgLyogc2F2ZSBvZmYgdGhlIHdvcmtpbmcgYXR0cmlidXRlcyBmb3IgdGhpcyBydWxlICovXG4gICAgICBzdGF0ZS5hdHRyQ29weShzdGF0ZS5hdHRyc1tpXSwgc3RhdGUuYXR0cnNXb3JraW5nW2ldKTtcbiAgICB9XG4gICAgc3RhdGUuYXR0cmlidXRlc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICBsZXQgYXR0cmkgPSBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgYXR0cmkgPSBzdGF0ZS5hdHRyc1tpXTtcbiAgICAgIGlmIChhdHRyaS5sZWZ0IHx8ICFhdHRyaS5maW5pdGUgfHwgYXR0cmkuY3ljbGljKSB7XG4gICAgICAgIGNvbnN0IHRlbXAgPSBzdGF0ZS5hdHRyR2VuKGF0dHJpLnJ1bGUpO1xuICAgICAgICBzdGF0ZS5hdHRyQ29weSh0ZW1wLCBhdHRyaSk7XG4gICAgICAgIHN0YXRlLmF0dHJzRXJyb3JzLnB1c2godGVtcCk7XG4gICAgICAgIHN0YXRlLmF0dHJzRXJyb3JDb3VudCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJ1dGggPSAodmFsKSA9PiAodmFsID8gJ3QnIDogJ2YnKTtcbiAgY29uc3QgdEVycm9yID0gKHZhbCkgPT4gKHZhbCA/ICdlJyA6ICdmJyk7XG4gIGNvbnN0IGZFcnJvciA9ICh2YWwpID0+ICh2YWwgPyAndCcgOiAnZScpO1xuICBjb25zdCBzaG93QXR0ciA9IChzZXEsIGluZGV4LCBhdHRyLCBkZXApID0+IHtcbiAgICBsZXQgc3RyID0gYCR7c2VxfToke2luZGV4fTpgO1xuICAgIHN0ciArPSBgJHt0RXJyb3IoYXR0ci5sZWZ0KX0gYDtcbiAgICBzdHIgKz0gYCR7dHJ1dGgoYXR0ci5uZXN0ZWQpfSBgO1xuICAgIHN0ciArPSBgJHt0cnV0aChhdHRyLnJpZ2h0KX0gYDtcbiAgICBzdHIgKz0gYCR7dEVycm9yKGF0dHIuY3ljbGljKX0gYDtcbiAgICBzdHIgKz0gYCR7ZkVycm9yKGF0dHIuZmluaXRlKX0gYDtcbiAgICBzdHIgKz0gYCR7dHJ1dGgoYXR0ci5lbXB0eSl9OmA7XG4gICAgc3RyICs9IGAke3N0YXRlLnR5cGVUb1N0cmluZyhkZXAucmVjdXJzaXZlVHlwZSl9OmA7XG4gICAgc3RyICs9IGRlcC5yZWN1cnNpdmVUeXBlID09PSBpZC5BVFRSX01SID8gZGVwLmdyb3VwTnVtYmVyIDogJy0nO1xuICAgIHN0ciArPSBgOiR7YXR0ci5ydWxlLm5hbWV9XFxuYDtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIGNvbnN0IHNob3dMZWdlbmQgPSAoKSA9PiB7XG4gICAgbGV0IHN0ciA9ICdMRUdFTkQgLSB0PXRydWUsIGY9ZmFsc2UsIGU9ZXJyb3JcXG4nO1xuICAgIHN0ciArPSAnc2VxdWVuY2U6cnVsZSBpbmRleDpsZWZ0IG5lc3RlZCByaWdodCBjeWNsaWMgZmluaXRlIGVtcHR5OnR5cGU6Z3JvdXAgbnVtYmVyOnJ1bGUgbmFtZVxcbic7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgY29uc3Qgc2hvd0F0dHJpYnV0ZUVycm9ycyA9ICgpID0+IHtcbiAgICBsZXQgYXR0cmkgPSBudWxsO1xuICAgIGxldCBkZXBpID0gbnVsbDtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgc3RyICs9ICdSVUxFIEFUVFJJQlVURVMgV0lUSCBFUlJPUlNcXG4nO1xuICAgIHN0ciArPSBzaG93TGVnZW5kKCk7XG4gICAgaWYgKHN0YXRlLmF0dHJzRXJyb3JDb3VudCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5hdHRyc0Vycm9yQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBhdHRyaSA9IHN0YXRlLmF0dHJzRXJyb3JzW2ldO1xuICAgICAgICBkZXBpID0gc3RhdGUucnVsZURlcHNbYXR0cmkucnVsZS5pbmRleF07XG4gICAgICAgIHN0ciArPSBzaG93QXR0cihpLCBhdHRyaS5ydWxlLmluZGV4LCBhdHRyaSwgZGVwaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnPG5vbmU+XFxuJztcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBjb25zdCBzaG93ID0gKHR5cGUpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGlpID0gMDtcbiAgICBsZXQgYXR0cmkgPSBudWxsO1xuICAgIGxldCBkZXBpID0gbnVsbDtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IHsgcnVsZUluZGV4ZXMgfSA9IHN0YXRlO1xuICAgIC8vIGxldCB1ZHRJbmRleGVzID0gc3RhdGUudWR0SW5kZXhlcztcbiAgICBpZiAodHlwZSA9PT0gOTcpIHtcbiAgICAgIHJ1bGVJbmRleGVzID0gc3RhdGUucnVsZUFscGhhSW5kZXhlcztcbiAgICAgIC8vIHVkdEluZGV4ZXMgPSBzdGF0ZS51ZHRBbHBoYUluZGV4ZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAxMTYpIHtcbiAgICAgIHJ1bGVJbmRleGVzID0gc3RhdGUucnVsZVR5cGVJbmRleGVzO1xuICAgICAgLy8gdWR0SW5kZXhlcyA9IHN0YXRlLnVkdEFscGhhSW5kZXhlcztcbiAgICB9XG4gICAgLyogc2hvdyBhbGwgYXR0cmlidXRlcyAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgaWkgPSBydWxlSW5kZXhlc1tpXTtcbiAgICAgIGF0dHJpID0gc3RhdGUuYXR0cnNbaWldO1xuICAgICAgZGVwaSA9IHN0YXRlLnJ1bGVEZXBzW2lpXTtcbiAgICAgIHN0ciArPSBzaG93QXR0cihpLCBpaSwgYXR0cmksIGRlcGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8vIERpc3BsYXkgdGhlIHJ1bGUgYXR0cmlidXRlcy5cbiAgLy8gLSBvcmRlclxuICAvLyAgICAgIC0gXCJpbmRleFwiIG9yIFwiaVwiLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgLy8gICAgICAtIFwiYWxwaGFcIiBvciBcImFcIiwgYWxwaGFiZXRpY2FsIG9yZGVyXG4gIC8vICAgICAgLSBcInR5cGVcIiBvciBcInRcIiwgb3JkZXJlZCBieSB0eXBlIChhbHBoYWJldGljYWwgd2l0aGluIGVhY2ggdHlwZS9ncm91cClcbiAgLy8gICAgICAtIG5vbmUgb2YgYWJvdmUsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICBjb25zdCBzaG93QXR0cmlidXRlcyA9IChvcmRlciA9ICdpbmRleCcpID0+IHtcbiAgICBpZiAoIXN0YXRlLmF0dHJpYnV0ZXNDb21wbGV0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlfTpzaG93QXR0cmlidXRlczogYXR0cmlidXRlcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBjb25zdCBsZWFkZXIgPSAnUlVMRSBBVFRSSUJVVEVTXFxuJztcbiAgICBpZiAob3JkZXIuY2hhckNvZGVBdCgwKSA9PT0gOTcpIHtcbiAgICAgIHN0ciArPSAnYWxwaGFiZXRpY2FsIGJ5IHJ1bGUgbmFtZVxcbic7XG4gICAgICBzdHIgKz0gbGVhZGVyO1xuICAgICAgc3RyICs9IHNob3dMZWdlbmQoKTtcbiAgICAgIHN0ciArPSBzaG93KDk3KTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyLmNoYXJDb2RlQXQoMCkgPT09IDExNikge1xuICAgICAgc3RyICs9ICdvcmRlcmVkIGJ5IHJ1bGUgdHlwZVxcbic7XG4gICAgICBzdHIgKz0gbGVhZGVyO1xuICAgICAgc3RyICs9IHNob3dMZWdlbmQoKTtcbiAgICAgIHN0ciArPSBzaG93KDExNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnb3JkZXJlZCBieSBydWxlIGluZGV4XFxuJztcbiAgICAgIHN0ciArPSBsZWFkZXI7XG4gICAgICBzdHIgKz0gc2hvd0xlZ2VuZCgpO1xuICAgICAgc3RyICs9IHNob3coKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKiBEZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQgLSBzZWUgTUROIFdlYiBEb2NzICovXG4gIHJldHVybiB7IHJ1bGVBdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZUVycm9ycyB9O1xufSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-attributes.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-dependencies.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-dependencies.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Determine rule dependencies and types.\n// For each rule, determine which other rules it refers to\n// and which of the other rules refer back to it.\n//\n// Rule types are:\n//  - non-recursive - the rule never refers to itself, even indirectly\n//  - recursive - the rule refers to itself, possibly indirectly\n//  - mutually-recursive - belongs to a group of two or more rules, each of which refers to every other rule in the group, including itself.\nmodule.exports = (() => {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n  let state = null; /* keep a global reference to the state for the show functions */\n\n  /* scan the opcodes of the indexed rule and discover which rules it references and which rule refer back to it */\n  const scan = (ruleCount, ruleDeps, index, isScanned) => {\n    let i = 0;\n    let j = 0;\n    const rdi = ruleDeps[index];\n    isScanned[index] = true;\n    const op = rdi.rule.opcodes;\n    for (i = 0; i < op.length; i += 1) {\n      const opi = op[i];\n      if (opi.type === id.RNM) {\n        rdi.refersTo[opi.index] = true;\n        if (!isScanned[opi.index]) {\n          scan(ruleCount, ruleDeps, opi.index, isScanned);\n        }\n        for (j = 0; j < ruleCount; j += 1) {\n          if (ruleDeps[opi.index].refersTo[j]) {\n            rdi.refersTo[j] = true;\n          }\n        }\n      } else if (opi.type === id.UDT) {\n        rdi.refersToUdt[opi.index] = true;\n      } else if (opi.type === id.BKR) {\n        if (opi.index < ruleCount) {\n          rdi.refersTo[opi.index] = true;\n          if (!isScanned[opi.index]) {\n            scan(ruleCount, ruleDeps, opi.index, isScanned);\n          }\n        } else {\n          rdi.refersToUdt[ruleCount - opi.index] = true;\n        }\n      }\n    }\n  };\n  // Determine the rule dependencies, types and mutually recursive groups.\n  const ruleDependencies = (stateArg) => {\n    state = stateArg; /* make it global */\n    let i = 0;\n    let j = 0;\n    let groupCount = 0;\n    let rdi = null;\n    let rdj = null;\n    let newGroup = false;\n    state.dependenciesComplete = false;\n\n    /* make a working array of rule scanned markers */\n    const isScanned = state.falseArray(state.ruleCount);\n\n    /* discover the rule dependencies */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.falsifyArray(isScanned);\n      scan(state.ruleCount, state.ruleDeps, i, isScanned);\n    }\n    /* discover all rules referencing each rule */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (i !== j) {\n          if (state.ruleDeps[j].refersTo[i]) {\n            state.ruleDeps[i].referencedBy[j] = true;\n          }\n        }\n      }\n    }\n    /* find the non-recursive and recursive types */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.ruleDeps[i].recursiveType = id.ATTR_N;\n      if (state.ruleDeps[i].refersTo[i]) {\n        state.ruleDeps[i].recursiveType = id.ATTR_R;\n      }\n    }\n\n    /* find the mutually-recursive groups, if any */\n    groupCount = -1;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[i];\n      if (rdi.recursiveType === id.ATTR_R) {\n        newGroup = true;\n        for (j = 0; j < state.ruleCount; j += 1) {\n          if (i !== j) {\n            rdj = state.ruleDeps[j];\n            if (rdj.recursiveType === id.ATTR_R) {\n              if (rdi.refersTo[j] && rdj.refersTo[i]) {\n                if (newGroup) {\n                  groupCount += 1;\n                  rdi.recursiveType = id.ATTR_MR;\n                  rdi.groupNumber = groupCount;\n                  newGroup = false;\n                }\n                rdj.recursiveType = id.ATTR_MR;\n                rdj.groupNumber = groupCount;\n              }\n            }\n          }\n        }\n      }\n    }\n    state.isMutuallyRecursive = groupCount > -1;\n\n    /* sort the rules/UDTS */\n    state.ruleAlphaIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesType);\n    if (state.isMutuallyRecursive) {\n      state.ruleTypeIndexes.sort(state.compRulesGroup);\n    }\n    if (state.udtCount) {\n      state.udtAlphaIndexes.sort(state.compUdtsAlpha);\n    }\n\n    state.dependenciesComplete = true;\n  };\n  const show = (type = null) => {\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    let startSeg = 0;\n    const maxRule = state.ruleCount - 1;\n    const maxUdt = state.udtCount - 1;\n    const lineLength = 100;\n    let str = '';\n    let pre = '';\n    const toArrow = '=> ';\n    const byArrow = '<= ';\n    let first = false;\n    let rdi = null;\n    let { ruleIndexes } = state;\n    let { udtIndexes } = state;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    }\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[ruleIndexes[i]];\n      pre = `${ruleIndexes[i]}:${state.typeToString(rdi.recursiveType)}:`;\n      if (state.isMutuallyRecursive) {\n        pre += rdi.groupNumber > -1 ? rdi.groupNumber : '-';\n        pre += ':';\n      }\n      pre += ' ';\n      str += `${pre + state.rules[ruleIndexes[i]].name}\\n`;\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.refersTo[ruleIndexes[j]]) {\n          if (first) {\n            str += toArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (state.udtCount) {\n        for (j = 0; j < state.udtCount; j += 1) {\n          if (rdi.refersToUdt[udtIndexes[j]]) {\n            if (first) {\n              str += toArrow;\n              first = false;\n              str += state.udts[udtIndexes[j]].name;\n            } else {\n              str += `, ${state.udts[udtIndexes[j]].name}`;\n            }\n            count += 1;\n          }\n          if (str.length - startSeg > lineLength && j !== maxUdt) {\n            str += `\\n${pre}${toArrow}`;\n            startSeg = str.length;\n          }\n        }\n      }\n      if (count === 0) {\n        str += '=> <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.referencedBy[ruleIndexes[j]]) {\n          if (first) {\n            str += byArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (count === 0) {\n        str += '<= <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      str += '\\n';\n    }\n    return str;\n  };\n  // Display the rule dependencies.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showRuleDependencies = (order = 'index') => {\n    let str = 'RULE DEPENDENCIES(index:type:[group number:])\\n';\n    str += '=> refers to rule names\\n';\n    str += '<= referenced by rule names\\n';\n    if (!state.dependenciesComplete) {\n      return str;\n    }\n\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += show(null);\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleDependencies, showRuleDependencies };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtZGVwZW5kZW5jaWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDBIQUF3QjtBQUM3QyxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0EsZUFBZSxlQUFlLEdBQUcsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFJLEVBQUUsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9ydWxlLWRlcGVuZGVuY2llcy5qcz9lYjUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIERldGVybWluZSBydWxlIGRlcGVuZGVuY2llcyBhbmQgdHlwZXMuXG4vLyBGb3IgZWFjaCBydWxlLCBkZXRlcm1pbmUgd2hpY2ggb3RoZXIgcnVsZXMgaXQgcmVmZXJzIHRvXG4vLyBhbmQgd2hpY2ggb2YgdGhlIG90aGVyIHJ1bGVzIHJlZmVyIGJhY2sgdG8gaXQuXG4vL1xuLy8gUnVsZSB0eXBlcyBhcmU6XG4vLyAgLSBub24tcmVjdXJzaXZlIC0gdGhlIHJ1bGUgbmV2ZXIgcmVmZXJzIHRvIGl0c2VsZiwgZXZlbiBpbmRpcmVjdGx5XG4vLyAgLSByZWN1cnNpdmUgLSB0aGUgcnVsZSByZWZlcnMgdG8gaXRzZWxmLCBwb3NzaWJseSBpbmRpcmVjdGx5XG4vLyAgLSBtdXR1YWxseS1yZWN1cnNpdmUgLSBiZWxvbmdzIHRvIGEgZ3JvdXAgb2YgdHdvIG9yIG1vcmUgcnVsZXMsIGVhY2ggb2Ygd2hpY2ggcmVmZXJzIHRvIGV2ZXJ5IG90aGVyIHJ1bGUgaW4gdGhlIGdyb3VwLCBpbmNsdWRpbmcgaXRzZWxmLlxubW9kdWxlLmV4cG9ydHMgPSAoKCkgPT4ge1xuICBjb25zdCBpZCA9IHJlcXVpcmUoJy4uL2FwZy1saWIvaWRlbnRpZmllcnMnKTtcbiAgbGV0IHN0YXRlID0gbnVsbDsgLyoga2VlcCBhIGdsb2JhbCByZWZlcmVuY2UgdG8gdGhlIHN0YXRlIGZvciB0aGUgc2hvdyBmdW5jdGlvbnMgKi9cblxuICAvKiBzY2FuIHRoZSBvcGNvZGVzIG9mIHRoZSBpbmRleGVkIHJ1bGUgYW5kIGRpc2NvdmVyIHdoaWNoIHJ1bGVzIGl0IHJlZmVyZW5jZXMgYW5kIHdoaWNoIHJ1bGUgcmVmZXIgYmFjayB0byBpdCAqL1xuICBjb25zdCBzY2FuID0gKHJ1bGVDb3VudCwgcnVsZURlcHMsIGluZGV4LCBpc1NjYW5uZWQpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGNvbnN0IHJkaSA9IHJ1bGVEZXBzW2luZGV4XTtcbiAgICBpc1NjYW5uZWRbaW5kZXhdID0gdHJ1ZTtcbiAgICBjb25zdCBvcCA9IHJkaS5ydWxlLm9wY29kZXM7XG4gICAgZm9yIChpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBvcGkgPSBvcFtpXTtcbiAgICAgIGlmIChvcGkudHlwZSA9PT0gaWQuUk5NKSB7XG4gICAgICAgIHJkaS5yZWZlcnNUb1tvcGkuaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpc1NjYW5uZWRbb3BpLmluZGV4XSkge1xuICAgICAgICAgIHNjYW4ocnVsZUNvdW50LCBydWxlRGVwcywgb3BpLmluZGV4LCBpc1NjYW5uZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBydWxlQ291bnQ7IGogKz0gMSkge1xuICAgICAgICAgIGlmIChydWxlRGVwc1tvcGkuaW5kZXhdLnJlZmVyc1RvW2pdKSB7XG4gICAgICAgICAgICByZGkucmVmZXJzVG9bal0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvcGkudHlwZSA9PT0gaWQuVURUKSB7XG4gICAgICAgIHJkaS5yZWZlcnNUb1VkdFtvcGkuaW5kZXhdID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAob3BpLnR5cGUgPT09IGlkLkJLUikge1xuICAgICAgICBpZiAob3BpLmluZGV4IDwgcnVsZUNvdW50KSB7XG4gICAgICAgICAgcmRpLnJlZmVyc1RvW29waS5pbmRleF0gPSB0cnVlO1xuICAgICAgICAgIGlmICghaXNTY2FubmVkW29waS5pbmRleF0pIHtcbiAgICAgICAgICAgIHNjYW4ocnVsZUNvdW50LCBydWxlRGVwcywgb3BpLmluZGV4LCBpc1NjYW5uZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZGkucmVmZXJzVG9VZHRbcnVsZUNvdW50IC0gb3BpLmluZGV4XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIERldGVybWluZSB0aGUgcnVsZSBkZXBlbmRlbmNpZXMsIHR5cGVzIGFuZCBtdXR1YWxseSByZWN1cnNpdmUgZ3JvdXBzLlxuICBjb25zdCBydWxlRGVwZW5kZW5jaWVzID0gKHN0YXRlQXJnKSA9PiB7XG4gICAgc3RhdGUgPSBzdGF0ZUFyZzsgLyogbWFrZSBpdCBnbG9iYWwgKi9cbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBncm91cENvdW50ID0gMDtcbiAgICBsZXQgcmRpID0gbnVsbDtcbiAgICBsZXQgcmRqID0gbnVsbDtcbiAgICBsZXQgbmV3R3JvdXAgPSBmYWxzZTtcbiAgICBzdGF0ZS5kZXBlbmRlbmNpZXNDb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgLyogbWFrZSBhIHdvcmtpbmcgYXJyYXkgb2YgcnVsZSBzY2FubmVkIG1hcmtlcnMgKi9cbiAgICBjb25zdCBpc1NjYW5uZWQgPSBzdGF0ZS5mYWxzZUFycmF5KHN0YXRlLnJ1bGVDb3VudCk7XG5cbiAgICAvKiBkaXNjb3ZlciB0aGUgcnVsZSBkZXBlbmRlbmNpZXMgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIHN0YXRlLmZhbHNpZnlBcnJheShpc1NjYW5uZWQpO1xuICAgICAgc2NhbihzdGF0ZS5ydWxlQ291bnQsIHN0YXRlLnJ1bGVEZXBzLCBpLCBpc1NjYW5uZWQpO1xuICAgIH1cbiAgICAvKiBkaXNjb3ZlciBhbGwgcnVsZXMgcmVmZXJlbmNpbmcgZWFjaCBydWxlICovXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3RhdGUucnVsZUNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICBpZiAoc3RhdGUucnVsZURlcHNbal0ucmVmZXJzVG9baV0pIHtcbiAgICAgICAgICAgIHN0YXRlLnJ1bGVEZXBzW2ldLnJlZmVyZW5jZWRCeVtqXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGZpbmQgdGhlIG5vbi1yZWN1cnNpdmUgYW5kIHJlY3Vyc2l2ZSB0eXBlcyAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgc3RhdGUucnVsZURlcHNbaV0ucmVjdXJzaXZlVHlwZSA9IGlkLkFUVFJfTjtcbiAgICAgIGlmIChzdGF0ZS5ydWxlRGVwc1tpXS5yZWZlcnNUb1tpXSkge1xuICAgICAgICBzdGF0ZS5ydWxlRGVwc1tpXS5yZWN1cnNpdmVUeXBlID0gaWQuQVRUUl9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIGZpbmQgdGhlIG11dHVhbGx5LXJlY3Vyc2l2ZSBncm91cHMsIGlmIGFueSAqL1xuICAgIGdyb3VwQ291bnQgPSAtMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIHJkaSA9IHN0YXRlLnJ1bGVEZXBzW2ldO1xuICAgICAgaWYgKHJkaS5yZWN1cnNpdmVUeXBlID09PSBpZC5BVFRSX1IpIHtcbiAgICAgICAgbmV3R3JvdXAgPSB0cnVlO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3RhdGUucnVsZUNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgcmRqID0gc3RhdGUucnVsZURlcHNbal07XG4gICAgICAgICAgICBpZiAocmRqLnJlY3Vyc2l2ZVR5cGUgPT09IGlkLkFUVFJfUikge1xuICAgICAgICAgICAgICBpZiAocmRpLnJlZmVyc1RvW2pdICYmIHJkai5yZWZlcnNUb1tpXSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdHcm91cCkge1xuICAgICAgICAgICAgICAgICAgZ3JvdXBDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgcmRpLnJlY3Vyc2l2ZVR5cGUgPSBpZC5BVFRSX01SO1xuICAgICAgICAgICAgICAgICAgcmRpLmdyb3VwTnVtYmVyID0gZ3JvdXBDb3VudDtcbiAgICAgICAgICAgICAgICAgIG5ld0dyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJkai5yZWN1cnNpdmVUeXBlID0gaWQuQVRUUl9NUjtcbiAgICAgICAgICAgICAgICByZGouZ3JvdXBOdW1iZXIgPSBncm91cENvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLmlzTXV0dWFsbHlSZWN1cnNpdmUgPSBncm91cENvdW50ID4gLTE7XG5cbiAgICAvKiBzb3J0IHRoZSBydWxlcy9VRFRTICovXG4gICAgc3RhdGUucnVsZUFscGhhSW5kZXhlcy5zb3J0KHN0YXRlLmNvbXBSdWxlc0FscGhhKTtcbiAgICBzdGF0ZS5ydWxlVHlwZUluZGV4ZXMuc29ydChzdGF0ZS5jb21wUnVsZXNBbHBoYSk7XG4gICAgc3RhdGUucnVsZVR5cGVJbmRleGVzLnNvcnQoc3RhdGUuY29tcFJ1bGVzVHlwZSk7XG4gICAgaWYgKHN0YXRlLmlzTXV0dWFsbHlSZWN1cnNpdmUpIHtcbiAgICAgIHN0YXRlLnJ1bGVUeXBlSW5kZXhlcy5zb3J0KHN0YXRlLmNvbXBSdWxlc0dyb3VwKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnVkdENvdW50KSB7XG4gICAgICBzdGF0ZS51ZHRBbHBoYUluZGV4ZXMuc29ydChzdGF0ZS5jb21wVWR0c0FscGhhKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5kZXBlbmRlbmNpZXNDb21wbGV0ZSA9IHRydWU7XG4gIH07XG4gIGNvbnN0IHNob3cgPSAodHlwZSA9IG51bGwpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IHN0YXJ0U2VnID0gMDtcbiAgICBjb25zdCBtYXhSdWxlID0gc3RhdGUucnVsZUNvdW50IC0gMTtcbiAgICBjb25zdCBtYXhVZHQgPSBzdGF0ZS51ZHRDb3VudCAtIDE7XG4gICAgY29uc3QgbGluZUxlbmd0aCA9IDEwMDtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IHByZSA9ICcnO1xuICAgIGNvbnN0IHRvQXJyb3cgPSAnPT4gJztcbiAgICBjb25zdCBieUFycm93ID0gJzw9ICc7XG4gICAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gICAgbGV0IHJkaSA9IG51bGw7XG4gICAgbGV0IHsgcnVsZUluZGV4ZXMgfSA9IHN0YXRlO1xuICAgIGxldCB7IHVkdEluZGV4ZXMgfSA9IHN0YXRlO1xuICAgIGlmICh0eXBlID09PSA5Nykge1xuICAgICAgcnVsZUluZGV4ZXMgPSBzdGF0ZS5ydWxlQWxwaGFJbmRleGVzO1xuICAgICAgdWR0SW5kZXhlcyA9IHN0YXRlLnVkdEFscGhhSW5kZXhlcztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDExNikge1xuICAgICAgcnVsZUluZGV4ZXMgPSBzdGF0ZS5ydWxlVHlwZUluZGV4ZXM7XG4gICAgICB1ZHRJbmRleGVzID0gc3RhdGUudWR0QWxwaGFJbmRleGVzO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIHJkaSA9IHN0YXRlLnJ1bGVEZXBzW3J1bGVJbmRleGVzW2ldXTtcbiAgICAgIHByZSA9IGAke3J1bGVJbmRleGVzW2ldfToke3N0YXRlLnR5cGVUb1N0cmluZyhyZGkucmVjdXJzaXZlVHlwZSl9OmA7XG4gICAgICBpZiAoc3RhdGUuaXNNdXR1YWxseVJlY3Vyc2l2ZSkge1xuICAgICAgICBwcmUgKz0gcmRpLmdyb3VwTnVtYmVyID4gLTEgPyByZGkuZ3JvdXBOdW1iZXIgOiAnLSc7XG4gICAgICAgIHByZSArPSAnOic7XG4gICAgICB9XG4gICAgICBwcmUgKz0gJyAnO1xuICAgICAgc3RyICs9IGAke3ByZSArIHN0YXRlLnJ1bGVzW3J1bGVJbmRleGVzW2ldXS5uYW1lfVxcbmA7XG4gICAgICBmaXJzdCA9IHRydWU7XG4gICAgICBjb3VudCA9IDA7XG4gICAgICBzdGFydFNlZyA9IHN0ci5sZW5ndGg7XG4gICAgICBzdHIgKz0gcHJlO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHN0YXRlLnJ1bGVDb3VudDsgaiArPSAxKSB7XG4gICAgICAgIGlmIChyZGkucmVmZXJzVG9bcnVsZUluZGV4ZXNbal1dKSB7XG4gICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICBzdHIgKz0gdG9BcnJvdztcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICBzdHIgKz0gc3RhdGUucnVsZURlcHNbcnVsZUluZGV4ZXNbal1dLnJ1bGUubmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyICs9IGAsICR7c3RhdGUucnVsZURlcHNbcnVsZUluZGV4ZXNbal1dLnJ1bGUubmFtZX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIubGVuZ3RoIC0gc3RhcnRTZWcgPiBsaW5lTGVuZ3RoICYmIGogIT09IG1heFJ1bGUpIHtcbiAgICAgICAgICBzdHIgKz0gYFxcbiR7cHJlfSR7dG9BcnJvd31gO1xuICAgICAgICAgIHN0YXJ0U2VnID0gc3RyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnVkdENvdW50KSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS51ZHRDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKHJkaS5yZWZlcnNUb1VkdFt1ZHRJbmRleGVzW2pdXSkge1xuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgIHN0ciArPSB0b0Fycm93O1xuICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICBzdHIgKz0gc3RhdGUudWR0c1t1ZHRJbmRleGVzW2pdXS5uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyICs9IGAsICR7c3RhdGUudWR0c1t1ZHRJbmRleGVzW2pdXS5uYW1lfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyLmxlbmd0aCAtIHN0YXJ0U2VnID4gbGluZUxlbmd0aCAmJiBqICE9PSBtYXhVZHQpIHtcbiAgICAgICAgICAgIHN0ciArPSBgXFxuJHtwcmV9JHt0b0Fycm93fWA7XG4gICAgICAgICAgICBzdGFydFNlZyA9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgc3RyICs9ICc9PiA8bm9uZT5cXG4nO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0ID09PSBmYWxzZSkge1xuICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICB9XG4gICAgICBmaXJzdCA9IHRydWU7XG4gICAgICBjb3VudCA9IDA7XG4gICAgICBzdGFydFNlZyA9IHN0ci5sZW5ndGg7XG4gICAgICBzdHIgKz0gcHJlO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHN0YXRlLnJ1bGVDb3VudDsgaiArPSAxKSB7XG4gICAgICAgIGlmIChyZGkucmVmZXJlbmNlZEJ5W3J1bGVJbmRleGVzW2pdXSkge1xuICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgc3RyICs9IGJ5QXJyb3c7XG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RyICs9IHN0YXRlLnJ1bGVEZXBzW3J1bGVJbmRleGVzW2pdXS5ydWxlLm5hbWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciArPSBgLCAke3N0YXRlLnJ1bGVEZXBzW3J1bGVJbmRleGVzW2pdXS5ydWxlLm5hbWV9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLmxlbmd0aCAtIHN0YXJ0U2VnID4gbGluZUxlbmd0aCAmJiBqICE9PSBtYXhSdWxlKSB7XG4gICAgICAgICAgc3RyICs9IGBcXG4ke3ByZX0ke3RvQXJyb3d9YDtcbiAgICAgICAgICBzdGFydFNlZyA9IHN0ci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICBzdHIgKz0gJzw9IDxub25lPlxcbic7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3QgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgIH1cbiAgICAgIHN0ciArPSAnXFxuJztcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgLy8gRGlzcGxheSB0aGUgcnVsZSBkZXBlbmRlbmNpZXMuXG4gIC8vIC0gb3JkZXJcbiAgLy8gICAgICAtIFwiaW5kZXhcIiBvciBcImlcIiwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIC8vICAgICAgLSBcImFscGhhXCIgb3IgXCJhXCIsIGFscGhhYmV0aWNhbCBvcmRlclxuICAvLyAgICAgIC0gXCJ0eXBlXCIgb3IgXCJ0XCIsIG9yZGVyZWQgYnkgdHlwZSAoYWxwaGFiZXRpY2FsIHdpdGhpbiBlYWNoIHR5cGUvZ3JvdXApXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgY29uc3Qgc2hvd1J1bGVEZXBlbmRlbmNpZXMgPSAob3JkZXIgPSAnaW5kZXgnKSA9PiB7XG4gICAgbGV0IHN0ciA9ICdSVUxFIERFUEVOREVOQ0lFUyhpbmRleDp0eXBlOltncm91cCBudW1iZXI6XSlcXG4nO1xuICAgIHN0ciArPSAnPT4gcmVmZXJzIHRvIHJ1bGUgbmFtZXNcXG4nO1xuICAgIHN0ciArPSAnPD0gcmVmZXJlbmNlZCBieSBydWxlIG5hbWVzXFxuJztcbiAgICBpZiAoIXN0YXRlLmRlcGVuZGVuY2llc0NvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGlmIChvcmRlci5jaGFyQ29kZUF0KDApID09PSA5Nykge1xuICAgICAgc3RyICs9ICdhbHBoYWJldGljYWwgYnkgcnVsZSBuYW1lXFxuJztcbiAgICAgIHN0ciArPSBzaG93KDk3KTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyLmNoYXJDb2RlQXQoMCkgPT09IDExNikge1xuICAgICAgc3RyICs9ICdvcmRlcmVkIGJ5IHJ1bGUgdHlwZVxcbic7XG4gICAgICBzdHIgKz0gc2hvdygxMTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJ29yZGVyZWQgYnkgcnVsZSBpbmRleFxcbic7XG4gICAgICBzdHIgKz0gc2hvdyhudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKiBEZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQgLSBzZWUgTUROIFdlYiBEb2NzICovXG4gIHJldHVybiB7IHJ1bGVEZXBlbmRlbmNpZXMsIHNob3dSdWxlRGVwZW5kZW5jaWVzIH07XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-dependencies.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/sabnf-grammar.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/sabnf-grammar.js ***!
  \**********************************************************************************************/
/***/ ((module) => {

eval("// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.2.1 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 95\n  //       udts = 0\n  //    opcodes = 372\n  //        ---   ABNF original opcodes\n  //        ALT = 43\n  //        CAT = 48\n  //        REP = 34\n  //        RNM = 149\n  //        TLS = 2\n  //        TBS = 61\n  //        TRG = 35\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [9 - 126]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = {name: 'File', lower: 'file', index: 0, isBkr: false};\n  this.rules[1] = {name: 'BlankLine', lower: 'blankline', index: 1, isBkr: false};\n  this.rules[2] = {name: 'Rule', lower: 'rule', index: 2, isBkr: false};\n  this.rules[3] = {name: 'RuleLookup', lower: 'rulelookup', index: 3, isBkr: false};\n  this.rules[4] = {name: 'RuleNameTest', lower: 'rulenametest', index: 4, isBkr: false};\n  this.rules[5] = {name: 'RuleName', lower: 'rulename', index: 5, isBkr: false};\n  this.rules[6] = {name: 'RuleNameError', lower: 'rulenameerror', index: 6, isBkr: false};\n  this.rules[7] = {name: 'DefinedAsTest', lower: 'definedastest', index: 7, isBkr: false};\n  this.rules[8] = {name: 'DefinedAsError', lower: 'definedaserror', index: 8, isBkr: false};\n  this.rules[9] = {name: 'DefinedAs', lower: 'definedas', index: 9, isBkr: false};\n  this.rules[10] = {name: 'Defined', lower: 'defined', index: 10, isBkr: false};\n  this.rules[11] = {name: 'IncAlt', lower: 'incalt', index: 11, isBkr: false};\n  this.rules[12] = {name: 'RuleError', lower: 'ruleerror', index: 12, isBkr: false};\n  this.rules[13] = {name: 'LineEndError', lower: 'lineenderror', index: 13, isBkr: false};\n  this.rules[14] = {name: 'Alternation', lower: 'alternation', index: 14, isBkr: false};\n  this.rules[15] = {name: 'Concatenation', lower: 'concatenation', index: 15, isBkr: false};\n  this.rules[16] = {name: 'Repetition', lower: 'repetition', index: 16, isBkr: false};\n  this.rules[17] = {name: 'Modifier', lower: 'modifier', index: 17, isBkr: false};\n  this.rules[18] = {name: 'Predicate', lower: 'predicate', index: 18, isBkr: false};\n  this.rules[19] = {name: 'BasicElement', lower: 'basicelement', index: 19, isBkr: false};\n  this.rules[20] = {name: 'BasicElementErr', lower: 'basicelementerr', index: 20, isBkr: false};\n  this.rules[21] = {name: 'Group', lower: 'group', index: 21, isBkr: false};\n  this.rules[22] = {name: 'GroupError', lower: 'grouperror', index: 22, isBkr: false};\n  this.rules[23] = {name: 'GroupOpen', lower: 'groupopen', index: 23, isBkr: false};\n  this.rules[24] = {name: 'GroupClose', lower: 'groupclose', index: 24, isBkr: false};\n  this.rules[25] = {name: 'Option', lower: 'option', index: 25, isBkr: false};\n  this.rules[26] = {name: 'OptionError', lower: 'optionerror', index: 26, isBkr: false};\n  this.rules[27] = {name: 'OptionOpen', lower: 'optionopen', index: 27, isBkr: false};\n  this.rules[28] = {name: 'OptionClose', lower: 'optionclose', index: 28, isBkr: false};\n  this.rules[29] = {name: 'RnmOp', lower: 'rnmop', index: 29, isBkr: false};\n  this.rules[30] = {name: 'BkrOp', lower: 'bkrop', index: 30, isBkr: false};\n  this.rules[31] = {name: 'bkrModifier', lower: 'bkrmodifier', index: 31, isBkr: false};\n  this.rules[32] = {name: 'cs', lower: 'cs', index: 32, isBkr: false};\n  this.rules[33] = {name: 'ci', lower: 'ci', index: 33, isBkr: false};\n  this.rules[34] = {name: 'um', lower: 'um', index: 34, isBkr: false};\n  this.rules[35] = {name: 'pm', lower: 'pm', index: 35, isBkr: false};\n  this.rules[36] = {name: 'bkr-name', lower: 'bkr-name', index: 36, isBkr: false};\n  this.rules[37] = {name: 'rname', lower: 'rname', index: 37, isBkr: false};\n  this.rules[38] = {name: 'uname', lower: 'uname', index: 38, isBkr: false};\n  this.rules[39] = {name: 'ename', lower: 'ename', index: 39, isBkr: false};\n  this.rules[40] = {name: 'UdtOp', lower: 'udtop', index: 40, isBkr: false};\n  this.rules[41] = {name: 'udt-non-empty', lower: 'udt-non-empty', index: 41, isBkr: false};\n  this.rules[42] = {name: 'udt-empty', lower: 'udt-empty', index: 42, isBkr: false};\n  this.rules[43] = {name: 'RepOp', lower: 'repop', index: 43, isBkr: false};\n  this.rules[44] = {name: 'AltOp', lower: 'altop', index: 44, isBkr: false};\n  this.rules[45] = {name: 'CatOp', lower: 'catop', index: 45, isBkr: false};\n  this.rules[46] = {name: 'StarOp', lower: 'starop', index: 46, isBkr: false};\n  this.rules[47] = {name: 'AndOp', lower: 'andop', index: 47, isBkr: false};\n  this.rules[48] = {name: 'NotOp', lower: 'notop', index: 48, isBkr: false};\n  this.rules[49] = {name: 'BkaOp', lower: 'bkaop', index: 49, isBkr: false};\n  this.rules[50] = {name: 'BknOp', lower: 'bknop', index: 50, isBkr: false};\n  this.rules[51] = {name: 'AbgOp', lower: 'abgop', index: 51, isBkr: false};\n  this.rules[52] = {name: 'AenOp', lower: 'aenop', index: 52, isBkr: false};\n  this.rules[53] = {name: 'TrgOp', lower: 'trgop', index: 53, isBkr: false};\n  this.rules[54] = {name: 'TbsOp', lower: 'tbsop', index: 54, isBkr: false};\n  this.rules[55] = {name: 'TlsOp', lower: 'tlsop', index: 55, isBkr: false};\n  this.rules[56] = {name: 'TlsCase', lower: 'tlscase', index: 56, isBkr: false};\n  this.rules[57] = {name: 'TlsOpen', lower: 'tlsopen', index: 57, isBkr: false};\n  this.rules[58] = {name: 'TlsClose', lower: 'tlsclose', index: 58, isBkr: false};\n  this.rules[59] = {name: 'TlsString', lower: 'tlsstring', index: 59, isBkr: false};\n  this.rules[60] = {name: 'StringTab', lower: 'stringtab', index: 60, isBkr: false};\n  this.rules[61] = {name: 'ClsOp', lower: 'clsop', index: 61, isBkr: false};\n  this.rules[62] = {name: 'ClsOpen', lower: 'clsopen', index: 62, isBkr: false};\n  this.rules[63] = {name: 'ClsClose', lower: 'clsclose', index: 63, isBkr: false};\n  this.rules[64] = {name: 'ClsString', lower: 'clsstring', index: 64, isBkr: false};\n  this.rules[65] = {name: 'ProsVal', lower: 'prosval', index: 65, isBkr: false};\n  this.rules[66] = {name: 'ProsValOpen', lower: 'prosvalopen', index: 66, isBkr: false};\n  this.rules[67] = {name: 'ProsValString', lower: 'prosvalstring', index: 67, isBkr: false};\n  this.rules[68] = {name: 'ProsValClose', lower: 'prosvalclose', index: 68, isBkr: false};\n  this.rules[69] = {name: 'rep-min', lower: 'rep-min', index: 69, isBkr: false};\n  this.rules[70] = {name: 'rep-min-max', lower: 'rep-min-max', index: 70, isBkr: false};\n  this.rules[71] = {name: 'rep-max', lower: 'rep-max', index: 71, isBkr: false};\n  this.rules[72] = {name: 'rep-num', lower: 'rep-num', index: 72, isBkr: false};\n  this.rules[73] = {name: 'dString', lower: 'dstring', index: 73, isBkr: false};\n  this.rules[74] = {name: 'xString', lower: 'xstring', index: 74, isBkr: false};\n  this.rules[75] = {name: 'bString', lower: 'bstring', index: 75, isBkr: false};\n  this.rules[76] = {name: 'Dec', lower: 'dec', index: 76, isBkr: false};\n  this.rules[77] = {name: 'Hex', lower: 'hex', index: 77, isBkr: false};\n  this.rules[78] = {name: 'Bin', lower: 'bin', index: 78, isBkr: false};\n  this.rules[79] = {name: 'dmin', lower: 'dmin', index: 79, isBkr: false};\n  this.rules[80] = {name: 'dmax', lower: 'dmax', index: 80, isBkr: false};\n  this.rules[81] = {name: 'bmin', lower: 'bmin', index: 81, isBkr: false};\n  this.rules[82] = {name: 'bmax', lower: 'bmax', index: 82, isBkr: false};\n  this.rules[83] = {name: 'xmin', lower: 'xmin', index: 83, isBkr: false};\n  this.rules[84] = {name: 'xmax', lower: 'xmax', index: 84, isBkr: false};\n  this.rules[85] = {name: 'dnum', lower: 'dnum', index: 85, isBkr: false};\n  this.rules[86] = {name: 'bnum', lower: 'bnum', index: 86, isBkr: false};\n  this.rules[87] = {name: 'xnum', lower: 'xnum', index: 87, isBkr: false};\n  this.rules[88] = {name: 'alphanum', lower: 'alphanum', index: 88, isBkr: false};\n  this.rules[89] = {name: 'owsp', lower: 'owsp', index: 89, isBkr: false};\n  this.rules[90] = {name: 'wsp', lower: 'wsp', index: 90, isBkr: false};\n  this.rules[91] = {name: 'space', lower: 'space', index: 91, isBkr: false};\n  this.rules[92] = {name: 'comment', lower: 'comment', index: 92, isBkr: false};\n  this.rules[93] = {name: 'LineEnd', lower: 'lineend', index: 93, isBkr: false};\n  this.rules[94] = {name: 'LineContinue', lower: 'linecontinue', index: 94, isBkr: false};\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* File */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[0].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[0].opcodes[2] = {type: 4, index: 1};// RNM(BlankLine)\n  this.rules[0].opcodes[3] = {type: 4, index: 2};// RNM(Rule)\n  this.rules[0].opcodes[4] = {type: 4, index: 12};// RNM(RuleError)\n\n  /* BlankLine */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = {type: 2, children: [1,5,7]};// CAT\n  this.rules[1].opcodes[1] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[1].opcodes[2] = {type: 1, children: [3,4]};// ALT\n  this.rules[1].opcodes[3] = {type: 6, string: [32]};// TBS\n  this.rules[1].opcodes[4] = {type: 6, string: [9]};// TBS\n  this.rules[1].opcodes[5] = {type: 3, min: 0, max: 1};// REP\n  this.rules[1].opcodes[6] = {type: 4, index: 92};// RNM(comment)\n  this.rules[1].opcodes[7] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* Rule */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = {type: 2, children: [1,2,3,4]};// CAT\n  this.rules[2].opcodes[1] = {type: 4, index: 3};// RNM(RuleLookup)\n  this.rules[2].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[2].opcodes[3] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[2].opcodes[4] = {type: 1, children: [5,8]};// ALT\n  this.rules[2].opcodes[5] = {type: 2, children: [6,7]};// CAT\n  this.rules[2].opcodes[6] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[2].opcodes[7] = {type: 4, index: 93};// RNM(LineEnd)\n  this.rules[2].opcodes[8] = {type: 2, children: [9,10]};// CAT\n  this.rules[2].opcodes[9] = {type: 4, index: 13};// RNM(LineEndError)\n  this.rules[2].opcodes[10] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* RuleLookup */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[3].opcodes[1] = {type: 4, index: 4};// RNM(RuleNameTest)\n  this.rules[3].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[3].opcodes[3] = {type: 4, index: 7};// RNM(DefinedAsTest)\n\n  /* RuleNameTest */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[4].opcodes[1] = {type: 4, index: 5};// RNM(RuleName)\n  this.rules[4].opcodes[2] = {type: 4, index: 6};// RNM(RuleNameError)\n\n  /* RuleName */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* RuleNameError */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[6].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[6].opcodes[2] = {type: 5, min: 33, max: 60};// TRG\n  this.rules[6].opcodes[3] = {type: 5, min: 62, max: 126};// TRG\n\n  /* DefinedAsTest */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[7].opcodes[1] = {type: 4, index: 9};// RNM(DefinedAs)\n  this.rules[7].opcodes[2] = {type: 4, index: 8};// RNM(DefinedAsError)\n\n  /* DefinedAsError */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = {type: 3, min: 1, max: 2};// REP\n  this.rules[8].opcodes[1] = {type: 5, min: 33, max: 126};// TRG\n\n  /* DefinedAs */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[9].opcodes[1] = {type: 4, index: 11};// RNM(IncAlt)\n  this.rules[9].opcodes[2] = {type: 4, index: 10};// RNM(Defined)\n\n  /* Defined */\n  this.rules[10].opcodes = [];\n  this.rules[10].opcodes[0] = {type: 6, string: [61]};// TBS\n\n  /* IncAlt */\n  this.rules[11].opcodes = [];\n  this.rules[11].opcodes[0] = {type: 6, string: [61,47]};// TBS\n\n  /* RuleError */\n  this.rules[12].opcodes = [];\n  this.rules[12].opcodes[0] = {type: 2, children: [1,6]};// CAT\n  this.rules[12].opcodes[1] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[12].opcodes[2] = {type: 1, children: [3,4,5]};// ALT\n  this.rules[12].opcodes[3] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[12].opcodes[4] = {type: 6, string: [9]};// TBS\n  this.rules[12].opcodes[5] = {type: 4, index: 94};// RNM(LineContinue)\n  this.rules[12].opcodes[6] = {type: 4, index: 93};// RNM(LineEnd)\n\n  /* LineEndError */\n  this.rules[13].opcodes = [];\n  this.rules[13].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[13].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[13].opcodes[2] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[13].opcodes[3] = {type: 6, string: [9]};// TBS\n  this.rules[13].opcodes[4] = {type: 4, index: 94};// RNM(LineContinue)\n\n  /* Alternation */\n  this.rules[14].opcodes = [];\n  this.rules[14].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[14].opcodes[1] = {type: 4, index: 15};// RNM(Concatenation)\n  this.rules[14].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[14].opcodes[3] = {type: 2, children: [4,5,6]};// CAT\n  this.rules[14].opcodes[4] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[14].opcodes[5] = {type: 4, index: 44};// RNM(AltOp)\n  this.rules[14].opcodes[6] = {type: 4, index: 15};// RNM(Concatenation)\n\n  /* Concatenation */\n  this.rules[15].opcodes = [];\n  this.rules[15].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[15].opcodes[1] = {type: 4, index: 16};// RNM(Repetition)\n  this.rules[15].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[15].opcodes[3] = {type: 2, children: [4,5]};// CAT\n  this.rules[15].opcodes[4] = {type: 4, index: 45};// RNM(CatOp)\n  this.rules[15].opcodes[5] = {type: 4, index: 16};// RNM(Repetition)\n\n  /* Repetition */\n  this.rules[16].opcodes = [];\n  this.rules[16].opcodes[0] = {type: 2, children: [1,3]};// CAT\n  this.rules[16].opcodes[1] = {type: 3, min: 0, max: 1};// REP\n  this.rules[16].opcodes[2] = {type: 4, index: 17};// RNM(Modifier)\n  this.rules[16].opcodes[3] = {type: 1, children: [4,5,6,7]};// ALT\n  this.rules[16].opcodes[4] = {type: 4, index: 21};// RNM(Group)\n  this.rules[16].opcodes[5] = {type: 4, index: 25};// RNM(Option)\n  this.rules[16].opcodes[6] = {type: 4, index: 19};// RNM(BasicElement)\n  this.rules[16].opcodes[7] = {type: 4, index: 20};// RNM(BasicElementErr)\n\n  /* Modifier */\n  this.rules[17].opcodes = [];\n  this.rules[17].opcodes[0] = {type: 1, children: [1,5]};// ALT\n  this.rules[17].opcodes[1] = {type: 2, children: [2,3]};// CAT\n  this.rules[17].opcodes[2] = {type: 4, index: 18};// RNM(Predicate)\n  this.rules[17].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[17].opcodes[4] = {type: 4, index: 43};// RNM(RepOp)\n  this.rules[17].opcodes[5] = {type: 4, index: 43};// RNM(RepOp)\n\n  /* Predicate */\n  this.rules[18].opcodes = [];\n  this.rules[18].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[18].opcodes[1] = {type: 4, index: 49};// RNM(BkaOp)\n  this.rules[18].opcodes[2] = {type: 4, index: 50};// RNM(BknOp)\n  this.rules[18].opcodes[3] = {type: 4, index: 47};// RNM(AndOp)\n  this.rules[18].opcodes[4] = {type: 4, index: 48};// RNM(NotOp)\n\n  /* BasicElement */\n  this.rules[19].opcodes = [];\n  this.rules[19].opcodes[0] = {type: 1, children: [1,2,3,4,5,6,7,8,9,10]};// ALT\n  this.rules[19].opcodes[1] = {type: 4, index: 40};// RNM(UdtOp)\n  this.rules[19].opcodes[2] = {type: 4, index: 29};// RNM(RnmOp)\n  this.rules[19].opcodes[3] = {type: 4, index: 53};// RNM(TrgOp)\n  this.rules[19].opcodes[4] = {type: 4, index: 54};// RNM(TbsOp)\n  this.rules[19].opcodes[5] = {type: 4, index: 55};// RNM(TlsOp)\n  this.rules[19].opcodes[6] = {type: 4, index: 61};// RNM(ClsOp)\n  this.rules[19].opcodes[7] = {type: 4, index: 30};// RNM(BkrOp)\n  this.rules[19].opcodes[8] = {type: 4, index: 51};// RNM(AbgOp)\n  this.rules[19].opcodes[9] = {type: 4, index: 52};// RNM(AenOp)\n  this.rules[19].opcodes[10] = {type: 4, index: 65};// RNM(ProsVal)\n\n  /* BasicElementErr */\n  this.rules[20].opcodes = [];\n  this.rules[20].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[20].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[20].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[20].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[20].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[20].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* Group */\n  this.rules[21].opcodes = [];\n  this.rules[21].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[21].opcodes[1] = {type: 4, index: 23};// RNM(GroupOpen)\n  this.rules[21].opcodes[2] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[21].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[21].opcodes[4] = {type: 4, index: 24};// RNM(GroupClose)\n  this.rules[21].opcodes[5] = {type: 4, index: 22};// RNM(GroupError)\n\n  /* GroupError */\n  this.rules[22].opcodes = [];\n  this.rules[22].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[22].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[22].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[22].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[22].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[22].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* GroupOpen */\n  this.rules[23].opcodes = [];\n  this.rules[23].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[23].opcodes[1] = {type: 6, string: [40]};// TBS\n  this.rules[23].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* GroupClose */\n  this.rules[24].opcodes = [];\n  this.rules[24].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[24].opcodes[1] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[24].opcodes[2] = {type: 6, string: [41]};// TBS\n\n  /* Option */\n  this.rules[25].opcodes = [];\n  this.rules[25].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[25].opcodes[1] = {type: 4, index: 27};// RNM(OptionOpen)\n  this.rules[25].opcodes[2] = {type: 4, index: 14};// RNM(Alternation)\n  this.rules[25].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[25].opcodes[4] = {type: 4, index: 28};// RNM(OptionClose)\n  this.rules[25].opcodes[5] = {type: 4, index: 26};// RNM(OptionError)\n\n  /* OptionError */\n  this.rules[26].opcodes = [];\n  this.rules[26].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[26].opcodes[1] = {type: 1, children: [2,3,4,5]};// ALT\n  this.rules[26].opcodes[2] = {type: 5, min: 33, max: 40};// TRG\n  this.rules[26].opcodes[3] = {type: 5, min: 42, max: 46};// TRG\n  this.rules[26].opcodes[4] = {type: 5, min: 48, max: 92};// TRG\n  this.rules[26].opcodes[5] = {type: 5, min: 94, max: 126};// TRG\n\n  /* OptionOpen */\n  this.rules[27].opcodes = [];\n  this.rules[27].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[27].opcodes[1] = {type: 6, string: [91]};// TBS\n  this.rules[27].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* OptionClose */\n  this.rules[28].opcodes = [];\n  this.rules[28].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[28].opcodes[1] = {type: 4, index: 89};// RNM(owsp)\n  this.rules[28].opcodes[2] = {type: 6, string: [93]};// TBS\n\n  /* RnmOp */\n  this.rules[29].opcodes = [];\n  this.rules[29].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* BkrOp */\n  this.rules[30].opcodes = [];\n  this.rules[30].opcodes[0] = {type: 2, children: [1,2,4]};// CAT\n  this.rules[30].opcodes[1] = {type: 6, string: [92]};// TBS\n  this.rules[30].opcodes[2] = {type: 3, min: 0, max: 1};// REP\n  this.rules[30].opcodes[3] = {type: 4, index: 31};// RNM(bkrModifier)\n  this.rules[30].opcodes[4] = {type: 4, index: 36};// RNM(bkr-name)\n\n  /* bkrModifier */\n  this.rules[31].opcodes = [];\n  this.rules[31].opcodes[0] = {type: 1, children: [1,7,13,19]};// ALT\n  this.rules[31].opcodes[1] = {type: 2, children: [2,3]};// CAT\n  this.rules[31].opcodes[2] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[4] = {type: 1, children: [5,6]};// ALT\n  this.rules[31].opcodes[5] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[6] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[7] = {type: 2, children: [8,9]};// CAT\n  this.rules[31].opcodes[8] = {type: 4, index: 33};// RNM(ci)\n  this.rules[31].opcodes[9] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[10] = {type: 1, children: [11,12]};// ALT\n  this.rules[31].opcodes[11] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[12] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[13] = {type: 2, children: [14,15]};// CAT\n  this.rules[31].opcodes[14] = {type: 4, index: 34};// RNM(um)\n  this.rules[31].opcodes[15] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[16] = {type: 1, children: [17,18]};// ALT\n  this.rules[31].opcodes[17] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[18] = {type: 4, index: 33};// RNM(ci)\n  this.rules[31].opcodes[19] = {type: 2, children: [20,21]};// CAT\n  this.rules[31].opcodes[20] = {type: 4, index: 35};// RNM(pm)\n  this.rules[31].opcodes[21] = {type: 3, min: 0, max: 1};// REP\n  this.rules[31].opcodes[22] = {type: 1, children: [23,24]};// ALT\n  this.rules[31].opcodes[23] = {type: 4, index: 32};// RNM(cs)\n  this.rules[31].opcodes[24] = {type: 4, index: 33};// RNM(ci)\n\n  /* cs */\n  this.rules[32].opcodes = [];\n  this.rules[32].opcodes[0] = {type: 6, string: [37,115]};// TBS\n\n  /* ci */\n  this.rules[33].opcodes = [];\n  this.rules[33].opcodes[0] = {type: 6, string: [37,105]};// TBS\n\n  /* um */\n  this.rules[34].opcodes = [];\n  this.rules[34].opcodes[0] = {type: 6, string: [37,117]};// TBS\n\n  /* pm */\n  this.rules[35].opcodes = [];\n  this.rules[35].opcodes[0] = {type: 6, string: [37,112]};// TBS\n\n  /* bkr-name */\n  this.rules[36].opcodes = [];\n  this.rules[36].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[36].opcodes[1] = {type: 4, index: 38};// RNM(uname)\n  this.rules[36].opcodes[2] = {type: 4, index: 39};// RNM(ename)\n  this.rules[36].opcodes[3] = {type: 4, index: 37};// RNM(rname)\n\n  /* rname */\n  this.rules[37].opcodes = [];\n  this.rules[37].opcodes[0] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* uname */\n  this.rules[38].opcodes = [];\n  this.rules[38].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[38].opcodes[1] = {type: 6, string: [117,95]};// TBS\n  this.rules[38].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* ename */\n  this.rules[39].opcodes = [];\n  this.rules[39].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[39].opcodes[1] = {type: 6, string: [101,95]};// TBS\n  this.rules[39].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* UdtOp */\n  this.rules[40].opcodes = [];\n  this.rules[40].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[40].opcodes[1] = {type: 4, index: 42};// RNM(udt-empty)\n  this.rules[40].opcodes[2] = {type: 4, index: 41};// RNM(udt-non-empty)\n\n  /* udt-non-empty */\n  this.rules[41].opcodes = [];\n  this.rules[41].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[41].opcodes[1] = {type: 6, string: [117,95]};// TBS\n  this.rules[41].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* udt-empty */\n  this.rules[42].opcodes = [];\n  this.rules[42].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[42].opcodes[1] = {type: 6, string: [101,95]};// TBS\n  this.rules[42].opcodes[2] = {type: 4, index: 88};// RNM(alphanum)\n\n  /* RepOp */\n  this.rules[43].opcodes = [];\n  this.rules[43].opcodes[0] = {type: 1, children: [1,5,8,11,12]};// ALT\n  this.rules[43].opcodes[1] = {type: 2, children: [2,3,4]};// CAT\n  this.rules[43].opcodes[2] = {type: 4, index: 69};// RNM(rep-min)\n  this.rules[43].opcodes[3] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[4] = {type: 4, index: 71};// RNM(rep-max)\n  this.rules[43].opcodes[5] = {type: 2, children: [6,7]};// CAT\n  this.rules[43].opcodes[6] = {type: 4, index: 69};// RNM(rep-min)\n  this.rules[43].opcodes[7] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[8] = {type: 2, children: [9,10]};// CAT\n  this.rules[43].opcodes[9] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[10] = {type: 4, index: 71};// RNM(rep-max)\n  this.rules[43].opcodes[11] = {type: 4, index: 46};// RNM(StarOp)\n  this.rules[43].opcodes[12] = {type: 4, index: 70};// RNM(rep-min-max)\n\n  /* AltOp */\n  this.rules[44].opcodes = [];\n  this.rules[44].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[44].opcodes[1] = {type: 6, string: [47]};// TBS\n  this.rules[44].opcodes[2] = {type: 4, index: 89};// RNM(owsp)\n\n  /* CatOp */\n  this.rules[45].opcodes = [];\n  this.rules[45].opcodes[0] = {type: 4, index: 90};// RNM(wsp)\n\n  /* StarOp */\n  this.rules[46].opcodes = [];\n  this.rules[46].opcodes[0] = {type: 6, string: [42]};// TBS\n\n  /* AndOp */\n  this.rules[47].opcodes = [];\n  this.rules[47].opcodes[0] = {type: 6, string: [38]};// TBS\n\n  /* NotOp */\n  this.rules[48].opcodes = [];\n  this.rules[48].opcodes[0] = {type: 6, string: [33]};// TBS\n\n  /* BkaOp */\n  this.rules[49].opcodes = [];\n  this.rules[49].opcodes[0] = {type: 6, string: [38,38]};// TBS\n\n  /* BknOp */\n  this.rules[50].opcodes = [];\n  this.rules[50].opcodes[0] = {type: 6, string: [33,33]};// TBS\n\n  /* AbgOp */\n  this.rules[51].opcodes = [];\n  this.rules[51].opcodes[0] = {type: 6, string: [37,94]};// TBS\n\n  /* AenOp */\n  this.rules[52].opcodes = [];\n  this.rules[52].opcodes[0] = {type: 6, string: [37,36]};// TBS\n\n  /* TrgOp */\n  this.rules[53].opcodes = [];\n  this.rules[53].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[53].opcodes[1] = {type: 6, string: [37]};// TBS\n  this.rules[53].opcodes[2] = {type: 1, children: [3,8,13]};// ALT\n  this.rules[53].opcodes[3] = {type: 2, children: [4,5,6,7]};// CAT\n  this.rules[53].opcodes[4] = {type: 4, index: 76};// RNM(Dec)\n  this.rules[53].opcodes[5] = {type: 4, index: 79};// RNM(dmin)\n  this.rules[53].opcodes[6] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[7] = {type: 4, index: 80};// RNM(dmax)\n  this.rules[53].opcodes[8] = {type: 2, children: [9,10,11,12]};// CAT\n  this.rules[53].opcodes[9] = {type: 4, index: 77};// RNM(Hex)\n  this.rules[53].opcodes[10] = {type: 4, index: 83};// RNM(xmin)\n  this.rules[53].opcodes[11] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[12] = {type: 4, index: 84};// RNM(xmax)\n  this.rules[53].opcodes[13] = {type: 2, children: [14,15,16,17]};// CAT\n  this.rules[53].opcodes[14] = {type: 4, index: 78};// RNM(Bin)\n  this.rules[53].opcodes[15] = {type: 4, index: 81};// RNM(bmin)\n  this.rules[53].opcodes[16] = {type: 6, string: [45]};// TBS\n  this.rules[53].opcodes[17] = {type: 4, index: 82};// RNM(bmax)\n\n  /* TbsOp */\n  this.rules[54].opcodes = [];\n  this.rules[54].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[54].opcodes[1] = {type: 6, string: [37]};// TBS\n  this.rules[54].opcodes[2] = {type: 1, children: [3,10,17]};// ALT\n  this.rules[54].opcodes[3] = {type: 2, children: [4,5,6]};// CAT\n  this.rules[54].opcodes[4] = {type: 4, index: 76};// RNM(Dec)\n  this.rules[54].opcodes[5] = {type: 4, index: 73};// RNM(dString)\n  this.rules[54].opcodes[6] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[7] = {type: 2, children: [8,9]};// CAT\n  this.rules[54].opcodes[8] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[9] = {type: 4, index: 73};// RNM(dString)\n  this.rules[54].opcodes[10] = {type: 2, children: [11,12,13]};// CAT\n  this.rules[54].opcodes[11] = {type: 4, index: 77};// RNM(Hex)\n  this.rules[54].opcodes[12] = {type: 4, index: 74};// RNM(xString)\n  this.rules[54].opcodes[13] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[14] = {type: 2, children: [15,16]};// CAT\n  this.rules[54].opcodes[15] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[16] = {type: 4, index: 74};// RNM(xString)\n  this.rules[54].opcodes[17] = {type: 2, children: [18,19,20]};// CAT\n  this.rules[54].opcodes[18] = {type: 4, index: 78};// RNM(Bin)\n  this.rules[54].opcodes[19] = {type: 4, index: 75};// RNM(bString)\n  this.rules[54].opcodes[20] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[54].opcodes[21] = {type: 2, children: [22,23]};// CAT\n  this.rules[54].opcodes[22] = {type: 6, string: [46]};// TBS\n  this.rules[54].opcodes[23] = {type: 4, index: 75};// RNM(bString)\n\n  /* TlsOp */\n  this.rules[55].opcodes = [];\n  this.rules[55].opcodes[0] = {type: 2, children: [1,2,3,4]};// CAT\n  this.rules[55].opcodes[1] = {type: 4, index: 56};// RNM(TlsCase)\n  this.rules[55].opcodes[2] = {type: 4, index: 57};// RNM(TlsOpen)\n  this.rules[55].opcodes[3] = {type: 4, index: 59};// RNM(TlsString)\n  this.rules[55].opcodes[4] = {type: 4, index: 58};// RNM(TlsClose)\n\n  /* TlsCase */\n  this.rules[56].opcodes = [];\n  this.rules[56].opcodes[0] = {type: 3, min: 0, max: 1};// REP\n  this.rules[56].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[56].opcodes[2] = {type: 7, string: [37,105]};// TLS\n  this.rules[56].opcodes[3] = {type: 7, string: [37,115]};// TLS\n\n  /* TlsOpen */\n  this.rules[57].opcodes = [];\n  this.rules[57].opcodes[0] = {type: 6, string: [34]};// TBS\n\n  /* TlsClose */\n  this.rules[58].opcodes = [];\n  this.rules[58].opcodes[0] = {type: 6, string: [34]};// TBS\n\n  /* TlsString */\n  this.rules[59].opcodes = [];\n  this.rules[59].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[59].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[59].opcodes[2] = {type: 5, min: 32, max: 33};// TRG\n  this.rules[59].opcodes[3] = {type: 5, min: 35, max: 126};// TRG\n  this.rules[59].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* StringTab */\n  this.rules[60].opcodes = [];\n  this.rules[60].opcodes[0] = {type: 6, string: [9]};// TBS\n\n  /* ClsOp */\n  this.rules[61].opcodes = [];\n  this.rules[61].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[61].opcodes[1] = {type: 4, index: 62};// RNM(ClsOpen)\n  this.rules[61].opcodes[2] = {type: 4, index: 64};// RNM(ClsString)\n  this.rules[61].opcodes[3] = {type: 4, index: 63};// RNM(ClsClose)\n\n  /* ClsOpen */\n  this.rules[62].opcodes = [];\n  this.rules[62].opcodes[0] = {type: 6, string: [39]};// TBS\n\n  /* ClsClose */\n  this.rules[63].opcodes = [];\n  this.rules[63].opcodes[0] = {type: 6, string: [39]};// TBS\n\n  /* ClsString */\n  this.rules[64].opcodes = [];\n  this.rules[64].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[64].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[64].opcodes[2] = {type: 5, min: 32, max: 38};// TRG\n  this.rules[64].opcodes[3] = {type: 5, min: 40, max: 126};// TRG\n  this.rules[64].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* ProsVal */\n  this.rules[65].opcodes = [];\n  this.rules[65].opcodes[0] = {type: 2, children: [1,2,3]};// CAT\n  this.rules[65].opcodes[1] = {type: 4, index: 66};// RNM(ProsValOpen)\n  this.rules[65].opcodes[2] = {type: 4, index: 67};// RNM(ProsValString)\n  this.rules[65].opcodes[3] = {type: 4, index: 68};// RNM(ProsValClose)\n\n  /* ProsValOpen */\n  this.rules[66].opcodes = [];\n  this.rules[66].opcodes[0] = {type: 6, string: [60]};// TBS\n\n  /* ProsValString */\n  this.rules[67].opcodes = [];\n  this.rules[67].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[67].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[67].opcodes[2] = {type: 5, min: 32, max: 61};// TRG\n  this.rules[67].opcodes[3] = {type: 5, min: 63, max: 126};// TRG\n  this.rules[67].opcodes[4] = {type: 4, index: 60};// RNM(StringTab)\n\n  /* ProsValClose */\n  this.rules[68].opcodes = [];\n  this.rules[68].opcodes[0] = {type: 6, string: [62]};// TBS\n\n  /* rep-min */\n  this.rules[69].opcodes = [];\n  this.rules[69].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-min-max */\n  this.rules[70].opcodes = [];\n  this.rules[70].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-max */\n  this.rules[71].opcodes = [];\n  this.rules[71].opcodes[0] = {type: 4, index: 72};// RNM(rep-num)\n\n  /* rep-num */\n  this.rules[72].opcodes = [];\n  this.rules[72].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[72].opcodes[1] = {type: 5, min: 48, max: 57};// TRG\n\n  /* dString */\n  this.rules[73].opcodes = [];\n  this.rules[73].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* xString */\n  this.rules[74].opcodes = [];\n  this.rules[74].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* bString */\n  this.rules[75].opcodes = [];\n  this.rules[75].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* Dec */\n  this.rules[76].opcodes = [];\n  this.rules[76].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[76].opcodes[1] = {type: 6, string: [68]};// TBS\n  this.rules[76].opcodes[2] = {type: 6, string: [100]};// TBS\n\n  /* Hex */\n  this.rules[77].opcodes = [];\n  this.rules[77].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[77].opcodes[1] = {type: 6, string: [88]};// TBS\n  this.rules[77].opcodes[2] = {type: 6, string: [120]};// TBS\n\n  /* Bin */\n  this.rules[78].opcodes = [];\n  this.rules[78].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[78].opcodes[1] = {type: 6, string: [66]};// TBS\n  this.rules[78].opcodes[2] = {type: 6, string: [98]};// TBS\n\n  /* dmin */\n  this.rules[79].opcodes = [];\n  this.rules[79].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* dmax */\n  this.rules[80].opcodes = [];\n  this.rules[80].opcodes[0] = {type: 4, index: 85};// RNM(dnum)\n\n  /* bmin */\n  this.rules[81].opcodes = [];\n  this.rules[81].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* bmax */\n  this.rules[82].opcodes = [];\n  this.rules[82].opcodes[0] = {type: 4, index: 86};// RNM(bnum)\n\n  /* xmin */\n  this.rules[83].opcodes = [];\n  this.rules[83].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* xmax */\n  this.rules[84].opcodes = [];\n  this.rules[84].opcodes[0] = {type: 4, index: 87};// RNM(xnum)\n\n  /* dnum */\n  this.rules[85].opcodes = [];\n  this.rules[85].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[85].opcodes[1] = {type: 5, min: 48, max: 57};// TRG\n\n  /* bnum */\n  this.rules[86].opcodes = [];\n  this.rules[86].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[86].opcodes[1] = {type: 5, min: 48, max: 49};// TRG\n\n  /* xnum */\n  this.rules[87].opcodes = [];\n  this.rules[87].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[87].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[87].opcodes[2] = {type: 5, min: 48, max: 57};// TRG\n  this.rules[87].opcodes[3] = {type: 5, min: 65, max: 70};// TRG\n  this.rules[87].opcodes[4] = {type: 5, min: 97, max: 102};// TRG\n\n  /* alphanum */\n  this.rules[88].opcodes = [];\n  this.rules[88].opcodes[0] = {type: 2, children: [1,4]};// CAT\n  this.rules[88].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[88].opcodes[2] = {type: 5, min: 97, max: 122};// TRG\n  this.rules[88].opcodes[3] = {type: 5, min: 65, max: 90};// TRG\n  this.rules[88].opcodes[4] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[88].opcodes[5] = {type: 1, children: [6,7,8,9]};// ALT\n  this.rules[88].opcodes[6] = {type: 5, min: 97, max: 122};// TRG\n  this.rules[88].opcodes[7] = {type: 5, min: 65, max: 90};// TRG\n  this.rules[88].opcodes[8] = {type: 5, min: 48, max: 57};// TRG\n  this.rules[88].opcodes[9] = {type: 6, string: [45]};// TBS\n\n  /* owsp */\n  this.rules[89].opcodes = [];\n  this.rules[89].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[89].opcodes[1] = {type: 4, index: 91};// RNM(space)\n\n  /* wsp */\n  this.rules[90].opcodes = [];\n  this.rules[90].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[90].opcodes[1] = {type: 4, index: 91};// RNM(space)\n\n  /* space */\n  this.rules[91].opcodes = [];\n  this.rules[91].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[91].opcodes[1] = {type: 6, string: [32]};// TBS\n  this.rules[91].opcodes[2] = {type: 6, string: [9]};// TBS\n  this.rules[91].opcodes[3] = {type: 4, index: 92};// RNM(comment)\n  this.rules[91].opcodes[4] = {type: 4, index: 94};// RNM(LineContinue)\n\n  /* comment */\n  this.rules[92].opcodes = [];\n  this.rules[92].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[92].opcodes[1] = {type: 6, string: [59]};// TBS\n  this.rules[92].opcodes[2] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[92].opcodes[3] = {type: 1, children: [4,5]};// ALT\n  this.rules[92].opcodes[4] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[92].opcodes[5] = {type: 6, string: [9]};// TBS\n\n  /* LineEnd */\n  this.rules[93].opcodes = [];\n  this.rules[93].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[93].opcodes[1] = {type: 6, string: [13,10]};// TBS\n  this.rules[93].opcodes[2] = {type: 6, string: [10]};// TBS\n  this.rules[93].opcodes[3] = {type: 6, string: [13]};// TBS\n\n  /* LineContinue */\n  this.rules[94].opcodes = [];\n  this.rules[94].opcodes[0] = {type: 2, children: [1,5]};// CAT\n  this.rules[94].opcodes[1] = {type: 1, children: [2,3,4]};// ALT\n  this.rules[94].opcodes[2] = {type: 6, string: [13,10]};// TBS\n  this.rules[94].opcodes[3] = {type: 6, string: [10]};// TBS\n  this.rules[94].opcodes[4] = {type: 6, string: [13]};// TBS\n  this.rules[94].opcodes[5] = {type: 1, children: [6,7]};// ALT\n  this.rules[94].opcodes[6] = {type: 6, string: [32]};// TBS\n  this.rules[94].opcodes[7] = {type: 6, string: [9]};// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \";\\n\";\n    str += \"; ABNF for JavaScript APG 2.0 SABNF\\n\";\n    str += \"; RFC 5234 with some restrictions and additions.\\n\";\n    str += \"; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\\n\";\n    str += \";  - accepts %s\\\"string\\\" as a case-sensitive string\\n\";\n    str += \";  - accepts %i\\\"string\\\" as a case-insensitive string\\n\";\n    str += \";  - accepts \\\"string\\\" as a case-insensitive string\\n\";\n    str += \";\\n\";\n    str += \"; Some restrictions:\\n\";\n    str += \";   1. Rules must begin at first character of each line.\\n\";\n    str += \";      Indentations on first rule and rules thereafter are not allowed.\\n\";\n    str += \";   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\\n\";\n    str += \";   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\\n\";\n    str += \";      However, a working parser cannot be generated from them.\\n\";\n    str += \";\\n\";\n    str += \"; Super set (SABNF) additions:\\n\";\n    str += \";   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\\n\";\n    str += \";      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\\n\";\n    str += \";      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\\n\";\n    str += \";      e.g. &%d13 or &rule or !(A / B)\\n\";\n    str += \";   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\\n\";\n    str += \";      'name' is alpha followed by alpha/num/hyphen just like a rule name.\\n\";\n    str += \";      u_name may be used as an element but no rule definition is given.\\n\";\n    str += \";      e.g. rule = A / u_myUdt\\n\";\n    str += \";           A = \\\"a\\\"\\n\";\n    str += \";      would be a valid grammar.\\n\";\n    str += \";   3. Case-sensitive, single-quoted strings are accepted.\\n\";\n    str += \";      e.g. 'abc' would be equivalent to %d97.98.99\\n\";\n    str += \";      (kept for backward compatibility, but superseded by %s\\\"abc\\\")  \\n\";\n    str += \"; New 12/26/2015\\n\";\n    str += \";   4. Look-behind operators are accepted as element prefixes.\\n\";\n    str += \";      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\\n\";\n    str += \";      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\\n\";\n    str += \";      e.g. &&%d13 or &&rule or !!(A / B)\\n\";\n    str += \";   5. Back reference operators, i.e. \\\\rulename, are accepted.\\n\";\n    str += \";      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\\n\";\n    str += \";      to match is a phrase previously matched by the rule 'rulename'.\\n\";\n    str += \";      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\\n\";\n    str += \";      In universal mode, \\\\rulename matches the last match to 'rulename' regardless of where it was found.\\n\";\n    str += \";      In parent-frame mode, \\\\rulename matches only the last match found on the parent's frame or parse tree level.\\n\";\n    str += \";      Back reference modifiers can be used to specify case and mode.\\n\";\n    str += \";      \\\\A defaults to case-insensitive and universal mode, e.g. \\\\A === \\\\%i%uA\\n\";\n    str += \";      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\\n\";\n    str += \";      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\\n\";\n    str += \";      Case and mode modifiers can appear in any order, e.g. \\\\%s%pA === \\\\%p%sA. \\n\";\n    str += \";   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";   8. String end anchor, AEN(%$) matches the end of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";\\n\";\n    str += \"File            = *(BlankLine / Rule / RuleError)\\n\";\n    str += \"BlankLine       = *(%d32/%d9) [comment] LineEnd\\n\";\n    str += \"Rule            = RuleLookup owsp Alternation ((owsp LineEnd)\\n\";\n    str += \"                / (LineEndError LineEnd))\\n\";\n    str += \"RuleLookup      = RuleNameTest owsp DefinedAsTest\\n\";\n    str += \"RuleNameTest    = RuleName/RuleNameError\\n\";\n    str += \"RuleName        = alphanum\\n\";\n    str += \"RuleNameError   = 1*(%d33-60/%d62-126)\\n\";\n    str += \"DefinedAsTest   = DefinedAs / DefinedAsError\\n\";\n    str += \"DefinedAsError  = 1*2%d33-126\\n\";\n    str += \"DefinedAs       = IncAlt / Defined\\n\";\n    str += \"Defined         = %d61\\n\";\n    str += \"IncAlt          = %d61.47\\n\";\n    str += \"RuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\\n\";\n    str += \"LineEndError    = 1*(%d32-126 / %d9  / LineContinue)\\n\";\n    str += \"Alternation     = Concatenation *(owsp AltOp Concatenation)\\n\";\n    str += \"Concatenation   = Repetition *(CatOp Repetition)\\n\";\n    str += \"Repetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\\n\";\n    str += \"Modifier        = (Predicate [RepOp])\\n\";\n    str += \"                / RepOp\\n\";\n    str += \"Predicate       = BkaOp\\n\";\n    str += \"                / BknOp\\n\";\n    str += \"                / AndOp\\n\";\n    str += \"                / NotOp\\n\";\n    str += \"BasicElement    = UdtOp\\n\";\n    str += \"                / RnmOp\\n\";\n    str += \"                / TrgOp\\n\";\n    str += \"                / TbsOp\\n\";\n    str += \"                / TlsOp\\n\";\n    str += \"                / ClsOp\\n\";\n    str += \"                / BkrOp\\n\";\n    str += \"                / AbgOp\\n\";\n    str += \"                / AenOp\\n\";\n    str += \"                / ProsVal\\n\";\n    str += \"BasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\\n\";\n    str += \"Group           = GroupOpen  Alternation (GroupClose / GroupError)\\n\";\n    str += \"GroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"GroupOpen       = %d40 owsp\\n\";\n    str += \"GroupClose      = owsp %d41\\n\";\n    str += \"Option          = OptionOpen Alternation (OptionClose / OptionError)\\n\";\n    str += \"OptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"OptionOpen      = %d91 owsp\\n\";\n    str += \"OptionClose     = owsp %d93\\n\";\n    str += \"RnmOp           = alphanum\\n\";\n    str += \"BkrOp           = %d92 [bkrModifier] bkr-name\\n\";\n    str += \"bkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\\n\";\n    str += \"cs              = '%s'\\n\";\n    str += \"ci              = '%i'\\n\";\n    str += \"um              = '%u'\\n\";\n    str += \"pm              = '%p'\\n\";\n    str += \"bkr-name        = uname / ename / rname\\n\";\n    str += \"rname           = alphanum\\n\";\n    str += \"uname           = %d117.95 alphanum\\n\";\n    str += \"ename           = %d101.95 alphanum\\n\";\n    str += \"UdtOp           = udt-empty\\n\";\n    str += \"                / udt-non-empty\\n\";\n    str += \"udt-non-empty   = %d117.95 alphanum\\n\";\n    str += \"udt-empty       = %d101.95 alphanum\\n\";\n    str += \"RepOp           = (rep-min StarOp rep-max)\\n\";\n    str += \"                / (rep-min StarOp)\\n\";\n    str += \"                / (StarOp rep-max)\\n\";\n    str += \"                / StarOp\\n\";\n    str += \"                / rep-min-max\\n\";\n    str += \"AltOp           = %d47 owsp\\n\";\n    str += \"CatOp           = wsp\\n\";\n    str += \"StarOp          = %d42\\n\";\n    str += \"AndOp           = %d38\\n\";\n    str += \"NotOp           = %d33\\n\";\n    str += \"BkaOp           = %d38.38\\n\";\n    str += \"BknOp           = %d33.33\\n\";\n    str += \"AbgOp           = %d37.94\\n\";\n    str += \"AenOp           = %d37.36\\n\";\n    str += \"TrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\\n\";\n    str += \"TbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\\n\";\n    str += \"TlsOp           = TlsCase TlsOpen TlsString TlsClose\\n\";\n    str += \"TlsCase         = [\\\"%i\\\" / \\\"%s\\\"]\\n\";\n    str += \"TlsOpen         = %d34\\n\";\n    str += \"TlsClose        = %d34\\n\";\n    str += \"TlsString       = *(%d32-33/%d35-126/StringTab)\\n\";\n    str += \"StringTab       = %d9\\n\";\n    str += \"ClsOp           = ClsOpen ClsString ClsClose\\n\";\n    str += \"ClsOpen         = %d39\\n\";\n    str += \"ClsClose        = %d39\\n\";\n    str += \"ClsString       = *(%d32-38/%d40-126/StringTab)\\n\";\n    str += \"ProsVal         = ProsValOpen ProsValString ProsValClose\\n\";\n    str += \"ProsValOpen     = %d60\\n\";\n    str += \"ProsValString   = *(%d32-61/%d63-126/StringTab)\\n\";\n    str += \"ProsValClose    = %d62\\n\";\n    str += \"rep-min         = rep-num\\n\";\n    str += \"rep-min-max     = rep-num\\n\";\n    str += \"rep-max         = rep-num\\n\";\n    str += \"rep-num         = 1*(%d48-57)\\n\";\n    str += \"dString         = dnum\\n\";\n    str += \"xString         = xnum\\n\";\n    str += \"bString         = bnum\\n\";\n    str += \"Dec             = (%d68/%d100)\\n\";\n    str += \"Hex             = (%d88/%d120)\\n\";\n    str += \"Bin             = (%d66/%d98)\\n\";\n    str += \"dmin            = dnum\\n\";\n    str += \"dmax            = dnum\\n\";\n    str += \"bmin            = bnum\\n\";\n    str += \"bmax            = bnum\\n\";\n    str += \"xmin            = xnum\\n\";\n    str += \"xmax            = xnum\\n\";\n    str += \"dnum            = 1*(%d48-57)\\n\";\n    str += \"bnum            = 1*%d48-49\\n\";\n    str += \"xnum            = 1*(%d48-57 / %d65-70 / %d97-102)\\n\";\n    str += \";\\n\";\n    str += \"; Basics\\n\";\n    str += \"alphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\\n\";\n    str += \"owsp            = *space\\n\";\n    str += \"wsp             = 1*space\\n\";\n    str += \"space           = %d32\\n\";\n    str += \"                / %d9\\n\";\n    str += \"                / comment\\n\";\n    str += \"                / LineContinue\\n\";\n    str += \"comment         = %d59 *(%d32-126 / %d9)\\n\";\n    str += \"LineEnd         = %d13.10\\n\";\n    str += \"                / %d10\\n\";\n    str += \"                / %d13\\n\";\n    str += \"LineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\\n\";\n    return str;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NhYm5mLWdyYW1tYXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2FibmYtZ3JhbW1hci5qcz9lZDJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIzIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWQ8YnI+XG4vLyAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpPGJyPlxuLy9cbi8vIEdlbmVyYXRlZCBieSBhcGctanMsIFZlcnNpb24gNC4yLjEgW2FwZy1qc10oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qcylcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ3JhbW1hcigpe1xuICAvLyBgYGBcbiAgLy8gU1VNTUFSWVxuICAvLyAgICAgIHJ1bGVzID0gOTVcbiAgLy8gICAgICAgdWR0cyA9IDBcbiAgLy8gICAgb3Bjb2RlcyA9IDM3MlxuICAvLyAgICAgICAgLS0tICAgQUJORiBvcmlnaW5hbCBvcGNvZGVzXG4gIC8vICAgICAgICBBTFQgPSA0M1xuICAvLyAgICAgICAgQ0FUID0gNDhcbiAgLy8gICAgICAgIFJFUCA9IDM0XG4gIC8vICAgICAgICBSTk0gPSAxNDlcbiAgLy8gICAgICAgIFRMUyA9IDJcbiAgLy8gICAgICAgIFRCUyA9IDYxXG4gIC8vICAgICAgICBUUkcgPSAzNVxuICAvLyAgICAgICAgLS0tICAgU0FCTkYgc3VwZXJzZXQgb3Bjb2Rlc1xuICAvLyAgICAgICAgVURUID0gMFxuICAvLyAgICAgICAgQU5EID0gMFxuICAvLyAgICAgICAgTk9UID0gMFxuICAvLyAgICAgICAgQktBID0gMFxuICAvLyAgICAgICAgQktOID0gMFxuICAvLyAgICAgICAgQktSID0gMFxuICAvLyAgICAgICAgQUJHID0gMFxuICAvLyAgICAgICAgQUVOID0gMFxuICAvLyBjaGFyYWN0ZXJzID0gWzkgLSAxMjZdXG4gIC8vIGBgYFxuICAvKiBPQkpFQ1QgSURFTlRJRklFUiAoZm9yIGludGVybmFsIHBhcnNlciB1c2UpICovXG4gIHRoaXMuZ3JhbW1hck9iamVjdCA9ICdncmFtbWFyT2JqZWN0JztcblxuICAvKiBSVUxFUyAqL1xuICB0aGlzLnJ1bGVzID0gW107XG4gIHRoaXMucnVsZXNbMF0gPSB7bmFtZTogJ0ZpbGUnLCBsb3dlcjogJ2ZpbGUnLCBpbmRleDogMCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxXSA9IHtuYW1lOiAnQmxhbmtMaW5lJywgbG93ZXI6ICdibGFua2xpbmUnLCBpbmRleDogMSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1syXSA9IHtuYW1lOiAnUnVsZScsIGxvd2VyOiAncnVsZScsIGluZGV4OiAyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzNdID0ge25hbWU6ICdSdWxlTG9va3VwJywgbG93ZXI6ICdydWxlbG9va3VwJywgaW5kZXg6IDMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNF0gPSB7bmFtZTogJ1J1bGVOYW1lVGVzdCcsIGxvd2VyOiAncnVsZW5hbWV0ZXN0JywgaW5kZXg6IDQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNV0gPSB7bmFtZTogJ1J1bGVOYW1lJywgbG93ZXI6ICdydWxlbmFtZScsIGluZGV4OiA1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzZdID0ge25hbWU6ICdSdWxlTmFtZUVycm9yJywgbG93ZXI6ICdydWxlbmFtZWVycm9yJywgaW5kZXg6IDYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbN10gPSB7bmFtZTogJ0RlZmluZWRBc1Rlc3QnLCBsb3dlcjogJ2RlZmluZWRhc3Rlc3QnLCBpbmRleDogNywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4XSA9IHtuYW1lOiAnRGVmaW5lZEFzRXJyb3InLCBsb3dlcjogJ2RlZmluZWRhc2Vycm9yJywgaW5kZXg6IDgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbOV0gPSB7bmFtZTogJ0RlZmluZWRBcycsIGxvd2VyOiAnZGVmaW5lZGFzJywgaW5kZXg6IDksIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTBdID0ge25hbWU6ICdEZWZpbmVkJywgbG93ZXI6ICdkZWZpbmVkJywgaW5kZXg6IDEwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzExXSA9IHtuYW1lOiAnSW5jQWx0JywgbG93ZXI6ICdpbmNhbHQnLCBpbmRleDogMTEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTJdID0ge25hbWU6ICdSdWxlRXJyb3InLCBsb3dlcjogJ3J1bGVlcnJvcicsIGluZGV4OiAxMiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxM10gPSB7bmFtZTogJ0xpbmVFbmRFcnJvcicsIGxvd2VyOiAnbGluZWVuZGVycm9yJywgaW5kZXg6IDEzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzE0XSA9IHtuYW1lOiAnQWx0ZXJuYXRpb24nLCBsb3dlcjogJ2FsdGVybmF0aW9uJywgaW5kZXg6IDE0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzE1XSA9IHtuYW1lOiAnQ29uY2F0ZW5hdGlvbicsIGxvd2VyOiAnY29uY2F0ZW5hdGlvbicsIGluZGV4OiAxNSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxNl0gPSB7bmFtZTogJ1JlcGV0aXRpb24nLCBsb3dlcjogJ3JlcGV0aXRpb24nLCBpbmRleDogMTYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTddID0ge25hbWU6ICdNb2RpZmllcicsIGxvd2VyOiAnbW9kaWZpZXInLCBpbmRleDogMTcsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMThdID0ge25hbWU6ICdQcmVkaWNhdGUnLCBsb3dlcjogJ3ByZWRpY2F0ZScsIGluZGV4OiAxOCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxOV0gPSB7bmFtZTogJ0Jhc2ljRWxlbWVudCcsIGxvd2VyOiAnYmFzaWNlbGVtZW50JywgaW5kZXg6IDE5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzIwXSA9IHtuYW1lOiAnQmFzaWNFbGVtZW50RXJyJywgbG93ZXI6ICdiYXNpY2VsZW1lbnRlcnInLCBpbmRleDogMjAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjFdID0ge25hbWU6ICdHcm91cCcsIGxvd2VyOiAnZ3JvdXAnLCBpbmRleDogMjEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjJdID0ge25hbWU6ICdHcm91cEVycm9yJywgbG93ZXI6ICdncm91cGVycm9yJywgaW5kZXg6IDIyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzIzXSA9IHtuYW1lOiAnR3JvdXBPcGVuJywgbG93ZXI6ICdncm91cG9wZW4nLCBpbmRleDogMjMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjRdID0ge25hbWU6ICdHcm91cENsb3NlJywgbG93ZXI6ICdncm91cGNsb3NlJywgaW5kZXg6IDI0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzI1XSA9IHtuYW1lOiAnT3B0aW9uJywgbG93ZXI6ICdvcHRpb24nLCBpbmRleDogMjUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjZdID0ge25hbWU6ICdPcHRpb25FcnJvcicsIGxvd2VyOiAnb3B0aW9uZXJyb3InLCBpbmRleDogMjYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjddID0ge25hbWU6ICdPcHRpb25PcGVuJywgbG93ZXI6ICdvcHRpb25vcGVuJywgaW5kZXg6IDI3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzI4XSA9IHtuYW1lOiAnT3B0aW9uQ2xvc2UnLCBsb3dlcjogJ29wdGlvbmNsb3NlJywgaW5kZXg6IDI4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzI5XSA9IHtuYW1lOiAnUm5tT3AnLCBsb3dlcjogJ3JubW9wJywgaW5kZXg6IDI5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMwXSA9IHtuYW1lOiAnQmtyT3AnLCBsb3dlcjogJ2Jrcm9wJywgaW5kZXg6IDMwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMxXSA9IHtuYW1lOiAnYmtyTW9kaWZpZXInLCBsb3dlcjogJ2Jrcm1vZGlmaWVyJywgaW5kZXg6IDMxLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMyXSA9IHtuYW1lOiAnY3MnLCBsb3dlcjogJ2NzJywgaW5kZXg6IDMyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMzXSA9IHtuYW1lOiAnY2knLCBsb3dlcjogJ2NpJywgaW5kZXg6IDMzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM0XSA9IHtuYW1lOiAndW0nLCBsb3dlcjogJ3VtJywgaW5kZXg6IDM0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM1XSA9IHtuYW1lOiAncG0nLCBsb3dlcjogJ3BtJywgaW5kZXg6IDM1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM2XSA9IHtuYW1lOiAnYmtyLW5hbWUnLCBsb3dlcjogJ2Jrci1uYW1lJywgaW5kZXg6IDM2LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM3XSA9IHtuYW1lOiAncm5hbWUnLCBsb3dlcjogJ3JuYW1lJywgaW5kZXg6IDM3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM4XSA9IHtuYW1lOiAndW5hbWUnLCBsb3dlcjogJ3VuYW1lJywgaW5kZXg6IDM4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM5XSA9IHtuYW1lOiAnZW5hbWUnLCBsb3dlcjogJ2VuYW1lJywgaW5kZXg6IDM5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQwXSA9IHtuYW1lOiAnVWR0T3AnLCBsb3dlcjogJ3VkdG9wJywgaW5kZXg6IDQwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQxXSA9IHtuYW1lOiAndWR0LW5vbi1lbXB0eScsIGxvd2VyOiAndWR0LW5vbi1lbXB0eScsIGluZGV4OiA0MSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s0Ml0gPSB7bmFtZTogJ3VkdC1lbXB0eScsIGxvd2VyOiAndWR0LWVtcHR5JywgaW5kZXg6IDQyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQzXSA9IHtuYW1lOiAnUmVwT3AnLCBsb3dlcjogJ3JlcG9wJywgaW5kZXg6IDQzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQ0XSA9IHtuYW1lOiAnQWx0T3AnLCBsb3dlcjogJ2FsdG9wJywgaW5kZXg6IDQ0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQ1XSA9IHtuYW1lOiAnQ2F0T3AnLCBsb3dlcjogJ2NhdG9wJywgaW5kZXg6IDQ1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQ2XSA9IHtuYW1lOiAnU3Rhck9wJywgbG93ZXI6ICdzdGFyb3AnLCBpbmRleDogNDYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDddID0ge25hbWU6ICdBbmRPcCcsIGxvd2VyOiAnYW5kb3AnLCBpbmRleDogNDcsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDhdID0ge25hbWU6ICdOb3RPcCcsIGxvd2VyOiAnbm90b3AnLCBpbmRleDogNDgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDldID0ge25hbWU6ICdCa2FPcCcsIGxvd2VyOiAnYmthb3AnLCBpbmRleDogNDksIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTBdID0ge25hbWU6ICdCa25PcCcsIGxvd2VyOiAnYmtub3AnLCBpbmRleDogNTAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTFdID0ge25hbWU6ICdBYmdPcCcsIGxvd2VyOiAnYWJnb3AnLCBpbmRleDogNTEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTJdID0ge25hbWU6ICdBZW5PcCcsIGxvd2VyOiAnYWVub3AnLCBpbmRleDogNTIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTNdID0ge25hbWU6ICdUcmdPcCcsIGxvd2VyOiAndHJnb3AnLCBpbmRleDogNTMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTRdID0ge25hbWU6ICdUYnNPcCcsIGxvd2VyOiAndGJzb3AnLCBpbmRleDogNTQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTVdID0ge25hbWU6ICdUbHNPcCcsIGxvd2VyOiAndGxzb3AnLCBpbmRleDogNTUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTZdID0ge25hbWU6ICdUbHNDYXNlJywgbG93ZXI6ICd0bHNjYXNlJywgaW5kZXg6IDU2LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzU3XSA9IHtuYW1lOiAnVGxzT3BlbicsIGxvd2VyOiAndGxzb3BlbicsIGluZGV4OiA1NywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1OF0gPSB7bmFtZTogJ1Rsc0Nsb3NlJywgbG93ZXI6ICd0bHNjbG9zZScsIGluZGV4OiA1OCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1OV0gPSB7bmFtZTogJ1Rsc1N0cmluZycsIGxvd2VyOiAndGxzc3RyaW5nJywgaW5kZXg6IDU5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzYwXSA9IHtuYW1lOiAnU3RyaW5nVGFiJywgbG93ZXI6ICdzdHJpbmd0YWInLCBpbmRleDogNjAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjFdID0ge25hbWU6ICdDbHNPcCcsIGxvd2VyOiAnY2xzb3AnLCBpbmRleDogNjEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjJdID0ge25hbWU6ICdDbHNPcGVuJywgbG93ZXI6ICdjbHNvcGVuJywgaW5kZXg6IDYyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzYzXSA9IHtuYW1lOiAnQ2xzQ2xvc2UnLCBsb3dlcjogJ2Nsc2Nsb3NlJywgaW5kZXg6IDYzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY0XSA9IHtuYW1lOiAnQ2xzU3RyaW5nJywgbG93ZXI6ICdjbHNzdHJpbmcnLCBpbmRleDogNjQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjVdID0ge25hbWU6ICdQcm9zVmFsJywgbG93ZXI6ICdwcm9zdmFsJywgaW5kZXg6IDY1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY2XSA9IHtuYW1lOiAnUHJvc1ZhbE9wZW4nLCBsb3dlcjogJ3Byb3N2YWxvcGVuJywgaW5kZXg6IDY2LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY3XSA9IHtuYW1lOiAnUHJvc1ZhbFN0cmluZycsIGxvd2VyOiAncHJvc3ZhbHN0cmluZycsIGluZGV4OiA2NywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s2OF0gPSB7bmFtZTogJ1Byb3NWYWxDbG9zZScsIGxvd2VyOiAncHJvc3ZhbGNsb3NlJywgaW5kZXg6IDY4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY5XSA9IHtuYW1lOiAncmVwLW1pbicsIGxvd2VyOiAncmVwLW1pbicsIGluZGV4OiA2OSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3MF0gPSB7bmFtZTogJ3JlcC1taW4tbWF4JywgbG93ZXI6ICdyZXAtbWluLW1heCcsIGluZGV4OiA3MCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3MV0gPSB7bmFtZTogJ3JlcC1tYXgnLCBsb3dlcjogJ3JlcC1tYXgnLCBpbmRleDogNzEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzJdID0ge25hbWU6ICdyZXAtbnVtJywgbG93ZXI6ICdyZXAtbnVtJywgaW5kZXg6IDcyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzczXSA9IHtuYW1lOiAnZFN0cmluZycsIGxvd2VyOiAnZHN0cmluZycsIGluZGV4OiA3MywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3NF0gPSB7bmFtZTogJ3hTdHJpbmcnLCBsb3dlcjogJ3hzdHJpbmcnLCBpbmRleDogNzQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzVdID0ge25hbWU6ICdiU3RyaW5nJywgbG93ZXI6ICdic3RyaW5nJywgaW5kZXg6IDc1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzc2XSA9IHtuYW1lOiAnRGVjJywgbG93ZXI6ICdkZWMnLCBpbmRleDogNzYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzddID0ge25hbWU6ICdIZXgnLCBsb3dlcjogJ2hleCcsIGluZGV4OiA3NywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3OF0gPSB7bmFtZTogJ0JpbicsIGxvd2VyOiAnYmluJywgaW5kZXg6IDc4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzc5XSA9IHtuYW1lOiAnZG1pbicsIGxvd2VyOiAnZG1pbicsIGluZGV4OiA3OSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4MF0gPSB7bmFtZTogJ2RtYXgnLCBsb3dlcjogJ2RtYXgnLCBpbmRleDogODAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODFdID0ge25hbWU6ICdibWluJywgbG93ZXI6ICdibWluJywgaW5kZXg6IDgxLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzgyXSA9IHtuYW1lOiAnYm1heCcsIGxvd2VyOiAnYm1heCcsIGluZGV4OiA4MiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4M10gPSB7bmFtZTogJ3htaW4nLCBsb3dlcjogJ3htaW4nLCBpbmRleDogODMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODRdID0ge25hbWU6ICd4bWF4JywgbG93ZXI6ICd4bWF4JywgaW5kZXg6IDg0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzg1XSA9IHtuYW1lOiAnZG51bScsIGxvd2VyOiAnZG51bScsIGluZGV4OiA4NSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4Nl0gPSB7bmFtZTogJ2JudW0nLCBsb3dlcjogJ2JudW0nLCBpbmRleDogODYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODddID0ge25hbWU6ICd4bnVtJywgbG93ZXI6ICd4bnVtJywgaW5kZXg6IDg3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzg4XSA9IHtuYW1lOiAnYWxwaGFudW0nLCBsb3dlcjogJ2FscGhhbnVtJywgaW5kZXg6IDg4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzg5XSA9IHtuYW1lOiAnb3dzcCcsIGxvd2VyOiAnb3dzcCcsIGluZGV4OiA4OSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s5MF0gPSB7bmFtZTogJ3dzcCcsIGxvd2VyOiAnd3NwJywgaW5kZXg6IDkwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzkxXSA9IHtuYW1lOiAnc3BhY2UnLCBsb3dlcjogJ3NwYWNlJywgaW5kZXg6IDkxLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzkyXSA9IHtuYW1lOiAnY29tbWVudCcsIGxvd2VyOiAnY29tbWVudCcsIGluZGV4OiA5MiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s5M10gPSB7bmFtZTogJ0xpbmVFbmQnLCBsb3dlcjogJ2xpbmVlbmQnLCBpbmRleDogOTMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbOTRdID0ge25hbWU6ICdMaW5lQ29udGludWUnLCBsb3dlcjogJ2xpbmVjb250aW51ZScsIGluZGV4OiA5NCwgaXNCa3I6IGZhbHNlfTtcblxuICAvKiBVRFRTICovXG4gIHRoaXMudWR0cyA9IFtdO1xuXG4gIC8qIE9QQ09ERVMgKi9cbiAgLyogRmlsZSAqL1xuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMX07Ly8gUk5NKEJsYW5rTGluZSlcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiAyfTsvLyBSTk0oUnVsZSlcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiAxMn07Ly8gUk5NKFJ1bGVFcnJvcilcblxuICAvKiBCbGFua0xpbmUgKi9cbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsNSw3XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbMl0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFszLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzNdID0ge3R5cGU6IDYsIHN0cmluZzogWzMyXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA0LCBpbmRleDogOTJ9Oy8vIFJOTShjb21tZW50KVxuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbN10gPSB7dHlwZTogNCwgaW5kZXg6IDkzfTsvLyBSTk0oTGluZUVuZClcblxuICAvKiBSdWxlICovXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogM307Ly8gUk5NKFJ1bGVMb29rdXApXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDE0fTsvLyBSTk0oQWx0ZXJuYXRpb24pXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzUsOF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbNV0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs2LDddfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzZdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogOTN9Oy8vIFJOTShMaW5lRW5kKVxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbOF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs5LDEwXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s5XSA9IHt0eXBlOiA0LCBpbmRleDogMTN9Oy8vIFJOTShMaW5lRW5kRXJyb3IpXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1sxMF0gPSB7dHlwZTogNCwgaW5kZXg6IDkzfTsvLyBSTk0oTGluZUVuZClcblxuICAvKiBSdWxlTG9va3VwICovXG4gIHRoaXMucnVsZXNbM10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDR9Oy8vIFJOTShSdWxlTmFtZVRlc3QpXG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDd9Oy8vIFJOTShEZWZpbmVkQXNUZXN0KVxuXG4gIC8qIFJ1bGVOYW1lVGVzdCAqL1xuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNX07Ly8gUk5NKFJ1bGVOYW1lKVxuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDZ9Oy8vIFJOTShSdWxlTmFtZUVycm9yKVxuXG4gIC8qIFJ1bGVOYW1lICovXG4gIHRoaXMucnVsZXNbNV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg4fTsvLyBSTk0oYWxwaGFudW0pXG5cbiAgLyogUnVsZU5hbWVFcnJvciAqL1xuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXNbMl0gPSB7dHlwZTogNSwgbWluOiAzMywgbWF4OiA2MH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDYyLCBtYXg6IDEyNn07Ly8gVFJHXG5cbiAgLyogRGVmaW5lZEFzVGVzdCAqL1xuICB0aGlzLnJ1bGVzWzddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbN10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogOX07Ly8gUk5NKERlZmluZWRBcylcbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4fTsvLyBSTk0oRGVmaW5lZEFzRXJyb3IpXG5cbiAgLyogRGVmaW5lZEFzRXJyb3IgKi9cbiAgdGhpcy5ydWxlc1s4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogMn07Ly8gUkVQXG4gIHRoaXMucnVsZXNbOF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDMzLCBtYXg6IDEyNn07Ly8gVFJHXG5cbiAgLyogRGVmaW5lZEFzICovXG4gIHRoaXMucnVsZXNbOV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzldLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s5XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAxMX07Ly8gUk5NKEluY0FsdClcbiAgdGhpcy5ydWxlc1s5XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiAxMH07Ly8gUk5NKERlZmluZWQpXG5cbiAgLyogRGVmaW5lZCAqL1xuICB0aGlzLnJ1bGVzWzEwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTBdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjFdfTsvLyBUQlNcblxuICAvKiBJbmNBbHQgKi9cbiAgdGhpcy5ydWxlc1sxMV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzExXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzYxLDQ3XX07Ly8gVEJTXG5cbiAgLyogUnVsZUVycm9yICovXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsNl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzFdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXNbMl0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFszLDQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogMzIsIG1heDogMTI2fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDk0fTsvLyBSTk0oTGluZUNvbnRpbnVlKVxuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzZdID0ge3R5cGU6IDQsIGluZGV4OiA5M307Ly8gUk5NKExpbmVFbmQpXG5cbiAgLyogTGluZUVuZEVycm9yICovXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxM10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzEzXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxM10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXNbM10gPSB7dHlwZTogNiwgc3RyaW5nOiBbOV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzEzXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA5NH07Ly8gUk5NKExpbmVDb250aW51ZSlcblxuICAvKiBBbHRlcm5hdGlvbiAqL1xuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxNF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogMTV9Oy8vIFJOTShDb25jYXRlbmF0aW9uKVxuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzWzJdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbM10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs0LDUsNl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDQ0fTsvLyBSTk0oQWx0T3ApXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDE1fTsvLyBSTk0oQ29uY2F0ZW5hdGlvbilcblxuICAvKiBDb25jYXRlbmF0aW9uICovXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxNV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAxNn07Ly8gUk5NKFJlcGV0aXRpb24pXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXNbMl0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1sxNV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzQsNV19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA0NX07Ly8gUk5NKENhdE9wKVxuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiAxNn07Ly8gUk5NKFJlcGV0aXRpb24pXG5cbiAgLyogUmVwZXRpdGlvbiAqL1xuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDE3fTsvLyBSTk0oTW9kaWZpZXIpXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbM10gPSB7dHlwZTogMSwgY2hpbGRyZW46IFs0LDUsNiw3XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDIxfTsvLyBSTk0oR3JvdXApXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDI1fTsvLyBSTk0oT3B0aW9uKVxuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzWzZdID0ge3R5cGU6IDQsIGluZGV4OiAxOX07Ly8gUk5NKEJhc2ljRWxlbWVudClcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogMjB9Oy8vIFJOTShCYXNpY0VsZW1lbnRFcnIpXG5cbiAgLyogTW9kaWZpZXIgKi9cbiAgdGhpcy5ydWxlc1sxN10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSw1XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXNbMV0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsyLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxN10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMTh9Oy8vIFJOTShQcmVkaWNhdGUpXG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXNbM10gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IDF9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA0M307Ly8gUk5NKFJlcE9wKVxuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiA0M307Ly8gUk5NKFJlcE9wKVxuXG4gIC8qIFByZWRpY2F0ZSAqL1xuICB0aGlzLnJ1bGVzWzE4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDQ5fTsvLyBSTk0oQmthT3ApXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDUwfTsvLyBSTk0oQmtuT3ApXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDQ3fTsvLyBSTk0oQW5kT3ApXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDQ4fTsvLyBSTk0oTm90T3ApXG5cbiAgLyogQmFzaWNFbGVtZW50ICovXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsMiwzLDQsNSw2LDcsOCw5LDEwXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDQwfTsvLyBSTk0oVWR0T3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDI5fTsvLyBSTk0oUm5tT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDUzfTsvLyBSTk0oVHJnT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDU0fTsvLyBSTk0oVGJzT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDU1fTsvLyBSTk0oVGxzT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDYxfTsvLyBSTk0oQ2xzT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbN10gPSB7dHlwZTogNCwgaW5kZXg6IDMwfTsvLyBSTk0oQmtyT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbOF0gPSB7dHlwZTogNCwgaW5kZXg6IDUxfTsvLyBSTk0oQWJnT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbOV0gPSB7dHlwZTogNCwgaW5kZXg6IDUyfTsvLyBSTk0oQWVuT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbMTBdID0ge3R5cGU6IDQsIGluZGV4OiA2NX07Ly8gUk5NKFByb3NWYWwpXG5cbiAgLyogQmFzaWNFbGVtZW50RXJyICovXG4gIHRoaXMucnVsZXNbMjBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syMF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogMzMsIG1heDogNDB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogNDIsIG1heDogNDZ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogNDgsIG1heDogOTJ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzVdID0ge3R5cGU6IDUsIG1pbjogOTQsIG1heDogMTI2fTsvLyBUUkdcblxuICAvKiBHcm91cCAqL1xuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAyM307Ly8gUk5NKEdyb3VwT3BlbilcbiAgdGhpcy5ydWxlc1syMV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMTR9Oy8vIFJOTShBbHRlcm5hdGlvbilcbiAgdGhpcy5ydWxlc1syMV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiAyNH07Ly8gUk5NKEdyb3VwQ2xvc2UpXG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDIyfTsvLyBSTk0oR3JvdXBFcnJvcilcblxuICAvKiBHcm91cEVycm9yICovXG4gIHRoaXMucnVsZXNbMjJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syMl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogMzMsIG1heDogNDB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogNDIsIG1heDogNDZ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogNDgsIG1heDogOTJ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzVdID0ge3R5cGU6IDUsIG1pbjogOTQsIG1heDogMTI2fTsvLyBUUkdcblxuICAvKiBHcm91cE9wZW4gKi9cbiAgdGhpcy5ydWxlc1syM10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzIzXS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjNdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDBdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1syM10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuXG4gIC8qIEdyb3VwQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1syNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzI0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjRdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcbiAgdGhpcy5ydWxlc1syNF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs0MV19Oy8vIFRCU1xuXG4gIC8qIE9wdGlvbiAqL1xuICB0aGlzLnJ1bGVzWzI1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzI1XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAyN307Ly8gUk5NKE9wdGlvbk9wZW4pXG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDE0fTsvLyBSTk0oQWx0ZXJuYXRpb24pXG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbM10gPSB7dHlwZTogMSwgY2hpbGRyZW46IFs0LDVdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1syNV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogMjh9Oy8vIFJOTShPcHRpb25DbG9zZSlcbiAgdGhpcy5ydWxlc1syNV0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA0LCBpbmRleDogMjZ9Oy8vIFJOTShPcHRpb25FcnJvcilcblxuICAvKiBPcHRpb25FcnJvciAqL1xuICB0aGlzLnJ1bGVzWzI2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjZdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0LDVdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMzLCBtYXg6IDQwfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDQyLCBtYXg6IDQ2fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDkyfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA1LCBtaW46IDk0LCBtYXg6IDEyNn07Ly8gVFJHXG5cbiAgLyogT3B0aW9uT3BlbiAqL1xuICB0aGlzLnJ1bGVzWzI3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjddLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syN10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5MV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzI3XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG5cbiAgLyogT3B0aW9uQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1syOF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzI4XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjhdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcbiAgdGhpcy5ydWxlc1syOF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5M119Oy8vIFRCU1xuXG4gIC8qIFJubU9wICovXG4gIHRoaXMucnVsZXNbMjldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syOV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBCa3JPcCAqL1xuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsNF19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzkyXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXNbMl0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IDF9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiAzMX07Ly8gUk5NKGJrck1vZGlmaWVyKVxuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiAzNn07Ly8gUk5NKGJrci1uYW1lKVxuXG4gIC8qIGJrck1vZGlmaWVyICovXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsNywxMywxOV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMiwzXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDMyfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbM10gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IDF9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzRdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbNSw2XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDM0fTsvLyBSTk0odW0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDM1fTsvLyBSTk0ocG0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbN10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs4LDldfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1s4XSA9IHt0eXBlOiA0LCBpbmRleDogMzN9Oy8vIFJOTShjaSlcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1s5XSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMTEsMTJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxMV0gPSB7dHlwZTogNCwgaW5kZXg6IDM0fTsvLyBSTk0odW0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTJdID0ge3R5cGU6IDQsIGluZGV4OiAzNX07Ly8gUk5NKHBtKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzEzXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzE0LDE1XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTRdID0ge3R5cGU6IDQsIGluZGV4OiAzNH07Ly8gUk5NKHVtKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzE1XSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTZdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMTcsMThdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxN10gPSB7dHlwZTogNCwgaW5kZXg6IDMyfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMThdID0ge3R5cGU6IDQsIGluZGV4OiAzM307Ly8gUk5NKGNpKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzE5XSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzIwLDIxXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjBdID0ge3R5cGU6IDQsIGluZGV4OiAzNX07Ly8gUk5NKHBtKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzIxXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjJdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMjMsMjRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1syM10gPSB7dHlwZTogNCwgaW5kZXg6IDMyfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjRdID0ge3R5cGU6IDQsIGluZGV4OiAzM307Ly8gUk5NKGNpKVxuXG4gIC8qIGNzICovXG4gIHRoaXMucnVsZXNbMzJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szMl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNywxMTVdfTsvLyBUQlNcblxuICAvKiBjaSAqL1xuICB0aGlzLnJ1bGVzWzMzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzNdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzcsMTA1XX07Ly8gVEJTXG5cbiAgLyogdW0gKi9cbiAgdGhpcy5ydWxlc1szNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzM0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM3LDExN119Oy8vIFRCU1xuXG4gIC8qIHBtICovXG4gIHRoaXMucnVsZXNbMzVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szNV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNywxMTJdfTsvLyBUQlNcblxuICAvKiBia3ItbmFtZSAqL1xuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzZdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAzOH07Ly8gUk5NKHVuYW1lKVxuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiAzOX07Ly8gUk5NKGVuYW1lKVxuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiAzN307Ly8gUk5NKHJuYW1lKVxuXG4gIC8qIHJuYW1lICovXG4gIHRoaXMucnVsZXNbMzddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szN10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiB1bmFtZSAqL1xuICB0aGlzLnJ1bGVzWzM4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzhdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szOF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMTcsOTVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1szOF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBlbmFtZSAqL1xuICB0aGlzLnJ1bGVzWzM5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzldLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szOV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMDEsOTVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1szOV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBVZHRPcCAqL1xuICB0aGlzLnJ1bGVzWzQwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDBdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s0MF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNDJ9Oy8vIFJOTSh1ZHQtZW1wdHkpXG4gIHRoaXMucnVsZXNbNDBdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDQxfTsvLyBSTk0odWR0LW5vbi1lbXB0eSlcblxuICAvKiB1ZHQtbm9uLWVtcHR5ICovXG4gIHRoaXMucnVsZXNbNDFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0MV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzQxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzExNyw5NV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzQxXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIHVkdC1lbXB0eSAqL1xuICB0aGlzLnJ1bGVzWzQyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDJdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0Ml0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMDEsOTVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s0Ml0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBSZXBPcCAqL1xuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDUsOCwxMSwxMl19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzFdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNjl9Oy8vIFJOTShyZXAtbWluKVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA0Nn07Ly8gUk5NKFN0YXJPcClcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNzF9Oy8vIFJOTShyZXAtbWF4KVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzVdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbNiw3XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDY5fTsvLyBSTk0ocmVwLW1pbilcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogNDZ9Oy8vIFJOTShTdGFyT3ApXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbOF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs5LDEwXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbOV0gPSB7dHlwZTogNCwgaW5kZXg6IDQ2fTsvLyBSTk0oU3Rhck9wKVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzEwXSA9IHt0eXBlOiA0LCBpbmRleDogNzF9Oy8vIFJOTShyZXAtbWF4KVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzExXSA9IHt0eXBlOiA0LCBpbmRleDogNDZ9Oy8vIFJOTShTdGFyT3ApXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbMTJdID0ge3R5cGU6IDQsIGluZGV4OiA3MH07Ly8gUk5NKHJlcC1taW4tbWF4KVxuXG4gIC8qIEFsdE9wICovXG4gIHRoaXMucnVsZXNbNDRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0NF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzQ0XS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzQ3XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNDRdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcblxuICAvKiBDYXRPcCAqL1xuICB0aGlzLnJ1bGVzWzQ1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDVdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDkwfTsvLyBSTk0od3NwKVxuXG4gIC8qIFN0YXJPcCAqL1xuICB0aGlzLnJ1bGVzWzQ2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDZdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDJdfTsvLyBUQlNcblxuICAvKiBBbmRPcCAqL1xuICB0aGlzLnJ1bGVzWzQ3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDddLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzhdfTsvLyBUQlNcblxuICAvKiBOb3RPcCAqL1xuICB0aGlzLnJ1bGVzWzQ4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDhdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzNdfTsvLyBUQlNcblxuICAvKiBCa2FPcCAqL1xuICB0aGlzLnJ1bGVzWzQ5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDldLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzgsMzhdfTsvLyBUQlNcblxuICAvKiBCa25PcCAqL1xuICB0aGlzLnJ1bGVzWzUwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTBdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzMsMzNdfTsvLyBUQlNcblxuICAvKiBBYmdPcCAqL1xuICB0aGlzLnJ1bGVzWzUxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTFdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzcsOTRdfTsvLyBUQlNcblxuICAvKiBBZW5PcCAqL1xuICB0aGlzLnJ1bGVzWzUyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTJdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzcsMzZdfTsvLyBUQlNcblxuICAvKiBUcmdPcCAqL1xuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszN119Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzJdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMyw4LDEzXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbM10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs0LDUsNiw3XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDc2fTsvLyBSTk0oRGVjKVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiA3OX07Ly8gUk5NKGRtaW4pXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbNl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogODB9Oy8vIFJOTShkbWF4KVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzhdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbOSwxMCwxMSwxMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzldID0ge3R5cGU6IDQsIGluZGV4OiA3N307Ly8gUk5NKEhleClcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxMF0gPSB7dHlwZTogNCwgaW5kZXg6IDgzfTsvLyBSTk0oeG1pbilcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxMl0gPSB7dHlwZTogNCwgaW5kZXg6IDg0fTsvLyBSTk0oeG1heClcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxM10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxNCwxNSwxNiwxN119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzE0XSA9IHt0eXBlOiA0LCBpbmRleDogNzh9Oy8vIFJOTShCaW4pXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTVdID0ge3R5cGU6IDQsIGluZGV4OiA4MX07Ly8gUk5NKGJtaW4pXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTZdID0ge3R5cGU6IDYsIHN0cmluZzogWzQ1XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTddID0ge3R5cGU6IDQsIGluZGV4OiA4Mn07Ly8gUk5NKGJtYXgpXG5cbiAgLyogVGJzT3AgKi9cbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzddfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzMsMTAsMTddfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzQsNSw2XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDc2fTsvLyBSTk0oRGVjKVxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiA3M307Ly8gUk5NKGRTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbNl0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzgsOV19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzhdID0ge3R5cGU6IDYsIHN0cmluZzogWzQ2XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbOV0gPSB7dHlwZTogNCwgaW5kZXg6IDczfTsvLyBSTk0oZFN0cmluZylcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxMSwxMiwxM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzExXSA9IHt0eXBlOiA0LCBpbmRleDogNzd9Oy8vIFJOTShIZXgpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTJdID0ge3R5cGU6IDQsIGluZGV4OiA3NH07Ly8gUk5NKHhTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTNdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTRdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMTUsMTZdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxNV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDZdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxNl0gPSB7dHlwZTogNCwgaW5kZXg6IDc0fTsvLyBSTk0oeFN0cmluZylcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxN10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxOCwxOSwyMF19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzE4XSA9IHt0eXBlOiA0LCBpbmRleDogNzh9Oy8vIFJOTShCaW4pXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTldID0ge3R5cGU6IDQsIGluZGV4OiA3NX07Ly8gUk5NKGJTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMjBdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMjFdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMjIsMjNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syMl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDZdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syM10gPSB7dHlwZTogNCwgaW5kZXg6IDc1fTsvLyBSTk0oYlN0cmluZylcblxuICAvKiBUbHNPcCAqL1xuICB0aGlzLnJ1bGVzWzU1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTVdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTVdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDU2fTsvLyBSTk0oVGxzQ2FzZSlcbiAgdGhpcy5ydWxlc1s1NV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNTd9Oy8vIFJOTShUbHNPcGVuKVxuICB0aGlzLnJ1bGVzWzU1XS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA1OX07Ly8gUk5NKFRsc1N0cmluZylcbiAgdGhpcy5ydWxlc1s1NV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNTh9Oy8vIFJOTShUbHNDbG9zZSlcblxuICAvKiBUbHNDYXNlICovXG4gIHRoaXMucnVsZXNbNTZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNTZdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA3LCBzdHJpbmc6IFszNywxMDVdfTsvLyBUTFNcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA3LCBzdHJpbmc6IFszNywxMTVdfTsvLyBUTFNcblxuICAvKiBUbHNPcGVuICovXG4gIHRoaXMucnVsZXNbNTddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1N10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNF19Oy8vIFRCU1xuXG4gIC8qIFRsc0Nsb3NlICovXG4gIHRoaXMucnVsZXNbNThdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1OF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNF19Oy8vIFRCU1xuXG4gIC8qIFRsc1N0cmluZyAqL1xuICB0aGlzLnJ1bGVzWzU5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s1OV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbMl0gPSB7dHlwZTogNSwgbWluOiAzMiwgbWF4OiAzM307Ly8gVFJHXG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbM10gPSB7dHlwZTogNSwgbWluOiAzNSwgbWF4OiAxMjZ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzU5XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA2MH07Ly8gUk5NKFN0cmluZ1RhYilcblxuICAvKiBTdHJpbmdUYWIgKi9cbiAgdGhpcy5ydWxlc1s2MF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzYwXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzldfTsvLyBUQlNcblxuICAvKiBDbHNPcCAqL1xuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjFdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA2Mn07Ly8gUk5NKENsc09wZW4pXG4gIHRoaXMucnVsZXNbNjFdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDY0fTsvLyBSTk0oQ2xzU3RyaW5nKVxuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA2M307Ly8gUk5NKENsc0Nsb3NlKVxuXG4gIC8qIENsc09wZW4gKi9cbiAgdGhpcy5ydWxlc1s2Ml0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzYyXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM5XX07Ly8gVEJTXG5cbiAgLyogQ2xzQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1s2M10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzYzXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM5XX07Ly8gVEJTXG5cbiAgLyogQ2xzU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNjRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzY0XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDM4fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDQwLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNjRdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDYwfTsvLyBSTk0oU3RyaW5nVGFiKVxuXG4gIC8qIFByb3NWYWwgKi9cbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzY1XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNjZ9Oy8vIFJOTShQcm9zVmFsT3BlbilcbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNjd9Oy8vIFJOTShQcm9zVmFsU3RyaW5nKVxuICB0aGlzLnJ1bGVzWzY1XS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA2OH07Ly8gUk5NKFByb3NWYWxDbG9zZSlcblxuICAvKiBQcm9zVmFsT3BlbiAqL1xuICB0aGlzLnJ1bGVzWzY2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjZdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjBdfTsvLyBUQlNcblxuICAvKiBQcm9zVmFsU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNjddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzY3XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDYxfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDYzLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNjddLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDYwfTsvLyBSTk0oU3RyaW5nVGFiKVxuXG4gIC8qIFByb3NWYWxDbG9zZSAqL1xuICB0aGlzLnJ1bGVzWzY4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjhdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjJdfTsvLyBUQlNcblxuICAvKiByZXAtbWluICovXG4gIHRoaXMucnVsZXNbNjldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2OV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogNzJ9Oy8vIFJOTShyZXAtbnVtKVxuXG4gIC8qIHJlcC1taW4tbWF4ICovXG4gIHRoaXMucnVsZXNbNzBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3MF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogNzJ9Oy8vIFJOTShyZXAtbnVtKVxuXG4gIC8qIHJlcC1tYXggKi9cbiAgdGhpcy5ydWxlc1s3MV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzcxXS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA3Mn07Ly8gUk5NKHJlcC1udW0pXG5cbiAgLyogcmVwLW51bSAqL1xuICB0aGlzLnJ1bGVzWzcyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzJdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s3Ml0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDU3fTsvLyBUUkdcblxuICAvKiBkU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNzNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3M10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODV9Oy8vIFJOTShkbnVtKVxuXG4gIC8qIHhTdHJpbmcgKi9cbiAgdGhpcy5ydWxlc1s3NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4N307Ly8gUk5NKHhudW0pXG5cbiAgLyogYlN0cmluZyAqL1xuICB0aGlzLnJ1bGVzWzc1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzVdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg2fTsvLyBSTk0oYm51bSlcblxuICAvKiBEZWMgKi9cbiAgdGhpcy5ydWxlc1s3Nl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc2XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNzZdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjhdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s3Nl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMDBdfTsvLyBUQlNcblxuICAvKiBIZXggKi9cbiAgdGhpcy5ydWxlc1s3N10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNzddLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbODhdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s3N10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMjBdfTsvLyBUQlNcblxuICAvKiBCaW4gKi9cbiAgdGhpcy5ydWxlc1s3OF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc4XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNzhdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjZdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s3OF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5OF19Oy8vIFRCU1xuXG4gIC8qIGRtaW4gKi9cbiAgdGhpcy5ydWxlc1s3OV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc5XS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4NX07Ly8gUk5NKGRudW0pXG5cbiAgLyogZG1heCAqL1xuICB0aGlzLnJ1bGVzWzgwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODBdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg1fTsvLyBSTk0oZG51bSlcblxuICAvKiBibWluICovXG4gIHRoaXMucnVsZXNbODFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4MV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODZ9Oy8vIFJOTShibnVtKVxuXG4gIC8qIGJtYXggKi9cbiAgdGhpcy5ydWxlc1s4Ml0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzgyXS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4Nn07Ly8gUk5NKGJudW0pXG5cbiAgLyogeG1pbiAqL1xuICB0aGlzLnJ1bGVzWzgzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODNdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg3fTsvLyBSTk0oeG51bSlcblxuICAvKiB4bWF4ICovXG4gIHRoaXMucnVsZXNbODRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4NF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODd9Oy8vIFJOTSh4bnVtKVxuXG4gIC8qIGRudW0gKi9cbiAgdGhpcy5ydWxlc1s4NV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg1XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbODVdLm9wY29kZXNbMV0gPSB7dHlwZTogNSwgbWluOiA0OCwgbWF4OiA1N307Ly8gVFJHXG5cbiAgLyogYm51bSAqL1xuICB0aGlzLnJ1bGVzWzg2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODZdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4Nl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDQ5fTsvLyBUUkdcblxuICAvKiB4bnVtICovXG4gIHRoaXMucnVsZXNbODddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzg3XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDU3fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDY1LCBtYXg6IDcwfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA1LCBtaW46IDk3LCBtYXg6IDEwMn07Ly8gVFJHXG5cbiAgLyogYWxwaGFudW0gKi9cbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg4XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSw0XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDk3LCBtYXg6IDEyMn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbM10gPSB7dHlwZTogNSwgbWluOiA2NSwgbWF4OiA5MH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbNF0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzYsNyw4LDldfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA1LCBtaW46IDk3LCBtYXg6IDEyMn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbN10gPSB7dHlwZTogNSwgbWluOiA2NSwgbWF4OiA5MH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbOF0gPSB7dHlwZTogNSwgbWluOiA0OCwgbWF4OiA1N307Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbOV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDVdfTsvLyBUQlNcblxuICAvKiBvd3NwICovXG4gIHRoaXMucnVsZXNbODldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4OV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzg5XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA5MX07Ly8gUk5NKHNwYWNlKVxuXG4gIC8qIHdzcCAqL1xuICB0aGlzLnJ1bGVzWzkwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTBdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s5MF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogOTF9Oy8vIFJOTShzcGFjZSlcblxuICAvKiBzcGFjZSAqL1xuICB0aGlzLnJ1bGVzWzkxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTFdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbOTFdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzJdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5MV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTFdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDkyfTsvLyBSTk0oY29tbWVudClcbiAgdGhpcy5ydWxlc1s5MV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogOTR9Oy8vIFJOTShMaW5lQ29udGludWUpXG5cbiAgLyogY29tbWVudCAqL1xuICB0aGlzLnJ1bGVzWzkyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s5Ml0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs1OV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzkyXS5vcGNvZGVzWzJdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbM10gPSB7dHlwZTogMSwgY2hpbGRyZW46IFs0LDVdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s5Ml0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbNV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbOV19Oy8vIFRCU1xuXG4gIC8qIExpbmVFbmQgKi9cbiAgdGhpcy5ydWxlc1s5M10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzkzXS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s5M10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMywxMF19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzkzXS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzEwXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTNdLm9wY29kZXNbM10gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTNdfTsvLyBUQlNcblxuICAvKiBMaW5lQ29udGludWUgKi9cbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSw1XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDMsNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzEzLDEwXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbM10gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTBdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxM119Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzVdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbNiw3XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbNl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzJdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG5cbiAgLy8gVGhlIGB0b1N0cmluZygpYCBmdW5jdGlvbiB3aWxsIGRpc3BsYXkgdGhlIG9yaWdpbmFsIGdyYW1tYXIgZmlsZShzKSB0aGF0IHByb2R1Y2VkIHRoZXNlIG9wY29kZXMuXG4gIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIHN0ciArPSBcIjtcXG5cIjtcbiAgICBzdHIgKz0gXCI7IEFCTkYgZm9yIEphdmFTY3JpcHQgQVBHIDIuMCBTQUJORlxcblwiO1xuICAgIHN0ciArPSBcIjsgUkZDIDUyMzQgd2l0aCBzb21lIHJlc3RyaWN0aW9ucyBhbmQgYWRkaXRpb25zLlxcblwiO1xuICAgIHN0ciArPSBcIjsgVXBkYXRlZCAxMS8yNC8yMDE1IGZvciBSRkMgNzQwNSBjYXNlLXNlbnNpdGl2ZSBsaXRlcmFsIHN0cmluZyBub3RhdGlvblxcblwiO1xuICAgIHN0ciArPSBcIjsgIC0gYWNjZXB0cyAlc1xcXCJzdHJpbmdcXFwiIGFzIGEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgLSBhY2NlcHRzICVpXFxcInN0cmluZ1xcXCIgYXMgYSBjYXNlLWluc2Vuc2l0aXZlIHN0cmluZ1xcblwiO1xuICAgIHN0ciArPSBcIjsgIC0gYWNjZXB0cyBcXFwic3RyaW5nXFxcIiBhcyBhIGNhc2UtaW5zZW5zaXRpdmUgc3RyaW5nXFxuXCI7XG4gICAgc3RyICs9IFwiO1xcblwiO1xuICAgIHN0ciArPSBcIjsgU29tZSByZXN0cmljdGlvbnM6XFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDEuIFJ1bGVzIG11c3QgYmVnaW4gYXQgZmlyc3QgY2hhcmFjdGVyIG9mIGVhY2ggbGluZS5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgSW5kZW50YXRpb25zIG9uIGZpcnN0IHJ1bGUgYW5kIHJ1bGVzIHRoZXJlYWZ0ZXIgYXJlIG5vdCBhbGxvd2VkLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAyLiBSZWxheGVkIGxpbmUgZW5kaW5ncy4gQ1JMRiwgTEYgb3IgQ1IgYXJlIGFjY2VwdGVkIGFzIHZhbGlkIGxpbmUgZW5kaW5nLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAzLiBQcm9zZSB2YWx1ZXMsIGkuZS4gPHByb3NlIHZhbHVlPiwgYXJlIGFjY2VwdGVkIGFzIHZhbGlkIGdyYW1tYXIgc3ludGF4LlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBIb3dldmVyLCBhIHdvcmtpbmcgcGFyc2VyIGNhbm5vdCBiZSBnZW5lcmF0ZWQgZnJvbSB0aGVtLlxcblwiO1xuICAgIHN0ciArPSBcIjtcXG5cIjtcbiAgICBzdHIgKz0gXCI7IFN1cGVyIHNldCAoU0FCTkYpIGFkZGl0aW9uczpcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgMS4gTG9vay1haGVhZCAoc3ludGFjdGljIHByZWRpY2F0ZSkgb3BlcmF0b3JzIGFyZSBhY2NlcHRlZCBhcyBlbGVtZW50IHByZWZpeGVzLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAmIGlzIHRoZSBwb3NpdGl2ZSBsb29rLWFoZWFkIG9wZXJhdG9yLCBzdWNjZWVkcyBhbmQgYmFja3RyYWNrcyBpZiB0aGUgbG9vay1haGVhZCBwaHJhc2UgaXMgZm91bmRcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgISBpcyB0aGUgbmVnYXRpdmUgbG9vay1haGVhZCBvcGVyYXRvciwgc3VjY2VlZHMgYW5kIGJhY2t0cmFja3MgaWYgdGhlIGxvb2stYWhlYWQgcGhyYXNlIGlzIE5PVCBmb3VuZFxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBlLmcuICYlZDEzIG9yICZydWxlIG9yICEoQSAvIEIpXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDIuIFVzZXItRGVmaW5lZCBUZXJtaW5hbHMgKFVEVCkgb2YgdGhlIGZvcm0sIHVfbmFtZSBhbmQgZV9uYW1lIGFyZSBhY2NlcHRlZC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgJ25hbWUnIGlzIGFscGhhIGZvbGxvd2VkIGJ5IGFscGhhL251bS9oeXBoZW4ganVzdCBsaWtlIGEgcnVsZSBuYW1lLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICB1X25hbWUgbWF5IGJlIHVzZWQgYXMgYW4gZWxlbWVudCBidXQgbm8gcnVsZSBkZWZpbml0aW9uIGlzIGdpdmVuLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBlLmcuIHJ1bGUgPSBBIC8gdV9teVVkdFxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAgICAgIEEgPSBcXFwiYVxcXCJcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgd291bGQgYmUgYSB2YWxpZCBncmFtbWFyLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAzLiBDYXNlLXNlbnNpdGl2ZSwgc2luZ2xlLXF1b3RlZCBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgZS5nLiAnYWJjJyB3b3VsZCBiZSBlcXVpdmFsZW50IHRvICVkOTcuOTguOTlcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgKGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGJ1dCBzdXBlcnNlZGVkIGJ5ICVzXFxcImFiY1xcXCIpICBcXG5cIjtcbiAgICBzdHIgKz0gXCI7IE5ldyAxMi8yNi8yMDE1XFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDQuIExvb2stYmVoaW5kIG9wZXJhdG9ycyBhcmUgYWNjZXB0ZWQgYXMgZWxlbWVudCBwcmVmaXhlcy5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgJiYgaXMgdGhlIHBvc2l0aXZlIGxvb2stYmVoaW5kIG9wZXJhdG9yLCBzdWNjZWVkcyBhbmQgYmFja3RyYWNrcyBpZiB0aGUgbG9vay1iZWhpbmQgcGhyYXNlIGlzIGZvdW5kXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgICEhIGlzIHRoZSBuZWdhdGl2ZSBsb29rLWJlaGluZCBvcGVyYXRvciwgc3VjY2VlZHMgYW5kIGJhY2t0cmFja3MgaWYgdGhlIGxvb2stYmVoaW5kIHBocmFzZSBpcyBOT1QgZm91bmRcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgZS5nLiAmJiVkMTMgb3IgJiZydWxlIG9yICEhKEEgLyBCKVxcblwiO1xuICAgIHN0ciArPSBcIjsgICA1LiBCYWNrIHJlZmVyZW5jZSBvcGVyYXRvcnMsIGkuZS4gXFxcXHJ1bGVuYW1lLCBhcmUgYWNjZXB0ZWQuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIEEgYmFjayByZWZlcmVuY2Ugb3BlcmF0b3IgYWN0cyBsaWtlIGEgVExTIG9yIFRCUyB0ZXJtaW5hbCBleGNlcHQgdGhhdCB0aGUgcGhyYXNlIGl0IGF0dGVtcHRzXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIHRvIG1hdGNoIGlzIGEgcGhyYXNlIHByZXZpb3VzbHkgbWF0Y2hlZCBieSB0aGUgcnVsZSAncnVsZW5hbWUnLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBUaGVyZSBhcmUgdHdvIG1vZGVzIG9mIHByZXZpb3VzIHBocmFzZSBtYXRjaGluZyAtIHRoZSBwYXJlbnQtZnJhbWUgbW9kZSBhbmQgdGhlIHVuaXZlcnNhbCBtb2RlLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBJbiB1bml2ZXJzYWwgbW9kZSwgXFxcXHJ1bGVuYW1lIG1hdGNoZXMgdGhlIGxhc3QgbWF0Y2ggdG8gJ3J1bGVuYW1lJyByZWdhcmRsZXNzIG9mIHdoZXJlIGl0IHdhcyBmb3VuZC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgSW4gcGFyZW50LWZyYW1lIG1vZGUsIFxcXFxydWxlbmFtZSBtYXRjaGVzIG9ubHkgdGhlIGxhc3QgbWF0Y2ggZm91bmQgb24gdGhlIHBhcmVudCdzIGZyYW1lIG9yIHBhcnNlIHRyZWUgbGV2ZWwuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIEJhY2sgcmVmZXJlbmNlIG1vZGlmaWVycyBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGNhc2UgYW5kIG1vZGUuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIFxcXFxBIGRlZmF1bHRzIHRvIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHVuaXZlcnNhbCBtb2RlLCBlLmcuIFxcXFxBID09PSBcXFxcJWkldUFcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgTW9kaWZpZXJzICVpIGFuZCAlcyBkZXRlcm1pbmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FzZS1zZW5zaXRpdmUgbW9kZSwgcmVzcGVjdGl2ZWx5LlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBNb2RpZmllcnMgJXUgYW5kICVwIGRldGVybWluZSB1bml2ZXJzYWwgbW9kZSBhbmQgcGFyZW50IGZyYW1lIG1vZGUsIHJlc3BlY3RpdmVseS5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgQ2FzZSBhbmQgbW9kZSBtb2RpZmllcnMgY2FuIGFwcGVhciBpbiBhbnkgb3JkZXIsIGUuZy4gXFxcXCVzJXBBID09PSBcXFxcJXAlc0EuIFxcblwiO1xuICAgIHN0ciArPSBcIjsgICA3LiBTdHJpbmcgYmVnaW4gYW5jaG9yLCBBQkcoJV4pIG1hdGNoZXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgaW5wdXQgc3RyaW5nIGxvY2F0aW9uLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBSZXR1cm5zIEVNUFRZIG9yIE5PTUFUQ0guIE5ldmVyIGNvbnN1bWVzIGFueSBjaGFyYWN0ZXJzLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICA4LiBTdHJpbmcgZW5kIGFuY2hvciwgQUVOKCUkKSBtYXRjaGVzIHRoZSBlbmQgb2YgdGhlIGlucHV0IHN0cmluZyBsb2NhdGlvbi5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgUmV0dXJucyBFTVBUWSBvciBOT01BVENILiBOZXZlciBjb25zdW1lcyBhbnkgY2hhcmFjdGVycy5cXG5cIjtcbiAgICBzdHIgKz0gXCI7XFxuXCI7XG4gICAgc3RyICs9IFwiRmlsZSAgICAgICAgICAgID0gKihCbGFua0xpbmUgLyBSdWxlIC8gUnVsZUVycm9yKVxcblwiO1xuICAgIHN0ciArPSBcIkJsYW5rTGluZSAgICAgICA9ICooJWQzMi8lZDkpIFtjb21tZW50XSBMaW5lRW5kXFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZSAgICAgICAgICAgID0gUnVsZUxvb2t1cCBvd3NwIEFsdGVybmF0aW9uICgob3dzcCBMaW5lRW5kKVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIChMaW5lRW5kRXJyb3IgTGluZUVuZCkpXFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZUxvb2t1cCAgICAgID0gUnVsZU5hbWVUZXN0IG93c3AgRGVmaW5lZEFzVGVzdFxcblwiO1xuICAgIHN0ciArPSBcIlJ1bGVOYW1lVGVzdCAgICA9IFJ1bGVOYW1lL1J1bGVOYW1lRXJyb3JcXG5cIjtcbiAgICBzdHIgKz0gXCJSdWxlTmFtZSAgICAgICAgPSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcIlJ1bGVOYW1lRXJyb3IgICA9IDEqKCVkMzMtNjAvJWQ2Mi0xMjYpXFxuXCI7XG4gICAgc3RyICs9IFwiRGVmaW5lZEFzVGVzdCAgID0gRGVmaW5lZEFzIC8gRGVmaW5lZEFzRXJyb3JcXG5cIjtcbiAgICBzdHIgKz0gXCJEZWZpbmVkQXNFcnJvciAgPSAxKjIlZDMzLTEyNlxcblwiO1xuICAgIHN0ciArPSBcIkRlZmluZWRBcyAgICAgICA9IEluY0FsdCAvIERlZmluZWRcXG5cIjtcbiAgICBzdHIgKz0gXCJEZWZpbmVkICAgICAgICAgPSAlZDYxXFxuXCI7XG4gICAgc3RyICs9IFwiSW5jQWx0ICAgICAgICAgID0gJWQ2MS40N1xcblwiO1xuICAgIHN0ciArPSBcIlJ1bGVFcnJvciAgICAgICA9IDEqKCVkMzItMTI2IC8gJWQ5ICAvIExpbmVDb250aW51ZSkgTGluZUVuZFxcblwiO1xuICAgIHN0ciArPSBcIkxpbmVFbmRFcnJvciAgICA9IDEqKCVkMzItMTI2IC8gJWQ5ICAvIExpbmVDb250aW51ZSlcXG5cIjtcbiAgICBzdHIgKz0gXCJBbHRlcm5hdGlvbiAgICAgPSBDb25jYXRlbmF0aW9uICoob3dzcCBBbHRPcCBDb25jYXRlbmF0aW9uKVxcblwiO1xuICAgIHN0ciArPSBcIkNvbmNhdGVuYXRpb24gICA9IFJlcGV0aXRpb24gKihDYXRPcCBSZXBldGl0aW9uKVxcblwiO1xuICAgIHN0ciArPSBcIlJlcGV0aXRpb24gICAgICA9IFtNb2RpZmllcl0gKEdyb3VwIC8gT3B0aW9uIC8gQmFzaWNFbGVtZW50IC8gQmFzaWNFbGVtZW50RXJyKVxcblwiO1xuICAgIHN0ciArPSBcIk1vZGlmaWVyICAgICAgICA9IChQcmVkaWNhdGUgW1JlcE9wXSlcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBSZXBPcFxcblwiO1xuICAgIHN0ciArPSBcIlByZWRpY2F0ZSAgICAgICA9IEJrYU9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gQmtuT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBBbmRPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIE5vdE9wXFxuXCI7XG4gICAgc3RyICs9IFwiQmFzaWNFbGVtZW50ICAgID0gVWR0T3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBSbm1PcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIFRyZ09wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gVGJzT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBUbHNPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIENsc09wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gQmtyT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBBYmdPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIEFlbk9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gUHJvc1ZhbFxcblwiO1xuICAgIHN0ciArPSBcIkJhc2ljRWxlbWVudEVyciA9IDEqKCVkMzMtNDAvJWQ0Mi00Ni8lZDQ4LTkyLyVkOTQtMTI2KVxcblwiO1xuICAgIHN0ciArPSBcIkdyb3VwICAgICAgICAgICA9IEdyb3VwT3BlbiAgQWx0ZXJuYXRpb24gKEdyb3VwQ2xvc2UgLyBHcm91cEVycm9yKVxcblwiO1xuICAgIHN0ciArPSBcIkdyb3VwRXJyb3IgICAgICA9IDEqKCVkMzMtNDAvJWQ0Mi00Ni8lZDQ4LTkyLyVkOTQtMTI2KSA7IHNhbWUgYXMgQmFzaWNFbGVtZW50RXJyXFxuXCI7XG4gICAgc3RyICs9IFwiR3JvdXBPcGVuICAgICAgID0gJWQ0MCBvd3NwXFxuXCI7XG4gICAgc3RyICs9IFwiR3JvdXBDbG9zZSAgICAgID0gb3dzcCAlZDQxXFxuXCI7XG4gICAgc3RyICs9IFwiT3B0aW9uICAgICAgICAgID0gT3B0aW9uT3BlbiBBbHRlcm5hdGlvbiAoT3B0aW9uQ2xvc2UgLyBPcHRpb25FcnJvcilcXG5cIjtcbiAgICBzdHIgKz0gXCJPcHRpb25FcnJvciAgICAgPSAxKiglZDMzLTQwLyVkNDItNDYvJWQ0OC05Mi8lZDk0LTEyNikgOyBzYW1lIGFzIEJhc2ljRWxlbWVudEVyclxcblwiO1xuICAgIHN0ciArPSBcIk9wdGlvbk9wZW4gICAgICA9ICVkOTEgb3dzcFxcblwiO1xuICAgIHN0ciArPSBcIk9wdGlvbkNsb3NlICAgICA9IG93c3AgJWQ5M1xcblwiO1xuICAgIHN0ciArPSBcIlJubU9wICAgICAgICAgICA9IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiQmtyT3AgICAgICAgICAgID0gJWQ5MiBbYmtyTW9kaWZpZXJdIGJrci1uYW1lXFxuXCI7XG4gICAgc3RyICs9IFwiYmtyTW9kaWZpZXIgICAgID0gKGNzIFt1bSAvIHBtXSkgLyAoY2kgW3VtIC8gcG1dKSAvICh1bSBbY3MgL2NpXSkgLyAocG0gW2NzIC8gY2ldKVxcblwiO1xuICAgIHN0ciArPSBcImNzICAgICAgICAgICAgICA9ICclcydcXG5cIjtcbiAgICBzdHIgKz0gXCJjaSAgICAgICAgICAgICAgPSAnJWknXFxuXCI7XG4gICAgc3RyICs9IFwidW0gICAgICAgICAgICAgID0gJyV1J1xcblwiO1xuICAgIHN0ciArPSBcInBtICAgICAgICAgICAgICA9ICclcCdcXG5cIjtcbiAgICBzdHIgKz0gXCJia3ItbmFtZSAgICAgICAgPSB1bmFtZSAvIGVuYW1lIC8gcm5hbWVcXG5cIjtcbiAgICBzdHIgKz0gXCJybmFtZSAgICAgICAgICAgPSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcInVuYW1lICAgICAgICAgICA9ICVkMTE3Ljk1IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiZW5hbWUgICAgICAgICAgID0gJWQxMDEuOTUgYWxwaGFudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJVZHRPcCAgICAgICAgICAgPSB1ZHQtZW1wdHlcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyB1ZHQtbm9uLWVtcHR5XFxuXCI7XG4gICAgc3RyICs9IFwidWR0LW5vbi1lbXB0eSAgID0gJWQxMTcuOTUgYWxwaGFudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJ1ZHQtZW1wdHkgICAgICAgPSAlZDEwMS45NSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcIlJlcE9wICAgICAgICAgICA9IChyZXAtbWluIFN0YXJPcCByZXAtbWF4KVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIChyZXAtbWluIFN0YXJPcClcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyAoU3Rhck9wIHJlcC1tYXgpXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gU3Rhck9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gcmVwLW1pbi1tYXhcXG5cIjtcbiAgICBzdHIgKz0gXCJBbHRPcCAgICAgICAgICAgPSAlZDQ3IG93c3BcXG5cIjtcbiAgICBzdHIgKz0gXCJDYXRPcCAgICAgICAgICAgPSB3c3BcXG5cIjtcbiAgICBzdHIgKz0gXCJTdGFyT3AgICAgICAgICAgPSAlZDQyXFxuXCI7XG4gICAgc3RyICs9IFwiQW5kT3AgICAgICAgICAgID0gJWQzOFxcblwiO1xuICAgIHN0ciArPSBcIk5vdE9wICAgICAgICAgICA9ICVkMzNcXG5cIjtcbiAgICBzdHIgKz0gXCJCa2FPcCAgICAgICAgICAgPSAlZDM4LjM4XFxuXCI7XG4gICAgc3RyICs9IFwiQmtuT3AgICAgICAgICAgID0gJWQzMy4zM1xcblwiO1xuICAgIHN0ciArPSBcIkFiZ09wICAgICAgICAgICA9ICVkMzcuOTRcXG5cIjtcbiAgICBzdHIgKz0gXCJBZW5PcCAgICAgICAgICAgPSAlZDM3LjM2XFxuXCI7XG4gICAgc3RyICs9IFwiVHJnT3AgICAgICAgICAgID0gJWQzNyAoKERlYyBkbWluICVkNDUgZG1heCkgLyAoSGV4IHhtaW4gJWQ0NSB4bWF4KSAvIChCaW4gYm1pbiAlZDQ1IGJtYXgpKVxcblwiO1xuICAgIHN0ciArPSBcIlRic09wICAgICAgICAgICA9ICVkMzcgKChEZWMgZFN0cmluZyAqKCVkNDYgZFN0cmluZykpIC8gKEhleCB4U3RyaW5nICooJWQ0NiB4U3RyaW5nKSkgLyAoQmluIGJTdHJpbmcgKiglZDQ2IGJTdHJpbmcpKSlcXG5cIjtcbiAgICBzdHIgKz0gXCJUbHNPcCAgICAgICAgICAgPSBUbHNDYXNlIFRsc09wZW4gVGxzU3RyaW5nIFRsc0Nsb3NlXFxuXCI7XG4gICAgc3RyICs9IFwiVGxzQ2FzZSAgICAgICAgID0gW1xcXCIlaVxcXCIgLyBcXFwiJXNcXFwiXVxcblwiO1xuICAgIHN0ciArPSBcIlRsc09wZW4gICAgICAgICA9ICVkMzRcXG5cIjtcbiAgICBzdHIgKz0gXCJUbHNDbG9zZSAgICAgICAgPSAlZDM0XFxuXCI7XG4gICAgc3RyICs9IFwiVGxzU3RyaW5nICAgICAgID0gKiglZDMyLTMzLyVkMzUtMTI2L1N0cmluZ1RhYilcXG5cIjtcbiAgICBzdHIgKz0gXCJTdHJpbmdUYWIgICAgICAgPSAlZDlcXG5cIjtcbiAgICBzdHIgKz0gXCJDbHNPcCAgICAgICAgICAgPSBDbHNPcGVuIENsc1N0cmluZyBDbHNDbG9zZVxcblwiO1xuICAgIHN0ciArPSBcIkNsc09wZW4gICAgICAgICA9ICVkMzlcXG5cIjtcbiAgICBzdHIgKz0gXCJDbHNDbG9zZSAgICAgICAgPSAlZDM5XFxuXCI7XG4gICAgc3RyICs9IFwiQ2xzU3RyaW5nICAgICAgID0gKiglZDMyLTM4LyVkNDAtMTI2L1N0cmluZ1RhYilcXG5cIjtcbiAgICBzdHIgKz0gXCJQcm9zVmFsICAgICAgICAgPSBQcm9zVmFsT3BlbiBQcm9zVmFsU3RyaW5nIFByb3NWYWxDbG9zZVxcblwiO1xuICAgIHN0ciArPSBcIlByb3NWYWxPcGVuICAgICA9ICVkNjBcXG5cIjtcbiAgICBzdHIgKz0gXCJQcm9zVmFsU3RyaW5nICAgPSAqKCVkMzItNjEvJWQ2My0xMjYvU3RyaW5nVGFiKVxcblwiO1xuICAgIHN0ciArPSBcIlByb3NWYWxDbG9zZSAgICA9ICVkNjJcXG5cIjtcbiAgICBzdHIgKz0gXCJyZXAtbWluICAgICAgICAgPSByZXAtbnVtXFxuXCI7XG4gICAgc3RyICs9IFwicmVwLW1pbi1tYXggICAgID0gcmVwLW51bVxcblwiO1xuICAgIHN0ciArPSBcInJlcC1tYXggICAgICAgICA9IHJlcC1udW1cXG5cIjtcbiAgICBzdHIgKz0gXCJyZXAtbnVtICAgICAgICAgPSAxKiglZDQ4LTU3KVxcblwiO1xuICAgIHN0ciArPSBcImRTdHJpbmcgICAgICAgICA9IGRudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJ4U3RyaW5nICAgICAgICAgPSB4bnVtXFxuXCI7XG4gICAgc3RyICs9IFwiYlN0cmluZyAgICAgICAgID0gYm51bVxcblwiO1xuICAgIHN0ciArPSBcIkRlYyAgICAgICAgICAgICA9ICglZDY4LyVkMTAwKVxcblwiO1xuICAgIHN0ciArPSBcIkhleCAgICAgICAgICAgICA9ICglZDg4LyVkMTIwKVxcblwiO1xuICAgIHN0ciArPSBcIkJpbiAgICAgICAgICAgICA9ICglZDY2LyVkOTgpXFxuXCI7XG4gICAgc3RyICs9IFwiZG1pbiAgICAgICAgICAgID0gZG51bVxcblwiO1xuICAgIHN0ciArPSBcImRtYXggICAgICAgICAgICA9IGRudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJibWluICAgICAgICAgICAgPSBibnVtXFxuXCI7XG4gICAgc3RyICs9IFwiYm1heCAgICAgICAgICAgID0gYm51bVxcblwiO1xuICAgIHN0ciArPSBcInhtaW4gICAgICAgICAgICA9IHhudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJ4bWF4ICAgICAgICAgICAgPSB4bnVtXFxuXCI7XG4gICAgc3RyICs9IFwiZG51bSAgICAgICAgICAgID0gMSooJWQ0OC01NylcXG5cIjtcbiAgICBzdHIgKz0gXCJibnVtICAgICAgICAgICAgPSAxKiVkNDgtNDlcXG5cIjtcbiAgICBzdHIgKz0gXCJ4bnVtICAgICAgICAgICAgPSAxKiglZDQ4LTU3IC8gJWQ2NS03MCAvICVkOTctMTAyKVxcblwiO1xuICAgIHN0ciArPSBcIjtcXG5cIjtcbiAgICBzdHIgKz0gXCI7IEJhc2ljc1xcblwiO1xuICAgIHN0ciArPSBcImFscGhhbnVtICAgICAgICA9ICglZDk3LTEyMi8lZDY1LTkwKSAqKCVkOTctMTIyLyVkNjUtOTAvJWQ0OC01Ny8lZDQ1KVxcblwiO1xuICAgIHN0ciArPSBcIm93c3AgICAgICAgICAgICA9ICpzcGFjZVxcblwiO1xuICAgIHN0ciArPSBcIndzcCAgICAgICAgICAgICA9IDEqc3BhY2VcXG5cIjtcbiAgICBzdHIgKz0gXCJzcGFjZSAgICAgICAgICAgPSAlZDMyXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gJWQ5XFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gY29tbWVudFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIExpbmVDb250aW51ZVxcblwiO1xuICAgIHN0ciArPSBcImNvbW1lbnQgICAgICAgICA9ICVkNTkgKiglZDMyLTEyNiAvICVkOSlcXG5cIjtcbiAgICBzdHIgKz0gXCJMaW5lRW5kICAgICAgICAgPSAlZDEzLjEwXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gJWQxMFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvICVkMTNcXG5cIjtcbiAgICBzdHIgKz0gXCJMaW5lQ29udGludWUgICAgPSAoJWQxMy4xMCAvICVkMTAgLyAlZDEzKSAoJWQzMiAvICVkOSlcXG5cIjtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/sabnf-grammar.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-callbacks.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-callbacks.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// These are the AST translation callback functions used by the scanner\n// to analyze the characters and lines.\nconst ids = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\nconst utils = __webpack_require__(/*! ../apg-lib/utilities */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\");\n\nfunction semLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: data.textLength,\n      endType: data.endType,\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semLineText(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.textLength = phraseCount;\n  }\n  return ids.SEM_OK;\n}\nfunction semLastLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else if (data.strict) {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: phraseCount,\n      endType: 'none',\n      invalidChars: data.invalidCount,\n    });\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex + phraseCount,\n      msg: 'no line end on last line - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n    });\n  } else {\n    /* add a line ender */\n    chars.push(10);\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount + 1,\n      textLength: phraseCount,\n      endType: 'LF',\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semInvalid(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex,\n      msg: `invalid character found '\\\\x${utils.charToHex(chars[phraseIndex])}'`,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semEnd(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_POST) {\n    data.lineNo += 1;\n  }\n  return ids.SEM_OK;\n}\nfunction semLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'LF';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character LF(\\\\n, \\\\x0A) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCR(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CR';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character CR(\\\\r, \\\\x0D) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCRLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CRLF';\n  }\n  return ids.SEM_OK;\n}\nconst callbacks = [];\ncallbacks.line = semLine;\ncallbacks['line-text'] = semLineText;\ncallbacks['last-line'] = semLastLine;\ncallbacks.invalid = semInvalid;\ncallbacks.end = semEnd;\ncallbacks.lf = semLF;\ncallbacks.cr = semCR;\ncallbacks.crlf = semCRLF;\nexports.callbacks = callbacks;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItY2FsbGJhY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQywwSEFBd0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLHNIQUFzQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQ0FBb0M7QUFDOUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2Nhbm5lci1jYWxsYmFja3MuanM/YjM4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGVzZSBhcmUgdGhlIEFTVCB0cmFuc2xhdGlvbiBjYWxsYmFjayBmdW5jdGlvbnMgdXNlZCBieSB0aGUgc2Nhbm5lclxuLy8gdG8gYW5hbHl6ZSB0aGUgY2hhcmFjdGVycyBhbmQgbGluZXMuXG5jb25zdCBpZHMgPSByZXF1aXJlKCcuLi9hcGctbGliL2lkZW50aWZpZXJzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL2FwZy1saWIvdXRpbGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHNlbUxpbmUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZW5kTGVuZ3RoID0gMDtcbiAgICBkYXRhLnRleHRMZW5ndGggPSAwO1xuICAgIGRhdGEuaW52YWxpZENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLmxpbmVzLnB1c2goe1xuICAgICAgbGluZU5vOiBkYXRhLmxpbmVzLmxlbmd0aCxcbiAgICAgIGJlZ2luQ2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICBsZW5ndGg6IHBocmFzZUNvdW50LFxuICAgICAgdGV4dExlbmd0aDogZGF0YS50ZXh0TGVuZ3RoLFxuICAgICAgZW5kVHlwZTogZGF0YS5lbmRUeXBlLFxuICAgICAgaW52YWxpZENoYXJzOiBkYXRhLmludmFsaWRDb3VudCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUxpbmVUZXh0KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QUkUpIHtcbiAgICBkYXRhLnRleHRMZW5ndGggPSBwaHJhc2VDb3VudDtcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUxhc3RMaW5lKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QUkUpIHtcbiAgICBkYXRhLmVuZExlbmd0aCA9IDA7XG4gICAgZGF0YS50ZXh0TGVuZ3RoID0gMDtcbiAgICBkYXRhLmludmFsaWRDb3VudCA9IDA7XG4gIH0gZWxzZSBpZiAoZGF0YS5zdHJpY3QpIHtcbiAgICBkYXRhLmxpbmVzLnB1c2goe1xuICAgICAgbGluZU5vOiBkYXRhLmxpbmVzLmxlbmd0aCxcbiAgICAgIGJlZ2luQ2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICBsZW5ndGg6IHBocmFzZUNvdW50LFxuICAgICAgdGV4dExlbmd0aDogcGhyYXNlQ291bnQsXG4gICAgICBlbmRUeXBlOiAnbm9uZScsXG4gICAgICBpbnZhbGlkQ2hhcnM6IGRhdGEuaW52YWxpZENvdW50LFxuICAgIH0pO1xuICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgbGluZTogZGF0YS5saW5lTm8sXG4gICAgICBjaGFyOiBwaHJhc2VJbmRleCArIHBocmFzZUNvdW50LFxuICAgICAgbXNnOiAnbm8gbGluZSBlbmQgb24gbGFzdCBsaW5lIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVzIENSTEYoXFxcXHJcXFxcbiwgXFxcXHgwRFxcXFx4MEEpJyxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvKiBhZGQgYSBsaW5lIGVuZGVyICovXG4gICAgY2hhcnMucHVzaCgxMCk7XG4gICAgZGF0YS5saW5lcy5wdXNoKHtcbiAgICAgIGxpbmVObzogZGF0YS5saW5lcy5sZW5ndGgsXG4gICAgICBiZWdpbkNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgbGVuZ3RoOiBwaHJhc2VDb3VudCArIDEsXG4gICAgICB0ZXh0TGVuZ3RoOiBwaHJhc2VDb3VudCxcbiAgICAgIGVuZFR5cGU6ICdMRicsXG4gICAgICBpbnZhbGlkQ2hhcnM6IGRhdGEuaW52YWxpZENvdW50LFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuZnVuY3Rpb24gc2VtSW52YWxpZChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUFJFKSB7XG4gICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICBsaW5lOiBkYXRhLmxpbmVObyxcbiAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgbXNnOiBgaW52YWxpZCBjaGFyYWN0ZXIgZm91bmQgJ1xcXFx4JHt1dGlscy5jaGFyVG9IZXgoY2hhcnNbcGhyYXNlSW5kZXhdKX0nYCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUVuZChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUE9TVCkge1xuICAgIGRhdGEubGluZU5vICs9IDE7XG4gIH1cbiAgcmV0dXJuIGlkcy5TRU1fT0s7XG59XG5mdW5jdGlvbiBzZW1MRihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUFJFKSB7XG4gICAgZGF0YS5lbmRUeXBlID0gJ0xGJztcbiAgICBpZiAoZGF0YS5zdHJpY3QpIHtcbiAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICBsaW5lOiBkYXRhLmxpbmVObyxcbiAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgIG1zZzogJ2xpbmUgZW5kIGNoYXJhY3RlciBMRihcXFxcbiwgXFxcXHgwQSkgLSBzdHJpY3QgQUJORiBzcGVjaWZpZXMgQ1JMRihcXFxcclxcXFxuLCBcXFxceDBEXFxcXHgwQSknLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuZnVuY3Rpb24gc2VtQ1Ioc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZW5kVHlwZSA9ICdDUic7XG4gICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgbGluZTogZGF0YS5saW5lTm8sXG4gICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICBtc2c6ICdsaW5lIGVuZCBjaGFyYWN0ZXIgQ1IoXFxcXHIsIFxcXFx4MEQpIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVzIENSTEYoXFxcXHJcXFxcbiwgXFxcXHgwRFxcXFx4MEEpJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUNSTEYoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZW5kVHlwZSA9ICdDUkxGJztcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmNvbnN0IGNhbGxiYWNrcyA9IFtdO1xuY2FsbGJhY2tzLmxpbmUgPSBzZW1MaW5lO1xuY2FsbGJhY2tzWydsaW5lLXRleHQnXSA9IHNlbUxpbmVUZXh0O1xuY2FsbGJhY2tzWydsYXN0LWxpbmUnXSA9IHNlbUxhc3RMaW5lO1xuY2FsbGJhY2tzLmludmFsaWQgPSBzZW1JbnZhbGlkO1xuY2FsbGJhY2tzLmVuZCA9IHNlbUVuZDtcbmNhbGxiYWNrcy5sZiA9IHNlbUxGO1xuY2FsbGJhY2tzLmNyID0gc2VtQ1I7XG5jYWxsYmFja3MuY3JsZiA9IHNlbUNSTEY7XG5leHBvcnRzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-callbacks.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-grammar.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-grammar.js ***!
  \************************************************************************************************/
/***/ ((module) => {

eval("// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.2.1 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 10\n  //       udts = 0\n  //    opcodes = 31\n  //        ---   ABNF original opcodes\n  //        ALT = 5\n  //        CAT = 2\n  //        REP = 4\n  //        RNM = 11\n  //        TLS = 0\n  //        TBS = 4\n  //        TRG = 5\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [0 - 4294967295]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = {name: 'file', lower: 'file', index: 0, isBkr: false};\n  this.rules[1] = {name: 'line', lower: 'line', index: 1, isBkr: false};\n  this.rules[2] = {name: 'line-text', lower: 'line-text', index: 2, isBkr: false};\n  this.rules[3] = {name: 'last-line', lower: 'last-line', index: 3, isBkr: false};\n  this.rules[4] = {name: 'valid', lower: 'valid', index: 4, isBkr: false};\n  this.rules[5] = {name: 'invalid', lower: 'invalid', index: 5, isBkr: false};\n  this.rules[6] = {name: 'end', lower: 'end', index: 6, isBkr: false};\n  this.rules[7] = {name: 'CRLF', lower: 'crlf', index: 7, isBkr: false};\n  this.rules[8] = {name: 'LF', lower: 'lf', index: 8, isBkr: false};\n  this.rules[9] = {name: 'CR', lower: 'cr', index: 9, isBkr: false};\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* file */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = {type: 2, children: [1,3]};// CAT\n  this.rules[0].opcodes[1] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[0].opcodes[2] = {type: 4, index: 1};// RNM(line)\n  this.rules[0].opcodes[3] = {type: 3, min: 0, max: 1};// REP\n  this.rules[0].opcodes[4] = {type: 4, index: 3};// RNM(last-line)\n\n  /* line */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = {type: 2, children: [1,2]};// CAT\n  this.rules[1].opcodes[1] = {type: 4, index: 2};// RNM(line-text)\n  this.rules[1].opcodes[2] = {type: 4, index: 6};// RNM(end)\n\n  /* line-text */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = {type: 3, min: 0, max: Infinity};// REP\n  this.rules[2].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[2].opcodes[2] = {type: 4, index: 4};// RNM(valid)\n  this.rules[2].opcodes[3] = {type: 4, index: 5};// RNM(invalid)\n\n  /* last-line */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = {type: 3, min: 1, max: Infinity};// REP\n  this.rules[3].opcodes[1] = {type: 1, children: [2,3]};// ALT\n  this.rules[3].opcodes[2] = {type: 4, index: 4};// RNM(valid)\n  this.rules[3].opcodes[3] = {type: 4, index: 5};// RNM(invalid)\n\n  /* valid */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = {type: 1, children: [1,2]};// ALT\n  this.rules[4].opcodes[1] = {type: 5, min: 32, max: 126};// TRG\n  this.rules[4].opcodes[2] = {type: 6, string: [9]};// TBS\n\n  /* invalid */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = {type: 1, children: [1,2,3,4]};// ALT\n  this.rules[5].opcodes[1] = {type: 5, min: 0, max: 8};// TRG\n  this.rules[5].opcodes[2] = {type: 5, min: 11, max: 12};// TRG\n  this.rules[5].opcodes[3] = {type: 5, min: 14, max: 31};// TRG\n  this.rules[5].opcodes[4] = {type: 5, min: 127, max: 4294967295};// TRG\n\n  /* end */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = {type: 1, children: [1,2,3]};// ALT\n  this.rules[6].opcodes[1] = {type: 4, index: 7};// RNM(CRLF)\n  this.rules[6].opcodes[2] = {type: 4, index: 8};// RNM(LF)\n  this.rules[6].opcodes[3] = {type: 4, index: 9};// RNM(CR)\n\n  /* CRLF */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = {type: 6, string: [13,10]};// TBS\n\n  /* LF */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = {type: 6, string: [10]};// TBS\n\n  /* CR */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = {type: 6, string: [13]};// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \"file = *line [last-line]\\n\";\n    str += \"line = line-text end\\n\";\n    str += \"line-text = *(valid/invalid)\\n\";\n    str += \"last-line = 1*(valid/invalid)\\n\";\n    str += \"valid = %d32-126 / %d9\\n\";\n    str += \"invalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\\n\";\n    str += \"end = CRLF / LF / CR\\n\";\n    str += \"CRLF = %d13.10\\n\";\n    str += \"LF = %d10\\n\";\n    str += \"CR = %d13\\n\";\n    return str;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItZ3JhbW1hci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsOEJBQThCLGdDQUFnQztBQUM5RCw4QkFBOEIsbUJBQW1CO0FBQ2pELDhCQUE4Qix5QkFBeUI7QUFDdkQsOEJBQThCLG1CQUFtQjs7QUFFakQ7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsOEJBQThCLG1CQUFtQjtBQUNqRCw4QkFBOEIsbUJBQW1COztBQUVqRDtBQUNBO0FBQ0EsOEJBQThCLGdDQUFnQztBQUM5RCw4QkFBOEIsMEJBQTBCO0FBQ3hELDhCQUE4QixtQkFBbUI7QUFDakQsOEJBQThCLG1CQUFtQjs7QUFFakQ7QUFDQTtBQUNBLDhCQUE4QixnQ0FBZ0M7QUFDOUQsOEJBQThCLDBCQUEwQjtBQUN4RCw4QkFBOEIsbUJBQW1CO0FBQ2pELDhCQUE4QixtQkFBbUI7O0FBRWpEO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hELDhCQUE4Qiw0QkFBNEI7QUFDMUQsOEJBQThCLHNCQUFzQjs7QUFFcEQ7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQsOEJBQThCLHlCQUF5QjtBQUN2RCw4QkFBOEIsMkJBQTJCO0FBQ3pELDhCQUE4QiwyQkFBMkI7QUFDekQsOEJBQThCLG9DQUFvQzs7QUFFbEU7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQsOEJBQThCLG1CQUFtQjtBQUNqRCw4QkFBOEIsbUJBQW1CO0FBQ2pELDhCQUE4QixtQkFBbUI7O0FBRWpEO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCOztBQUV4RDtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1Qjs7QUFFckQ7QUFDQTtBQUNBLDhCQUE4Qix1QkFBdUI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2Nhbm5lci1ncmFtbWFyLmpzP2IxMjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjMgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZDxicj5cbi8vICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSk8YnI+XG4vL1xuLy8gR2VuZXJhdGVkIGJ5IGFwZy1qcywgVmVyc2lvbiA0LjIuMSBbYXBnLWpzXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBncmFtbWFyKCl7XG4gIC8vIGBgYFxuICAvLyBTVU1NQVJZXG4gIC8vICAgICAgcnVsZXMgPSAxMFxuICAvLyAgICAgICB1ZHRzID0gMFxuICAvLyAgICBvcGNvZGVzID0gMzFcbiAgLy8gICAgICAgIC0tLSAgIEFCTkYgb3JpZ2luYWwgb3Bjb2Rlc1xuICAvLyAgICAgICAgQUxUID0gNVxuICAvLyAgICAgICAgQ0FUID0gMlxuICAvLyAgICAgICAgUkVQID0gNFxuICAvLyAgICAgICAgUk5NID0gMTFcbiAgLy8gICAgICAgIFRMUyA9IDBcbiAgLy8gICAgICAgIFRCUyA9IDRcbiAgLy8gICAgICAgIFRSRyA9IDVcbiAgLy8gICAgICAgIC0tLSAgIFNBQk5GIHN1cGVyc2V0IG9wY29kZXNcbiAgLy8gICAgICAgIFVEVCA9IDBcbiAgLy8gICAgICAgIEFORCA9IDBcbiAgLy8gICAgICAgIE5PVCA9IDBcbiAgLy8gICAgICAgIEJLQSA9IDBcbiAgLy8gICAgICAgIEJLTiA9IDBcbiAgLy8gICAgICAgIEJLUiA9IDBcbiAgLy8gICAgICAgIEFCRyA9IDBcbiAgLy8gICAgICAgIEFFTiA9IDBcbiAgLy8gY2hhcmFjdGVycyA9IFswIC0gNDI5NDk2NzI5NV1cbiAgLy8gYGBgXG4gIC8qIE9CSkVDVCBJREVOVElGSUVSIChmb3IgaW50ZXJuYWwgcGFyc2VyIHVzZSkgKi9cbiAgdGhpcy5ncmFtbWFyT2JqZWN0ID0gJ2dyYW1tYXJPYmplY3QnO1xuXG4gIC8qIFJVTEVTICovXG4gIHRoaXMucnVsZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1swXSA9IHtuYW1lOiAnZmlsZScsIGxvd2VyOiAnZmlsZScsIGluZGV4OiAwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzFdID0ge25hbWU6ICdsaW5lJywgbG93ZXI6ICdsaW5lJywgaW5kZXg6IDEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMl0gPSB7bmFtZTogJ2xpbmUtdGV4dCcsIGxvd2VyOiAnbGluZS10ZXh0JywgaW5kZXg6IDIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbM10gPSB7bmFtZTogJ2xhc3QtbGluZScsIGxvd2VyOiAnbGFzdC1saW5lJywgaW5kZXg6IDMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNF0gPSB7bmFtZTogJ3ZhbGlkJywgbG93ZXI6ICd2YWxpZCcsIGluZGV4OiA0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzVdID0ge25hbWU6ICdpbnZhbGlkJywgbG93ZXI6ICdpbnZhbGlkJywgaW5kZXg6IDUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNl0gPSB7bmFtZTogJ2VuZCcsIGxvd2VyOiAnZW5kJywgaW5kZXg6IDYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbN10gPSB7bmFtZTogJ0NSTEYnLCBsb3dlcjogJ2NybGYnLCBpbmRleDogNywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4XSA9IHtuYW1lOiAnTEYnLCBsb3dlcjogJ2xmJywgaW5kZXg6IDgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbOV0gPSB7bmFtZTogJ0NSJywgbG93ZXI6ICdjcicsIGluZGV4OiA5LCBpc0JrcjogZmFsc2V9O1xuXG4gIC8qIFVEVFMgKi9cbiAgdGhpcy51ZHRzID0gW107XG5cbiAgLyogT1BDT0RFUyAqL1xuICAvKiBmaWxlICovXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzFdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMX07Ly8gUk5NKGxpbmUpXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogM307Ly8gUk5NKGxhc3QtbGluZSlcblxuICAvKiBsaW5lICovXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAyfTsvLyBSTk0obGluZS10ZXh0KVxuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDZ9Oy8vIFJOTShlbmQpXG5cbiAgLyogbGluZS10ZXh0ICovXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNH07Ly8gUk5NKHZhbGlkKVxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDV9Oy8vIFJOTShpbnZhbGlkKVxuXG4gIC8qIGxhc3QtbGluZSAqL1xuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDR9Oy8vIFJOTSh2YWxpZClcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA1fTsvLyBSTk0oaW52YWxpZClcblxuICAvKiB2YWxpZCAqL1xuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG5cbiAgLyogaW52YWxpZCAqL1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDMsNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMV0gPSB7dHlwZTogNSwgbWluOiAwLCBtYXg6IDh9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMl0gPSB7dHlwZTogNSwgbWluOiAxMSwgbWF4OiAxMn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDE0LCBtYXg6IDMxfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s1XS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogMTI3LCBtYXg6IDQyOTQ5NjcyOTV9Oy8vIFRSR1xuXG4gIC8qIGVuZCAqL1xuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA3fTsvLyBSTk0oQ1JMRilcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4fTsvLyBSTk0oTEYpXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA0LCBpbmRleDogOX07Ly8gUk5NKENSKVxuXG4gIC8qIENSTEYgKi9cbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbN10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMywxMF19Oy8vIFRCU1xuXG4gIC8qIExGICovXG4gIHRoaXMucnVsZXNbOF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzhdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTBdfTsvLyBUQlNcblxuICAvKiBDUiAqL1xuICB0aGlzLnJ1bGVzWzldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s5XS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzEzXX07Ly8gVEJTXG5cbiAgLy8gVGhlIGB0b1N0cmluZygpYCBmdW5jdGlvbiB3aWxsIGRpc3BsYXkgdGhlIG9yaWdpbmFsIGdyYW1tYXIgZmlsZShzKSB0aGF0IHByb2R1Y2VkIHRoZXNlIG9wY29kZXMuXG4gIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIHN0ciArPSBcImZpbGUgPSAqbGluZSBbbGFzdC1saW5lXVxcblwiO1xuICAgIHN0ciArPSBcImxpbmUgPSBsaW5lLXRleHQgZW5kXFxuXCI7XG4gICAgc3RyICs9IFwibGluZS10ZXh0ID0gKih2YWxpZC9pbnZhbGlkKVxcblwiO1xuICAgIHN0ciArPSBcImxhc3QtbGluZSA9IDEqKHZhbGlkL2ludmFsaWQpXFxuXCI7XG4gICAgc3RyICs9IFwidmFsaWQgPSAlZDMyLTEyNiAvICVkOVxcblwiO1xuICAgIHN0ciArPSBcImludmFsaWQgPSAlZDAtOCAvICVkMTEtMTIgLyVkMTQtMzEgLyAleDdmLWZmZmZmZmZmXFxuXCI7XG4gICAgc3RyICs9IFwiZW5kID0gQ1JMRiAvIExGIC8gQ1JcXG5cIjtcbiAgICBzdHIgKz0gXCJDUkxGID0gJWQxMy4xMFxcblwiO1xuICAgIHN0ciArPSBcIkxGID0gJWQxMFxcblwiO1xuICAgIHN0ciArPSBcIkNSID0gJWQxM1xcblwiO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-grammar.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module reads the input grammar file and does a preliminary analysis\n// before attempting to parse it into a grammar object.\n// See:<br>\n// `./dist/scanner-grammar.bnf`<br>\n// for the grammar file this parser is based on.\n//\n// It has two primary functions.\n// - verify the character codes - no non-printing ASCII characters\n// - catalog the lines - create an array with a line object for each line.\n// The object carries information about the line number and character length which is used\n// by the parser generator primarily for error reporting.\nmodule.exports = function exfn(chars, errors, strict, trace) {\n  const thisFileName = 'scanner.js: ';\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const grammar = new (__webpack_require__(/*! ./scanner-grammar */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-grammar.js\"))();\n  const { callbacks } = __webpack_require__(/*! ./scanner-callbacks */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-callbacks.js\");\n\n  /* Scan the grammar for character code errors and catalog the lines. */\n  const lines = [];\n  // eslint-disable-next-line new-cap\n  const parser = new apglib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new apglib.ast();\n  parser.ast.callbacks = callbacks;\n  if (trace) {\n    if (trace.traceObject !== 'traceObject') {\n      throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n    }\n    parser.trace = trace;\n  }\n\n  /* parse the input SABNF grammar */\n  const test = parser.parse(grammar, 'file', chars);\n  if (test.success !== true) {\n    errors.push({\n      line: 0,\n      char: 0,\n      msg: 'syntax analysis error analyzing input SABNF grammar',\n    });\n    return;\n  }\n  const data = {\n    lines,\n    lineNo: 0,\n    errors,\n    strict: !!strict,\n  };\n\n  /* translate (analyze) the input SABNF grammar */\n  parser.ast.translate(data);\n  // eslint-disable-next-line consistent-return\n  return lines;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDRIQUF5QjtBQUNsRCx1QkFBdUIsbUJBQU8sQ0FBQyx5SEFBbUI7QUFDbEQsVUFBVSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyw2SEFBcUI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9zY2FubmVyLmpzPzcwZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgcmVhZHMgdGhlIGlucHV0IGdyYW1tYXIgZmlsZSBhbmQgZG9lcyBhIHByZWxpbWluYXJ5IGFuYWx5c2lzXG4vLyBiZWZvcmUgYXR0ZW1wdGluZyB0byBwYXJzZSBpdCBpbnRvIGEgZ3JhbW1hciBvYmplY3QuXG4vLyBTZWU6PGJyPlxuLy8gYC4vZGlzdC9zY2FubmVyLWdyYW1tYXIuYm5mYDxicj5cbi8vIGZvciB0aGUgZ3JhbW1hciBmaWxlIHRoaXMgcGFyc2VyIGlzIGJhc2VkIG9uLlxuLy9cbi8vIEl0IGhhcyB0d28gcHJpbWFyeSBmdW5jdGlvbnMuXG4vLyAtIHZlcmlmeSB0aGUgY2hhcmFjdGVyIGNvZGVzIC0gbm8gbm9uLXByaW50aW5nIEFTQ0lJIGNoYXJhY3RlcnNcbi8vIC0gY2F0YWxvZyB0aGUgbGluZXMgLSBjcmVhdGUgYW4gYXJyYXkgd2l0aCBhIGxpbmUgb2JqZWN0IGZvciBlYWNoIGxpbmUuXG4vLyBUaGUgb2JqZWN0IGNhcnJpZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmUgbnVtYmVyIGFuZCBjaGFyYWN0ZXIgbGVuZ3RoIHdoaWNoIGlzIHVzZWRcbi8vIGJ5IHRoZSBwYXJzZXIgZ2VuZXJhdG9yIHByaW1hcmlseSBmb3IgZXJyb3IgcmVwb3J0aW5nLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleGZuKGNoYXJzLCBlcnJvcnMsIHN0cmljdCwgdHJhY2UpIHtcbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ3NjYW5uZXIuanM6ICc7XG4gIGNvbnN0IGFwZ2xpYiA9IHJlcXVpcmUoJy4uL2FwZy1saWIvbm9kZS1leHBvcnRzJyk7XG4gIGNvbnN0IGdyYW1tYXIgPSBuZXcgKHJlcXVpcmUoJy4vc2Nhbm5lci1ncmFtbWFyJykpKCk7XG4gIGNvbnN0IHsgY2FsbGJhY2tzIH0gPSByZXF1aXJlKCcuL3NjYW5uZXItY2FsbGJhY2tzJyk7XG5cbiAgLyogU2NhbiB0aGUgZ3JhbW1hciBmb3IgY2hhcmFjdGVyIGNvZGUgZXJyb3JzIGFuZCBjYXRhbG9nIHRoZSBsaW5lcy4gKi9cbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgY29uc3QgcGFyc2VyID0gbmV3IGFwZ2xpYi5wYXJzZXIoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgcGFyc2VyLmFzdCA9IG5ldyBhcGdsaWIuYXN0KCk7XG4gIHBhcnNlci5hc3QuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICBpZiAodHJhY2UpIHtcbiAgICBpZiAodHJhY2UudHJhY2VPYmplY3QgIT09ICd0cmFjZU9iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXRyYWNlIGFyZ3VtZW50IGlzIG5vdCBhIHRyYWNlIG9iamVjdGApO1xuICAgIH1cbiAgICBwYXJzZXIudHJhY2UgPSB0cmFjZTtcbiAgfVxuXG4gIC8qIHBhcnNlIHRoZSBpbnB1dCBTQUJORiBncmFtbWFyICovXG4gIGNvbnN0IHRlc3QgPSBwYXJzZXIucGFyc2UoZ3JhbW1hciwgJ2ZpbGUnLCBjaGFycyk7XG4gIGlmICh0ZXN0LnN1Y2Nlc3MgIT09IHRydWUpIHtcbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICBsaW5lOiAwLFxuICAgICAgY2hhcjogMCxcbiAgICAgIG1zZzogJ3N5bnRheCBhbmFseXNpcyBlcnJvciBhbmFseXppbmcgaW5wdXQgU0FCTkYgZ3JhbW1hcicsXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgbGluZXMsXG4gICAgbGluZU5vOiAwLFxuICAgIGVycm9ycyxcbiAgICBzdHJpY3Q6ICEhc3RyaWN0LFxuICB9O1xuXG4gIC8qIHRyYW5zbGF0ZSAoYW5hbHl6ZSkgdGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgKi9cbiAgcGFyc2VyLmFzdC50cmFuc2xhdGUoZGF0YSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICByZXR1cm4gbGluZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/semantic-callbacks.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/semantic-callbacks.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the AST translation callback functions for the semantic analysis\n// phase of the generator.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = apglib.ids;\n\n  /* Some helper functions. */\n  const NameList = function NameList() {\n    this.names = [];\n    /* Adds a new rule name object to the list. Returns -1 if the name already exists. */\n    /* Returns the added name object if the name does not already exist. */\n    this.add = function add(name) {\n      let ret = -1;\n      const find = this.get(name);\n      if (find === -1) {\n        ret = {\n          name,\n          lower: name.toLowerCase(),\n          index: this.names.length,\n        };\n        this.names.push(ret);\n      }\n      return ret;\n    };\n    /* Brute-force look up. */\n    this.get = function get(name) {\n      let ret = -1;\n      const lower = name.toLowerCase();\n      for (let i = 0; i < this.names.length; i += 1) {\n        if (this.names[i].lower === lower) {\n          ret = this.names[i];\n          break;\n        }\n      }\n      return ret;\n    };\n  };\n  /* converts text decimal numbers from, e.g. %d99, to an integer */\n  const decnum = function decnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 10 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text binary numbers from, e.g. %b10, to an integer */\n  const binnum = function binnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 2 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text hexadecimal numbers from, e.g. %xff, to an integer */\n  const hexnum = function hexnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      let digit = chars[i];\n      if (digit >= 48 && digit <= 57) {\n        digit -= 48;\n      } else if (digit >= 65 && digit <= 70) {\n        digit -= 55;\n      } else if (digit >= 97 && digit <= 102) {\n        digit -= 87;\n      } else {\n        throw new Error('hexnum out of range');\n      }\n      num = 16 * num + digit;\n    }\n    return num;\n  };\n\n  // This is the prototype for all semantic analysis callback functions.\n  // ````\n  // state - the translator state\n  //   id.SEM_PRE for downward (pre-branch) traversal of the AST\n  //   id.SEM_POST for upward (post branch) traversal of the AST\n  // chars - the array of character codes for the input string\n  // phraseIndex - index into the chars array to the first\n  //               character of the phrase\n  // phraseCount - the number of characters in the phrase\n  // data - user-defined data passed to the translator\n  //        for use by the callback functions.\n  // @return id.SEM_OK, normal return.\n  //         id.SEM_SKIP in state id.SEM_PRE will\n  //         skip the branch below.\n  //         Any thing else is an error which will\n  //         stop the translation.\n  // ````\n  /*\n  function semCallbackPrototype(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n    } else if (state === id.SEM_POST) {\n    }\n    return ret;\n  }\n  */\n  // The AST callback functions.\n  function semFile(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleNames = new NameList();\n      data.udtNames = new NameList();\n      data.rules = [];\n      data.udts = [];\n      data.rulesLineMap = [];\n      data.opcodes = [];\n      data.altStack = [];\n      data.topStack = null;\n      data.topRule = null;\n    } else if (state === id.SEM_POST) {\n      /* validate RNM rule names and set opcode rule index */\n      let nameObj;\n      data.rules.forEach((rule) => {\n        rule.isBkr = false;\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.RNM) {\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj === -1) {\n              data.errors.push({\n                line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                char: op.index.phraseIndex,\n                msg: `Rule name '${op.index.name}' used but not defined.`,\n              });\n              op.index = -1;\n            } else {\n              op.index = nameObj.index;\n            }\n          }\n        });\n      });\n      /* validate BKR rule names and set opcode rule index */\n      data.udts.forEach((udt) => {\n        udt.isBkr = false;\n      });\n      data.rules.forEach((rule) => {\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.BKR) {\n            rule.hasBkr = true;\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj !== -1) {\n              data.rules[nameObj.index].isBkr = true;\n              op.index = nameObj.index;\n            } else {\n              nameObj = data.udtNames.get(op.index.name);\n              if (nameObj !== -1) {\n                data.udts[nameObj.index].isBkr = true;\n                op.index = data.rules.length + nameObj.index;\n              } else {\n                data.errors.push({\n                  line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                  char: op.index.phraseIndex,\n                  msg: `Back reference name '${op.index.name}' refers to undefined rule or unamed UDT.`,\n                });\n                op.index = -1;\n              }\n            }\n          }\n        });\n      });\n    }\n    return ret;\n  }\n  function semRule(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.altStack.length = 0;\n      data.topStack = null;\n      data.rulesLineMap.push({\n        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleLookup(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = '';\n      data.definedas = '';\n    } else if (state === id.SEM_POST) {\n      let ruleName;\n      if (data.definedas === '=') {\n        ruleName = data.ruleNames.add(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' previously defined.`,\n          });\n        } else {\n          /* start a new rule */\n          data.topRule = {\n            name: ruleName.name,\n            lower: ruleName.lower,\n            opcodes: [],\n            index: ruleName.index,\n          };\n          data.rules.push(data.topRule);\n          data.opcodes = data.topRule.opcodes;\n        }\n      } else {\n        ruleName = data.ruleNames.get(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' for incremental alternate not previously defined.`,\n          });\n        } else {\n          data.topRule = data.rules[ruleName.index];\n          data.opcodes = data.topRule.opcodes;\n        }\n      }\n    }\n    return ret;\n  }\n  function semAlternation(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      const TRUE = true;\n      while (TRUE) {\n        if (data.definedas === null) {\n          /* rule error - skip opcode generation */\n          ret = id.SEM_SKIP;\n          break;\n        }\n        if (data.topStack === null) {\n          /* top-level ALT */\n          if (data.definedas === '=') {\n            /* \"=\" new rule */\n            data.topStack = {\n              alt: {\n                type: id.ALT,\n                children: [],\n              },\n              cat: null,\n            };\n            data.altStack.push(data.topStack);\n            data.opcodes.push(data.topStack.alt);\n            break;\n          }\n          /* \"=/\" incremental alternate */\n          data.topStack = {\n            alt: data.opcodes[0],\n            cat: null,\n          };\n          data.altStack.push(data.topStack);\n          break;\n        }\n        /* lower-level ALT */\n        data.topStack = {\n          alt: {\n            type: id.ALT,\n            children: [],\n          },\n          cat: null,\n        };\n        data.altStack.push(data.topStack);\n        data.opcodes.push(data.topStack.alt);\n        break;\n      }\n    } else if (state === id.SEM_POST) {\n      data.altStack.pop();\n      if (data.altStack.length > 0) {\n        data.topStack = data.altStack[data.altStack.length - 1];\n      } else {\n        data.topStack = null;\n      }\n    }\n    return ret;\n  }\n  function semConcatenation(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.alt.children.push(data.opcodes.length);\n      data.topStack.cat = {\n        type: id.CAT,\n        children: [],\n      };\n      data.opcodes.push(data.topStack.cat);\n    } else if (state === id.SEM_POST) {\n      data.topStack.cat = null;\n    }\n    return ret;\n  }\n  function semRepetition(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.cat.children.push(data.opcodes.length);\n    }\n    return ret;\n  }\n  function semOptionOpen(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.REP,\n        min: 0,\n        max: 1,\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDefined(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=';\n    }\n    return ret;\n  }\n  function semIncAlt(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=/';\n    }\n    return ret;\n  }\n  function semRepOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = Infinity;\n      data.topRep = {\n        type: id.REP,\n        min: 0,\n        max: Infinity,\n      };\n      data.opcodes.push(data.topRep);\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `repetition min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.topRep.min = data.min;\n      data.topRep.max = data.max;\n    }\n    return ret;\n  }\n  function semRepMin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMinMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n      data.min = data.max;\n    }\n    return ret;\n  }\n  function semAndOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AND,\n      });\n    }\n    return ret;\n  }\n  function semNotOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.NOT,\n      });\n    }\n    return ret;\n  }\n  function semRnmOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.RNM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex,\n          name: apglib.utils.charsToString(chars, phraseIndex, phraseCount),\n        },\n      });\n    }\n    return ret;\n  }\n  function semAbgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.ABG,\n      });\n    }\n    return ret;\n  }\n  function semAenOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AEN,\n      });\n    }\n    return ret;\n  }\n  function semBkaOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKA,\n      });\n    }\n    return ret;\n  }\n  function semBknOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKN,\n      });\n    }\n    return ret;\n  }\n  function semBkrOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ci = true; /* default to case insensitive */\n      data.cs = false;\n      data.um = true;\n      data.pm = false;\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKR,\n        bkrCase: data.cs === true ? id.BKR_MODE_CS : id.BKR_MODE_CI,\n        bkrMode: data.pm === true ? id.BKR_MODE_PM : id.BKR_MODE_UM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex: data.bkrname.phraseIndex,\n          name: apglib.utils.charsToString(chars, data.bkrname.phraseIndex, data.bkrname.phraseLength),\n        },\n      });\n    }\n    return ret;\n  }\n  function semBkrCi(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.ci = true;\n    }\n    return ret;\n  }\n  function semBkrCs(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.cs = true;\n    }\n    return ret;\n  }\n  function semBkrUm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.um = true;\n    }\n    return ret;\n  }\n  function semBkrPm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.pm = true;\n    }\n    return ret;\n  }\n  function semBkrName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.bkrname = {\n        phraseIndex,\n        phraseLength: phraseCount,\n      };\n    }\n    return ret;\n  }\n  function semUdtEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: true,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: true,\n        index: udtName.index,\n      });\n    }\n    return ret;\n  }\n  function semUdtNonEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtNonEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: false,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: false,\n        index: udtName.index,\n        syntax: null,\n        semantic: null,\n      });\n    }\n    return ret;\n  }\n  function semTlsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tlscase = true; /* default to case insensitive */\n    }\n    return ret;\n  }\n  function semTlsCase(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount > 0 && (chars[phraseIndex + 1] === 83 || chars[phraseIndex + 1] === 115)) {\n        data.tlscase = false; /* set to case sensitive */\n      }\n    }\n    return ret;\n  }\n  function semTlsString(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (data.tlscase) {\n        const str = chars.slice(phraseIndex, phraseIndex + phraseCount);\n        for (let i = 0; i < str.length; i += 1) {\n          if (str[i] >= 65 && str[i] <= 90) {\n            str[i] += 32;\n          }\n        }\n        data.opcodes.push({\n          type: id.TLS,\n          string: str,\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex, phraseIndex + phraseCount),\n        });\n      }\n    }\n    return ret;\n  }\n  function semClsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount <= 2) {\n        /* only TLS is allowed to be empty */\n        data.opcodes.push({\n          type: id.TLS,\n          string: [],\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex + 1, phraseIndex + phraseCount - 1),\n        });\n      }\n    }\n    return ret;\n  }\n  function semTbsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tbsstr = [];\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.TBS,\n        string: data.tbsstr,\n      });\n    }\n    return ret;\n  }\n  function semTrgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = 0;\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.opcodes.push({\n        type: id.TRG,\n        min: data.min,\n        max: data.max,\n      });\n    }\n    return ret;\n  }\n  function semDmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(decnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semBstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(binnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semXstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(hexnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  // Define the callback functions to the AST object.\n  this.callbacks = [];\n  this.callbacks.abgop = semAbgOp;\n  this.callbacks.aenop = semAenOp;\n  this.callbacks.alternation = semAlternation;\n  this.callbacks.andop = semAndOp;\n  this.callbacks.bmax = semBmax;\n  this.callbacks.bmin = semBmin;\n  this.callbacks.bkaop = semBkaOp;\n  this.callbacks.bknop = semBknOp;\n  this.callbacks.bkrop = semBkrOp;\n  this.callbacks['bkr-name'] = semBkrName;\n  this.callbacks.bstring = semBstring;\n  this.callbacks.clsop = semClsOp;\n  this.callbacks.ci = semBkrCi;\n  this.callbacks.cs = semBkrCs;\n  this.callbacks.um = semBkrUm;\n  this.callbacks.pm = semBkrPm;\n  this.callbacks.concatenation = semConcatenation;\n  this.callbacks.defined = semDefined;\n  this.callbacks.dmax = semDmax;\n  this.callbacks.dmin = semDmin;\n  this.callbacks.dstring = semDstring;\n  this.callbacks.file = semFile;\n  this.callbacks.incalt = semIncAlt;\n  this.callbacks.notop = semNotOp;\n  this.callbacks.optionopen = semOptionOpen;\n  this.callbacks['rep-max'] = semRepMax;\n  this.callbacks['rep-min'] = semRepMin;\n  this.callbacks['rep-min-max'] = semRepMinMax;\n  this.callbacks.repetition = semRepetition;\n  this.callbacks.repop = semRepOp;\n  this.callbacks.rnmop = semRnmOp;\n  this.callbacks.rule = semRule;\n  this.callbacks.rulelookup = semRuleLookup;\n  this.callbacks.rulename = semRuleName;\n  this.callbacks.tbsop = semTbsOp;\n  this.callbacks.tlscase = semTlsCase;\n  this.callbacks.tlsstring = semTlsString;\n  this.callbacks.tlsop = semTlsOp;\n  this.callbacks.trgop = semTrgOp;\n  this.callbacks['udt-empty'] = semUdtEmpty;\n  this.callbacks['udt-non-empty'] = semUdtNonEmpty;\n  this.callbacks.xmax = semXmax;\n  this.callbacks.xmin = semXmin;\n  this.callbacks.xstring = semXstring;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NlbWFudGljLWNhbGxiYWNrcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDRIQUF5QjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCxlQUFlO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QyxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFNBQVMsU0FBUyxTQUFTO0FBQzdGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxTQUFTLFNBQVMsU0FBUztBQUNwRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2VtYW50aWMtY2FsbGJhY2tzLmpzPzQ2MDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgaGFzIGFsbCBvZiB0aGUgQVNUIHRyYW5zbGF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIHNlbWFudGljIGFuYWx5c2lzXG4vLyBwaGFzZSBvZiB0aGUgZ2VuZXJhdG9yLlxuLy8gU2VlOjxicj5cbi8vIGAuL2Rpc3QvYWJuZi1mb3Itc2FibmYtZ3JhbW1hci5ibmZgPGJyPlxuLy8gZm9yIHRoZSBncmFtbWFyIGZpbGUgdGhlc2UgY2FsbGJhY2sgZnVuY3Rpb25zIGFyZSBiYXNlZCBvbi5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhmbigpIHtcbiAgY29uc3QgYXBnbGliID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHMnKTtcbiAgY29uc3QgaWQgPSBhcGdsaWIuaWRzO1xuXG4gIC8qIFNvbWUgaGVscGVyIGZ1bmN0aW9ucy4gKi9cbiAgY29uc3QgTmFtZUxpc3QgPSBmdW5jdGlvbiBOYW1lTGlzdCgpIHtcbiAgICB0aGlzLm5hbWVzID0gW107XG4gICAgLyogQWRkcyBhIG5ldyBydWxlIG5hbWUgb2JqZWN0IHRvIHRoZSBsaXN0LiBSZXR1cm5zIC0xIGlmIHRoZSBuYW1lIGFscmVhZHkgZXhpc3RzLiAqL1xuICAgIC8qIFJldHVybnMgdGhlIGFkZGVkIG5hbWUgb2JqZWN0IGlmIHRoZSBuYW1lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuICovXG4gICAgdGhpcy5hZGQgPSBmdW5jdGlvbiBhZGQobmFtZSkge1xuICAgICAgbGV0IHJldCA9IC0xO1xuICAgICAgY29uc3QgZmluZCA9IHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgaWYgKGZpbmQgPT09IC0xKSB7XG4gICAgICAgIHJldCA9IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGxvd2VyOiBuYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgaW5kZXg6IHRoaXMubmFtZXMubGVuZ3RoLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWVzLnB1c2gocmV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICAvKiBCcnV0ZS1mb3JjZSBsb29rIHVwLiAqL1xuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIGxldCByZXQgPSAtMTtcbiAgICAgIGNvbnN0IGxvd2VyID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWVzW2ldLmxvd2VyID09PSBsb3dlcikge1xuICAgICAgICAgIHJldCA9IHRoaXMubmFtZXNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfTtcbiAgLyogY29udmVydHMgdGV4dCBkZWNpbWFsIG51bWJlcnMgZnJvbSwgZS5nLiAlZDk5LCB0byBhbiBpbnRlZ2VyICovXG4gIGNvbnN0IGRlY251bSA9IGZ1bmN0aW9uIGRlY251bShjaGFycywgYmVnLCBsZW4pIHtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBmb3IgKGxldCBpID0gYmVnOyBpIDwgYmVnICsgbGVuOyBpICs9IDEpIHtcbiAgICAgIG51bSA9IDEwICogbnVtICsgY2hhcnNbaV0gLSA0ODtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcbiAgLyogY29udmVydHMgdGV4dCBiaW5hcnkgbnVtYmVycyBmcm9tLCBlLmcuICViMTAsIHRvIGFuIGludGVnZXIgKi9cbiAgY29uc3QgYmlubnVtID0gZnVuY3Rpb24gYmlubnVtKGNoYXJzLCBiZWcsIGxlbikge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSBiZWc7IGkgPCBiZWcgKyBsZW47IGkgKz0gMSkge1xuICAgICAgbnVtID0gMiAqIG51bSArIGNoYXJzW2ldIC0gNDg7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG4gIC8qIGNvbnZlcnRzIHRleHQgaGV4YWRlY2ltYWwgbnVtYmVycyBmcm9tLCBlLmcuICV4ZmYsIHRvIGFuIGludGVnZXIgKi9cbiAgY29uc3QgaGV4bnVtID0gZnVuY3Rpb24gaGV4bnVtKGNoYXJzLCBiZWcsIGxlbikge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSBiZWc7IGkgPCBiZWcgKyBsZW47IGkgKz0gMSkge1xuICAgICAgbGV0IGRpZ2l0ID0gY2hhcnNbaV07XG4gICAgICBpZiAoZGlnaXQgPj0gNDggJiYgZGlnaXQgPD0gNTcpIHtcbiAgICAgICAgZGlnaXQgLT0gNDg7XG4gICAgICB9IGVsc2UgaWYgKGRpZ2l0ID49IDY1ICYmIGRpZ2l0IDw9IDcwKSB7XG4gICAgICAgIGRpZ2l0IC09IDU1O1xuICAgICAgfSBlbHNlIGlmIChkaWdpdCA+PSA5NyAmJiBkaWdpdCA8PSAxMDIpIHtcbiAgICAgICAgZGlnaXQgLT0gODc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleG51bSBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIG51bSA9IDE2ICogbnVtICsgZGlnaXQ7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyB0aGUgcHJvdG90eXBlIGZvciBhbGwgc2VtYW50aWMgYW5hbHlzaXMgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAvLyBgYGBgXG4gIC8vIHN0YXRlIC0gdGhlIHRyYW5zbGF0b3Igc3RhdGVcbiAgLy8gICBpZC5TRU1fUFJFIGZvciBkb3dud2FyZCAocHJlLWJyYW5jaCkgdHJhdmVyc2FsIG9mIHRoZSBBU1RcbiAgLy8gICBpZC5TRU1fUE9TVCBmb3IgdXB3YXJkIChwb3N0IGJyYW5jaCkgdHJhdmVyc2FsIG9mIHRoZSBBU1RcbiAgLy8gY2hhcnMgLSB0aGUgYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzIGZvciB0aGUgaW5wdXQgc3RyaW5nXG4gIC8vIHBocmFzZUluZGV4IC0gaW5kZXggaW50byB0aGUgY2hhcnMgYXJyYXkgdG8gdGhlIGZpcnN0XG4gIC8vICAgICAgICAgICAgICAgY2hhcmFjdGVyIG9mIHRoZSBwaHJhc2VcbiAgLy8gcGhyYXNlQ291bnQgLSB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gdGhlIHBocmFzZVxuICAvLyBkYXRhIC0gdXNlci1kZWZpbmVkIGRhdGEgcGFzc2VkIHRvIHRoZSB0cmFuc2xhdG9yXG4gIC8vICAgICAgICBmb3IgdXNlIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIC8vIEByZXR1cm4gaWQuU0VNX09LLCBub3JtYWwgcmV0dXJuLlxuICAvLyAgICAgICAgIGlkLlNFTV9TS0lQIGluIHN0YXRlIGlkLlNFTV9QUkUgd2lsbFxuICAvLyAgICAgICAgIHNraXAgdGhlIGJyYW5jaCBiZWxvdy5cbiAgLy8gICAgICAgICBBbnkgdGhpbmcgZWxzZSBpcyBhbiBlcnJvciB3aGljaCB3aWxsXG4gIC8vICAgICAgICAgc3RvcCB0aGUgdHJhbnNsYXRpb24uXG4gIC8vIGBgYGBcbiAgLypcbiAgZnVuY3Rpb24gc2VtQ2FsbGJhY2tQcm90b3R5cGUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBsZXQgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgKi9cbiAgLy8gVGhlIEFTVCBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIHNlbUZpbGUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnJ1bGVOYW1lcyA9IG5ldyBOYW1lTGlzdCgpO1xuICAgICAgZGF0YS51ZHROYW1lcyA9IG5ldyBOYW1lTGlzdCgpO1xuICAgICAgZGF0YS5ydWxlcyA9IFtdO1xuICAgICAgZGF0YS51ZHRzID0gW107XG4gICAgICBkYXRhLnJ1bGVzTGluZU1hcCA9IFtdO1xuICAgICAgZGF0YS5vcGNvZGVzID0gW107XG4gICAgICBkYXRhLmFsdFN0YWNrID0gW107XG4gICAgICBkYXRhLnRvcFN0YWNrID0gbnVsbDtcbiAgICAgIGRhdGEudG9wUnVsZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIC8qIHZhbGlkYXRlIFJOTSBydWxlIG5hbWVzIGFuZCBzZXQgb3Bjb2RlIHJ1bGUgaW5kZXggKi9cbiAgICAgIGxldCBuYW1lT2JqO1xuICAgICAgZGF0YS5ydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICAgIHJ1bGUuaXNCa3IgPSBmYWxzZTtcbiAgICAgICAgcnVsZS5vcGNvZGVzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgICAgaWYgKG9wLnR5cGUgPT09IGlkLlJOTSkge1xuICAgICAgICAgICAgbmFtZU9iaiA9IGRhdGEucnVsZU5hbWVzLmdldChvcC5pbmRleC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lT2JqID09PSAtMSkge1xuICAgICAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIG9wLmluZGV4LnBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBjaGFyOiBvcC5pbmRleC5waHJhc2VJbmRleCxcbiAgICAgICAgICAgICAgICBtc2c6IGBSdWxlIG5hbWUgJyR7b3AuaW5kZXgubmFtZX0nIHVzZWQgYnV0IG5vdCBkZWZpbmVkLmAsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBvcC5pbmRleCA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3AuaW5kZXggPSBuYW1lT2JqLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8qIHZhbGlkYXRlIEJLUiBydWxlIG5hbWVzIGFuZCBzZXQgb3Bjb2RlIHJ1bGUgaW5kZXggKi9cbiAgICAgIGRhdGEudWR0cy5mb3JFYWNoKCh1ZHQpID0+IHtcbiAgICAgICAgdWR0LmlzQmtyID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGRhdGEucnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgICBydWxlLm9wY29kZXMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gaWQuQktSKSB7XG4gICAgICAgICAgICBydWxlLmhhc0JrciA9IHRydWU7XG4gICAgICAgICAgICBuYW1lT2JqID0gZGF0YS5ydWxlTmFtZXMuZ2V0KG9wLmluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWVPYmogIT09IC0xKSB7XG4gICAgICAgICAgICAgIGRhdGEucnVsZXNbbmFtZU9iai5pbmRleF0uaXNCa3IgPSB0cnVlO1xuICAgICAgICAgICAgICBvcC5pbmRleCA9IG5hbWVPYmouaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lT2JqID0gZGF0YS51ZHROYW1lcy5nZXQob3AuaW5kZXgubmFtZSk7XG4gICAgICAgICAgICAgIGlmIChuYW1lT2JqICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGRhdGEudWR0c1tuYW1lT2JqLmluZGV4XS5pc0JrciA9IHRydWU7XG4gICAgICAgICAgICAgICAgb3AuaW5kZXggPSBkYXRhLnJ1bGVzLmxlbmd0aCArIG5hbWVPYmouaW5kZXg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIG9wLmluZGV4LnBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIGNoYXI6IG9wLmluZGV4LnBocmFzZUluZGV4LFxuICAgICAgICAgICAgICAgICAgbXNnOiBgQmFjayByZWZlcmVuY2UgbmFtZSAnJHtvcC5pbmRleC5uYW1lfScgcmVmZXJzIHRvIHVuZGVmaW5lZCBydWxlIG9yIHVuYW1lZCBVRFQuYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcC5pbmRleCA9IC0xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJ1bGUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLmFsdFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICBkYXRhLnRvcFN0YWNrID0gbnVsbDtcbiAgICAgIGRhdGEucnVsZXNMaW5lTWFwLnB1c2goe1xuICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SdWxlTG9va3VwKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS5ydWxlTmFtZSA9ICcnO1xuICAgICAgZGF0YS5kZWZpbmVkYXMgPSAnJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgbGV0IHJ1bGVOYW1lO1xuICAgICAgaWYgKGRhdGEuZGVmaW5lZGFzID09PSAnPScpIHtcbiAgICAgICAgcnVsZU5hbWUgPSBkYXRhLnJ1bGVOYW1lcy5hZGQoZGF0YS5ydWxlTmFtZSk7XG4gICAgICAgIGlmIChydWxlTmFtZSA9PT0gLTEpIHtcbiAgICAgICAgICBkYXRhLmRlZmluZWRhcyA9IG51bGw7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiBgUnVsZSBuYW1lICcke2RhdGEucnVsZU5hbWV9JyBwcmV2aW91c2x5IGRlZmluZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBzdGFydCBhIG5ldyBydWxlICovXG4gICAgICAgICAgZGF0YS50b3BSdWxlID0ge1xuICAgICAgICAgICAgbmFtZTogcnVsZU5hbWUubmFtZSxcbiAgICAgICAgICAgIGxvd2VyOiBydWxlTmFtZS5sb3dlcixcbiAgICAgICAgICAgIG9wY29kZXM6IFtdLFxuICAgICAgICAgICAgaW5kZXg6IHJ1bGVOYW1lLmluZGV4LFxuICAgICAgICAgIH07XG4gICAgICAgICAgZGF0YS5ydWxlcy5wdXNoKGRhdGEudG9wUnVsZSk7XG4gICAgICAgICAgZGF0YS5vcGNvZGVzID0gZGF0YS50b3BSdWxlLm9wY29kZXM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ1bGVOYW1lID0gZGF0YS5ydWxlTmFtZXMuZ2V0KGRhdGEucnVsZU5hbWUpO1xuICAgICAgICBpZiAocnVsZU5hbWUgPT09IC0xKSB7XG4gICAgICAgICAgZGF0YS5kZWZpbmVkYXMgPSBudWxsO1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogYFJ1bGUgbmFtZSAnJHtkYXRhLnJ1bGVOYW1lfScgZm9yIGluY3JlbWVudGFsIGFsdGVybmF0ZSBub3QgcHJldmlvdXNseSBkZWZpbmVkLmAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YS50b3BSdWxlID0gZGF0YS5ydWxlc1tydWxlTmFtZS5pbmRleF07XG4gICAgICAgICAgZGF0YS5vcGNvZGVzID0gZGF0YS50b3BSdWxlLm9wY29kZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1BbHRlcm5hdGlvbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGxldCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgIGlmIChkYXRhLmRlZmluZWRhcyA9PT0gbnVsbCkge1xuICAgICAgICAgIC8qIHJ1bGUgZXJyb3IgLSBza2lwIG9wY29kZSBnZW5lcmF0aW9uICovXG4gICAgICAgICAgcmV0ID0gaWQuU0VNX1NLSVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudG9wU3RhY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAvKiB0b3AtbGV2ZWwgQUxUICovXG4gICAgICAgICAgaWYgKGRhdGEuZGVmaW5lZGFzID09PSAnPScpIHtcbiAgICAgICAgICAgIC8qIFwiPVwiIG5ldyBydWxlICovXG4gICAgICAgICAgICBkYXRhLnRvcFN0YWNrID0ge1xuICAgICAgICAgICAgICBhbHQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBpZC5BTFQsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjYXQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YS5hbHRTdGFjay5wdXNoKGRhdGEudG9wU3RhY2spO1xuICAgICAgICAgICAgZGF0YS5vcGNvZGVzLnB1c2goZGF0YS50b3BTdGFjay5hbHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIFwiPS9cIiBpbmNyZW1lbnRhbCBhbHRlcm5hdGUgKi9cbiAgICAgICAgICBkYXRhLnRvcFN0YWNrID0ge1xuICAgICAgICAgICAgYWx0OiBkYXRhLm9wY29kZXNbMF0sXG4gICAgICAgICAgICBjYXQ6IG51bGwsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBkYXRhLmFsdFN0YWNrLnB1c2goZGF0YS50b3BTdGFjayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyogbG93ZXItbGV2ZWwgQUxUICovXG4gICAgICAgIGRhdGEudG9wU3RhY2sgPSB7XG4gICAgICAgICAgYWx0OiB7XG4gICAgICAgICAgICB0eXBlOiBpZC5BTFQsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGRhdGEuYWx0U3RhY2sucHVzaChkYXRhLnRvcFN0YWNrKTtcbiAgICAgICAgZGF0YS5vcGNvZGVzLnB1c2goZGF0YS50b3BTdGFjay5hbHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5hbHRTdGFjay5wb3AoKTtcbiAgICAgIGlmIChkYXRhLmFsdFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGF0YS50b3BTdGFjayA9IGRhdGEuYWx0U3RhY2tbZGF0YS5hbHRTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEudG9wU3RhY2sgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUNvbmNhdGVuYXRpb24oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnRvcFN0YWNrLmFsdC5jaGlsZHJlbi5wdXNoKGRhdGEub3Bjb2Rlcy5sZW5ndGgpO1xuICAgICAgZGF0YS50b3BTdGFjay5jYXQgPSB7XG4gICAgICAgIHR5cGU6IGlkLkNBVCxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgfTtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKGRhdGEudG9wU3RhY2suY2F0KTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS50b3BTdGFjay5jYXQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJlcGV0aXRpb24oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnRvcFN0YWNrLmNhdC5jaGlsZHJlbi5wdXNoKGRhdGEub3Bjb2Rlcy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbU9wdGlvbk9wZW4oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5SRVAsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxLFxuICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJ1bGVOYW1lKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS5ydWxlTmFtZSA9IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbURlZmluZWQoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5kZWZpbmVkYXMgPSAnPSc7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtSW5jQWx0KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEuZGVmaW5lZGFzID0gJz0vJztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SZXBPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEubWluID0gMDtcbiAgICAgIGRhdGEubWF4ID0gSW5maW5pdHk7XG4gICAgICBkYXRhLnRvcFJlcCA9IHtcbiAgICAgICAgdHlwZTogaWQuUkVQLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogSW5maW5pdHksXG4gICAgICB9O1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goZGF0YS50b3BSZXApO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBpZiAoZGF0YS5taW4gPiBkYXRhLm1heCkge1xuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6IGByZXBldGl0aW9uIG1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIG1heDogbWluOiAke2RhdGEubWlufTogbWF4OiAke2RhdGEubWF4fWAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGF0YS50b3BSZXAubWluID0gZGF0YS5taW47XG4gICAgICBkYXRhLnRvcFJlcC5tYXggPSBkYXRhLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SZXBNaW4oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5taW4gPSBkZWNudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUmVwTWF4KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWF4ID0gZGVjbnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJlcE1pbk1heChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1heCA9IGRlY251bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICAgIGRhdGEubWluID0gZGF0YS5tYXg7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQW5kT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5BTkQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ob3RPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLk5PVCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJubU9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuUk5NLFxuICAgICAgICAvKiBOT1RFOiB0aGlzIGlzIHRlbXBvcmFyeSBpbmZvLCBpbmRleCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggaW50ZWdlciBsYXRlci4gKi9cbiAgICAgICAgLyogUHJvYmFibHkgbm90IHRoZSBiZXN0IGNvZGluZyBwcmFjdGljZSBidXQgaGVyZSB5b3UgZ28uICovXG4gICAgICAgIGluZGV4OiB7XG4gICAgICAgICAgcGhyYXNlSW5kZXgsXG4gICAgICAgICAgbmFtZTogYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCksXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1BYmdPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLkFCRyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUFlbk9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuQUVOLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmthT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5CS0EsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca25PcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLkJLTixcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJrck9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS5jaSA9IHRydWU7IC8qIGRlZmF1bHQgdG8gY2FzZSBpbnNlbnNpdGl2ZSAqL1xuICAgICAgZGF0YS5jcyA9IGZhbHNlO1xuICAgICAgZGF0YS51bSA9IHRydWU7XG4gICAgICBkYXRhLnBtID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuQktSLFxuICAgICAgICBia3JDYXNlOiBkYXRhLmNzID09PSB0cnVlID8gaWQuQktSX01PREVfQ1MgOiBpZC5CS1JfTU9ERV9DSSxcbiAgICAgICAgYmtyTW9kZTogZGF0YS5wbSA9PT0gdHJ1ZSA/IGlkLkJLUl9NT0RFX1BNIDogaWQuQktSX01PREVfVU0sXG4gICAgICAgIC8qIE5PVEU6IHRoaXMgaXMgdGVtcG9yYXJ5IGluZm8sIGluZGV4IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBpbnRlZ2VyIGxhdGVyLiAqL1xuICAgICAgICAvKiBQcm9iYWJseSBub3QgdGhlIGJlc3QgY29kaW5nIHByYWN0aWNlIGJ1dCBoZXJlIHlvdSBnby4gKi9cbiAgICAgICAgaW5kZXg6IHtcbiAgICAgICAgICBwaHJhc2VJbmRleDogZGF0YS5ia3JuYW1lLnBocmFzZUluZGV4LFxuICAgICAgICAgIG5hbWU6IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBkYXRhLmJrcm5hbWUucGhyYXNlSW5kZXgsIGRhdGEuYmtybmFtZS5waHJhc2VMZW5ndGgpLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyQ2koc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5jaSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyQ3Moc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5jcyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyVW0oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS51bSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyUG0oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5wbSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyTmFtZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLmJrcm5hbWUgPSB7XG4gICAgICAgIHBocmFzZUluZGV4LFxuICAgICAgICBwaHJhc2VMZW5ndGg6IHBocmFzZUNvdW50LFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1VZHRFbXB0eShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBjb25zdCBuYW1lID0gYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgICBsZXQgdWR0TmFtZSA9IGRhdGEudWR0TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgaWYgKHVkdE5hbWUgPT09IC0xKSB7XG4gICAgICAgIHVkdE5hbWUgPSBkYXRhLnVkdE5hbWVzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKHVkdE5hbWUgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZW1VZHRFbXB0eTogbmFtZSBsb29rIHVwIGVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEudWR0cy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiB1ZHROYW1lLm5hbWUsXG4gICAgICAgICAgbG93ZXI6IHVkdE5hbWUubG93ZXIsXG4gICAgICAgICAgaW5kZXg6IHVkdE5hbWUuaW5kZXgsXG4gICAgICAgICAgZW1wdHk6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5VRFQsXG4gICAgICAgIGVtcHR5OiB0cnVlLFxuICAgICAgICBpbmRleDogdWR0TmFtZS5pbmRleCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVVkdE5vbkVtcHR5KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhcGdsaWIudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICAgIGxldCB1ZHROYW1lID0gZGF0YS51ZHROYW1lcy5hZGQobmFtZSk7XG4gICAgICBpZiAodWR0TmFtZSA9PT0gLTEpIHtcbiAgICAgICAgdWR0TmFtZSA9IGRhdGEudWR0TmFtZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAodWR0TmFtZSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlbVVkdE5vbkVtcHR5OiBuYW1lIGxvb2sgdXAgZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS51ZHRzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHVkdE5hbWUubmFtZSxcbiAgICAgICAgICBsb3dlcjogdWR0TmFtZS5sb3dlcixcbiAgICAgICAgICBpbmRleDogdWR0TmFtZS5pbmRleCxcbiAgICAgICAgICBlbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5VRFQsXG4gICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgaW5kZXg6IHVkdE5hbWUuaW5kZXgsXG4gICAgICAgIHN5bnRheDogbnVsbCxcbiAgICAgICAgc2VtYW50aWM6IG51bGwsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1UbHNPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEudGxzY2FzZSA9IHRydWU7IC8qIGRlZmF1bHQgdG8gY2FzZSBpbnNlbnNpdGl2ZSAqL1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVRsc0Nhc2Uoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgaWYgKHBocmFzZUNvdW50ID4gMCAmJiAoY2hhcnNbcGhyYXNlSW5kZXggKyAxXSA9PT0gODMgfHwgY2hhcnNbcGhyYXNlSW5kZXggKyAxXSA9PT0gMTE1KSkge1xuICAgICAgICBkYXRhLnRsc2Nhc2UgPSBmYWxzZTsgLyogc2V0IHRvIGNhc2Ugc2Vuc2l0aXZlICovXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtVGxzU3RyaW5nKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGlmIChkYXRhLnRsc2Nhc2UpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gY2hhcnMuc2xpY2UocGhyYXNlSW5kZXgsIHBocmFzZUluZGV4ICsgcGhyYXNlQ291bnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChzdHJbaV0gPj0gNjUgJiYgc3RyW2ldIDw9IDkwKSB7XG4gICAgICAgICAgICBzdHJbaV0gKz0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBpZC5UTFMsXG4gICAgICAgICAgc3RyaW5nOiBzdHIsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGlkLlRCUyxcbiAgICAgICAgICBzdHJpbmc6IGNoYXJzLnNsaWNlKHBocmFzZUluZGV4LCBwaHJhc2VJbmRleCArIHBocmFzZUNvdW50KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQ2xzT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgaWYgKHBocmFzZUNvdW50IDw9IDIpIHtcbiAgICAgICAgLyogb25seSBUTFMgaXMgYWxsb3dlZCB0byBiZSBlbXB0eSAqL1xuICAgICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogaWQuVExTLFxuICAgICAgICAgIHN0cmluZzogW10sXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGlkLlRCUyxcbiAgICAgICAgICBzdHJpbmc6IGNoYXJzLnNsaWNlKHBocmFzZUluZGV4ICsgMSwgcGhyYXNlSW5kZXggKyBwaHJhc2VDb3VudCAtIDEpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1UYnNPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEudGJzc3RyID0gW107XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuVEJTLFxuICAgICAgICBzdHJpbmc6IGRhdGEudGJzc3RyLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtVHJnT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLm1pbiA9IDA7XG4gICAgICBkYXRhLm1heCA9IDA7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGlmIChkYXRhLm1pbiA+IGRhdGEubWF4KSB7XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgIG1zZzogYFRSRywgKCVkbWluLW1heCksIG1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIG1heDogbWluOiAke2RhdGEubWlufTogbWF4OiAke2RhdGEubWF4fWAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5UUkcsXG4gICAgICAgIG1pbjogZGF0YS5taW4sXG4gICAgICAgIG1heDogZGF0YS5tYXgsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1EbWluKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWluID0gZGVjbnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbURtYXgoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5tYXggPSBkZWNudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQm1pbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1pbiA9IGJpbm51bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1CbWF4KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWF4ID0gYmlubnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVhtaW4oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5taW4gPSBoZXhudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtWG1heChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1heCA9IGhleG51bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ec3RyaW5nKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEudGJzc3RyLnB1c2goZGVjbnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Cc3RyaW5nKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEudGJzc3RyLnB1c2goYmlubnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Yc3RyaW5nKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEudGJzc3RyLnB1c2goaGV4bnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvLyBEZWZpbmUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucyB0byB0aGUgQVNUIG9iamVjdC5cbiAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgdGhpcy5jYWxsYmFja3MuYWJnb3AgPSBzZW1BYmdPcDtcbiAgdGhpcy5jYWxsYmFja3MuYWVub3AgPSBzZW1BZW5PcDtcbiAgdGhpcy5jYWxsYmFja3MuYWx0ZXJuYXRpb24gPSBzZW1BbHRlcm5hdGlvbjtcbiAgdGhpcy5jYWxsYmFja3MuYW5kb3AgPSBzZW1BbmRPcDtcbiAgdGhpcy5jYWxsYmFja3MuYm1heCA9IHNlbUJtYXg7XG4gIHRoaXMuY2FsbGJhY2tzLmJtaW4gPSBzZW1CbWluO1xuICB0aGlzLmNhbGxiYWNrcy5ia2FvcCA9IHNlbUJrYU9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia25vcCA9IHNlbUJrbk9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia3JvcCA9IHNlbUJrck9wO1xuICB0aGlzLmNhbGxiYWNrc1snYmtyLW5hbWUnXSA9IHNlbUJrck5hbWU7XG4gIHRoaXMuY2FsbGJhY2tzLmJzdHJpbmcgPSBzZW1Cc3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy5jbHNvcCA9IHNlbUNsc09wO1xuICB0aGlzLmNhbGxiYWNrcy5jaSA9IHNlbUJrckNpO1xuICB0aGlzLmNhbGxiYWNrcy5jcyA9IHNlbUJrckNzO1xuICB0aGlzLmNhbGxiYWNrcy51bSA9IHNlbUJrclVtO1xuICB0aGlzLmNhbGxiYWNrcy5wbSA9IHNlbUJrclBtO1xuICB0aGlzLmNhbGxiYWNrcy5jb25jYXRlbmF0aW9uID0gc2VtQ29uY2F0ZW5hdGlvbjtcbiAgdGhpcy5jYWxsYmFja3MuZGVmaW5lZCA9IHNlbURlZmluZWQ7XG4gIHRoaXMuY2FsbGJhY2tzLmRtYXggPSBzZW1EbWF4O1xuICB0aGlzLmNhbGxiYWNrcy5kbWluID0gc2VtRG1pbjtcbiAgdGhpcy5jYWxsYmFja3MuZHN0cmluZyA9IHNlbURzdHJpbmc7XG4gIHRoaXMuY2FsbGJhY2tzLmZpbGUgPSBzZW1GaWxlO1xuICB0aGlzLmNhbGxiYWNrcy5pbmNhbHQgPSBzZW1JbmNBbHQ7XG4gIHRoaXMuY2FsbGJhY2tzLm5vdG9wID0gc2VtTm90T3A7XG4gIHRoaXMuY2FsbGJhY2tzLm9wdGlvbm9wZW4gPSBzZW1PcHRpb25PcGVuO1xuICB0aGlzLmNhbGxiYWNrc1sncmVwLW1heCddID0gc2VtUmVwTWF4O1xuICB0aGlzLmNhbGxiYWNrc1sncmVwLW1pbiddID0gc2VtUmVwTWluO1xuICB0aGlzLmNhbGxiYWNrc1sncmVwLW1pbi1tYXgnXSA9IHNlbVJlcE1pbk1heDtcbiAgdGhpcy5jYWxsYmFja3MucmVwZXRpdGlvbiA9IHNlbVJlcGV0aXRpb247XG4gIHRoaXMuY2FsbGJhY2tzLnJlcG9wID0gc2VtUmVwT3A7XG4gIHRoaXMuY2FsbGJhY2tzLnJubW9wID0gc2VtUm5tT3A7XG4gIHRoaXMuY2FsbGJhY2tzLnJ1bGUgPSBzZW1SdWxlO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlbG9va3VwID0gc2VtUnVsZUxvb2t1cDtcbiAgdGhpcy5jYWxsYmFja3MucnVsZW5hbWUgPSBzZW1SdWxlTmFtZTtcbiAgdGhpcy5jYWxsYmFja3MudGJzb3AgPSBzZW1UYnNPcDtcbiAgdGhpcy5jYWxsYmFja3MudGxzY2FzZSA9IHNlbVRsc0Nhc2U7XG4gIHRoaXMuY2FsbGJhY2tzLnRsc3N0cmluZyA9IHNlbVRsc1N0cmluZztcbiAgdGhpcy5jYWxsYmFja3MudGxzb3AgPSBzZW1UbHNPcDtcbiAgdGhpcy5jYWxsYmFja3MudHJnb3AgPSBzZW1UcmdPcDtcbiAgdGhpcy5jYWxsYmFja3NbJ3VkdC1lbXB0eSddID0gc2VtVWR0RW1wdHk7XG4gIHRoaXMuY2FsbGJhY2tzWyd1ZHQtbm9uLWVtcHR5J10gPSBzZW1VZHROb25FbXB0eTtcbiAgdGhpcy5jYWxsYmFja3MueG1heCA9IHNlbVhtYXg7XG4gIHRoaXMuY2FsbGJhY2tzLnhtaW4gPSBzZW1YbWluO1xuICB0aGlzLmNhbGxiYWNrcy54c3RyaW5nID0gc2VtWHN0cmluZztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/semantic-callbacks.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/show-rules.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/show-rules.js ***!
  \*******************************************************************************************/
/***/ ((module) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\nmodule.exports = (function exfn() {\n  const thisFileName = 'show-rules.js';\n  // Display the rules.\n  // This function may be called before the attributes calculation.\n  // Sorting is done independently from the attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  const showRules = function showRules(rulesIn = [], udtsIn = [], order = 'index') {\n    const thisFuncName = 'showRules';\n    let alphaArray = [];\n    let udtAlphaArray = [];\n    const indexArray = [];\n    const udtIndexArray = [];\n    const rules = rulesIn;\n    const udts = udtsIn;\n    const ruleCount = rulesIn.length;\n    const udtCount = udtsIn.length;\n    let str = 'RULE/UDT NAMES';\n    let i;\n    function compRulesAlpha(left, right) {\n      if (rules[left].lower < rules[right].lower) {\n        return -1;\n      }\n      if (rules[left].lower > rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    function compUdtsAlpha(left, right) {\n      if (udts[left].lower < udts[right].lower) {\n        return -1;\n      }\n      if (udts[left].lower > udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    if (!(Array.isArray(rulesIn) && rulesIn.length)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: rules arg must be array with length > 0`);\n    }\n    if (!Array.isArray(udtsIn)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: udts arg must be array`);\n    }\n\n    for (i = 0; i < ruleCount; i += 1) {\n      indexArray.push(i);\n    }\n    alphaArray = indexArray.slice(0);\n    alphaArray.sort(compRulesAlpha);\n    if (udtCount) {\n      for (i = 0; i < udtCount; i += 1) {\n        udtIndexArray.push(i);\n      }\n      udtAlphaArray = udtIndexArray.slice(0);\n      udtAlphaArray.sort(compUdtsAlpha);\n    }\n    if (order.charCodeAt(0) === 97) {\n      str += ' - alphabetical by rule/UDT name\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${alphaArray[i]}: ${rules[alphaArray[i]].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udtAlphaArray[i]}: ${udts[udtAlphaArray[i]].name}\\n`;\n        }\n      }\n    } else {\n      str += ' - ordered by rule/UDT index\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${rules[i].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udts[i].name}\\n`;\n        }\n      }\n    }\n    return str;\n  };\n  return showRules;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3Nob3ctcnVsZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhLEdBQUcsYUFBYTtBQUN0RDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsR0FBRyxhQUFhO0FBQ3REOztBQUVBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixFQUFFLElBQUksY0FBYyxJQUFJLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsb0JBQW9CLEVBQUUsSUFBSSxpQkFBaUIsSUFBSSw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixFQUFFLElBQUksY0FBYztBQUN0QztBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsb0JBQW9CLEVBQUUsSUFBSSxhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9zaG93LXJ1bGVzLmpzPzc3M2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gZXhmbigpIHtcbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ3Nob3ctcnVsZXMuanMnO1xuICAvLyBEaXNwbGF5IHRoZSBydWxlcy5cbiAgLy8gVGhpcyBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGJlZm9yZSB0aGUgYXR0cmlidXRlcyBjYWxjdWxhdGlvbi5cbiAgLy8gU29ydGluZyBpcyBkb25lIGluZGVwZW5kZW50bHkgZnJvbSB0aGUgYXR0cmlidXRlcy5cbiAgLy8gLSBvcmRlclxuICAvLyAgICAgIC0gXCJpbmRleFwiIG9yIFwiaVwiLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgLy8gICAgICAtIFwiYWxwaGFcIiBvciBcImFcIiwgYWxwaGFiZXRpY2FsIG9yZGVyXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgY29uc3Qgc2hvd1J1bGVzID0gZnVuY3Rpb24gc2hvd1J1bGVzKHJ1bGVzSW4gPSBbXSwgdWR0c0luID0gW10sIG9yZGVyID0gJ2luZGV4Jykge1xuICAgIGNvbnN0IHRoaXNGdW5jTmFtZSA9ICdzaG93UnVsZXMnO1xuICAgIGxldCBhbHBoYUFycmF5ID0gW107XG4gICAgbGV0IHVkdEFscGhhQXJyYXkgPSBbXTtcbiAgICBjb25zdCBpbmRleEFycmF5ID0gW107XG4gICAgY29uc3QgdWR0SW5kZXhBcnJheSA9IFtdO1xuICAgIGNvbnN0IHJ1bGVzID0gcnVsZXNJbjtcbiAgICBjb25zdCB1ZHRzID0gdWR0c0luO1xuICAgIGNvbnN0IHJ1bGVDb3VudCA9IHJ1bGVzSW4ubGVuZ3RoO1xuICAgIGNvbnN0IHVkdENvdW50ID0gdWR0c0luLmxlbmd0aDtcbiAgICBsZXQgc3RyID0gJ1JVTEUvVURUIE5BTUVTJztcbiAgICBsZXQgaTtcbiAgICBmdW5jdGlvbiBjb21wUnVsZXNBbHBoYShsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKHJ1bGVzW2xlZnRdLmxvd2VyIDwgcnVsZXNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChydWxlc1tsZWZ0XS5sb3dlciA+IHJ1bGVzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wVWR0c0FscGhhKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAodWR0c1tsZWZ0XS5sb3dlciA8IHVkdHNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh1ZHRzW2xlZnRdLmxvd2VyID4gdWR0c1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKCEoQXJyYXkuaXNBcnJheShydWxlc0luKSAmJiBydWxlc0luLmxlbmd0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9OiR7dGhpc0Z1bmNOYW1lfTogcnVsZXMgYXJnIG11c3QgYmUgYXJyYXkgd2l0aCBsZW5ndGggPiAwYCk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh1ZHRzSW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfToke3RoaXNGdW5jTmFtZX06IHVkdHMgYXJnIG11c3QgYmUgYXJyYXlgKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIGluZGV4QXJyYXkucHVzaChpKTtcbiAgICB9XG4gICAgYWxwaGFBcnJheSA9IGluZGV4QXJyYXkuc2xpY2UoMCk7XG4gICAgYWxwaGFBcnJheS5zb3J0KGNvbXBSdWxlc0FscGhhKTtcbiAgICBpZiAodWR0Q291bnQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHVkdEluZGV4QXJyYXkucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIHVkdEFscGhhQXJyYXkgPSB1ZHRJbmRleEFycmF5LnNsaWNlKDApO1xuICAgICAgdWR0QWxwaGFBcnJheS5zb3J0KGNvbXBVZHRzQWxwaGEpO1xuICAgIH1cbiAgICBpZiAob3JkZXIuY2hhckNvZGVBdCgwKSA9PT0gOTcpIHtcbiAgICAgIHN0ciArPSAnIC0gYWxwaGFiZXRpY2FsIGJ5IHJ1bGUvVURUIG5hbWVcXG4nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBgJHtpfTogJHthbHBoYUFycmF5W2ldfTogJHtydWxlc1thbHBoYUFycmF5W2ldXS5uYW1lfVxcbmA7XG4gICAgICB9XG4gICAgICBpZiAodWR0Q291bnQpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHVkdENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICBzdHIgKz0gYCR7aX06ICR7dWR0QWxwaGFBcnJheVtpXX06ICR7dWR0c1t1ZHRBbHBoYUFycmF5W2ldXS5uYW1lfVxcbmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgLSBvcmRlcmVkIGJ5IHJ1bGUvVURUIGluZGV4XFxuJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gYCR7aX06ICR7cnVsZXNbaV0ubmFtZX1cXG5gO1xuICAgICAgfVxuICAgICAgaWYgKHVkdENvdW50KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRDb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgc3RyICs9IGAke2l9OiAke3VkdHNbaV0ubmFtZX1cXG5gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIHJldHVybiBzaG93UnVsZXM7XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/show-rules.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/syntax-callbacks.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/syntax-callbacks.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the callback functions for the syntax phase of the generation.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const thisFileName = 'syntax-callbacks.js: ';\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = apglib.ids;\n  let topAlt;\n  /* syntax, RNM, callback functions */\n  const synFile = function synFile(result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack = [];\n        data.repCount = 0;\n        break;\n      case id.EMPTY:\n        data.errors.push({\n          line: 0,\n          char: 0,\n          msg: 'grammar file is empty',\n        });\n        break;\n      case id.MATCH:\n        if (data.ruleCount === 0) {\n          data.errors.push({\n            line: 0,\n            char: 0,\n            msg: 'no rules defined',\n          });\n        }\n        break;\n      case id.NOMATCH:\n        throw new Error(`${thisFileName}synFile: grammar file NOMATCH: design error: should never happen.`);\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // eslint-disable-next-line func-names\n  const synRule = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack.length = 0;\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      case id.EMPTY:\n        throw new Error(`${thisFileName}synRule: EMPTY: rule cannot be empty`);\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.ruleCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized SABNF line. Invalid rule, comment or blank line.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleNameError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Rule names must be alphanum and begin with alphabetic character.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synDefinedAsError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: \"Expected '=' or '=/'. Not found.\",\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAndOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'AND operator(&) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synNotOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'NOT operator(!) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkaOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Positive look-behind operator(&&) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBknOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Negative look-behind operator(!!) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAbgOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Beginning of string anchor(%^) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAenOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'End of string anchor(%$) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkrOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Back reference operator(${name}) found - strict ABNF specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synUdtOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `UDT operator found(${name}) - strict ABNF specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: \"Tab character (\\\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)\",\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synStringTab = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.stringTabChar = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.tlsOpen),\n          char: topAlt.tlsOpen,\n          msg: 'Case-insensitive literal string(\"...\") opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.tlsOpen = null;\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.clsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in literal string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.clsOpen),\n          char: topAlt.clsOpen,\n          msg: \"Case-sensitive literal string('...') opened but not closed.\",\n        });\n        topAlt.clsOpen = null;\n        topAlt.basicError = true;\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, topAlt.clsOpen),\n            char: topAlt.clsOpen,\n            msg: \"Case-sensitive string operator('...') found - strict ABNF specified.\",\n          });\n        }\n        topAlt.clsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.prosValOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in prose value string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.prosValOpen = null;\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar.',\n        });\n        topAlt.prosValOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: phraseIndex,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.groupOpen),\n          char: topAlt.groupOpen,\n          msg: 'Group \"(...)\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.groupError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: phraseIndex,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.optionOpen),\n          char: topAlt.optionOpen,\n          msg: 'Option \"[...]\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.optionError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBasicElementError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (topAlt.basicError === false) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Unrecognized SABNF element.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEnd = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (result.phraseLength === 1 && data.strict) {\n          const end = chars[phraseIndex] === 13 ? 'CR' : 'LF';\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Line end '${end}' found - strict ABNF specified, only CRLF allowed.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEndError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized grammar element or characters.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRepetition = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.repCount += 1;\n        break;\n      case id.MATCH:\n        data.repCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // Define the list of callback functions.\n  this.callbacks = [];\n  this.callbacks.andop = synAndOp;\n  this.callbacks.basicelementerr = synBasicElementError;\n  this.callbacks.clsclose = synClsClose;\n  this.callbacks.clsopen = synClsOpen;\n  this.callbacks.clsstring = synClsString;\n  this.callbacks.definedaserror = synDefinedAsError;\n  this.callbacks.file = synFile;\n  this.callbacks.groupclose = synGroupClose;\n  this.callbacks.groupopen = synGroupOpen;\n  this.callbacks.lineenderror = synLineEndError;\n  this.callbacks.lineend = synLineEnd;\n  this.callbacks.notop = synNotOp;\n  this.callbacks.optionclose = synOptionClose;\n  this.callbacks.optionopen = synOptionOpen;\n  this.callbacks.prosvalclose = synProsValClose;\n  this.callbacks.prosvalopen = synProsValOpen;\n  this.callbacks.prosvalstring = synProsValString;\n  this.callbacks.repetition = synRepetition;\n  this.callbacks.rule = synRule;\n  this.callbacks.ruleerror = synRuleError;\n  this.callbacks.rulenameerror = synRuleNameError;\n  this.callbacks.stringtab = synStringTab;\n  this.callbacks.tlsclose = synTlsClose;\n  this.callbacks.tlsopen = synTlsOpen;\n  this.callbacks.tlsstring = synTlsString;\n  this.callbacks.udtop = synUdtOp;\n  this.callbacks.bkaop = synBkaOp;\n  this.callbacks.bknop = synBknOp;\n  this.callbacks.bkrop = synBkrOp;\n  this.callbacks.abgop = synAbgOp;\n  this.callbacks.aenop = synAenOp;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3N5bnRheC1jYWxsYmFja3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDRIQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUk7QUFDbEMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc3ludGF4LWNhbGxiYWNrcy5qcz9jZjgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtbmFtZXMgKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGhhcyBhbGwgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIHN5bnRheCBwaGFzZSBvZiB0aGUgZ2VuZXJhdGlvbi5cbi8vIFNlZTo8YnI+XG4vLyBgLi9kaXN0L2FibmYtZm9yLXNhYm5mLWdyYW1tYXIuYm5mYDxicj5cbi8vIGZvciB0aGUgZ3JhbW1hciBmaWxlIHRoZXNlIGNhbGxiYWNrIGZ1bmN0aW9ucyBhcmUgYmFzZWQgb24uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4Zm4oKSB7XG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdzeW50YXgtY2FsbGJhY2tzLmpzOiAnO1xuICBjb25zdCBhcGdsaWIgPSByZXF1aXJlKCcuLi9hcGctbGliL25vZGUtZXhwb3J0cycpO1xuICBjb25zdCBpZCA9IGFwZ2xpYi5pZHM7XG4gIGxldCB0b3BBbHQ7XG4gIC8qIHN5bnRheCwgUk5NLCBjYWxsYmFjayBmdW5jdGlvbnMgKi9cbiAgY29uc3Qgc3luRmlsZSA9IGZ1bmN0aW9uIHN5bkZpbGUocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuYWx0U3RhY2sgPSBbXTtcbiAgICAgICAgZGF0YS5yZXBDb3VudCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogMCxcbiAgICAgICAgICBjaGFyOiAwLFxuICAgICAgICAgIG1zZzogJ2dyYW1tYXIgZmlsZSBpcyBlbXB0eScsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnJ1bGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogMCxcbiAgICAgICAgICAgIGNoYXI6IDAsXG4gICAgICAgICAgICBtc2c6ICdubyBydWxlcyBkZWZpbmVkJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiBncmFtbWFyIGZpbGUgTk9NQVRDSDogZGVzaWduIGVycm9yOiBzaG91bGQgbmV2ZXIgaGFwcGVuLmApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIGNvbnN0IHN5blJ1bGUgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuYWx0U3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgdG9wQWx0ID0ge1xuICAgICAgICAgIGdyb3VwT3BlbjogbnVsbCxcbiAgICAgICAgICBncm91cEVycm9yOiBmYWxzZSxcbiAgICAgICAgICBvcHRpb25PcGVuOiBudWxsLFxuICAgICAgICAgIG9wdGlvbkVycm9yOiBmYWxzZSxcbiAgICAgICAgICB0bHNPcGVuOiBudWxsLFxuICAgICAgICAgIGNsc09wZW46IG51bGwsXG4gICAgICAgICAgcHJvc1ZhbE9wZW46IG51bGwsXG4gICAgICAgICAgYmFzaWNFcnJvcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGRhdGEuYWx0U3RhY2sucHVzaCh0b3BBbHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luUnVsZTogRU1QVFk6IHJ1bGUgY2Fubm90IGJlIGVtcHR5YCk7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgZGF0YS5ydWxlQ291bnQgKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUnVsZUVycm9yID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgIG1zZzogJ1VucmVjb2duaXplZCBTQUJORiBsaW5lLiBJbnZhbGlkIHJ1bGUsIGNvbW1lbnQgb3IgYmxhbmsgbGluZS4nLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUnVsZU5hbWVFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6ICdSdWxlIG5hbWVzIG11c3QgYmUgYWxwaGFudW0gYW5kIGJlZ2luIHdpdGggYWxwaGFiZXRpYyBjaGFyYWN0ZXIuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkRlZmluZWRBc0Vycm9yID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgIG1zZzogXCJFeHBlY3RlZCAnPScgb3IgJz0vJy4gTm90IGZvdW5kLlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQW5kT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnQU5EIG9wZXJhdG9yKCYpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luTm90T3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnTk9UIG9wZXJhdG9yKCEpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQmthT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnUG9zaXRpdmUgbG9vay1iZWhpbmQgb3BlcmF0b3IoJiYpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQmtuT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnTmVnYXRpdmUgbG9vay1iZWhpbmQgb3BlcmF0b3IoISEpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQWJnT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnQmVnaW5uaW5nIG9mIHN0cmluZyBhbmNob3IoJV4pIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQWVuT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnRW5kIG9mIHN0cmluZyBhbmNob3IoJSQpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQmtyT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcmVzdWx0LnBocmFzZUxlbmd0aCk7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiBgQmFjayByZWZlcmVuY2Ugb3BlcmF0b3IoJHtuYW1lfSkgZm91bmQgLSBzdHJpY3QgQUJORiBzcGVjaWZpZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5VZHRPcCA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoZGF0YS5zdHJpY3QpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCByZXN1bHQucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgICBtc2c6IGBVRFQgb3BlcmF0b3IgZm91bmQoJHtuYW1lfSkgLSBzdHJpY3QgQUJORiBzcGVjaWZpZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5UbHNPcGVuID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4KSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdC50bHNPcGVuID0gcGhyYXNlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blRsc1N0cmluZyA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgZGF0YS5zdHJpbmdUYWJDaGFyID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaW5nVGFiQ2hhciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgZGF0YS5zdHJpbmdUYWJDaGFyKSxcbiAgICAgICAgICAgIGNoYXI6IGRhdGEuc3RyaW5nVGFiQ2hhcixcbiAgICAgICAgICAgIG1zZzogXCJUYWIgY2hhcmFjdGVyIChcXFxcdCwgeDA5KSBub3QgYWxsb3dlZCBpbiBsaXRlcmFsIHN0cmluZyAoc2VlICdxdW90ZWQtc3RyaW5nJyBkZWZpbml0aW9uLCBSRkMgNzQwNS4pXCIsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luU3RyaW5nVGFiID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuc3RyaW5nVGFiQ2hhciA9IHBocmFzZUluZGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5UbHNDbG9zZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQudGxzT3BlbiksXG4gICAgICAgICAgY2hhcjogdG9wQWx0LnRsc09wZW4sXG4gICAgICAgICAgbXNnOiAnQ2FzZS1pbnNlbnNpdGl2ZSBsaXRlcmFsIHN0cmluZyhcIi4uLlwiKSBvcGVuZWQgYnV0IG5vdCBjbG9zZWQuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdC5iYXNpY0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdG9wQWx0LnRsc09wZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdC50bHNPcGVuID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQ2xzT3BlbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQuY2xzT3BlbiA9IHBocmFzZUluZGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5DbHNTdHJpbmcgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuc3RyaW5nVGFiQ2hhciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmluZ1RhYkNoYXIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIGRhdGEuc3RyaW5nVGFiQ2hhciksXG4gICAgICAgICAgICBjaGFyOiBkYXRhLnN0cmluZ1RhYkNoYXIsXG4gICAgICAgICAgICBtc2c6ICdUYWIgY2hhcmFjdGVyIChcXFxcdCwgeDA5KSBub3QgYWxsb3dlZCBpbiBsaXRlcmFsIHN0cmluZy4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkNsc0Nsb3NlID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHRvcEFsdC5jbHNPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQuY2xzT3BlbixcbiAgICAgICAgICBtc2c6IFwiQ2FzZS1zZW5zaXRpdmUgbGl0ZXJhbCBzdHJpbmcoJy4uLicpIG9wZW5lZCBidXQgbm90IGNsb3NlZC5cIixcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdC5jbHNPcGVuID0gbnVsbDtcbiAgICAgICAgdG9wQWx0LmJhc2ljRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQuY2xzT3BlbiksXG4gICAgICAgICAgICBjaGFyOiB0b3BBbHQuY2xzT3BlbixcbiAgICAgICAgICAgIG1zZzogXCJDYXNlLXNlbnNpdGl2ZSBzdHJpbmcgb3BlcmF0b3IoJy4uLicpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLlwiLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRvcEFsdC5jbHNPcGVuID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUHJvc1ZhbE9wZW4gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0LnByb3NWYWxPcGVuID0gcGhyYXNlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blByb3NWYWxTdHJpbmcgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuc3RyaW5nVGFiQ2hhciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmluZ1RhYkNoYXIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIGRhdGEuc3RyaW5nVGFiQ2hhciksXG4gICAgICAgICAgICBjaGFyOiBkYXRhLnN0cmluZ1RhYkNoYXIsXG4gICAgICAgICAgICBtc2c6ICdUYWIgY2hhcmFjdGVyIChcXFxcdCwgeDA5KSBub3QgYWxsb3dlZCBpbiBwcm9zZSB2YWx1ZSBzdHJpbmcuJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5Qcm9zVmFsQ2xvc2UgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgdG9wQWx0LnByb3NWYWxPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQucHJvc1ZhbE9wZW4sXG4gICAgICAgICAgbXNnOiAnUHJvc2UgdmFsdWUgb3BlcmF0b3IoPC4uLj4pIG9wZW5lZCBidXQgbm90IGNsb3NlZC4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdG9wQWx0LmJhc2ljRXJyb3IgPSB0cnVlO1xuICAgICAgICB0b3BBbHQucHJvc1ZhbE9wZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgdG9wQWx0LnByb3NWYWxPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQucHJvc1ZhbE9wZW4sXG4gICAgICAgICAgbXNnOiAnUHJvc2UgdmFsdWUgb3BlcmF0b3IoPC4uLj4pIGZvdW5kLiBUaGUgQUJORiBzeW50YXggaXMgdmFsaWQsIGJ1dCBhIHBhcnNlciBjYW5ub3QgYmUgZ2VuZXJhdGVkIGZyb20gdGhpcyBncmFtbWFyLicsXG4gICAgICAgIH0pO1xuICAgICAgICB0b3BBbHQucHJvc1ZhbE9wZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5Hcm91cE9wZW4gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0ID0ge1xuICAgICAgICAgIGdyb3VwT3BlbjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgZ3JvdXBFcnJvcjogZmFsc2UsXG4gICAgICAgICAgb3B0aW9uT3BlbjogbnVsbCxcbiAgICAgICAgICBvcHRpb25FcnJvcjogZmFsc2UsXG4gICAgICAgICAgdGxzT3BlbjogbnVsbCxcbiAgICAgICAgICBjbHNPcGVuOiBudWxsLFxuICAgICAgICAgIHByb3NWYWxPcGVuOiBudWxsLFxuICAgICAgICAgIGJhc2ljRXJyb3I6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBkYXRhLmFsdFN0YWNrLnB1c2godG9wQWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luR3JvdXBDbG9zZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQuZ3JvdXBPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQuZ3JvdXBPcGVuLFxuICAgICAgICAgIG1zZzogJ0dyb3VwIFwiKC4uLilcIiBvcGVuZWQgYnV0IG5vdCBjbG9zZWQuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdCA9IGRhdGEuYWx0U3RhY2sucG9wKCk7XG4gICAgICAgIHRvcEFsdC5ncm91cEVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQgPSBkYXRhLmFsdFN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5PcHRpb25PcGVuID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdCA9IHtcbiAgICAgICAgICBncm91cE9wZW46IG51bGwsXG4gICAgICAgICAgZ3JvdXBFcnJvcjogZmFsc2UsXG4gICAgICAgICAgb3B0aW9uT3BlbjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgb3B0aW9uRXJyb3I6IGZhbHNlLFxuICAgICAgICAgIHRsc09wZW46IG51bGwsXG4gICAgICAgICAgY2xzT3BlbjogbnVsbCxcbiAgICAgICAgICBwcm9zVmFsT3BlbjogbnVsbCxcbiAgICAgICAgICBiYXNpY0Vycm9yOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgZGF0YS5hbHRTdGFjay5wdXNoKHRvcEFsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bk9wdGlvbkNsb3NlID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHRvcEFsdC5vcHRpb25PcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQub3B0aW9uT3BlbixcbiAgICAgICAgICBtc2c6ICdPcHRpb24gXCJbLi4uXVwiIG9wZW5lZCBidXQgbm90IGNsb3NlZC4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdG9wQWx0ID0gZGF0YS5hbHRTdGFjay5wb3AoKTtcbiAgICAgICAgdG9wQWx0Lm9wdGlvbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQgPSBkYXRhLmFsdFN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5CYXNpY0VsZW1lbnRFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAodG9wQWx0LmJhc2ljRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnVW5yZWNvZ25pemVkIFNBQk5GIGVsZW1lbnQuJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5MaW5lRW5kID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChyZXN1bHQucGhyYXNlTGVuZ3RoID09PSAxICYmIGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgY29uc3QgZW5kID0gY2hhcnNbcGhyYXNlSW5kZXhdID09PSAxMyA/ICdDUicgOiAnTEYnO1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogYExpbmUgZW5kICcke2VuZH0nIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLCBvbmx5IENSTEYgYWxsb3dlZC5gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkxpbmVFbmRFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6ICdVbnJlY29nbml6ZWQgZ3JhbW1hciBlbGVtZW50IG9yIGNoYXJhY3RlcnMuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blJlcGV0aXRpb24gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGRhdGEucmVwQ291bnQgKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLnJlcENvdW50ICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIC8vIERlZmluZSB0aGUgbGlzdCBvZiBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIHRoaXMuY2FsbGJhY2tzID0gW107XG4gIHRoaXMuY2FsbGJhY2tzLmFuZG9wID0gc3luQW5kT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmJhc2ljZWxlbWVudGVyciA9IHN5bkJhc2ljRWxlbWVudEVycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5jbHNjbG9zZSA9IHN5bkNsc0Nsb3NlO1xuICB0aGlzLmNhbGxiYWNrcy5jbHNvcGVuID0gc3luQ2xzT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MuY2xzc3RyaW5nID0gc3luQ2xzU3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy5kZWZpbmVkYXNlcnJvciA9IHN5bkRlZmluZWRBc0Vycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5maWxlID0gc3luRmlsZTtcbiAgdGhpcy5jYWxsYmFja3MuZ3JvdXBjbG9zZSA9IHN5bkdyb3VwQ2xvc2U7XG4gIHRoaXMuY2FsbGJhY2tzLmdyb3Vwb3BlbiA9IHN5bkdyb3VwT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MubGluZWVuZGVycm9yID0gc3luTGluZUVuZEVycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5saW5lZW5kID0gc3luTGluZUVuZDtcbiAgdGhpcy5jYWxsYmFja3Mubm90b3AgPSBzeW5Ob3RPcDtcbiAgdGhpcy5jYWxsYmFja3Mub3B0aW9uY2xvc2UgPSBzeW5PcHRpb25DbG9zZTtcbiAgdGhpcy5jYWxsYmFja3Mub3B0aW9ub3BlbiA9IHN5bk9wdGlvbk9wZW47XG4gIHRoaXMuY2FsbGJhY2tzLnByb3N2YWxjbG9zZSA9IHN5blByb3NWYWxDbG9zZTtcbiAgdGhpcy5jYWxsYmFja3MucHJvc3ZhbG9wZW4gPSBzeW5Qcm9zVmFsT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MucHJvc3ZhbHN0cmluZyA9IHN5blByb3NWYWxTdHJpbmc7XG4gIHRoaXMuY2FsbGJhY2tzLnJlcGV0aXRpb24gPSBzeW5SZXBldGl0aW9uO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlID0gc3luUnVsZTtcbiAgdGhpcy5jYWxsYmFja3MucnVsZWVycm9yID0gc3luUnVsZUVycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlbmFtZWVycm9yID0gc3luUnVsZU5hbWVFcnJvcjtcbiAgdGhpcy5jYWxsYmFja3Muc3RyaW5ndGFiID0gc3luU3RyaW5nVGFiO1xuICB0aGlzLmNhbGxiYWNrcy50bHNjbG9zZSA9IHN5blRsc0Nsb3NlO1xuICB0aGlzLmNhbGxiYWNrcy50bHNvcGVuID0gc3luVGxzT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MudGxzc3RyaW5nID0gc3luVGxzU3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy51ZHRvcCA9IHN5blVkdE9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia2FvcCA9IHN5bkJrYU9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia25vcCA9IHN5bkJrbk9wO1xuICB0aGlzLmNhbGxiYWNrcy5ia3JvcCA9IHN5bkJrck9wO1xuICB0aGlzLmNhbGxiYWNrcy5hYmdvcCA9IHN5bkFiZ09wO1xuICB0aGlzLmNhbGxiYWNrcy5hZW5vcCA9IHN5bkFlbk9wO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/syntax-callbacks.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/converter.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/converter.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes the public encoding, decoding and conversion functions.\n// Its private functions provide the disassembling and interpetation of the source and destination encoding types.\n// In the case of Unicode encodings, private functions determine the presence of Byte Order Marks (BOMs), if any.\n//\n// Throws \"TypeError\" exceptions on input errors.\n//\n\n'use strict;';\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n\nconst trans = __webpack_require__(/*! ./transformers */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/transformers.js\");\n\n/* types */\nconst UTF8 = 'UTF8';\nconst UTF16 = 'UTF16';\nconst UTF16BE = 'UTF16BE';\nconst UTF16LE = 'UTF16LE';\nconst UTF32 = 'UTF32';\nconst UTF32BE = 'UTF32BE';\nconst UTF32LE = 'UTF32LE';\nconst UINT7 = 'UINT7';\nconst ASCII = 'ASCII';\nconst BINARY = 'BINARY';\nconst UINT8 = 'UINT8';\nconst UINT16 = 'UINT16';\nconst UINT16LE = 'UINT16LE';\nconst UINT16BE = 'UINT16BE';\nconst UINT32 = 'UINT32';\nconst UINT32LE = 'UINT32LE';\nconst UINT32BE = 'UINT32BE';\nconst ESCAPED = 'ESCAPED';\nconst STRING = 'STRING';\n\n/* private functions */\n// Find the UTF8 BOM, if any.\nconst bom8 = function bom8(src) {\n  src.type = UTF8;\n  const buf = src.data;\n  src.bom = 0;\n  if (buf.length >= 3) {\n    if (buf[0] === 0xef && buf[1] === 0xbb && buf[2] === 0xbf) {\n      src.bom = 3;\n    }\n  }\n};\n// Find the UTF16 BOM, if any, and determine the UTF16 type.\n// Defaults to UTF16BE.\n// Throws TypeError exception if BOM does not match the specified type.\nconst bom16 = function bom16(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF16:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.type = UTF16LE;\n          src.bom = 2;\n        }\n      }\n      break;\n    case UTF16BE:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          throw new TypeError(`src type: \"${UTF16BE}\" specified but BOM is for \"${UTF16LE}\"`);\n        }\n      }\n      break;\n    case UTF16LE:\n      src.type = UTF16LE;\n      if (buf.length >= 0) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          throw new TypeError(`src type: \"${UTF16LE}\" specified but BOM is for \"${UTF16BE}\"`);\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.bom = 2;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF16 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Find the UTF32 BOM, if any, and determine the UTF32 type.\n// Defaults to UTF32BE.\n// Throws exception if BOM does not match the specified type.\nconst bom32 = function bom32(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF32:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.type = UTF32LE;\n          src.bom = 4;\n        }\n      }\n      break;\n    case UTF32BE:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          throw new TypeError(`src type: ${UTF32BE} specified but BOM is for ${UTF32LE}\"`);\n        }\n      }\n      break;\n    case UTF32LE:\n      src.type = UTF32LE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          throw new TypeError(`src type: \"${UTF32LE}\" specified but BOM is for \"${UTF32BE}\"`);\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.bom = 4;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF32 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Validates the source encoding type and matching data.\n// If the BASE64: prefix is present, the base 64 decoding is done here as the initial step.\n// - For type STRING, data must be a JavaScript string.\n// - For type BASE64:*, data may be a string or Buffer.\n// - For all other types, data must be a Buffer.\n// - The BASE64: prefix is not allowed for type STRING.\nconst validateSrc = function validateSrc(type, data) {\n  function getType(typeArg) {\n    const ret = {\n      type: '',\n      base64: false,\n    };\n    const rx = /^(base64:)?([a-zA-Z0-9]+)$/i;\n    const result = rx.exec(typeArg);\n    if (result) {\n      if (result[2]) {\n        ret.type = result[2].toUpperCase();\n      }\n      if (result[1]) {\n        ret.base64 = true;\n      }\n    }\n    return ret;\n  }\n  const ret = getType(type.toUpperCase());\n  if (ret.base64) {\n    /* handle base 64 */\n    if (ret.type === STRING) {\n      throw new TypeError(`type: \"${type} \"BASE64:\" prefix not allowed with type ${STRING}`);\n    }\n    if (Buffer.isBuffer(data)) {\n      ret.data = trans.base64.decode(data);\n    } else if (typeof data === 'string') {\n      const buf = Buffer.from(data, 'ascii');\n      ret.data = trans.base64.decode(buf);\n    } else {\n      throw new TypeError(`type: \"${type} unrecognized data type: typeof(data): ${typeof data}`);\n    }\n  } else {\n    ret.data = data;\n  }\n  switch (ret.type) {\n    case UTF8:\n      bom8(ret);\n      break;\n    case UTF16:\n    case UTF16BE:\n    case UTF16LE:\n      bom16(ret);\n      break;\n    case UTF32:\n    case UTF32BE:\n    case UTF32LE:\n      bom32(ret);\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case STRING:\n    case ESCAPED:\n      break;\n    default:\n      throw new TypeError(`type: \"${type}\" not recognized`);\n  }\n  if (ret.type === STRING) {\n    if (typeof ret.data !== 'string') {\n      throw new TypeError(`type: \"${type}\" but data is not a string`);\n    }\n  } else if (!Buffer.isBuffer(ret.data)) {\n    throw new TypeError(`type: \"${type}\" but data is not a Buffer`);\n  }\n  return ret;\n};\n// Disassembles and validates the destination type.\n// `chars` must be an Array of integers.\n// The :BASE64 suffix is not allowed for type STRING.\nconst validateDst = function validateDst(type, chars) {\n  function getType(typeArg) {\n    let fix;\n    let rem;\n    const ret = {\n      crlf: false,\n      lf: false,\n      base64: false,\n      type: '',\n    };\n    /* prefix, if any */\n    const TRUE = true;\n    while (TRUE) {\n      rem = typeArg;\n      fix = typeArg.slice(0, 5);\n      if (fix === 'CRLF:') {\n        ret.crlf = true;\n        rem = typeArg.slice(5);\n        break;\n      }\n      fix = typeArg.slice(0, 3);\n      if (fix === 'LF:') {\n        ret.lf = true;\n        rem = typeArg.slice(3);\n        break;\n      }\n      break;\n    }\n    /* suffix, if any */\n    fix = rem.split(':');\n    if (fix.length === 1) {\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    } else if (fix.length === 2 && fix[1] === 'BASE64') {\n      ret.base64 = true;\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    }\n    return ret;\n  }\n  if (!Array.isArray(chars)) {\n    throw new TypeError(`dst chars: not array: \"${typeof chars}`);\n  }\n  if (typeof type !== 'string') {\n    throw new TypeError(`dst type: not string: \"${typeof type}`);\n  }\n  const ret = getType(type.toUpperCase());\n  switch (ret.type) {\n    case UTF8:\n    case UTF16BE:\n    case UTF16LE:\n    case UTF32BE:\n    case UTF32LE:\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case ESCAPED:\n      break;\n    case STRING:\n      if (ret.base64) {\n        throw new TypeError(`\":BASE64\" suffix not allowed with type ${STRING}`);\n      }\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UTF16:\n      ret.type = UTF16BE;\n      break;\n    case UTF32:\n      ret.type = UTF32BE;\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    default:\n      throw new TypeError(`dst type unrecognized: \"${type}\" : must have form [crlf:|lf:]type[:base64]`);\n  }\n  return ret;\n};\n// Select and call the requested encoding function.\nconst encode = function encode(type, chars) {\n  switch (type) {\n    case UTF8:\n      return trans.utf8.encode(chars);\n    case UTF16BE:\n      return trans.utf16be.encode(chars);\n    case UTF16LE:\n      return trans.utf16le.encode(chars);\n    case UTF32BE:\n      return trans.utf32be.encode(chars);\n    case UTF32LE:\n      return trans.utf32le.encode(chars);\n    case UINT7:\n      return trans.uint7.encode(chars);\n    case UINT8:\n      return trans.uint8.encode(chars);\n    case UINT16BE:\n      return trans.uint16be.encode(chars);\n    case UINT16LE:\n      return trans.uint16le.encode(chars);\n    case UINT32BE:\n      return trans.uint32be.encode(chars);\n    case UINT32LE:\n      return trans.uint32le.encode(chars);\n    case STRING:\n      return trans.string.encode(chars);\n    case ESCAPED:\n      return trans.escaped.encode(chars);\n    default:\n      throw new TypeError(`encode type \"${type}\" not recognized`);\n  }\n};\n// Select and call the requested decoding function.\n// `src` contains BOM information as well as the source type and data.\nconst decode = function decode(src) {\n  switch (src.type) {\n    case UTF8:\n      return trans.utf8.decode(src.data, src.bom);\n    case UTF16LE:\n      return trans.utf16le.decode(src.data, src.bom);\n    case UTF16BE:\n      return trans.utf16be.decode(src.data, src.bom);\n    case UTF32BE:\n      return trans.utf32be.decode(src.data, src.bom);\n    case UTF32LE:\n      return trans.utf32le.decode(src.data, src.bom);\n    case UINT7:\n      return trans.uint7.decode(src.data);\n    case UINT8:\n      return trans.uint8.decode(src.data);\n    case UINT16BE:\n      return trans.uint16be.decode(src.data);\n    case UINT16LE:\n      return trans.uint16le.decode(src.data);\n    case UINT32BE:\n      return trans.uint32be.decode(src.data);\n    case UINT32LE:\n      return trans.uint32le.decode(src.data);\n    case STRING:\n      return trans.string.decode(src.data);\n    case ESCAPED:\n      return trans.escaped.decode(src.data);\n    default:\n      throw new TypeError(`decode type \"${src.type}\" not recognized`);\n  }\n};\n\n// The public decoding function. Returns an array of integers.\nexports.decode = function exportsDecode(type, data) {\n  const src = validateSrc(type, data);\n  return decode(src);\n};\n// The public encoding function. Returns a Buffer-typed byte array.\nexports.encode = function exportsEncode(type, chars) {\n  let c;\n  let buf;\n  const dst = validateDst(type, chars);\n  if (dst.crlf) {\n    /* prefix with CRLF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.crlf(chars);\n    buf = encode(dst.type, c);\n  } else if (dst.lf) {\n    /* prefix with LF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.lf(chars);\n    buf = encode(dst.type, c);\n  } else {\n    buf = encode(dst.type, chars);\n  }\n  if (dst.base64) {\n    /* post base 64 encoding */\n    buf = trans.base64.encode(buf);\n  }\n  return buf;\n};\n// Converts data of type `srcType` to data of type `dstType`.\n// `srcData` may be a JavaScript String, or node.js Buffer, depending on the corresponding type.\nconst convert = function convert(srcType, srcData, dstType) {\n  return exports.encode(dstType, exports.decode(srcType, srcData));\n};\nexports.convert = convert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFbkMsY0FBYyxtQkFBTyxDQUFDLHdIQUFnQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNENBQTRDLFFBQVEsOEJBQThCLFFBQVE7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSw4QkFBOEIsUUFBUTtBQUMxRixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsMkJBQTJCLFFBQVE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSw4QkFBOEIsUUFBUTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLHlDQUF5QyxPQUFPO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9DQUFvQyxNQUFNLHdDQUF3QyxZQUFZO0FBQzlGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBLElBQUk7QUFDSixrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE9BQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1jb252LWFwaS9jb252ZXJ0ZXIuanM/ODhlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBleHBvc2VzIHRoZSBwdWJsaWMgZW5jb2RpbmcsIGRlY29kaW5nIGFuZCBjb252ZXJzaW9uIGZ1bmN0aW9ucy5cbi8vIEl0cyBwcml2YXRlIGZ1bmN0aW9ucyBwcm92aWRlIHRoZSBkaXNhc3NlbWJsaW5nIGFuZCBpbnRlcnBldGF0aW9uIG9mIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGVuY29kaW5nIHR5cGVzLlxuLy8gSW4gdGhlIGNhc2Ugb2YgVW5pY29kZSBlbmNvZGluZ3MsIHByaXZhdGUgZnVuY3Rpb25zIGRldGVybWluZSB0aGUgcHJlc2VuY2Ugb2YgQnl0ZSBPcmRlciBNYXJrcyAoQk9NcyksIGlmIGFueS5cbi8vXG4vLyBUaHJvd3MgXCJUeXBlRXJyb3JcIiBleGNlcHRpb25zIG9uIGlucHV0IGVycm9ycy5cbi8vXG5cbid1c2Ugc3RyaWN0Oyc7XG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKTtcblxuY29uc3QgdHJhbnMgPSByZXF1aXJlKCcuL3RyYW5zZm9ybWVycycpO1xuXG4vKiB0eXBlcyAqL1xuY29uc3QgVVRGOCA9ICdVVEY4JztcbmNvbnN0IFVURjE2ID0gJ1VURjE2JztcbmNvbnN0IFVURjE2QkUgPSAnVVRGMTZCRSc7XG5jb25zdCBVVEYxNkxFID0gJ1VURjE2TEUnO1xuY29uc3QgVVRGMzIgPSAnVVRGMzInO1xuY29uc3QgVVRGMzJCRSA9ICdVVEYzMkJFJztcbmNvbnN0IFVURjMyTEUgPSAnVVRGMzJMRSc7XG5jb25zdCBVSU5UNyA9ICdVSU5UNyc7XG5jb25zdCBBU0NJSSA9ICdBU0NJSSc7XG5jb25zdCBCSU5BUlkgPSAnQklOQVJZJztcbmNvbnN0IFVJTlQ4ID0gJ1VJTlQ4JztcbmNvbnN0IFVJTlQxNiA9ICdVSU5UMTYnO1xuY29uc3QgVUlOVDE2TEUgPSAnVUlOVDE2TEUnO1xuY29uc3QgVUlOVDE2QkUgPSAnVUlOVDE2QkUnO1xuY29uc3QgVUlOVDMyID0gJ1VJTlQzMic7XG5jb25zdCBVSU5UMzJMRSA9ICdVSU5UMzJMRSc7XG5jb25zdCBVSU5UMzJCRSA9ICdVSU5UMzJCRSc7XG5jb25zdCBFU0NBUEVEID0gJ0VTQ0FQRUQnO1xuY29uc3QgU1RSSU5HID0gJ1NUUklORyc7XG5cbi8qIHByaXZhdGUgZnVuY3Rpb25zICovXG4vLyBGaW5kIHRoZSBVVEY4IEJPTSwgaWYgYW55LlxuY29uc3QgYm9tOCA9IGZ1bmN0aW9uIGJvbTgoc3JjKSB7XG4gIHNyYy50eXBlID0gVVRGODtcbiAgY29uc3QgYnVmID0gc3JjLmRhdGE7XG4gIHNyYy5ib20gPSAwO1xuICBpZiAoYnVmLmxlbmd0aCA+PSAzKSB7XG4gICAgaWYgKGJ1ZlswXSA9PT0gMHhlZiAmJiBidWZbMV0gPT09IDB4YmIgJiYgYnVmWzJdID09PSAweGJmKSB7XG4gICAgICBzcmMuYm9tID0gMztcbiAgICB9XG4gIH1cbn07XG4vLyBGaW5kIHRoZSBVVEYxNiBCT00sIGlmIGFueSwgYW5kIGRldGVybWluZSB0aGUgVVRGMTYgdHlwZS5cbi8vIERlZmF1bHRzIHRvIFVURjE2QkUuXG4vLyBUaHJvd3MgVHlwZUVycm9yIGV4Y2VwdGlvbiBpZiBCT00gZG9lcyBub3QgbWF0Y2ggdGhlIHNwZWNpZmllZCB0eXBlLlxuY29uc3QgYm9tMTYgPSBmdW5jdGlvbiBib20xNihzcmMpIHtcbiAgY29uc3QgYnVmID0gc3JjLmRhdGE7XG4gIHNyYy5ib20gPSAwO1xuICBzd2l0Y2ggKHNyYy50eXBlKSB7XG4gICAgY2FzZSBVVEYxNjpcbiAgICAgIHNyYy50eXBlID0gVVRGMTZCRTtcbiAgICAgIGlmIChidWYubGVuZ3RoID49IDIpIHtcbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMHhmZSAmJiBidWZbMV0gPT09IDB4ZmYpIHtcbiAgICAgICAgICBzcmMuYm9tID0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChidWZbMF0gPT09IDB4ZmYgJiYgYnVmWzFdID09PSAweGZlKSB7XG4gICAgICAgICAgc3JjLnR5cGUgPSBVVEYxNkxFO1xuICAgICAgICAgIHNyYy5ib20gPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjE2QkU6XG4gICAgICBzcmMudHlwZSA9IFVURjE2QkU7XG4gICAgICBpZiAoYnVmLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGlmIChidWZbMF0gPT09IDB4ZmUgJiYgYnVmWzFdID09PSAweGZmKSB7XG4gICAgICAgICAgc3JjLmJvbSA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmWzBdID09PSAweGZmICYmIGJ1ZlsxXSA9PT0gMHhmZSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHNyYyB0eXBlOiBcIiR7VVRGMTZCRX1cIiBzcGVjaWZpZWQgYnV0IEJPTSBpcyBmb3IgXCIke1VURjE2TEV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYxNkxFOlxuICAgICAgc3JjLnR5cGUgPSBVVEYxNkxFO1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPj0gMCkge1xuICAgICAgICBpZiAoYnVmWzBdID09PSAweGZlICYmIGJ1ZlsxXSA9PT0gMHhmZikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHNyYyB0eXBlOiBcIiR7VVRGMTZMRX1cIiBzcGVjaWZpZWQgYnV0IEJPTSBpcyBmb3IgXCIke1VURjE2QkV9XCJgKTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZbMF0gPT09IDB4ZmYgJiYgYnVmWzFdID09PSAweGZlKSB7XG4gICAgICAgICAgc3JjLmJvbSA9IDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVVEYxNiBCT006IHNyYyB0eXBlIFwiJHtzcmMudHlwZX1cIiB1bnJlY29nbml6ZWRgKTtcbiAgfVxufTtcbi8vIEZpbmQgdGhlIFVURjMyIEJPTSwgaWYgYW55LCBhbmQgZGV0ZXJtaW5lIHRoZSBVVEYzMiB0eXBlLlxuLy8gRGVmYXVsdHMgdG8gVVRGMzJCRS5cbi8vIFRocm93cyBleGNlcHRpb24gaWYgQk9NIGRvZXMgbm90IG1hdGNoIHRoZSBzcGVjaWZpZWQgdHlwZS5cbmNvbnN0IGJvbTMyID0gZnVuY3Rpb24gYm9tMzIoc3JjKSB7XG4gIGNvbnN0IGJ1ZiA9IHNyYy5kYXRhO1xuICBzcmMuYm9tID0gMDtcbiAgc3dpdGNoIChzcmMudHlwZSkge1xuICAgIGNhc2UgVVRGMzI6XG4gICAgICBzcmMudHlwZSA9IFVURjMyQkU7XG4gICAgICBpZiAoYnVmLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgIGlmIChidWZbMF0gPT09IDAgJiYgYnVmWzFdID09PSAwICYmIGJ1ZlsyXSA9PT0gMHhmZSAmJiBidWZbM10gPT09IDB4ZmYpIHtcbiAgICAgICAgICBzcmMuYm9tID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmWzBdID09PSAweGZmICYmIGJ1ZlsxXSA9PT0gMHhmZSAmJiBidWZbMl0gPT09IDAgJiYgYnVmWzNdID09PSAwKSB7XG4gICAgICAgICAgc3JjLnR5cGUgPSBVVEYzMkxFO1xuICAgICAgICAgIHNyYy5ib20gPSA0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjMyQkU6XG4gICAgICBzcmMudHlwZSA9IFVURjMyQkU7XG4gICAgICBpZiAoYnVmLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgIGlmIChidWZbMF0gPT09IDAgJiYgYnVmWzFdID09PSAwICYmIGJ1ZlsyXSA9PT0gMHhmZSAmJiBidWZbM10gPT09IDB4ZmYpIHtcbiAgICAgICAgICBzcmMuYm9tID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmWzBdID09PSAweGZmICYmIGJ1ZlsxXSA9PT0gMHhmZSAmJiBidWZbMl0gPT09IDAgJiYgYnVmWzNdID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3JjIHR5cGU6ICR7VVRGMzJCRX0gc3BlY2lmaWVkIGJ1dCBCT00gaXMgZm9yICR7VVRGMzJMRX1cImApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjMyTEU6XG4gICAgICBzcmMudHlwZSA9IFVURjMyTEU7XG4gICAgICBpZiAoYnVmLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgIGlmIChidWZbMF0gPT09IDAgJiYgYnVmWzFdID09PSAwICYmIGJ1ZlsyXSA9PT0gMHhmZSAmJiBidWZbM10gPT09IDB4ZmYpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzcmMgdHlwZTogXCIke1VURjMyTEV9XCIgc3BlY2lmaWVkIGJ1dCBCT00gaXMgZm9yIFwiJHtVVEYzMkJFfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMHhmZiAmJiBidWZbMV0gPT09IDB4ZmUgJiYgYnVmWzJdID09PSAwICYmIGJ1ZlszXSA9PT0gMCkge1xuICAgICAgICAgIHNyYy5ib20gPSA0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVVRGMzIgQk9NOiBzcmMgdHlwZSBcIiR7c3JjLnR5cGV9XCIgdW5yZWNvZ25pemVkYCk7XG4gIH1cbn07XG4vLyBWYWxpZGF0ZXMgdGhlIHNvdXJjZSBlbmNvZGluZyB0eXBlIGFuZCBtYXRjaGluZyBkYXRhLlxuLy8gSWYgdGhlIEJBU0U2NDogcHJlZml4IGlzIHByZXNlbnQsIHRoZSBiYXNlIDY0IGRlY29kaW5nIGlzIGRvbmUgaGVyZSBhcyB0aGUgaW5pdGlhbCBzdGVwLlxuLy8gLSBGb3IgdHlwZSBTVFJJTkcsIGRhdGEgbXVzdCBiZSBhIEphdmFTY3JpcHQgc3RyaW5nLlxuLy8gLSBGb3IgdHlwZSBCQVNFNjQ6KiwgZGF0YSBtYXkgYmUgYSBzdHJpbmcgb3IgQnVmZmVyLlxuLy8gLSBGb3IgYWxsIG90aGVyIHR5cGVzLCBkYXRhIG11c3QgYmUgYSBCdWZmZXIuXG4vLyAtIFRoZSBCQVNFNjQ6IHByZWZpeCBpcyBub3QgYWxsb3dlZCBmb3IgdHlwZSBTVFJJTkcuXG5jb25zdCB2YWxpZGF0ZVNyYyA9IGZ1bmN0aW9uIHZhbGlkYXRlU3JjKHR5cGUsIGRhdGEpIHtcbiAgZnVuY3Rpb24gZ2V0VHlwZSh0eXBlQXJnKSB7XG4gICAgY29uc3QgcmV0ID0ge1xuICAgICAgdHlwZTogJycsXG4gICAgICBiYXNlNjQ6IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3QgcnggPSAvXihiYXNlNjQ6KT8oW2EtekEtWjAtOV0rKSQvaTtcbiAgICBjb25zdCByZXN1bHQgPSByeC5leGVjKHR5cGVBcmcpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChyZXN1bHRbMl0pIHtcbiAgICAgICAgcmV0LnR5cGUgPSByZXN1bHRbMl0udG9VcHBlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHRbMV0pIHtcbiAgICAgICAgcmV0LmJhc2U2NCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgY29uc3QgcmV0ID0gZ2V0VHlwZSh0eXBlLnRvVXBwZXJDYXNlKCkpO1xuICBpZiAocmV0LmJhc2U2NCkge1xuICAgIC8qIGhhbmRsZSBiYXNlIDY0ICovXG4gICAgaWYgKHJldC50eXBlID09PSBTVFJJTkcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGU6IFwiJHt0eXBlfSBcIkJBU0U2NDpcIiBwcmVmaXggbm90IGFsbG93ZWQgd2l0aCB0eXBlICR7U1RSSU5HfWApO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICByZXQuZGF0YSA9IHRyYW5zLmJhc2U2NC5kZWNvZGUoZGF0YSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEsICdhc2NpaScpO1xuICAgICAgcmV0LmRhdGEgPSB0cmFucy5iYXNlNjQuZGVjb2RlKGJ1Zik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGU6IFwiJHt0eXBlfSB1bnJlY29nbml6ZWQgZGF0YSB0eXBlOiB0eXBlb2YoZGF0YSk6ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldC5kYXRhID0gZGF0YTtcbiAgfVxuICBzd2l0Y2ggKHJldC50eXBlKSB7XG4gICAgY2FzZSBVVEY4OlxuICAgICAgYm9tOChyZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYxNjpcbiAgICBjYXNlIFVURjE2QkU6XG4gICAgY2FzZSBVVEYxNkxFOlxuICAgICAgYm9tMTYocmV0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMzI6XG4gICAgY2FzZSBVVEYzMkJFOlxuICAgIGNhc2UgVVRGMzJMRTpcbiAgICAgIGJvbTMyKHJldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVJTlQxNjpcbiAgICAgIHJldC50eXBlID0gVUlOVDE2QkU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVJTlQzMjpcbiAgICAgIHJldC50eXBlID0gVUlOVDMyQkU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEFTQ0lJOlxuICAgICAgcmV0LnR5cGUgPSBVSU5UNztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQklOQVJZOlxuICAgICAgcmV0LnR5cGUgPSBVSU5UODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVUlOVDc6XG4gICAgY2FzZSBVSU5UODpcbiAgICBjYXNlIFVJTlQxNkxFOlxuICAgIGNhc2UgVUlOVDE2QkU6XG4gICAgY2FzZSBVSU5UMzJMRTpcbiAgICBjYXNlIFVJTlQzMkJFOlxuICAgIGNhc2UgU1RSSU5HOlxuICAgIGNhc2UgRVNDQVBFRDpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlOiBcIiR7dHlwZX1cIiBub3QgcmVjb2duaXplZGApO1xuICB9XG4gIGlmIChyZXQudHlwZSA9PT0gU1RSSU5HKSB7XG4gICAgaWYgKHR5cGVvZiByZXQuZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGU6IFwiJHt0eXBlfVwiIGJ1dCBkYXRhIGlzIG5vdCBhIHN0cmluZ2ApO1xuICAgIH1cbiAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHJldC5kYXRhKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGU6IFwiJHt0eXBlfVwiIGJ1dCBkYXRhIGlzIG5vdCBhIEJ1ZmZlcmApO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gRGlzYXNzZW1ibGVzIGFuZCB2YWxpZGF0ZXMgdGhlIGRlc3RpbmF0aW9uIHR5cGUuXG4vLyBgY2hhcnNgIG11c3QgYmUgYW4gQXJyYXkgb2YgaW50ZWdlcnMuXG4vLyBUaGUgOkJBU0U2NCBzdWZmaXggaXMgbm90IGFsbG93ZWQgZm9yIHR5cGUgU1RSSU5HLlxuY29uc3QgdmFsaWRhdGVEc3QgPSBmdW5jdGlvbiB2YWxpZGF0ZURzdCh0eXBlLCBjaGFycykge1xuICBmdW5jdGlvbiBnZXRUeXBlKHR5cGVBcmcpIHtcbiAgICBsZXQgZml4O1xuICAgIGxldCByZW07XG4gICAgY29uc3QgcmV0ID0ge1xuICAgICAgY3JsZjogZmFsc2UsXG4gICAgICBsZjogZmFsc2UsXG4gICAgICBiYXNlNjQ6IGZhbHNlLFxuICAgICAgdHlwZTogJycsXG4gICAgfTtcbiAgICAvKiBwcmVmaXgsIGlmIGFueSAqL1xuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICByZW0gPSB0eXBlQXJnO1xuICAgICAgZml4ID0gdHlwZUFyZy5zbGljZSgwLCA1KTtcbiAgICAgIGlmIChmaXggPT09ICdDUkxGOicpIHtcbiAgICAgICAgcmV0LmNybGYgPSB0cnVlO1xuICAgICAgICByZW0gPSB0eXBlQXJnLnNsaWNlKDUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZpeCA9IHR5cGVBcmcuc2xpY2UoMCwgMyk7XG4gICAgICBpZiAoZml4ID09PSAnTEY6Jykge1xuICAgICAgICByZXQubGYgPSB0cnVlO1xuICAgICAgICByZW0gPSB0eXBlQXJnLnNsaWNlKDMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvKiBzdWZmaXgsIGlmIGFueSAqL1xuICAgIGZpeCA9IHJlbS5zcGxpdCgnOicpO1xuICAgIGlmIChmaXgubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgIHJldC50eXBlID0gZml4WzBdO1xuICAgIH0gZWxzZSBpZiAoZml4Lmxlbmd0aCA9PT0gMiAmJiBmaXhbMV0gPT09ICdCQVNFNjQnKSB7XG4gICAgICByZXQuYmFzZTY0ID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgcmV0LnR5cGUgPSBmaXhbMF07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGRzdCBjaGFyczogbm90IGFycmF5OiBcIiR7dHlwZW9mIGNoYXJzfWApO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkc3QgdHlwZTogbm90IHN0cmluZzogXCIke3R5cGVvZiB0eXBlfWApO1xuICB9XG4gIGNvbnN0IHJldCA9IGdldFR5cGUodHlwZS50b1VwcGVyQ2FzZSgpKTtcbiAgc3dpdGNoIChyZXQudHlwZSkge1xuICAgIGNhc2UgVVRGODpcbiAgICBjYXNlIFVURjE2QkU6XG4gICAgY2FzZSBVVEYxNkxFOlxuICAgIGNhc2UgVVRGMzJCRTpcbiAgICBjYXNlIFVURjMyTEU6XG4gICAgY2FzZSBVSU5UNzpcbiAgICBjYXNlIFVJTlQ4OlxuICAgIGNhc2UgVUlOVDE2TEU6XG4gICAgY2FzZSBVSU5UMTZCRTpcbiAgICBjYXNlIFVJTlQzMkxFOlxuICAgIGNhc2UgVUlOVDMyQkU6XG4gICAgY2FzZSBFU0NBUEVEOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTVFJJTkc6XG4gICAgICBpZiAocmV0LmJhc2U2NCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcIjpCQVNFNjRcIiBzdWZmaXggbm90IGFsbG93ZWQgd2l0aCB0eXBlICR7U1RSSU5HfWApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBU0NJSTpcbiAgICAgIHJldC50eXBlID0gVUlOVDc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJJTkFSWTpcbiAgICAgIHJldC50eXBlID0gVUlOVDg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjE2OlxuICAgICAgcmV0LnR5cGUgPSBVVEYxNkJFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYzMjpcbiAgICAgIHJldC50eXBlID0gVVRGMzJCRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVUlOVDE2OlxuICAgICAgcmV0LnR5cGUgPSBVSU5UMTZCRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVUlOVDMyOlxuICAgICAgcmV0LnR5cGUgPSBVSU5UMzJCRTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkc3QgdHlwZSB1bnJlY29nbml6ZWQ6IFwiJHt0eXBlfVwiIDogbXVzdCBoYXZlIGZvcm0gW2NybGY6fGxmOl10eXBlWzpiYXNlNjRdYCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBTZWxlY3QgYW5kIGNhbGwgdGhlIHJlcXVlc3RlZCBlbmNvZGluZyBmdW5jdGlvbi5cbmNvbnN0IGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZSh0eXBlLCBjaGFycykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFVURjg6XG4gICAgICByZXR1cm4gdHJhbnMudXRmOC5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVVRGMTZCRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYxNmJlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVVEYxNkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjE2bGUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVURjMyQkU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMzJiZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVVRGMzJMRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYzMmxlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVSU5UNzpcbiAgICAgIHJldHVybiB0cmFucy51aW50Ny5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVUlOVDg6XG4gICAgICByZXR1cm4gdHJhbnMudWludDguZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVJTlQxNkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQxNmJlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVSU5UMTZMRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MTZsZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVUlOVDMyQkU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDMyYmUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVJTlQzMkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQzMmxlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBTVFJJTkc6XG4gICAgICByZXR1cm4gdHJhbnMuc3RyaW5nLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBFU0NBUEVEOlxuICAgICAgcmV0dXJuIHRyYW5zLmVzY2FwZWQuZW5jb2RlKGNoYXJzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZW5jb2RlIHR5cGUgXCIke3R5cGV9XCIgbm90IHJlY29nbml6ZWRgKTtcbiAgfVxufTtcbi8vIFNlbGVjdCBhbmQgY2FsbCB0aGUgcmVxdWVzdGVkIGRlY29kaW5nIGZ1bmN0aW9uLlxuLy8gYHNyY2AgY29udGFpbnMgQk9NIGluZm9ybWF0aW9uIGFzIHdlbGwgYXMgdGhlIHNvdXJjZSB0eXBlIGFuZCBkYXRhLlxuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHNyYykge1xuICBzd2l0Y2ggKHNyYy50eXBlKSB7XG4gICAgY2FzZSBVVEY4OlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjguZGVjb2RlKHNyYy5kYXRhLCBzcmMuYm9tKTtcbiAgICBjYXNlIFVURjE2TEU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMTZsZS5kZWNvZGUoc3JjLmRhdGEsIHNyYy5ib20pO1xuICAgIGNhc2UgVVRGMTZCRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYxNmJlLmRlY29kZShzcmMuZGF0YSwgc3JjLmJvbSk7XG4gICAgY2FzZSBVVEYzMkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjMyYmUuZGVjb2RlKHNyYy5kYXRhLCBzcmMuYm9tKTtcbiAgICBjYXNlIFVURjMyTEU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMzJsZS5kZWNvZGUoc3JjLmRhdGEsIHNyYy5ib20pO1xuICAgIGNhc2UgVUlOVDc6XG4gICAgICByZXR1cm4gdHJhbnMudWludDcuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIFVJTlQ4OlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQ4LmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBVSU5UMTZCRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MTZiZS5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGNhc2UgVUlOVDE2TEU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDE2bGUuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIFVJTlQzMkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQzMmJlLmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBVSU5UMzJMRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MzJsZS5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGNhc2UgU1RSSU5HOlxuICAgICAgcmV0dXJuIHRyYW5zLnN0cmluZy5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGNhc2UgRVNDQVBFRDpcbiAgICAgIHJldHVybiB0cmFucy5lc2NhcGVkLmRlY29kZShzcmMuZGF0YSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGRlY29kZSB0eXBlIFwiJHtzcmMudHlwZX1cIiBub3QgcmVjb2duaXplZGApO1xuICB9XG59O1xuXG4vLyBUaGUgcHVibGljIGRlY29kaW5nIGZ1bmN0aW9uLiBSZXR1cm5zIGFuIGFycmF5IG9mIGludGVnZXJzLlxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBleHBvcnRzRGVjb2RlKHR5cGUsIGRhdGEpIHtcbiAgY29uc3Qgc3JjID0gdmFsaWRhdGVTcmModHlwZSwgZGF0YSk7XG4gIHJldHVybiBkZWNvZGUoc3JjKTtcbn07XG4vLyBUaGUgcHVibGljIGVuY29kaW5nIGZ1bmN0aW9uLiBSZXR1cm5zIGEgQnVmZmVyLXR5cGVkIGJ5dGUgYXJyYXkuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGV4cG9ydHNFbmNvZGUodHlwZSwgY2hhcnMpIHtcbiAgbGV0IGM7XG4gIGxldCBidWY7XG4gIGNvbnN0IGRzdCA9IHZhbGlkYXRlRHN0KHR5cGUsIGNoYXJzKTtcbiAgaWYgKGRzdC5jcmxmKSB7XG4gICAgLyogcHJlZml4IHdpdGggQ1JMRiBsaW5lIGVuZCBjb252ZXJzaW9uLCBkb24ndCBjb250YW1pbmF0ZSBjYWxsZXIncyBjaGFycyBhcnJheSAqL1xuICAgIGMgPSB0cmFucy5saW5lRW5kcy5jcmxmKGNoYXJzKTtcbiAgICBidWYgPSBlbmNvZGUoZHN0LnR5cGUsIGMpO1xuICB9IGVsc2UgaWYgKGRzdC5sZikge1xuICAgIC8qIHByZWZpeCB3aXRoIExGIGxpbmUgZW5kIGNvbnZlcnNpb24sIGRvbid0IGNvbnRhbWluYXRlIGNhbGxlcidzIGNoYXJzIGFycmF5ICovXG4gICAgYyA9IHRyYW5zLmxpbmVFbmRzLmxmKGNoYXJzKTtcbiAgICBidWYgPSBlbmNvZGUoZHN0LnR5cGUsIGMpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IGVuY29kZShkc3QudHlwZSwgY2hhcnMpO1xuICB9XG4gIGlmIChkc3QuYmFzZTY0KSB7XG4gICAgLyogcG9zdCBiYXNlIDY0IGVuY29kaW5nICovXG4gICAgYnVmID0gdHJhbnMuYmFzZTY0LmVuY29kZShidWYpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuLy8gQ29udmVydHMgZGF0YSBvZiB0eXBlIGBzcmNUeXBlYCB0byBkYXRhIG9mIHR5cGUgYGRzdFR5cGVgLlxuLy8gYHNyY0RhdGFgIG1heSBiZSBhIEphdmFTY3JpcHQgU3RyaW5nLCBvciBub2RlLmpzIEJ1ZmZlciwgZGVwZW5kaW5nIG9uIHRoZSBjb3JyZXNwb25kaW5nIHR5cGUuXG5jb25zdCBjb252ZXJ0ID0gZnVuY3Rpb24gY29udmVydChzcmNUeXBlLCBzcmNEYXRhLCBkc3RUeXBlKSB7XG4gIHJldHVybiBleHBvcnRzLmVuY29kZShkc3RUeXBlLCBleHBvcnRzLmRlY29kZShzcmNUeXBlLCBzcmNEYXRhKSk7XG59O1xuZXhwb3J0cy5jb252ZXJ0ID0gY29udmVydDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/converter.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/transformers.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/transformers.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* eslint-disable prefer-destructuring */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-bitwise */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module contains the actual encoding and decoding algorithms.\n// Throws \"RangeError\" exceptions on characters or bytes out of range for the given encoding.\n\n'use strict;';\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n\n/* decoding error codes */\nconst NON_SHORTEST = 0xfffffffc;\nconst TRAILING = 0xfffffffd;\nconst RANGE = 0xfffffffe;\nconst ILL_FORMED = 0xffffffff;\n\n/* mask[n] = 2**n - 1, ie. mask[n] = n bits on. e.g. mask[6] = %b111111 */\nconst mask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023];\n\n/* ascii[n] = 'HH', where 0xHH = n, eg. ascii[254] = 'FE' */\nconst ascii = [\n  '00',\n  '01',\n  '02',\n  '03',\n  '04',\n  '05',\n  '06',\n  '07',\n  '08',\n  '09',\n  '0A',\n  '0B',\n  '0C',\n  '0D',\n  '0E',\n  '0F',\n  '10',\n  '11',\n  '12',\n  '13',\n  '14',\n  '15',\n  '16',\n  '17',\n  '18',\n  '19',\n  '1A',\n  '1B',\n  '1C',\n  '1D',\n  '1E',\n  '1F',\n  '20',\n  '21',\n  '22',\n  '23',\n  '24',\n  '25',\n  '26',\n  '27',\n  '28',\n  '29',\n  '2A',\n  '2B',\n  '2C',\n  '2D',\n  '2E',\n  '2F',\n  '30',\n  '31',\n  '32',\n  '33',\n  '34',\n  '35',\n  '36',\n  '37',\n  '38',\n  '39',\n  '3A',\n  '3B',\n  '3C',\n  '3D',\n  '3E',\n  '3F',\n  '40',\n  '41',\n  '42',\n  '43',\n  '44',\n  '45',\n  '46',\n  '47',\n  '48',\n  '49',\n  '4A',\n  '4B',\n  '4C',\n  '4D',\n  '4E',\n  '4F',\n  '50',\n  '51',\n  '52',\n  '53',\n  '54',\n  '55',\n  '56',\n  '57',\n  '58',\n  '59',\n  '5A',\n  '5B',\n  '5C',\n  '5D',\n  '5E',\n  '5F',\n  '60',\n  '61',\n  '62',\n  '63',\n  '64',\n  '65',\n  '66',\n  '67',\n  '68',\n  '69',\n  '6A',\n  '6B',\n  '6C',\n  '6D',\n  '6E',\n  '6F',\n  '70',\n  '71',\n  '72',\n  '73',\n  '74',\n  '75',\n  '76',\n  '77',\n  '78',\n  '79',\n  '7A',\n  '7B',\n  '7C',\n  '7D',\n  '7E',\n  '7F',\n  '80',\n  '81',\n  '82',\n  '83',\n  '84',\n  '85',\n  '86',\n  '87',\n  '88',\n  '89',\n  '8A',\n  '8B',\n  '8C',\n  '8D',\n  '8E',\n  '8F',\n  '90',\n  '91',\n  '92',\n  '93',\n  '94',\n  '95',\n  '96',\n  '97',\n  '98',\n  '99',\n  '9A',\n  '9B',\n  '9C',\n  '9D',\n  '9E',\n  '9F',\n  'A0',\n  'A1',\n  'A2',\n  'A3',\n  'A4',\n  'A5',\n  'A6',\n  'A7',\n  'A8',\n  'A9',\n  'AA',\n  'AB',\n  'AC',\n  'AD',\n  'AE',\n  'AF',\n  'B0',\n  'B1',\n  'B2',\n  'B3',\n  'B4',\n  'B5',\n  'B6',\n  'B7',\n  'B8',\n  'B9',\n  'BA',\n  'BB',\n  'BC',\n  'BD',\n  'BE',\n  'BF',\n  'C0',\n  'C1',\n  'C2',\n  'C3',\n  'C4',\n  'C5',\n  'C6',\n  'C7',\n  'C8',\n  'C9',\n  'CA',\n  'CB',\n  'CC',\n  'CD',\n  'CE',\n  'CF',\n  'D0',\n  'D1',\n  'D2',\n  'D3',\n  'D4',\n  'D5',\n  'D6',\n  'D7',\n  'D8',\n  'D9',\n  'DA',\n  'DB',\n  'DC',\n  'DD',\n  'DE',\n  'DF',\n  'E0',\n  'E1',\n  'E2',\n  'E3',\n  'E4',\n  'E5',\n  'E6',\n  'E7',\n  'E8',\n  'E9',\n  'EA',\n  'EB',\n  'EC',\n  'ED',\n  'EE',\n  'EF',\n  'F0',\n  'F1',\n  'F2',\n  'F3',\n  'F4',\n  'F5',\n  'F6',\n  'F7',\n  'F8',\n  'F9',\n  'FA',\n  'FB',\n  'FC',\n  'FD',\n  'FE',\n  'FF',\n];\n\n/* vector of base 64 characters */\nconst base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('');\n\n/* vector of base 64 character codes */\nconst base64codes = [];\nbase64chars.forEach((char) => {\n  base64codes.push(char.charCodeAt(0));\n});\n\n// The UTF8 algorithms.\nexports.utf8 = {\n  encode(chars) {\n    const bytes = [];\n    chars.forEach((char) => {\n      if (char >= 0 && char <= 0x7f) {\n        bytes.push(char);\n      } else if (char <= 0x7ff) {\n        bytes.push(0xc0 + ((char >> 6) & mask[5]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char < 0xd800 || (char > 0xdfff && char <= 0xffff)) {\n        bytes.push(0xe0 + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        const u = (char >> 16) & mask[5];\n        bytes.push(0xf0 + (u >> 2));\n        bytes.push(0x80 + ((u & mask[2]) << 4) + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else {\n        throw new RangeError(`utf8.encode: character out of range: char: ${char}`);\n      }\n    });\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* bytes functions return error for non-shortest forms & values out of range */\n    function bytes2(b1, b2) {\n      /* U+0080..U+07FF */\n      /* 00000000 00000yyy yyxxxxxx | 110yyyyy 10xxxxxx */\n      if ((b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[5]) << 6) + (b2 & mask[6]);\n      if (x < 0x80) {\n        return NON_SHORTEST;\n      }\n      return x;\n    }\n    function bytes3(b1, b2, b3) {\n      /* U+0800..U+FFFF */\n      /* 00000000 zzzzyyyy yyxxxxxx | 1110zzzz 10yyyyyy 10xxxxxx */\n      if ((b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[4]) << 12) + ((b2 & mask[6]) << 6) + (b3 & mask[6]);\n      if (x < 0x800) {\n        return NON_SHORTEST;\n      }\n      if (x >= 0xd800 && x <= 0xdfff) {\n        return RANGE;\n      }\n      return x;\n    }\n    function bytes4(b1, b2, b3, b4) {\n      /* U+10000..U+10FFFF */\n      /* 000uuuuu zzzzyyyy yyxxxxxx | 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx */\n      if ((b4 & 0xc0) !== 0x80 || (b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x =\n        ((((b1 & mask[3]) << 2) + ((b2 >> 4) & mask[2])) << 16) +\n        ((b2 & mask[4]) << 12) +\n        ((b3 & mask[6]) << 6) +\n        (b4 & mask[6]);\n      if (x < 0x10000) {\n        return NON_SHORTEST;\n      }\n      if (x > 0x10ffff) {\n        return RANGE;\n      }\n      return x;\n    }\n    let c;\n    let b1;\n    let i1;\n    let i2;\n    let i3;\n    let inc;\n    const len = buf.length;\n    let i = bom ? 3 : 0;\n    const chars = [];\n    while (i < len) {\n      b1 = buf[i];\n      c = ILL_FORMED;\n      const TRUE = true;\n      while (TRUE) {\n        if (b1 >= 0 && b1 <= 0x7f) {\n          /* U+0000..U+007F 00..7F */\n          c = b1;\n          inc = 1;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 < len && b1 >= 0xc2 && b1 <= 0xdf) {\n          /* U+0080..U+07FF C2..DF 80..BF */\n          c = bytes2(b1, buf[i1]);\n          inc = 2;\n          break;\n        }\n        i2 = i + 2;\n        if (i2 < len && b1 >= 0xe0 && b1 <= 0xef) {\n          /* U+0800..U+FFFF */\n          c = bytes3(b1, buf[i1], buf[i2]);\n          inc = 3;\n          break;\n        }\n        i3 = i + 3;\n        if (i3 < len && b1 >= 0xf0 && b1 <= 0xf4) {\n          /* U+10000..U+10FFFF */\n          c = bytes4(b1, buf[i1], buf[i2], buf[i3]);\n          inc = 4;\n          break;\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        break;\n      }\n      if (c > 0x10ffff) {\n        const at = `byte[${i}]`;\n        if (c === ILL_FORMED) {\n          throw new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${at}`);\n        }\n        if (c === TRAILING) {\n          throw new RangeError(`utf8.decode: illegal trailing byte found at: ${at}`);\n        }\n        if (c === RANGE) {\n          throw new RangeError(`utf8.decode: code point out of range found at: ${at}`);\n        }\n        if (c === NON_SHORTEST) {\n          throw new RangeError(`utf8.decode: non-shortest form found at: ${at}`);\n        }\n        throw new RangeError(`utf8.decode: unrecognized error found at: ${at}`);\n      }\n      chars.push(c);\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16BE algorithms.\nexports.utf16be = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push((char >> 8) & mask[8]);\n        bytes.push(char & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(h & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n      } else {\n        throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i] << 8) + buf[i1];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i + 2] << 8) + buf[i3];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16LE algorithms.\nexports.utf16le = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push(char & mask[8]);\n        bytes.push((char >> 8) & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push(h & mask[8]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n      } else {\n        throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i1] << 8) + buf[i];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i3] << 8) + buf[i + 2];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF32BE algorithms.\nexports.utf32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UTF32LE algorithms.\nexports.utf32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UINT7 algorithms. ASCII or 7-bit unsigned integers.\nexports.uint7 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0x7f) {\n        throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      if (buf[i] > 0x7f) {\n        throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${i}]: ${buf[i]}`);\n      }\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT8 algorithms. BINARY, Latin 1 or 8-bit unsigned integers.\nexports.uint8 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0xff) {\n        throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT16BE algorithms. Big-endian 16-bit unsigned integers.\nexports.uint16be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i] << 8) + buf[i + 1]);\n    }\n    return chars;\n  },\n};\n\n// The UINT16LE algorithms. Little-endian 16-bit unsigned integers.\nexports.uint16le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32BE algorithms. Big-endian 32-bit unsigned integers.\nexports.uint32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32LE algorithms. Little-endian 32-bit unsigned integers.\nexports.uint32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The STRING algorithms. Converts JavaScript strings to Array of 32-bit integers and vice versa.\n// Uses the node.js Buffer's native \"utf16le\" capabilites.\nexports.string = {\n  encode(chars) {\n    return exports.utf16le.encode(chars).toString('utf16le');\n  },\n  decode(str) {\n    return exports.utf16le.decode(Buffer.from(str, 'utf16le'), 0);\n  },\n};\n\n// The ESCAPED algorithms.\n// Note that ESCAPED format contains only ASCII characters.\n// The characters are always in the form of a Buffer of bytes.\nexports.escaped = {\n  // Encodes an Array of 32-bit integers into ESCAPED format.\n  encode(chars) {\n    const bytes = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      const char = chars[i];\n      if (char === 96) {\n        bytes.push(char);\n        bytes.push(char);\n      } else if (char === 10) {\n        bytes.push(char);\n      } else if (char >= 32 && char <= 126) {\n        bytes.push(char);\n      } else {\n        let str = '';\n        if (char >= 0 && char <= 31) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 127 && char <= 255) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 0x100 && char <= 0xffff) {\n          str += `\\`u${ascii[(char >> 8) & mask[8]]}${ascii[char & mask[8]]}`;\n        } else if (char >= 0x10000 && char <= 0xffffffff) {\n          str += '`u{';\n          const digit = (char >> 24) & mask[8];\n          if (digit > 0) {\n            str += ascii[digit];\n          }\n          str += `${ascii[(char >> 16) & mask[8]] + ascii[(char >> 8) & mask[8]] + ascii[char & mask[8]]}}`;\n        } else {\n          throw new Error('escape.encode(char): char > 0xffffffff not allowed');\n        }\n        const buf = Buffer.from(str);\n        buf.forEach((b) => {\n          bytes.push(b);\n        });\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  // Decodes ESCAPED format from a Buffer of bytes to an Array of 32-bit integers.\n  decode(buf) {\n    function isHex(hex) {\n      if ((hex >= 48 && hex <= 57) || (hex >= 65 && hex <= 70) || (hex >= 97 && hex <= 102)) {\n        return true;\n      }\n      return false;\n    }\n    function getx(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 2, error: true };\n      if (i + 1 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getu(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      if (i + 3 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1]) && isHex(bufArg[i + 2]) && isHex(bufArg[i + 3])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1], bufArg[i + 2], bufArg[i + 3]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getU(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      let str = '';\n      while (i < len && isHex(bufArg[i])) {\n        str += String.fromCodePoint(bufArg[i]);\n        // eslint-disable-next-line no-param-reassign\n        i += 1;\n      }\n      ret.char = parseInt(str, 16);\n      if (bufArg[i] === 125 && !Number.isNaN(ret.char)) {\n        ret.error = false;\n      }\n      ret.nexti = i + 1;\n      return ret;\n    }\n    const chars = [];\n    const len = buf.length;\n    let i1;\n    let ret;\n    let error;\n    let i = 0;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        error = true;\n        if (buf[i] !== 96) {\n          /* unescaped character */\n          chars.push(buf[i]);\n          i += 1;\n          error = false;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 >= len) {\n          break;\n        }\n        if (buf[i1] === 96) {\n          /* escaped grave accent */\n          chars.push(96);\n          i += 2;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 120) {\n          ret = getx(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped hex */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 117) {\n          if (buf[i1 + 1] === 123) {\n            ret = getU(i1 + 2, len, buf);\n            if (ret.error) {\n              break;\n            }\n            /* escaped utf-32 */\n            chars.push(ret.char);\n            i = ret.nexti;\n            error = false;\n            break;\n          }\n          ret = getu(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped utf-16 */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        break;\n      }\n      if (error) {\n        throw new Error(`escaped.decode: ill-formed escape sequence at buf[${i}]`);\n      }\n    }\n    return chars;\n  },\n};\n\n// The line end conversion algorigthms.\nconst CR = 13;\nconst LF = 10;\nexports.lineEnds = {\n  crlf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(CR);\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(CR);\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(CR);\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n  lf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n};\n\n// The base 64 algorithms.\nexports.base64 = {\n  encode(buf) {\n    if (buf.length === 0) {\n      return Buffer.alloc(0);\n    }\n    let i;\n    let j;\n    let n;\n    let tail = buf.length % 3;\n    tail = tail > 0 ? 3 - tail : 0;\n    let units = (buf.length + tail) / 3;\n    const base64 = Buffer.alloc(units * 4);\n    if (tail > 0) {\n      units -= 1;\n    }\n    i = 0;\n    j = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = buf[i++] << 16;\n      n += buf[i++] << 8;\n      n += buf[i++];\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j++] = base64codes[n & mask[6]];\n    }\n    if (tail === 0) {\n      return base64;\n    }\n    if (tail === 1) {\n      n = buf[i++] << 16;\n      n += buf[i] << 8;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    if (tail === 2) {\n      n = buf[i] << 16;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[64];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    return undefined;\n  },\n  decode(codes) {\n    /* remove white space and ctrl characters, validate & translate characters */\n    function validate(buf) {\n      const chars = [];\n      let tail = 0;\n      for (let i = 0; i < buf.length; i += 1) {\n        const char = buf[i];\n        const TRUE = true;\n        while (TRUE) {\n          if (char === 32 || char === 9 || char === 10 || char === 13) {\n            break;\n          }\n          if (char >= 65 && char <= 90) {\n            chars.push(char - 65);\n            break;\n          }\n          if (char >= 97 && char <= 122) {\n            chars.push(char - 71);\n            break;\n          }\n          if (char >= 48 && char <= 57) {\n            chars.push(char + 4);\n            break;\n          }\n          if (char === 43) {\n            chars.push(62);\n            break;\n          }\n          if (char === 47) {\n            chars.push(63);\n            break;\n          }\n          if (char === 61) {\n            chars.push(64);\n            tail += 1;\n            break;\n          }\n          /* invalid character */\n          throw new RangeError(`base64.decode: invalid character buf[${i}]: ${char}`);\n        }\n      }\n      /* validate length */\n      if (chars.length % 4 > 0) {\n        throw new RangeError(`base64.decode: string length not integral multiple of 4: ${chars.length}`);\n      }\n      /* validate tail */\n      switch (tail) {\n        case 0:\n          break;\n        case 1:\n          if (chars[chars.length - 1] !== 64) {\n            throw new RangeError('base64.decode: one tail character found: not last character');\n          }\n          break;\n        case 2:\n          if (chars[chars.length - 1] !== 64 || chars[chars.length - 2] !== 64) {\n            throw new RangeError('base64.decode: two tail characters found: not last characters');\n          }\n          break;\n        default:\n          throw new RangeError(`base64.decode: more than two tail characters found: ${tail}`);\n      }\n      return { tail, buf: Buffer.from(chars) };\n    }\n\n    if (codes.length === 0) {\n      return Buffer.alloc(0);\n    }\n    const val = validate(codes);\n    const { tail } = val;\n    const base64 = val.buf;\n    let i;\n    let j;\n    let n;\n    let units = base64.length / 4;\n    const buf = Buffer.alloc(units * 3 - tail);\n    if (tail > 0) {\n      units -= 1;\n    }\n    j = 0;\n    i = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i++] << 6;\n      n += base64[i++];\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j++] = (n >> 8) & mask[8];\n      buf[j++] = n & mask[8];\n    }\n    if (tail === 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i] << 6;\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j] = (n >> 8) & mask[8];\n    }\n    if (tail === 2) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      buf[j] = (n >> 16) & mask[8];\n    }\n    return buf;\n  },\n  // Converts a base 64 Buffer of bytes to a JavaScript string with line breaks.\n  toString(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${buf.length}`);\n    }\n    let str = '';\n    let lineLen = 0;\n    function buildLine(c1, c2, c3, c4) {\n      switch (lineLen) {\n        case 76:\n          str += `\\r\\n${c1}${c2}${c3}${c4}`;\n          lineLen = 4;\n          break;\n        case 75:\n          str += `${c1}\\r\\n${c2}${c3}${c4}`;\n          lineLen = 3;\n          break;\n        case 74:\n          str += `${c1 + c2}\\r\\n${c3}${c4}`;\n          lineLen = 2;\n          break;\n        case 73:\n          str += `${c1 + c2 + c3}\\r\\n${c4}`;\n          lineLen = 1;\n          break;\n        default:\n          str += c1 + c2 + c3 + c4;\n          lineLen += 4;\n          break;\n      }\n    }\n    function validate(c) {\n      if (c >= 65 && c <= 90) {\n        return true;\n      }\n      if (c >= 97 && c <= 122) {\n        return true;\n      }\n      if (c >= 48 && c <= 57) {\n        return true;\n      }\n      if (c === 43) {\n        return true;\n      }\n      if (c === 47) {\n        return true;\n      }\n      if (c === 61) {\n        return true;\n      }\n      return false;\n    }\n    for (let i = 0; i < buf.length; i += 4) {\n      for (let j = i; j < i + 4; j += 1) {\n        if (!validate(buf[j])) {\n          throw new RangeError(`base64.toString: buf[${j}]: ${buf[j]} : not valid base64 character code`);\n        }\n      }\n      buildLine(\n        String.fromCharCode(buf[i]),\n        String.fromCharCode(buf[i + 1]),\n        String.fromCharCode(buf[i + 2]),\n        String.fromCharCode(buf[i + 3])\n      );\n    }\n    return str;\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvdHJhbnNmb3JtZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMkVBQTJFLEtBQUs7QUFDaEY7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQSx1RkFBdUYsR0FBRztBQUMxRjtBQUNBO0FBQ0EsK0VBQStFLEdBQUc7QUFDbEY7QUFDQTtBQUNBLGlGQUFpRixHQUFHO0FBQ3BGO0FBQ0E7QUFDQSwyRUFBMkUsR0FBRztBQUM5RTtBQUNBLDBFQUEwRSxHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsaUZBQWlGLEVBQUUsS0FBSyxLQUFLO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsV0FBVztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsRUFBRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlGQUFpRixFQUFFLEtBQUssS0FBSztBQUM3RjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLFdBQVc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLEVBQUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLE1BQU0sS0FBSyxLQUFLO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLFdBQVc7QUFDakg7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLDBGQUEwRixNQUFNLEtBQUssS0FBSztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLE1BQU0sS0FBSyxLQUFLO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLFdBQVc7QUFDakg7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLDBGQUEwRixNQUFNLEtBQUssS0FBSztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLHNGQUFzRixFQUFFLEtBQUssU0FBUztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHNGQUFzRixFQUFFLEtBQUssT0FBTztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLHNGQUFzRixFQUFFLEtBQUssU0FBUztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixNQUFNLEtBQUssS0FBSztBQUM1RztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdHQUF3RyxXQUFXO0FBQ25IO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLE1BQU0sS0FBSyxLQUFLO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0dBQXdHLFdBQVc7QUFDbkg7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdHQUF3RyxXQUFXO0FBQ25IO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxXQUFXO0FBQ25IO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkMsVUFBVTtBQUNWLHVCQUF1QixZQUFZO0FBQ25DLFVBQVU7QUFDVix1QkFBdUIsNkJBQTZCLEVBQUUsc0JBQXNCO0FBQzVFLFVBQVU7QUFDVixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0ZBQXNGO0FBQzFHLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEVBQUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxFQUFFLEtBQUssS0FBSztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixhQUFhO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLEtBQUs7QUFDM0Y7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsV0FBVztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRyxNQUFNLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxNQUFNLEdBQUcsRUFBRSxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhLE1BQU0sR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxzQkFBc0IsV0FBVztBQUNqQztBQUNBLHVEQUF1RCxFQUFFLEtBQUssUUFBUTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvdHJhbnNmb3JtZXJzLmpzPzIwMTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWRlc3RydWN0dXJpbmcgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBsdXNwbHVzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4vKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBjb250YWlucyB0aGUgYWN0dWFsIGVuY29kaW5nIGFuZCBkZWNvZGluZyBhbGdvcml0aG1zLlxuLy8gVGhyb3dzIFwiUmFuZ2VFcnJvclwiIGV4Y2VwdGlvbnMgb24gY2hhcmFjdGVycyBvciBieXRlcyBvdXQgb2YgcmFuZ2UgZm9yIHRoZSBnaXZlbiBlbmNvZGluZy5cblxuJ3VzZSBzdHJpY3Q7JztcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuXG4vKiBkZWNvZGluZyBlcnJvciBjb2RlcyAqL1xuY29uc3QgTk9OX1NIT1JURVNUID0gMHhmZmZmZmZmYztcbmNvbnN0IFRSQUlMSU5HID0gMHhmZmZmZmZmZDtcbmNvbnN0IFJBTkdFID0gMHhmZmZmZmZmZTtcbmNvbnN0IElMTF9GT1JNRUQgPSAweGZmZmZmZmZmO1xuXG4vKiBtYXNrW25dID0gMioqbiAtIDEsIGllLiBtYXNrW25dID0gbiBiaXRzIG9uLiBlLmcuIG1hc2tbNl0gPSAlYjExMTExMSAqL1xuY29uc3QgbWFzayA9IFswLCAxLCAzLCA3LCAxNSwgMzEsIDYzLCAxMjcsIDI1NSwgNTExLCAxMDIzXTtcblxuLyogYXNjaWlbbl0gPSAnSEgnLCB3aGVyZSAweEhIID0gbiwgZWcuIGFzY2lpWzI1NF0gPSAnRkUnICovXG5jb25zdCBhc2NpaSA9IFtcbiAgJzAwJyxcbiAgJzAxJyxcbiAgJzAyJyxcbiAgJzAzJyxcbiAgJzA0JyxcbiAgJzA1JyxcbiAgJzA2JyxcbiAgJzA3JyxcbiAgJzA4JyxcbiAgJzA5JyxcbiAgJzBBJyxcbiAgJzBCJyxcbiAgJzBDJyxcbiAgJzBEJyxcbiAgJzBFJyxcbiAgJzBGJyxcbiAgJzEwJyxcbiAgJzExJyxcbiAgJzEyJyxcbiAgJzEzJyxcbiAgJzE0JyxcbiAgJzE1JyxcbiAgJzE2JyxcbiAgJzE3JyxcbiAgJzE4JyxcbiAgJzE5JyxcbiAgJzFBJyxcbiAgJzFCJyxcbiAgJzFDJyxcbiAgJzFEJyxcbiAgJzFFJyxcbiAgJzFGJyxcbiAgJzIwJyxcbiAgJzIxJyxcbiAgJzIyJyxcbiAgJzIzJyxcbiAgJzI0JyxcbiAgJzI1JyxcbiAgJzI2JyxcbiAgJzI3JyxcbiAgJzI4JyxcbiAgJzI5JyxcbiAgJzJBJyxcbiAgJzJCJyxcbiAgJzJDJyxcbiAgJzJEJyxcbiAgJzJFJyxcbiAgJzJGJyxcbiAgJzMwJyxcbiAgJzMxJyxcbiAgJzMyJyxcbiAgJzMzJyxcbiAgJzM0JyxcbiAgJzM1JyxcbiAgJzM2JyxcbiAgJzM3JyxcbiAgJzM4JyxcbiAgJzM5JyxcbiAgJzNBJyxcbiAgJzNCJyxcbiAgJzNDJyxcbiAgJzNEJyxcbiAgJzNFJyxcbiAgJzNGJyxcbiAgJzQwJyxcbiAgJzQxJyxcbiAgJzQyJyxcbiAgJzQzJyxcbiAgJzQ0JyxcbiAgJzQ1JyxcbiAgJzQ2JyxcbiAgJzQ3JyxcbiAgJzQ4JyxcbiAgJzQ5JyxcbiAgJzRBJyxcbiAgJzRCJyxcbiAgJzRDJyxcbiAgJzREJyxcbiAgJzRFJyxcbiAgJzRGJyxcbiAgJzUwJyxcbiAgJzUxJyxcbiAgJzUyJyxcbiAgJzUzJyxcbiAgJzU0JyxcbiAgJzU1JyxcbiAgJzU2JyxcbiAgJzU3JyxcbiAgJzU4JyxcbiAgJzU5JyxcbiAgJzVBJyxcbiAgJzVCJyxcbiAgJzVDJyxcbiAgJzVEJyxcbiAgJzVFJyxcbiAgJzVGJyxcbiAgJzYwJyxcbiAgJzYxJyxcbiAgJzYyJyxcbiAgJzYzJyxcbiAgJzY0JyxcbiAgJzY1JyxcbiAgJzY2JyxcbiAgJzY3JyxcbiAgJzY4JyxcbiAgJzY5JyxcbiAgJzZBJyxcbiAgJzZCJyxcbiAgJzZDJyxcbiAgJzZEJyxcbiAgJzZFJyxcbiAgJzZGJyxcbiAgJzcwJyxcbiAgJzcxJyxcbiAgJzcyJyxcbiAgJzczJyxcbiAgJzc0JyxcbiAgJzc1JyxcbiAgJzc2JyxcbiAgJzc3JyxcbiAgJzc4JyxcbiAgJzc5JyxcbiAgJzdBJyxcbiAgJzdCJyxcbiAgJzdDJyxcbiAgJzdEJyxcbiAgJzdFJyxcbiAgJzdGJyxcbiAgJzgwJyxcbiAgJzgxJyxcbiAgJzgyJyxcbiAgJzgzJyxcbiAgJzg0JyxcbiAgJzg1JyxcbiAgJzg2JyxcbiAgJzg3JyxcbiAgJzg4JyxcbiAgJzg5JyxcbiAgJzhBJyxcbiAgJzhCJyxcbiAgJzhDJyxcbiAgJzhEJyxcbiAgJzhFJyxcbiAgJzhGJyxcbiAgJzkwJyxcbiAgJzkxJyxcbiAgJzkyJyxcbiAgJzkzJyxcbiAgJzk0JyxcbiAgJzk1JyxcbiAgJzk2JyxcbiAgJzk3JyxcbiAgJzk4JyxcbiAgJzk5JyxcbiAgJzlBJyxcbiAgJzlCJyxcbiAgJzlDJyxcbiAgJzlEJyxcbiAgJzlFJyxcbiAgJzlGJyxcbiAgJ0EwJyxcbiAgJ0ExJyxcbiAgJ0EyJyxcbiAgJ0EzJyxcbiAgJ0E0JyxcbiAgJ0E1JyxcbiAgJ0E2JyxcbiAgJ0E3JyxcbiAgJ0E4JyxcbiAgJ0E5JyxcbiAgJ0FBJyxcbiAgJ0FCJyxcbiAgJ0FDJyxcbiAgJ0FEJyxcbiAgJ0FFJyxcbiAgJ0FGJyxcbiAgJ0IwJyxcbiAgJ0IxJyxcbiAgJ0IyJyxcbiAgJ0IzJyxcbiAgJ0I0JyxcbiAgJ0I1JyxcbiAgJ0I2JyxcbiAgJ0I3JyxcbiAgJ0I4JyxcbiAgJ0I5JyxcbiAgJ0JBJyxcbiAgJ0JCJyxcbiAgJ0JDJyxcbiAgJ0JEJyxcbiAgJ0JFJyxcbiAgJ0JGJyxcbiAgJ0MwJyxcbiAgJ0MxJyxcbiAgJ0MyJyxcbiAgJ0MzJyxcbiAgJ0M0JyxcbiAgJ0M1JyxcbiAgJ0M2JyxcbiAgJ0M3JyxcbiAgJ0M4JyxcbiAgJ0M5JyxcbiAgJ0NBJyxcbiAgJ0NCJyxcbiAgJ0NDJyxcbiAgJ0NEJyxcbiAgJ0NFJyxcbiAgJ0NGJyxcbiAgJ0QwJyxcbiAgJ0QxJyxcbiAgJ0QyJyxcbiAgJ0QzJyxcbiAgJ0Q0JyxcbiAgJ0Q1JyxcbiAgJ0Q2JyxcbiAgJ0Q3JyxcbiAgJ0Q4JyxcbiAgJ0Q5JyxcbiAgJ0RBJyxcbiAgJ0RCJyxcbiAgJ0RDJyxcbiAgJ0REJyxcbiAgJ0RFJyxcbiAgJ0RGJyxcbiAgJ0UwJyxcbiAgJ0UxJyxcbiAgJ0UyJyxcbiAgJ0UzJyxcbiAgJ0U0JyxcbiAgJ0U1JyxcbiAgJ0U2JyxcbiAgJ0U3JyxcbiAgJ0U4JyxcbiAgJ0U5JyxcbiAgJ0VBJyxcbiAgJ0VCJyxcbiAgJ0VDJyxcbiAgJ0VEJyxcbiAgJ0VFJyxcbiAgJ0VGJyxcbiAgJ0YwJyxcbiAgJ0YxJyxcbiAgJ0YyJyxcbiAgJ0YzJyxcbiAgJ0Y0JyxcbiAgJ0Y1JyxcbiAgJ0Y2JyxcbiAgJ0Y3JyxcbiAgJ0Y4JyxcbiAgJ0Y5JyxcbiAgJ0ZBJyxcbiAgJ0ZCJyxcbiAgJ0ZDJyxcbiAgJ0ZEJyxcbiAgJ0ZFJyxcbiAgJ0ZGJyxcbl07XG5cbi8qIHZlY3RvciBvZiBiYXNlIDY0IGNoYXJhY3RlcnMgKi9cbmNvbnN0IGJhc2U2NGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89Jy5zcGxpdCgnJyk7XG5cbi8qIHZlY3RvciBvZiBiYXNlIDY0IGNoYXJhY3RlciBjb2RlcyAqL1xuY29uc3QgYmFzZTY0Y29kZXMgPSBbXTtcbmJhc2U2NGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgYmFzZTY0Y29kZXMucHVzaChjaGFyLmNoYXJDb2RlQXQoMCkpO1xufSk7XG5cbi8vIFRoZSBVVEY4IGFsZ29yaXRobXMuXG5leHBvcnRzLnV0ZjggPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgaWYgKGNoYXIgPj0gMCAmJiBjaGFyIDw9IDB4N2YpIHtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA8PSAweDdmZikge1xuICAgICAgICBieXRlcy5wdXNoKDB4YzAgKyAoKGNoYXIgPj4gNikgJiBtYXNrWzVdKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCArIChjaGFyICYgbWFza1s2XSkpO1xuICAgICAgfSBlbHNlIGlmIChjaGFyIDwgMHhkODAwIHx8IChjaGFyID4gMHhkZmZmICYmIGNoYXIgPD0gMHhmZmZmKSkge1xuICAgICAgICBieXRlcy5wdXNoKDB4ZTAgKyAoKGNoYXIgPj4gMTIpICYgbWFza1s0XSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgKyAoKGNoYXIgPj4gNikgJiBtYXNrWzZdKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCArIChjaGFyICYgbWFza1s2XSkpO1xuICAgICAgfSBlbHNlIGlmIChjaGFyID49IDB4MTAwMDAgJiYgY2hhciA8PSAweDEwZmZmZikge1xuICAgICAgICBjb25zdCB1ID0gKGNoYXIgPj4gMTYpICYgbWFza1s1XTtcbiAgICAgICAgYnl0ZXMucHVzaCgweGYwICsgKHUgPj4gMikpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgKyAoKHUgJiBtYXNrWzJdKSA8PCA0KSArICgoY2hhciA+PiAxMikgJiBtYXNrWzRdKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCArICgoY2hhciA+PiA2KSAmIG1hc2tbNl0pKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwICsgKGNoYXIgJiBtYXNrWzZdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmOC5lbmNvZGU6IGNoYXJhY3RlciBvdXQgb2YgcmFuZ2U6IGNoYXI6ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9LFxuICBkZWNvZGUoYnVmLCBib20pIHtcbiAgICAvKiBieXRlcyBmdW5jdGlvbnMgcmV0dXJuIGVycm9yIGZvciBub24tc2hvcnRlc3QgZm9ybXMgJiB2YWx1ZXMgb3V0IG9mIHJhbmdlICovXG4gICAgZnVuY3Rpb24gYnl0ZXMyKGIxLCBiMikge1xuICAgICAgLyogVSswMDgwLi5VKzA3RkYgKi9cbiAgICAgIC8qIDAwMDAwMDAwIDAwMDAweXl5IHl5eHh4eHh4IHwgMTEweXl5eXkgMTB4eHh4eHggKi9cbiAgICAgIGlmICgoYjIgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICByZXR1cm4gVFJBSUxJTkc7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gKChiMSAmIG1hc2tbNV0pIDw8IDYpICsgKGIyICYgbWFza1s2XSk7XG4gICAgICBpZiAoeCA8IDB4ODApIHtcbiAgICAgICAgcmV0dXJuIE5PTl9TSE9SVEVTVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBieXRlczMoYjEsIGIyLCBiMykge1xuICAgICAgLyogVSswODAwLi5VK0ZGRkYgKi9cbiAgICAgIC8qIDAwMDAwMDAwIHp6enp5eXl5IHl5eHh4eHh4IHwgMTExMHp6enogMTB5eXl5eXkgMTB4eHh4eHggKi9cbiAgICAgIGlmICgoYjMgJiAweGMwKSAhPT0gMHg4MCB8fCAoYjIgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICByZXR1cm4gVFJBSUxJTkc7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gKChiMSAmIG1hc2tbNF0pIDw8IDEyKSArICgoYjIgJiBtYXNrWzZdKSA8PCA2KSArIChiMyAmIG1hc2tbNl0pO1xuICAgICAgaWYgKHggPCAweDgwMCkge1xuICAgICAgICByZXR1cm4gTk9OX1NIT1JURVNUO1xuICAgICAgfVxuICAgICAgaWYgKHggPj0gMHhkODAwICYmIHggPD0gMHhkZmZmKSB7XG4gICAgICAgIHJldHVybiBSQU5HRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBieXRlczQoYjEsIGIyLCBiMywgYjQpIHtcbiAgICAgIC8qIFUrMTAwMDAuLlUrMTBGRkZGICovXG4gICAgICAvKiAwMDB1dXV1dSB6enp6eXl5eSB5eXh4eHh4eCB8IDExMTEwdXV1IDEwdXV6enp6IDEweXl5eXl5IDEweHh4eHh4ICovXG4gICAgICBpZiAoKGI0ICYgMHhjMCkgIT09IDB4ODAgfHwgKGIzICYgMHhjMCkgIT09IDB4ODAgfHwgKGIyICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgcmV0dXJuIFRSQUlMSU5HO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9XG4gICAgICAgICgoKChiMSAmIG1hc2tbM10pIDw8IDIpICsgKChiMiA+PiA0KSAmIG1hc2tbMl0pKSA8PCAxNikgK1xuICAgICAgICAoKGIyICYgbWFza1s0XSkgPDwgMTIpICtcbiAgICAgICAgKChiMyAmIG1hc2tbNl0pIDw8IDYpICtcbiAgICAgICAgKGI0ICYgbWFza1s2XSk7XG4gICAgICBpZiAoeCA8IDB4MTAwMDApIHtcbiAgICAgICAgcmV0dXJuIE5PTl9TSE9SVEVTVDtcbiAgICAgIH1cbiAgICAgIGlmICh4ID4gMHgxMGZmZmYpIHtcbiAgICAgICAgcmV0dXJuIFJBTkdFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGxldCBjO1xuICAgIGxldCBiMTtcbiAgICBsZXQgaTE7XG4gICAgbGV0IGkyO1xuICAgIGxldCBpMztcbiAgICBsZXQgaW5jO1xuICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgbGV0IGkgPSBib20gPyAzIDogMDtcbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBiMSA9IGJ1ZltpXTtcbiAgICAgIGMgPSBJTExfRk9STUVEO1xuICAgICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgICBpZiAoYjEgPj0gMCAmJiBiMSA8PSAweDdmKSB7XG4gICAgICAgICAgLyogVSswMDAwLi5VKzAwN0YgMDAuLjdGICovXG4gICAgICAgICAgYyA9IGIxO1xuICAgICAgICAgIGluYyA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaTEgPSBpICsgMTtcbiAgICAgICAgaWYgKGkxIDwgbGVuICYmIGIxID49IDB4YzIgJiYgYjEgPD0gMHhkZikge1xuICAgICAgICAgIC8qIFUrMDA4MC4uVSswN0ZGIEMyLi5ERiA4MC4uQkYgKi9cbiAgICAgICAgICBjID0gYnl0ZXMyKGIxLCBidWZbaTFdKTtcbiAgICAgICAgICBpbmMgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkyID0gaSArIDI7XG4gICAgICAgIGlmIChpMiA8IGxlbiAmJiBiMSA+PSAweGUwICYmIGIxIDw9IDB4ZWYpIHtcbiAgICAgICAgICAvKiBVKzA4MDAuLlUrRkZGRiAqL1xuICAgICAgICAgIGMgPSBieXRlczMoYjEsIGJ1ZltpMV0sIGJ1ZltpMl0pO1xuICAgICAgICAgIGluYyA9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaTMgPSBpICsgMztcbiAgICAgICAgaWYgKGkzIDwgbGVuICYmIGIxID49IDB4ZjAgJiYgYjEgPD0gMHhmNCkge1xuICAgICAgICAgIC8qIFUrMTAwMDAuLlUrMTBGRkZGICovXG4gICAgICAgICAgYyA9IGJ5dGVzNChiMSwgYnVmW2kxXSwgYnVmW2kyXSwgYnVmW2kzXSk7XG4gICAgICAgICAgaW5jID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBpZiB3ZSBmYWxsIHRocm91Z2ggdG8gaGVyZSwgaXQgaXMgYW4gaWxsLWZvcm1lZCBzZXF1ZW5jZSAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChjID4gMHgxMGZmZmYpIHtcbiAgICAgICAgY29uc3QgYXQgPSBgYnl0ZVske2l9XWA7XG4gICAgICAgIGlmIChjID09PSBJTExfRk9STUVEKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjguZGVjb2RlOiBpbGwtZm9ybWVkIFVURjggYnl0ZSBzZXF1ZW5jZSBmb3VuZCBhdDogJHthdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gVFJBSUxJTkcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmOC5kZWNvZGU6IGlsbGVnYWwgdHJhaWxpbmcgYnl0ZSBmb3VuZCBhdDogJHthdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gUkFOR0UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmOC5kZWNvZGU6IGNvZGUgcG9pbnQgb3V0IG9mIHJhbmdlIGZvdW5kIGF0OiAke2F0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSBOT05fU0hPUlRFU1QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmOC5kZWNvZGU6IG5vbi1zaG9ydGVzdCBmb3JtIGZvdW5kIGF0OiAke2F0fWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGY4LmRlY29kZTogdW5yZWNvZ25pemVkIGVycm9yIGZvdW5kIGF0OiAke2F0fWApO1xuICAgICAgfVxuICAgICAgY2hhcnMucHVzaChjKTtcbiAgICAgIGkgKz0gaW5jO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVVRGMTZCRSBhbGdvcml0aG1zLlxuZXhwb3J0cy51dGYxNmJlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGxldCBjaGFyO1xuICAgIGxldCBoO1xuICAgIGxldCBsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNoYXIgPSBjaGFyc1tpXTtcbiAgICAgIGlmICgoY2hhciA+PSAwICYmIGNoYXIgPD0gMHhkN2ZmKSB8fCAoY2hhciA+PSAweGUwMDAgJiYgY2hhciA8PSAweGZmZmYpKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goKGNoYXIgPj4gOCkgJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyICYgbWFza1s4XSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMHgxMDAwMCAmJiBjaGFyIDw9IDB4MTBmZmZmKSB7XG4gICAgICAgIGwgPSBjaGFyIC0gMHgxMDAwMDtcbiAgICAgICAgaCA9IDB4ZDgwMCArIChsID4+IDEwKTtcbiAgICAgICAgbCA9IDB4ZGMwMCArIChsICYgbWFza1sxMF0pO1xuICAgICAgICBieXRlcy5wdXNoKChoID4+IDgpICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2goaCAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKChsID4+IDgpICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2gobCAmIG1hc2tbOF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjE2YmUuZW5jb2RlOiBVVEYxNkJFIHZhbHVlIG91dCBvZiByYW5nZTogY2hhclske2l9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9LFxuICBkZWNvZGUoYnVmLCBib20pIHtcbiAgICAvKiBhc3N1bWVzIGNhbGxlciBoYXMgaW5zdXJlZCB0aGF0IGJ1ZiBpcyBhIEJ1ZmZlciBvZiBieXRlcyAqL1xuICAgIGlmIChidWYubGVuZ3RoICUgMiA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYxNmJlLmRlY29kZTogZGF0YSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDI6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgbGV0IGkgPSBib20gPyAyIDogMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgbGV0IGM7XG4gICAgbGV0IGluYztcbiAgICBsZXQgaTE7XG4gICAgbGV0IGkzO1xuICAgIGxldCBoaWdoO1xuICAgIGxldCBsb3c7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgICAgaTEgPSBpICsgMTtcbiAgICAgICAgaWYgKGkxIDwgbGVuKSB7XG4gICAgICAgICAgaGlnaCA9IChidWZbaV0gPDwgOCkgKyBidWZbaTFdO1xuICAgICAgICAgIGlmIChoaWdoIDwgMHhkODAwIHx8IGhpZ2ggPiAweGRmZmYpIHtcbiAgICAgICAgICAgIGMgPSBoaWdoO1xuICAgICAgICAgICAgaW5jID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpMyA9IGkgKyAzO1xuICAgICAgICAgIGlmIChpMyA8IGxlbikge1xuICAgICAgICAgICAgbG93ID0gKGJ1ZltpICsgMl0gPDwgOCkgKyBidWZbaTNdO1xuICAgICAgICAgICAgaWYgKGhpZ2ggPD0gMHhkYmZmICYmIGxvdyA+PSAweGRjMDAgJiYgbG93IDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoaGlnaCAtIDB4ZDgwMCkgPDwgMTApICsgKGxvdyAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgIGluYyA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBpZiB3ZSBmYWxsIHRocm91Z2ggdG8gaGVyZSwgaXQgaXMgYW4gaWxsLWZvcm1lZCBzZXF1ZW5jZSAqL1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMTZiZS5kZWNvZGU6IGlsbC1mb3JtZWQgVVRGMTZCRSBieXRlIHNlcXVlbmNlIGZvdW5kOiBieXRlWyR7aX1dYCk7XG4gICAgICB9XG4gICAgICBjaGFyc1tqKytdID0gYztcbiAgICAgIGkgKz0gaW5jO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVVRGMTZMRSBhbGdvcml0aG1zLlxuZXhwb3J0cy51dGYxNmxlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGxldCBjaGFyO1xuICAgIGxldCBoO1xuICAgIGxldCBsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNoYXIgPSBjaGFyc1tpXTtcbiAgICAgIGlmICgoY2hhciA+PSAwICYmIGNoYXIgPD0gMHhkN2ZmKSB8fCAoY2hhciA+PSAweGUwMDAgJiYgY2hhciA8PSAweGZmZmYpKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhciAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKChjaGFyID4+IDgpICYgbWFza1s4XSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMHgxMDAwMCAmJiBjaGFyIDw9IDB4MTBmZmZmKSB7XG4gICAgICAgIGwgPSBjaGFyIC0gMHgxMDAwMDtcbiAgICAgICAgaCA9IDB4ZDgwMCArIChsID4+IDEwKTtcbiAgICAgICAgbCA9IDB4ZGMwMCArIChsICYgbWFza1sxMF0pO1xuICAgICAgICBieXRlcy5wdXNoKGggJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaCgoaCA+PiA4KSAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKGwgJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaCgobCA+PiA4KSAmIG1hc2tbOF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjE2bGUuZW5jb2RlOiBVVEYxNkxFIHZhbHVlIG91dCBvZiByYW5nZTogY2hhclske2l9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9LFxuICBkZWNvZGUoYnVmLCBib20pIHtcbiAgICAvKiBhc3N1bWVzIGNhbGxlciBoYXMgaW5zdXJlZCB0aGF0IGJ1ZiBpcyBhIEJ1ZmZlciBvZiBieXRlcyAqL1xuICAgIGlmIChidWYubGVuZ3RoICUgMiA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYxNmxlLmRlY29kZTogZGF0YSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDI6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgbGV0IGkgPSBib20gPyAyIDogMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgbGV0IGM7XG4gICAgbGV0IGluYztcbiAgICBsZXQgaTE7XG4gICAgbGV0IGkzO1xuICAgIGxldCBoaWdoO1xuICAgIGxldCBsb3c7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgICAgaTEgPSBpICsgMTtcbiAgICAgICAgaWYgKGkxIDwgbGVuKSB7XG4gICAgICAgICAgaGlnaCA9IChidWZbaTFdIDw8IDgpICsgYnVmW2ldO1xuICAgICAgICAgIGlmIChoaWdoIDwgMHhkODAwIHx8IGhpZ2ggPiAweGRmZmYpIHtcbiAgICAgICAgICAgIGMgPSBoaWdoO1xuICAgICAgICAgICAgaW5jID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpMyA9IGkgKyAzO1xuICAgICAgICAgIGlmIChpMyA8IGxlbikge1xuICAgICAgICAgICAgbG93ID0gKGJ1ZltpM10gPDwgOCkgKyBidWZbaSArIDJdO1xuICAgICAgICAgICAgaWYgKGhpZ2ggPD0gMHhkYmZmICYmIGxvdyA+PSAweGRjMDAgJiYgbG93IDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoaGlnaCAtIDB4ZDgwMCkgPDwgMTApICsgKGxvdyAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgIGluYyA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBpZiB3ZSBmYWxsIHRocm91Z2ggdG8gaGVyZSwgaXQgaXMgYW4gaWxsLWZvcm1lZCBzZXF1ZW5jZSAqL1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMTZsZS5kZWNvZGU6IGlsbC1mb3JtZWQgVVRGMTZMRSBieXRlIHNlcXVlbmNlIGZvdW5kOiBieXRlWyR7aX1dYCk7XG4gICAgICB9XG4gICAgICBjaGFyc1tqKytdID0gYztcbiAgICAgIGkgKz0gaW5jO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVVRGMzJCRSBhbGdvcml0aG1zLlxuZXhwb3J0cy51dGYzMmJlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoICogNCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIGlmICgoY2hhciA+PSAweGQ4MDAgJiYgY2hhciA8PSAweGRmZmYpIHx8IGNoYXIgPiAweDEwZmZmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMzJiZS5lbmNvZGU6IFVURjMyQkUgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aSAvIDR9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAyNCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAxNikgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiA4KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IGNoYXIgJiBtYXNrWzhdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYsIGJvbSkge1xuICAgIC8qIGNhbGxlciB0byBpbnN1cmUgYnVmIGlzIGEgQnVmZmVyIG9mIGJ5dGVzICovXG4gICAgaWYgKGJ1Zi5sZW5ndGggJSA0ID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjMyYmUuZGVjb2RlOiBVVEYzMkJFIGJ5dGUgbGVuZ3RoIG11c3QgYmUgZXZlbiBtdWx0aXBsZSBvZiA0OiBsZW5ndGg6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBsZXQgaSA9IGJvbSA/IDQgOiAwO1xuICAgIGZvciAoOyBpIDwgYnVmLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBjb25zdCBjaGFyID0gKGJ1ZltpXSA8PCAyNCkgKyAoYnVmW2kgKyAxXSA8PCAxNikgKyAoYnVmW2kgKyAyXSA8PCA4KSArIGJ1ZltpICsgM107XG4gICAgICBpZiAoKGNoYXIgPj0gMHhkODAwICYmIGNoYXIgPD0gMHhkZmZmKSB8fCBjaGFyID4gMHgxMGZmZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjMyYmUuZGVjb2RlOiBVVEYzMkJFIGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2kgLyA0fV06ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzLnB1c2goY2hhcik7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVVEYzMkxFIGFsZ29yaXRobXMuXG5leHBvcnRzLnV0ZjMybGUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGggKiA0KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgaWYgKChjaGFyID49IDB4ZDgwMCAmJiBjaGFyIDw9IDB4ZGZmZikgfHwgY2hhciA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYzMmxlLmVuY29kZTogVVRGMzJMRSBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpIC8gNH1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgICBidWZbaSsrXSA9IGNoYXIgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiA4KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDE2KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDI0KSAmIG1hc2tbOF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1ZiwgYm9tKSB7XG4gICAgLyogY2FsbGVyIHRvIGluc3VyZSBidWYgaXMgYSBCdWZmZXIgb2YgYnl0ZXMgKi9cbiAgICBpZiAoYnVmLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMzJiZS5kZWNvZGU6IFVURjMyTEUgYnl0ZSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDQ6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGxldCBpID0gYm9tID8gNCA6IDA7XG4gICAgZm9yICg7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGNvbnN0IGNoYXIgPSAoYnVmW2kgKyAzXSA8PCAyNCkgKyAoYnVmW2kgKyAyXSA8PCAxNikgKyAoYnVmW2kgKyAxXSA8PCA4KSArIGJ1ZltpXTtcbiAgICAgIGlmICgoY2hhciA+PSAweGQ4MDAgJiYgY2hhciA8PSAweGRmZmYpIHx8IGNoYXIgPiAweDEwZmZmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMzJsZS5lbmNvZGU6IFVURjMyTEUgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aSAvIDR9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgICAgY2hhcnMucHVzaChjaGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVJTlQ3IGFsZ29yaXRobXMuIEFTQ0lJIG9yIDctYml0IHVuc2lnbmVkIGludGVnZXJzLlxuZXhwb3J0cy51aW50NyA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGNoYXJzW2ldID4gMHg3Zikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDcuZW5jb2RlOiBVSU5UNyBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpfV06ICR7Y2hhcnNbaV19YCk7XG4gICAgICB9XG4gICAgICBidWZbaV0gPSBjaGFyc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChidWZbaV0gPiAweDdmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50Ny5kZWNvZGU6IFVJTlQ3IGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogYnl0ZVske2l9XTogJHtidWZbaV19YCk7XG4gICAgICB9XG4gICAgICBjaGFyc1tpXSA9IGJ1ZltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVJTlQ4IGFsZ29yaXRobXMuIEJJTkFSWSwgTGF0aW4gMSBvciA4LWJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cbmV4cG9ydHMudWludDggPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChjaGFyc1tpXSA+IDB4ZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQ4LmVuY29kZTogVUlOVDggY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aX1dOiAke2NoYXJzW2ldfWApO1xuICAgICAgfVxuICAgICAgYnVmW2ldID0gY2hhcnNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYpIHtcbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjaGFyc1tpXSA9IGJ1ZltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVJTlQxNkJFIGFsZ29yaXRobXMuIEJpZy1lbmRpYW4gMTYtYml0IHVuc2lnbmVkIGludGVnZXJzLlxuZXhwb3J0cy51aW50MTZiZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCAqIDIpO1xuICAgIGxldCBpID0gMDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBpZiAoY2hhciA+IDB4ZmZmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDE2YmUuZW5jb2RlOiBVSU5UMTZCRSBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpIC8gMn1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDgpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gY2hhciAmIG1hc2tbOF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGlmIChidWYubGVuZ3RoICUgMiA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50MTZiZS5kZWNvZGU6IFVJTlQxNkJFIGJ5dGUgbGVuZ3RoIG11c3QgYmUgZXZlbiBtdWx0aXBsZSBvZiAyOiBsZW5ndGg6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY2hhcnMucHVzaCgoYnVmW2ldIDw8IDgpICsgYnVmW2kgKyAxXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVSU5UMTZMRSBhbGdvcml0aG1zLiBMaXR0bGUtZW5kaWFuIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cbmV4cG9ydHMudWludDE2bGUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGggKiAyKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgaWYgKGNoYXIgPiAweGZmZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQxNmxlLmVuY29kZTogVUlOVDE2TEUgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aSAvIDJ9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgICAgYnVmW2krK10gPSBjaGFyICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gOCkgJiBtYXNrWzhdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCAlIDIgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDE2bGUuZGVjb2RlOiBVSU5UMTZMRSBieXRlIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgMjogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNoYXJzLnB1c2goKGJ1ZltpICsgMV0gPDwgOCkgKyBidWZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVUlOVDMyQkUgYWxnb3JpdGhtcy4gQmlnLWVuZGlhbiAzMi1iaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5leHBvcnRzLnVpbnQzMmJlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoICogNCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMjQpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMTYpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gOCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSBjaGFyICYgbWFza1s4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggJSA0ID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQzMmJlLmRlY29kZTogVUlOVDMyQkUgYnl0ZSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDQ6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBjaGFycy5wdXNoKChidWZbaV0gPDwgMjQpICsgKGJ1ZltpICsgMV0gPDwgMTYpICsgKGJ1ZltpICsgMl0gPDwgOCkgKyBidWZbaSArIDNdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVJTlQzMkxFIGFsZ29yaXRobXMuIExpdHRsZS1lbmRpYW4gMzItYml0IHVuc2lnbmVkIGludGVnZXJzLlxuZXhwb3J0cy51aW50MzJsZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCAqIDQpO1xuICAgIGxldCBpID0gMDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBidWZbaSsrXSA9IGNoYXIgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiA4KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDE2KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDI0KSAmIG1hc2tbOF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1Zikge1xuICAgIC8qIGNhbGxlciB0byBpbnN1cmUgYnVmIGlzIGEgQnVmZmVyIG9mIGJ5dGVzICovXG4gICAgaWYgKGJ1Zi5sZW5ndGggJSA0ID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQzMmxlLmRlY29kZTogVUlOVDMyTEUgYnl0ZSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDQ6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBjaGFycy5wdXNoKChidWZbaSArIDNdIDw8IDI0KSArIChidWZbaSArIDJdIDw8IDE2KSArIChidWZbaSArIDFdIDw8IDgpICsgYnVmW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFNUUklORyBhbGdvcml0aG1zLiBDb252ZXJ0cyBKYXZhU2NyaXB0IHN0cmluZ3MgdG8gQXJyYXkgb2YgMzItYml0IGludGVnZXJzIGFuZCB2aWNlIHZlcnNhLlxuLy8gVXNlcyB0aGUgbm9kZS5qcyBCdWZmZXIncyBuYXRpdmUgXCJ1dGYxNmxlXCIgY2FwYWJpbGl0ZXMuXG5leHBvcnRzLnN0cmluZyA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudXRmMTZsZS5lbmNvZGUoY2hhcnMpLnRvU3RyaW5nKCd1dGYxNmxlJyk7XG4gIH0sXG4gIGRlY29kZShzdHIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy51dGYxNmxlLmRlY29kZShCdWZmZXIuZnJvbShzdHIsICd1dGYxNmxlJyksIDApO1xuICB9LFxufTtcblxuLy8gVGhlIEVTQ0FQRUQgYWxnb3JpdGhtcy5cbi8vIE5vdGUgdGhhdCBFU0NBUEVEIGZvcm1hdCBjb250YWlucyBvbmx5IEFTQ0lJIGNoYXJhY3RlcnMuXG4vLyBUaGUgY2hhcmFjdGVycyBhcmUgYWx3YXlzIGluIHRoZSBmb3JtIG9mIGEgQnVmZmVyIG9mIGJ5dGVzLlxuZXhwb3J0cy5lc2NhcGVkID0ge1xuICAvLyBFbmNvZGVzIGFuIEFycmF5IG9mIDMyLWJpdCBpbnRlZ2VycyBpbnRvIEVTQ0FQRUQgZm9ybWF0LlxuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBjaGFyc1tpXTtcbiAgICAgIGlmIChjaGFyID09PSA5Nikge1xuICAgICAgICBieXRlcy5wdXNoKGNoYXIpO1xuICAgICAgICBieXRlcy5wdXNoKGNoYXIpO1xuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAxMCkge1xuICAgICAgICBieXRlcy5wdXNoKGNoYXIpO1xuICAgICAgfSBlbHNlIGlmIChjaGFyID49IDMyICYmIGNoYXIgPD0gMTI2KSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc3RyID0gJyc7XG4gICAgICAgIGlmIChjaGFyID49IDAgJiYgY2hhciA8PSAzMSkge1xuICAgICAgICAgIHN0ciArPSBgXFxgeCR7YXNjaWlbY2hhcl19YDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID49IDEyNyAmJiBjaGFyIDw9IDI1NSkge1xuICAgICAgICAgIHN0ciArPSBgXFxgeCR7YXNjaWlbY2hhcl19YDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID49IDB4MTAwICYmIGNoYXIgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgc3RyICs9IGBcXGB1JHthc2NpaVsoY2hhciA+PiA4KSAmIG1hc2tbOF1dfSR7YXNjaWlbY2hhciAmIG1hc2tbOF1dfWA7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA+PSAweDEwMDAwICYmIGNoYXIgPD0gMHhmZmZmZmZmZikge1xuICAgICAgICAgIHN0ciArPSAnYHV7JztcbiAgICAgICAgICBjb25zdCBkaWdpdCA9IChjaGFyID4+IDI0KSAmIG1hc2tbOF07XG4gICAgICAgICAgaWYgKGRpZ2l0ID4gMCkge1xuICAgICAgICAgICAgc3RyICs9IGFzY2lpW2RpZ2l0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyICs9IGAke2FzY2lpWyhjaGFyID4+IDE2KSAmIG1hc2tbOF1dICsgYXNjaWlbKGNoYXIgPj4gOCkgJiBtYXNrWzhdXSArIGFzY2lpW2NoYXIgJiBtYXNrWzhdXX19YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VzY2FwZS5lbmNvZGUoY2hhcik6IGNoYXIgPiAweGZmZmZmZmZmIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oc3RyKTtcbiAgICAgICAgYnVmLmZvckVhY2goKGIpID0+IHtcbiAgICAgICAgICBieXRlcy5wdXNoKGIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSxcbiAgLy8gRGVjb2RlcyBFU0NBUEVEIGZvcm1hdCBmcm9tIGEgQnVmZmVyIG9mIGJ5dGVzIHRvIGFuIEFycmF5IG9mIDMyLWJpdCBpbnRlZ2Vycy5cbiAgZGVjb2RlKGJ1Zikge1xuICAgIGZ1bmN0aW9uIGlzSGV4KGhleCkge1xuICAgICAgaWYgKChoZXggPj0gNDggJiYgaGV4IDw9IDU3KSB8fCAoaGV4ID49IDY1ICYmIGhleCA8PSA3MCkgfHwgKGhleCA+PSA5NyAmJiBoZXggPD0gMTAyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0eChpLCBsZW4sIGJ1ZkFyZykge1xuICAgICAgY29uc3QgcmV0ID0geyBjaGFyOiBudWxsLCBuZXh0aTogaSArIDIsIGVycm9yOiB0cnVlIH07XG4gICAgICBpZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgICAgaWYgKGlzSGV4KGJ1ZkFyZ1tpXSkgJiYgaXNIZXgoYnVmQXJnW2kgKyAxXSkpIHtcbiAgICAgICAgICBjb25zdCBzdHIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChidWZBcmdbaV0sIGJ1ZkFyZ1tpICsgMV0pO1xuICAgICAgICAgIHJldC5jaGFyID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocmV0LmNoYXIpKSB7XG4gICAgICAgICAgICByZXQuZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldHUoaSwgbGVuLCBidWZBcmcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHsgY2hhcjogbnVsbCwgbmV4dGk6IGkgKyA0LCBlcnJvcjogdHJ1ZSB9O1xuICAgICAgaWYgKGkgKyAzIDwgbGVuKSB7XG4gICAgICAgIGlmIChpc0hleChidWZBcmdbaV0pICYmIGlzSGV4KGJ1ZkFyZ1tpICsgMV0pICYmIGlzSGV4KGJ1ZkFyZ1tpICsgMl0pICYmIGlzSGV4KGJ1ZkFyZ1tpICsgM10pKSB7XG4gICAgICAgICAgY29uc3Qgc3RyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYnVmQXJnW2ldLCBidWZBcmdbaSArIDFdLCBidWZBcmdbaSArIDJdLCBidWZBcmdbaSArIDNdKTtcbiAgICAgICAgICByZXQuY2hhciA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHJldC5jaGFyKSkge1xuICAgICAgICAgICAgcmV0LmVycm9yID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRVKGksIGxlbiwgYnVmQXJnKSB7XG4gICAgICBjb25zdCByZXQgPSB7IGNoYXI6IG51bGwsIG5leHRpOiBpICsgNCwgZXJyb3I6IHRydWUgfTtcbiAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgIHdoaWxlIChpIDwgbGVuICYmIGlzSGV4KGJ1ZkFyZ1tpXSkpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGJ1ZkFyZ1tpXSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgICByZXQuY2hhciA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICAgICAgaWYgKGJ1ZkFyZ1tpXSA9PT0gMTI1ICYmICFOdW1iZXIuaXNOYU4ocmV0LmNoYXIpKSB7XG4gICAgICAgIHJldC5lcnJvciA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0Lm5leHRpID0gaSArIDE7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgbGV0IGkxO1xuICAgIGxldCByZXQ7XG4gICAgbGV0IGVycm9yO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgICBlcnJvciA9IHRydWU7XG4gICAgICAgIGlmIChidWZbaV0gIT09IDk2KSB7XG4gICAgICAgICAgLyogdW5lc2NhcGVkIGNoYXJhY3RlciAqL1xuICAgICAgICAgIGNoYXJzLnB1c2goYnVmW2ldKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpMSA9IGkgKyAxO1xuICAgICAgICBpZiAoaTEgPj0gbGVuKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZltpMV0gPT09IDk2KSB7XG4gICAgICAgICAgLyogZXNjYXBlZCBncmF2ZSBhY2NlbnQgKi9cbiAgICAgICAgICBjaGFycy5wdXNoKDk2KTtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmW2kxXSA9PT0gMTIwKSB7XG4gICAgICAgICAgcmV0ID0gZ2V0eChpMSArIDEsIGxlbiwgYnVmKTtcbiAgICAgICAgICBpZiAocmV0LmVycm9yKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogZXNjYXBlZCBoZXggKi9cbiAgICAgICAgICBjaGFycy5wdXNoKHJldC5jaGFyKTtcbiAgICAgICAgICBpID0gcmV0Lm5leHRpO1xuICAgICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZltpMV0gPT09IDExNykge1xuICAgICAgICAgIGlmIChidWZbaTEgKyAxXSA9PT0gMTIzKSB7XG4gICAgICAgICAgICByZXQgPSBnZXRVKGkxICsgMiwgbGVuLCBidWYpO1xuICAgICAgICAgICAgaWYgKHJldC5lcnJvcikge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGVzY2FwZWQgdXRmLTMyICovXG4gICAgICAgICAgICBjaGFycy5wdXNoKHJldC5jaGFyKTtcbiAgICAgICAgICAgIGkgPSByZXQubmV4dGk7XG4gICAgICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldCA9IGdldHUoaTEgKyAxLCBsZW4sIGJ1Zik7XG4gICAgICAgICAgaWYgKHJldC5lcnJvcikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGVzY2FwZWQgdXRmLTE2ICovXG4gICAgICAgICAgY2hhcnMucHVzaChyZXQuY2hhcik7XG4gICAgICAgICAgaSA9IHJldC5uZXh0aTtcbiAgICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXNjYXBlZC5kZWNvZGU6IGlsbC1mb3JtZWQgZXNjYXBlIHNlcXVlbmNlIGF0IGJ1Zlske2l9XWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgbGluZSBlbmQgY29udmVyc2lvbiBhbGdvcmlndGhtcy5cbmNvbnN0IENSID0gMTM7XG5jb25zdCBMRiA9IDEwO1xuZXhwb3J0cy5saW5lRW5kcyA9IHtcbiAgY3JsZihjaGFycykge1xuICAgIGNvbnN0IGxmY2hhcnMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFycy5sZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAoY2hhcnNbaV0pIHtcbiAgICAgICAgY2FzZSBDUjpcbiAgICAgICAgICBpZiAoaSArIDEgPCBjaGFycy5sZW5ndGggJiYgY2hhcnNbaSArIDFdID09PSBMRikge1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxmY2hhcnMucHVzaChDUik7XG4gICAgICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMRjpcbiAgICAgICAgICBsZmNoYXJzLnB1c2goQ1IpO1xuICAgICAgICAgIGxmY2hhcnMucHVzaChMRik7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxmY2hhcnMucHVzaChjaGFyc1tpXSk7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGZjaGFycy5sZW5ndGggPiAwICYmIGxmY2hhcnNbbGZjaGFycy5sZW5ndGggLSAxXSAhPT0gTEYpIHtcbiAgICAgIGxmY2hhcnMucHVzaChDUik7XG4gICAgICBsZmNoYXJzLnB1c2goTEYpO1xuICAgIH1cbiAgICByZXR1cm4gbGZjaGFycztcbiAgfSxcbiAgbGYoY2hhcnMpIHtcbiAgICBjb25zdCBsZmNoYXJzID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgY2hhcnMubGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKGNoYXJzW2ldKSB7XG4gICAgICAgIGNhc2UgQ1I6XG4gICAgICAgICAgaWYgKGkgKyAxIDwgY2hhcnMubGVuZ3RoICYmIGNoYXJzW2kgKyAxXSA9PT0gTEYpIHtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZmNoYXJzLnB1c2goTEYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExGOlxuICAgICAgICAgIGxmY2hhcnMucHVzaChMRik7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxmY2hhcnMucHVzaChjaGFyc1tpXSk7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGZjaGFycy5sZW5ndGggPiAwICYmIGxmY2hhcnNbbGZjaGFycy5sZW5ndGggLSAxXSAhPT0gTEYpIHtcbiAgICAgIGxmY2hhcnMucHVzaChMRik7XG4gICAgfVxuICAgIHJldHVybiBsZmNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIGJhc2UgNjQgYWxnb3JpdGhtcy5cbmV4cG9ydHMuYmFzZTY0ID0ge1xuICBlbmNvZGUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgfVxuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCBuO1xuICAgIGxldCB0YWlsID0gYnVmLmxlbmd0aCAlIDM7XG4gICAgdGFpbCA9IHRhaWwgPiAwID8gMyAtIHRhaWwgOiAwO1xuICAgIGxldCB1bml0cyA9IChidWYubGVuZ3RoICsgdGFpbCkgLyAzO1xuICAgIGNvbnN0IGJhc2U2NCA9IEJ1ZmZlci5hbGxvYyh1bml0cyAqIDQpO1xuICAgIGlmICh0YWlsID4gMCkge1xuICAgICAgdW5pdHMgLT0gMTtcbiAgICB9XG4gICAgaSA9IDA7XG4gICAgaiA9IDA7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1bml0czsgdSArPSAxKSB7XG4gICAgICBuID0gYnVmW2krK10gPDwgMTY7XG4gICAgICBuICs9IGJ1ZltpKytdIDw8IDg7XG4gICAgICBuICs9IGJ1ZltpKytdO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxOCkgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gMTIpICYgbWFza1s2XV07XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDYpICYgbWFza1s2XV07XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzW24gJiBtYXNrWzZdXTtcbiAgICB9XG4gICAgaWYgKHRhaWwgPT09IDApIHtcbiAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIGlmICh0YWlsID09PSAxKSB7XG4gICAgICBuID0gYnVmW2krK10gPDwgMTY7XG4gICAgICBuICs9IGJ1ZltpXSA8PCA4O1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxOCkgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gMTIpICYgbWFza1s2XV07XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDYpICYgbWFza1s2XV07XG4gICAgICBiYXNlNjRbal0gPSBiYXNlNjRjb2Rlc1s2NF07XG4gICAgICByZXR1cm4gYmFzZTY0O1xuICAgIH1cbiAgICBpZiAodGFpbCA9PT0gMikge1xuICAgICAgbiA9IGJ1ZltpXSA8PCAxNjtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gMTgpICYgbWFza1s2XV07XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDEyKSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1s2NF07XG4gICAgICBiYXNlNjRbal0gPSBiYXNlNjRjb2Rlc1s2NF07XG4gICAgICByZXR1cm4gYmFzZTY0O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuICBkZWNvZGUoY29kZXMpIHtcbiAgICAvKiByZW1vdmUgd2hpdGUgc3BhY2UgYW5kIGN0cmwgY2hhcmFjdGVycywgdmFsaWRhdGUgJiB0cmFuc2xhdGUgY2hhcmFjdGVycyAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKGJ1Zikge1xuICAgICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICAgIGxldCB0YWlsID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBidWZbaV07XG4gICAgICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgICAgIGlmIChjaGFyID09PSAzMiB8fCBjaGFyID09PSA5IHx8IGNoYXIgPT09IDEwIHx8IGNoYXIgPT09IDEzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPj0gNjUgJiYgY2hhciA8PSA5MCkge1xuICAgICAgICAgICAgY2hhcnMucHVzaChjaGFyIC0gNjUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyID49IDk3ICYmIGNoYXIgPD0gMTIyKSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKGNoYXIgLSA3MSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPj0gNDggJiYgY2hhciA8PSA1Nykge1xuICAgICAgICAgICAgY2hhcnMucHVzaChjaGFyICsgNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPT09IDQzKSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKDYyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA9PT0gNDcpIHtcbiAgICAgICAgICAgIGNoYXJzLnB1c2goNjMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyID09PSA2MSkge1xuICAgICAgICAgICAgY2hhcnMucHVzaCg2NCk7XG4gICAgICAgICAgICB0YWlsICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogaW52YWxpZCBjaGFyYWN0ZXIgKi9cbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgYmFzZTY0LmRlY29kZTogaW52YWxpZCBjaGFyYWN0ZXIgYnVmWyR7aX1dOiAke2NoYXJ9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIHZhbGlkYXRlIGxlbmd0aCAqL1xuICAgICAgaWYgKGNoYXJzLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBiYXNlNjQuZGVjb2RlOiBzdHJpbmcgbGVuZ3RoIG5vdCBpbnRlZ3JhbCBtdWx0aXBsZSBvZiA0OiAke2NoYXJzLmxlbmd0aH1gKTtcbiAgICAgIH1cbiAgICAgIC8qIHZhbGlkYXRlIHRhaWwgKi9cbiAgICAgIHN3aXRjaCAodGFpbCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoY2hhcnNbY2hhcnMubGVuZ3RoIC0gMV0gIT09IDY0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYmFzZTY0LmRlY29kZTogb25lIHRhaWwgY2hhcmFjdGVyIGZvdW5kOiBub3QgbGFzdCBjaGFyYWN0ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpZiAoY2hhcnNbY2hhcnMubGVuZ3RoIC0gMV0gIT09IDY0IHx8IGNoYXJzW2NoYXJzLmxlbmd0aCAtIDJdICE9PSA2NCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Jhc2U2NC5kZWNvZGU6IHR3byB0YWlsIGNoYXJhY3RlcnMgZm91bmQ6IG5vdCBsYXN0IGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGJhc2U2NC5kZWNvZGU6IG1vcmUgdGhhbiB0d28gdGFpbCBjaGFyYWN0ZXJzIGZvdW5kOiAke3RhaWx9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0YWlsLCBidWY6IEJ1ZmZlci5mcm9tKGNoYXJzKSB9O1xuICAgIH1cblxuICAgIGlmIChjb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbCA9IHZhbGlkYXRlKGNvZGVzKTtcbiAgICBjb25zdCB7IHRhaWwgfSA9IHZhbDtcbiAgICBjb25zdCBiYXNlNjQgPSB2YWwuYnVmO1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCBuO1xuICAgIGxldCB1bml0cyA9IGJhc2U2NC5sZW5ndGggLyA0O1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyh1bml0cyAqIDMgLSB0YWlsKTtcbiAgICBpZiAodGFpbCA+IDApIHtcbiAgICAgIHVuaXRzIC09IDE7XG4gICAgfVxuICAgIGogPSAwO1xuICAgIGkgPSAwO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdW5pdHM7IHUgKz0gMSkge1xuICAgICAgbiA9IGJhc2U2NFtpKytdIDw8IDE4O1xuICAgICAgbiArPSBiYXNlNjRbaSsrXSA8PCAxMjtcbiAgICAgIG4gKz0gYmFzZTY0W2krK10gPDwgNjtcbiAgICAgIG4gKz0gYmFzZTY0W2krK107XG4gICAgICBidWZbaisrXSA9IChuID4+IDE2KSAmIG1hc2tbOF07XG4gICAgICBidWZbaisrXSA9IChuID4+IDgpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltqKytdID0gbiAmIG1hc2tbOF07XG4gICAgfVxuICAgIGlmICh0YWlsID09PSAxKSB7XG4gICAgICBuID0gYmFzZTY0W2krK10gPDwgMTg7XG4gICAgICBuICs9IGJhc2U2NFtpKytdIDw8IDEyO1xuICAgICAgbiArPSBiYXNlNjRbaV0gPDwgNjtcbiAgICAgIGJ1ZltqKytdID0gKG4gPj4gMTYpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltqXSA9IChuID4+IDgpICYgbWFza1s4XTtcbiAgICB9XG4gICAgaWYgKHRhaWwgPT09IDIpIHtcbiAgICAgIG4gPSBiYXNlNjRbaSsrXSA8PCAxODtcbiAgICAgIG4gKz0gYmFzZTY0W2krK10gPDwgMTI7XG4gICAgICBidWZbal0gPSAobiA+PiAxNikgJiBtYXNrWzhdO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICAvLyBDb252ZXJ0cyBhIGJhc2UgNjQgQnVmZmVyIG9mIGJ5dGVzIHRvIGEgSmF2YVNjcmlwdCBzdHJpbmcgd2l0aCBsaW5lIGJyZWFrcy5cbiAgdG9TdHJpbmcoYnVmKSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggJSA0ID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGJhc2U2NC50b1N0cmluZzogaW5wdXQgYnVmZmVyIGxlbmd0aCBub3QgbXVsdGlwbGUgb2YgNDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IGxpbmVMZW4gPSAwO1xuICAgIGZ1bmN0aW9uIGJ1aWxkTGluZShjMSwgYzIsIGMzLCBjNCkge1xuICAgICAgc3dpdGNoIChsaW5lTGVuKSB7XG4gICAgICAgIGNhc2UgNzY6XG4gICAgICAgICAgc3RyICs9IGBcXHJcXG4ke2MxfSR7YzJ9JHtjM30ke2M0fWA7XG4gICAgICAgICAgbGluZUxlbiA9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzU6XG4gICAgICAgICAgc3RyICs9IGAke2MxfVxcclxcbiR7YzJ9JHtjM30ke2M0fWA7XG4gICAgICAgICAgbGluZUxlbiA9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzQ6XG4gICAgICAgICAgc3RyICs9IGAke2MxICsgYzJ9XFxyXFxuJHtjM30ke2M0fWA7XG4gICAgICAgICAgbGluZUxlbiA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzM6XG4gICAgICAgICAgc3RyICs9IGAke2MxICsgYzIgKyBjM31cXHJcXG4ke2M0fWA7XG4gICAgICAgICAgbGluZUxlbiA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3RyICs9IGMxICsgYzIgKyBjMyArIGM0O1xuICAgICAgICAgIGxpbmVMZW4gKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoYykge1xuICAgICAgaWYgKGMgPj0gNjUgJiYgYyA8PSA5MCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID49IDk3ICYmIGMgPD0gMTIyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPj0gNDggJiYgYyA8PSA1Nykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID09PSA0Mykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID09PSA0Nykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID09PSA2MSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgaSArIDQ7IGogKz0gMSkge1xuICAgICAgICBpZiAoIXZhbGlkYXRlKGJ1ZltqXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgYmFzZTY0LnRvU3RyaW5nOiBidWZbJHtqfV06ICR7YnVmW2pdfSA6IG5vdCB2YWxpZCBiYXNlNjQgY2hhcmFjdGVyIGNvZGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVpbGRMaW5lKFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSksXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2kgKyAxXSksXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2kgKyAyXSksXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2kgKyAzXSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH0sXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/transformers.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/ast.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/ast.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable guard-for-in */\n/* eslint-disable no-restricted-syntax */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is used by the parser to build an [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST).\n// The AST can be thought of as a subset of the full parse tree.\n// Each node of the AST holds the phrase that was matched at the corresponding, named parse tree node.\n// It is built as the parser successfully matches phrases to the rule names\n// (`RNM` operators) and `UDT`s as it parses an input string.\n// The user controls which `RNM` or `UDT` names to keep on the AST.\n// The user can also associate callback functions with some or all of the retained\n// AST nodes to be used to translate the node phrases. That is, associate semantic\n// actions to the matched phrases.\n// Translating the AST rather that attempting to apply semantic actions during\n// the parsing process, has the advantage that there is no backtracking and that the phrases\n// are known while traversing down tree as will as up.\n//\n// Let `ast` be an `ast.js` object. To identify a node to be kept on the AST:\n// ```\n// ast.callbacks[\"rulename\"] = true; (all nodes default to false)\n// ```\n// To associate a callback function with a node:\n// ```\n// ast.callbacks[\"rulename\"] = fn\n// ```\n// `rulename` is any `RNM` or `UDT` name defined by the associated grammar\n// and `fn` is a user-written callback function.\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js2-examples/tree/master/ast) for examples of how to create an AST,\n// define the nodes and callback functions and attach it to a parser.)\nmodule.exports = function exportsAst() {\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\");\n\n  const thisFileName = 'ast.js: ';\n  const that = this;\n  let rules = null;\n  let udts = null;\n  let chars = null;\n  let nodeCount = 0;\n  const nodesDefined = [];\n  const nodeCallbacks = [];\n  const stack = [];\n  const records = [];\n  this.callbacks = [];\n  this.astObject = 'astObject';\n  /* called by the parser to initialize the AST with the rules, UDTs and the input characters */\n  this.init = function init(rulesIn, udtsIn, charsIn) {\n    stack.length = 0;\n    records.length = 0;\n    nodesDefined.length = 0;\n    nodeCount = 0;\n    rules = rulesIn;\n    udts = udtsIn;\n    chars = charsIn;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    nodeCount = rules.length + udts.length;\n    for (i = 0; i < nodeCount; i += 1) {\n      nodesDefined[i] = false;\n      nodeCallbacks[i] = null;\n    }\n    for (const index in that.callbacks) {\n      const lower = index.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);\n      }\n      if (typeof that.callbacks[index] === 'function') {\n        nodesDefined[i] = true;\n        nodeCallbacks[i] = that.callbacks[index];\n      }\n      if (that.callbacks[index] === true) {\n        nodesDefined[i] = true;\n      }\n    }\n  };\n  /* AST node definitions - called by the parser's `RNM` operator */\n  this.ruleDefined = function ruleDefined(index) {\n    return nodesDefined[index] !== false;\n  };\n  /* AST node definitions - called by the parser's `UDT` operator */\n  this.udtDefined = function udtDefined(index) {\n    return nodesDefined[rules.length + index] !== false;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the downward traversal of the node */\n  this.down = function down(callbackIndex, name) {\n    const thisIndex = records.length;\n    stack.push(thisIndex);\n    records.push({\n      name,\n      thisIndex,\n      thatIndex: null,\n      state: id.SEM_PRE,\n      callbackIndex,\n      phraseIndex: null,\n      phraseLength: null,\n      stack: stack.length,\n    });\n    return thisIndex;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the upward traversal of the node */\n  this.up = function up(callbackIndex, name, phraseIndex, phraseLength) {\n    const thisIndex = records.length;\n    const thatIndex = stack.pop();\n    records.push({\n      name,\n      thisIndex,\n      thatIndex,\n      state: id.SEM_POST,\n      callbackIndex,\n      phraseIndex,\n      phraseLength,\n      stack: stack.length,\n    });\n    records[thatIndex].thatIndex = thisIndex;\n    records[thatIndex].phraseIndex = phraseIndex;\n    records[thatIndex].phraseLength = phraseLength;\n    return thisIndex;\n  };\n  // Called by the user to translate the AST.\n  // Translate means to associate or apply some semantic action to the\n  // phrases that were syntactically matched to the AST nodes according\n  // to the defining grammar.\n  // ```\n  // data - optional user-defined data\n  //        passed to the callback functions by the translator\n  // ```\n  this.translate = function translate(data) {\n    let ret;\n    let callback;\n    let record;\n    for (let i = 0; i < records.length; i += 1) {\n      record = records[i];\n      callback = nodeCallbacks[record.callbackIndex];\n      if (record.state === id.SEM_PRE) {\n        if (callback !== null) {\n          ret = callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);\n          if (ret === id.SEM_SKIP) {\n            i = record.thatIndex;\n          }\n        }\n      } else if (callback !== null) {\n        callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);\n      }\n    }\n  };\n  /* called by the parser to reset the length of the records array */\n  /* necessary on backtracking */\n  this.setLength = function setLength(length) {\n    records.length = length;\n    if (length > 0) {\n      stack.length = records[length - 1].stack;\n    } else {\n      stack.length = 0;\n    }\n  };\n  /* called by the parser to get the length of the records array */\n  this.getLength = function getLength() {\n    return records.length;\n  };\n  /* helper for XML display */\n  function indent(n) {\n    let ret = '';\n    for (let i = 0; i < n; i += 1) {\n      ret += ' ';\n    }\n    return ret;\n  }\n  // Generate an `XML` version of the AST.\n  // Useful if you want to use a special or favorite XML parser to translate the\n  // AST.\n  // ```\n  // mode - the display mode of the captured phrases\n  //      - default mode is \"ascii\"\n  //      - can be: \"ascii\"\n  //                \"decimal\"\n  //                \"hexadecimal\"\n  //                \"unicode\"\n  // ```\n  this.toXml = function toSml(modeArg) {\n    let display = utils.charsToDec;\n    let caption = 'decimal integer character codes';\n    if (typeof modeArg === 'string' && modeArg.length >= 3) {\n      const mode = modeArg.slice(0, 3).toLowerCase();\n      if (mode === 'asc') {\n        display = utils.charsToAscii;\n        caption = 'ASCII for printing characters, hex for non-printing';\n      } else if (mode === 'hex') {\n        display = utils.charsToHex;\n        caption = 'hexadecimal integer character codes';\n      } else if (mode === 'uni') {\n        display = utils.charsToUnicode;\n        caption = 'Unicode UTF-32 integer character codes';\n      }\n    }\n    let xml = '';\n    let depth = 0;\n    xml += '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n    xml += `<root nodes=\"${records.length / 2}\" characters=\"${chars.length}\">\\n`;\n    xml += `<!-- input string, ${caption} -->\\n`;\n    xml += indent(depth + 2);\n    xml += display(chars);\n    xml += '\\n';\n    records.forEach((rec) => {\n      if (rec.state === id.SEM_PRE) {\n        depth += 1;\n        xml += indent(depth);\n        xml += `<node name=\"${rec.name}\" index=\"${rec.phraseIndex}\" length=\"${rec.phraseLength}\">\\n`;\n        xml += indent(depth + 2);\n        xml += display(chars, rec.phraseIndex, rec.phraseLength);\n        xml += '\\n';\n      } else {\n        xml += indent(depth);\n        xml += `</node><!-- name=\"${rec.name}\" -->\\n`;\n        depth -= 1;\n      }\n    });\n\n    xml += '</root>\\n';\n    return xml;\n  };\n  /* generate a JavaScript object version of the AST */\n  /* for the phrase-matching engine apg-exp */\n  this.phrases = function phrases() {\n    const obj = {};\n    let i;\n    let record;\n    for (i = 0; i < records.length; i += 1) {\n      record = records[i];\n      if (record.state === id.SEM_PRE) {\n        if (!Array.isArray(obj[record.name])) {\n          obj[record.name] = [];\n        }\n        obj[record.name].push({\n          index: record.phraseIndex,\n          length: record.phraseLength,\n        });\n      }\n    }\n    return obj;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2FzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsaUhBQWU7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsNkdBQWE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsY0FBYyxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQixnQkFBZ0IsYUFBYTtBQUMzRSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTLFdBQVcsZ0JBQWdCLFlBQVksaUJBQWlCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvYXN0LmpzP2I3NmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgaXMgdXNlZCBieSB0aGUgcGFyc2VyIHRvIGJ1aWxkIGFuIFtBYnN0cmFjdCBTeW50YXggVHJlZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWJzdHJhY3Rfc3ludGF4X3RyZWUpIChBU1QpLlxuLy8gVGhlIEFTVCBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIHN1YnNldCBvZiB0aGUgZnVsbCBwYXJzZSB0cmVlLlxuLy8gRWFjaCBub2RlIG9mIHRoZSBBU1QgaG9sZHMgdGhlIHBocmFzZSB0aGF0IHdhcyBtYXRjaGVkIGF0IHRoZSBjb3JyZXNwb25kaW5nLCBuYW1lZCBwYXJzZSB0cmVlIG5vZGUuXG4vLyBJdCBpcyBidWlsdCBhcyB0aGUgcGFyc2VyIHN1Y2Nlc3NmdWxseSBtYXRjaGVzIHBocmFzZXMgdG8gdGhlIHJ1bGUgbmFtZXNcbi8vIChgUk5NYCBvcGVyYXRvcnMpIGFuZCBgVURUYHMgYXMgaXQgcGFyc2VzIGFuIGlucHV0IHN0cmluZy5cbi8vIFRoZSB1c2VyIGNvbnRyb2xzIHdoaWNoIGBSTk1gIG9yIGBVRFRgIG5hbWVzIHRvIGtlZXAgb24gdGhlIEFTVC5cbi8vIFRoZSB1c2VyIGNhbiBhbHNvIGFzc29jaWF0ZSBjYWxsYmFjayBmdW5jdGlvbnMgd2l0aCBzb21lIG9yIGFsbCBvZiB0aGUgcmV0YWluZWRcbi8vIEFTVCBub2RlcyB0byBiZSB1c2VkIHRvIHRyYW5zbGF0ZSB0aGUgbm9kZSBwaHJhc2VzLiBUaGF0IGlzLCBhc3NvY2lhdGUgc2VtYW50aWNcbi8vIGFjdGlvbnMgdG8gdGhlIG1hdGNoZWQgcGhyYXNlcy5cbi8vIFRyYW5zbGF0aW5nIHRoZSBBU1QgcmF0aGVyIHRoYXQgYXR0ZW1wdGluZyB0byBhcHBseSBzZW1hbnRpYyBhY3Rpb25zIGR1cmluZ1xuLy8gdGhlIHBhcnNpbmcgcHJvY2VzcywgaGFzIHRoZSBhZHZhbnRhZ2UgdGhhdCB0aGVyZSBpcyBubyBiYWNrdHJhY2tpbmcgYW5kIHRoYXQgdGhlIHBocmFzZXNcbi8vIGFyZSBrbm93biB3aGlsZSB0cmF2ZXJzaW5nIGRvd24gdHJlZSBhcyB3aWxsIGFzIHVwLlxuLy9cbi8vIExldCBgYXN0YCBiZSBhbiBgYXN0LmpzYCBvYmplY3QuIFRvIGlkZW50aWZ5IGEgbm9kZSB0byBiZSBrZXB0IG9uIHRoZSBBU1Q6XG4vLyBgYGBcbi8vIGFzdC5jYWxsYmFja3NbXCJydWxlbmFtZVwiXSA9IHRydWU7IChhbGwgbm9kZXMgZGVmYXVsdCB0byBmYWxzZSlcbi8vIGBgYFxuLy8gVG8gYXNzb2NpYXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIG5vZGU6XG4vLyBgYGBcbi8vIGFzdC5jYWxsYmFja3NbXCJydWxlbmFtZVwiXSA9IGZuXG4vLyBgYGBcbi8vIGBydWxlbmFtZWAgaXMgYW55IGBSTk1gIG9yIGBVRFRgIG5hbWUgZGVmaW5lZCBieSB0aGUgYXNzb2NpYXRlZCBncmFtbWFyXG4vLyBhbmQgYGZuYCBpcyBhIHVzZXItd3JpdHRlbiBjYWxsYmFjayBmdW5jdGlvbi5cbi8vIChTZWUgW2BhcGctZXhhbXBsZXNgXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzMi1leGFtcGxlcy90cmVlL21hc3Rlci9hc3QpIGZvciBleGFtcGxlcyBvZiBob3cgdG8gY3JlYXRlIGFuIEFTVCxcbi8vIGRlZmluZSB0aGUgbm9kZXMgYW5kIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgYXR0YWNoIGl0IHRvIGEgcGFyc2VyLilcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwb3J0c0FzdCgpIHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuL2lkZW50aWZpZXJzJyk7XG4gIGNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcblxuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnYXN0LmpzOiAnO1xuICBjb25zdCB0aGF0ID0gdGhpcztcbiAgbGV0IHJ1bGVzID0gbnVsbDtcbiAgbGV0IHVkdHMgPSBudWxsO1xuICBsZXQgY2hhcnMgPSBudWxsO1xuICBsZXQgbm9kZUNvdW50ID0gMDtcbiAgY29uc3Qgbm9kZXNEZWZpbmVkID0gW107XG4gIGNvbnN0IG5vZGVDYWxsYmFja3MgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgY29uc3QgcmVjb3JkcyA9IFtdO1xuICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICB0aGlzLmFzdE9iamVjdCA9ICdhc3RPYmplY3QnO1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlciB0byBpbml0aWFsaXplIHRoZSBBU1Qgd2l0aCB0aGUgcnVsZXMsIFVEVHMgYW5kIHRoZSBpbnB1dCBjaGFyYWN0ZXJzICovXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIGluaXQocnVsZXNJbiwgdWR0c0luLCBjaGFyc0luKSB7XG4gICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICByZWNvcmRzLmxlbmd0aCA9IDA7XG4gICAgbm9kZXNEZWZpbmVkLmxlbmd0aCA9IDA7XG4gICAgbm9kZUNvdW50ID0gMDtcbiAgICBydWxlcyA9IHJ1bGVzSW47XG4gICAgdWR0cyA9IHVkdHNJbjtcbiAgICBjaGFycyA9IGNoYXJzSW47XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGlzdC5wdXNoKHJ1bGVzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaCh1ZHRzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgbm9kZUNvdW50ID0gcnVsZXMubGVuZ3RoICsgdWR0cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vZGVDb3VudDsgaSArPSAxKSB7XG4gICAgICBub2Rlc0RlZmluZWRbaV0gPSBmYWxzZTtcbiAgICAgIG5vZGVDYWxsYmFja3NbaV0gPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGluZGV4IGluIHRoYXQuY2FsbGJhY2tzKSB7XG4gICAgICBjb25zdCBsb3dlciA9IGluZGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpID0gbGlzdC5pbmRleE9mKGxvd2VyKTtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWluaXQ6IG5vZGUgJyR7aW5kZXh9JyBub3QgYSBydWxlIG9yIHVkdCBuYW1lYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoYXQuY2FsbGJhY2tzW2luZGV4XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBub2Rlc0RlZmluZWRbaV0gPSB0cnVlO1xuICAgICAgICBub2RlQ2FsbGJhY2tzW2ldID0gdGhhdC5jYWxsYmFja3NbaW5kZXhdO1xuICAgICAgfVxuICAgICAgaWYgKHRoYXQuY2FsbGJhY2tzW2luZGV4XSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2Rlc0RlZmluZWRbaV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogQVNUIG5vZGUgZGVmaW5pdGlvbnMgLSBjYWxsZWQgYnkgdGhlIHBhcnNlcidzIGBSTk1gIG9wZXJhdG9yICovXG4gIHRoaXMucnVsZURlZmluZWQgPSBmdW5jdGlvbiBydWxlRGVmaW5lZChpbmRleCkge1xuICAgIHJldHVybiBub2Rlc0RlZmluZWRbaW5kZXhdICE9PSBmYWxzZTtcbiAgfTtcbiAgLyogQVNUIG5vZGUgZGVmaW5pdGlvbnMgLSBjYWxsZWQgYnkgdGhlIHBhcnNlcidzIGBVRFRgIG9wZXJhdG9yICovXG4gIHRoaXMudWR0RGVmaW5lZCA9IGZ1bmN0aW9uIHVkdERlZmluZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gbm9kZXNEZWZpbmVkW3J1bGVzLmxlbmd0aCArIGluZGV4XSAhPT0gZmFsc2U7XG4gIH07XG4gIC8qIGNhbGxlZCBieSB0aGUgcGFyc2VyJ3MgYFJOTWAgJiBgVURUYCBvcGVyYXRvcnMgKi9cbiAgLyogYnVpbGRzIGEgcmVjb3JkIGZvciB0aGUgZG93bndhcmQgdHJhdmVyc2FsIG9mIHRoZSBub2RlICovXG4gIHRoaXMuZG93biA9IGZ1bmN0aW9uIGRvd24oY2FsbGJhY2tJbmRleCwgbmFtZSkge1xuICAgIGNvbnN0IHRoaXNJbmRleCA9IHJlY29yZHMubGVuZ3RoO1xuICAgIHN0YWNrLnB1c2godGhpc0luZGV4KTtcbiAgICByZWNvcmRzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHRoaXNJbmRleCxcbiAgICAgIHRoYXRJbmRleDogbnVsbCxcbiAgICAgIHN0YXRlOiBpZC5TRU1fUFJFLFxuICAgICAgY2FsbGJhY2tJbmRleCxcbiAgICAgIHBocmFzZUluZGV4OiBudWxsLFxuICAgICAgcGhyYXNlTGVuZ3RoOiBudWxsLFxuICAgICAgc3RhY2s6IHN0YWNrLmxlbmd0aCxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpc0luZGV4O1xuICB9O1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlcidzIGBSTk1gICYgYFVEVGAgb3BlcmF0b3JzICovXG4gIC8qIGJ1aWxkcyBhIHJlY29yZCBmb3IgdGhlIHVwd2FyZCB0cmF2ZXJzYWwgb2YgdGhlIG5vZGUgKi9cbiAgdGhpcy51cCA9IGZ1bmN0aW9uIHVwKGNhbGxiYWNrSW5kZXgsIG5hbWUsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgpIHtcbiAgICBjb25zdCB0aGlzSW5kZXggPSByZWNvcmRzLmxlbmd0aDtcbiAgICBjb25zdCB0aGF0SW5kZXggPSBzdGFjay5wb3AoKTtcbiAgICByZWNvcmRzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHRoaXNJbmRleCxcbiAgICAgIHRoYXRJbmRleCxcbiAgICAgIHN0YXRlOiBpZC5TRU1fUE9TVCxcbiAgICAgIGNhbGxiYWNrSW5kZXgsXG4gICAgICBwaHJhc2VJbmRleCxcbiAgICAgIHBocmFzZUxlbmd0aCxcbiAgICAgIHN0YWNrOiBzdGFjay5sZW5ndGgsXG4gICAgfSk7XG4gICAgcmVjb3Jkc1t0aGF0SW5kZXhdLnRoYXRJbmRleCA9IHRoaXNJbmRleDtcbiAgICByZWNvcmRzW3RoYXRJbmRleF0ucGhyYXNlSW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICByZWNvcmRzW3RoYXRJbmRleF0ucGhyYXNlTGVuZ3RoID0gcGhyYXNlTGVuZ3RoO1xuICAgIHJldHVybiB0aGlzSW5kZXg7XG4gIH07XG4gIC8vIENhbGxlZCBieSB0aGUgdXNlciB0byB0cmFuc2xhdGUgdGhlIEFTVC5cbiAgLy8gVHJhbnNsYXRlIG1lYW5zIHRvIGFzc29jaWF0ZSBvciBhcHBseSBzb21lIHNlbWFudGljIGFjdGlvbiB0byB0aGVcbiAgLy8gcGhyYXNlcyB0aGF0IHdlcmUgc3ludGFjdGljYWxseSBtYXRjaGVkIHRvIHRoZSBBU1Qgbm9kZXMgYWNjb3JkaW5nXG4gIC8vIHRvIHRoZSBkZWZpbmluZyBncmFtbWFyLlxuICAvLyBgYGBcbiAgLy8gZGF0YSAtIG9wdGlvbmFsIHVzZXItZGVmaW5lZCBkYXRhXG4gIC8vICAgICAgICBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucyBieSB0aGUgdHJhbnNsYXRvclxuICAvLyBgYGBcbiAgdGhpcy50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUoZGF0YSkge1xuICAgIGxldCByZXQ7XG4gICAgbGV0IGNhbGxiYWNrO1xuICAgIGxldCByZWNvcmQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvcmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgY2FsbGJhY2sgPSBub2RlQ2FsbGJhY2tzW3JlY29yZC5jYWxsYmFja0luZGV4XTtcbiAgICAgIGlmIChyZWNvcmQuc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0ID0gY2FsbGJhY2soaWQuU0VNX1BSRSwgY2hhcnMsIHJlY29yZC5waHJhc2VJbmRleCwgcmVjb3JkLnBocmFzZUxlbmd0aCwgZGF0YSk7XG4gICAgICAgICAgaWYgKHJldCA9PT0gaWQuU0VNX1NLSVApIHtcbiAgICAgICAgICAgIGkgPSByZWNvcmQudGhhdEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICBjYWxsYmFjayhpZC5TRU1fUE9TVCwgY2hhcnMsIHJlY29yZC5waHJhc2VJbmRleCwgcmVjb3JkLnBocmFzZUxlbmd0aCwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlciB0byByZXNldCB0aGUgbGVuZ3RoIG9mIHRoZSByZWNvcmRzIGFycmF5ICovXG4gIC8qIG5lY2Vzc2FyeSBvbiBiYWNrdHJhY2tpbmcgKi9cbiAgdGhpcy5zZXRMZW5ndGggPSBmdW5jdGlvbiBzZXRMZW5ndGgobGVuZ3RoKSB7XG4gICAgcmVjb3Jkcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHJlY29yZHNbbGVuZ3RoIC0gMV0uc3RhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9O1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlciB0byBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgcmVjb3JkcyBhcnJheSAqL1xuICB0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCgpIHtcbiAgICByZXR1cm4gcmVjb3Jkcy5sZW5ndGg7XG4gIH07XG4gIC8qIGhlbHBlciBmb3IgWE1MIGRpc3BsYXkgKi9cbiAgZnVuY3Rpb24gaW5kZW50KG4pIHtcbiAgICBsZXQgcmV0ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDEpIHtcbiAgICAgIHJldCArPSAnICc7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLy8gR2VuZXJhdGUgYW4gYFhNTGAgdmVyc2lvbiBvZiB0aGUgQVNULlxuICAvLyBVc2VmdWwgaWYgeW91IHdhbnQgdG8gdXNlIGEgc3BlY2lhbCBvciBmYXZvcml0ZSBYTUwgcGFyc2VyIHRvIHRyYW5zbGF0ZSB0aGVcbiAgLy8gQVNULlxuICAvLyBgYGBcbiAgLy8gbW9kZSAtIHRoZSBkaXNwbGF5IG1vZGUgb2YgdGhlIGNhcHR1cmVkIHBocmFzZXNcbiAgLy8gICAgICAtIGRlZmF1bHQgbW9kZSBpcyBcImFzY2lpXCJcbiAgLy8gICAgICAtIGNhbiBiZTogXCJhc2NpaVwiXG4gIC8vICAgICAgICAgICAgICAgIFwiZGVjaW1hbFwiXG4gIC8vICAgICAgICAgICAgICAgIFwiaGV4YWRlY2ltYWxcIlxuICAvLyAgICAgICAgICAgICAgICBcInVuaWNvZGVcIlxuICAvLyBgYGBcbiAgdGhpcy50b1htbCA9IGZ1bmN0aW9uIHRvU21sKG1vZGVBcmcpIHtcbiAgICBsZXQgZGlzcGxheSA9IHV0aWxzLmNoYXJzVG9EZWM7XG4gICAgbGV0IGNhcHRpb24gPSAnZGVjaW1hbCBpbnRlZ2VyIGNoYXJhY3RlciBjb2Rlcyc7XG4gICAgaWYgKHR5cGVvZiBtb2RlQXJnID09PSAnc3RyaW5nJyAmJiBtb2RlQXJnLmxlbmd0aCA+PSAzKSB7XG4gICAgICBjb25zdCBtb2RlID0gbW9kZUFyZy5zbGljZSgwLCAzKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKG1vZGUgPT09ICdhc2MnKSB7XG4gICAgICAgIGRpc3BsYXkgPSB1dGlscy5jaGFyc1RvQXNjaWk7XG4gICAgICAgIGNhcHRpb24gPSAnQVNDSUkgZm9yIHByaW50aW5nIGNoYXJhY3RlcnMsIGhleCBmb3Igbm9uLXByaW50aW5nJztcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2hleCcpIHtcbiAgICAgICAgZGlzcGxheSA9IHV0aWxzLmNoYXJzVG9IZXg7XG4gICAgICAgIGNhcHRpb24gPSAnaGV4YWRlY2ltYWwgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMnO1xuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAndW5pJykge1xuICAgICAgICBkaXNwbGF5ID0gdXRpbHMuY2hhcnNUb1VuaWNvZGU7XG4gICAgICAgIGNhcHRpb24gPSAnVW5pY29kZSBVVEYtMzIgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMnO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgeG1sID0gJyc7XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICB4bWwgKz0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cInV0Zi04XCI/Plxcbic7XG4gICAgeG1sICs9IGA8cm9vdCBub2Rlcz1cIiR7cmVjb3Jkcy5sZW5ndGggLyAyfVwiIGNoYXJhY3RlcnM9XCIke2NoYXJzLmxlbmd0aH1cIj5cXG5gO1xuICAgIHhtbCArPSBgPCEtLSBpbnB1dCBzdHJpbmcsICR7Y2FwdGlvbn0gLS0+XFxuYDtcbiAgICB4bWwgKz0gaW5kZW50KGRlcHRoICsgMik7XG4gICAgeG1sICs9IGRpc3BsYXkoY2hhcnMpO1xuICAgIHhtbCArPSAnXFxuJztcbiAgICByZWNvcmRzLmZvckVhY2goKHJlYykgPT4ge1xuICAgICAgaWYgKHJlYy5zdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICB4bWwgKz0gaW5kZW50KGRlcHRoKTtcbiAgICAgICAgeG1sICs9IGA8bm9kZSBuYW1lPVwiJHtyZWMubmFtZX1cIiBpbmRleD1cIiR7cmVjLnBocmFzZUluZGV4fVwiIGxlbmd0aD1cIiR7cmVjLnBocmFzZUxlbmd0aH1cIj5cXG5gO1xuICAgICAgICB4bWwgKz0gaW5kZW50KGRlcHRoICsgMik7XG4gICAgICAgIHhtbCArPSBkaXNwbGF5KGNoYXJzLCByZWMucGhyYXNlSW5kZXgsIHJlYy5waHJhc2VMZW5ndGgpO1xuICAgICAgICB4bWwgKz0gJ1xcbic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4bWwgKz0gaW5kZW50KGRlcHRoKTtcbiAgICAgICAgeG1sICs9IGA8L25vZGU+PCEtLSBuYW1lPVwiJHtyZWMubmFtZX1cIiAtLT5cXG5gO1xuICAgICAgICBkZXB0aCAtPSAxO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgeG1sICs9ICc8L3Jvb3Q+XFxuJztcbiAgICByZXR1cm4geG1sO1xuICB9O1xuICAvKiBnZW5lcmF0ZSBhIEphdmFTY3JpcHQgb2JqZWN0IHZlcnNpb24gb2YgdGhlIEFTVCAqL1xuICAvKiBmb3IgdGhlIHBocmFzZS1tYXRjaGluZyBlbmdpbmUgYXBnLWV4cCAqL1xuICB0aGlzLnBocmFzZXMgPSBmdW5jdGlvbiBwaHJhc2VzKCkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGxldCBpO1xuICAgIGxldCByZWNvcmQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHJlY29yZCA9IHJlY29yZHNbaV07XG4gICAgICBpZiAocmVjb3JkLnN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpbcmVjb3JkLm5hbWVdKSkge1xuICAgICAgICAgIG9ialtyZWNvcmQubmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBvYmpbcmVjb3JkLm5hbWVdLnB1c2goe1xuICAgICAgICAgIGluZGV4OiByZWNvcmQucGhyYXNlSW5kZXgsXG4gICAgICAgICAgbGVuZ3RoOiByZWNvcmQucGhyYXNlTGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/ast.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/circular-buffer.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/circular-buffer.js ***!
  \************************************************************************************************/
/***/ ((module) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module acts as a \"circular buffer\". It is used to keep track\n// only the last N records in an array of records. If more than N records\n// are saved, each additional record overwrites the previously oldest record.\n// This module deals only with the record indexes and does not save\n// any actual records. It is used by [`trace.js`](./trace.html) for limiting the number of\n// trace records saved.\nmodule.exports = function exportsCircularBuffer() {\n  'use strict;';\n\n  const thisFileName = 'circular-buffer.js: ';\n  let itemIndex = -1;\n  let maxListSize = 0;\n  // Initialize buffer.<br>\n  // *size* is `maxListSize`, the maximum number of records saved before overwriting begins.\n  this.init = function init(size) {\n    if (typeof size !== 'number' || size <= 0) {\n      throw new Error(`${thisFileName}init: circular buffer size must an integer > 0`);\n    }\n    maxListSize = Math.ceil(size);\n    itemIndex = -1;\n  };\n  // Call this to increment the number of records collected.<br>\n  // Returns the array index number to store the next record in.\n  this.increment = function increment() {\n    itemIndex += 1;\n    return (itemIndex + maxListSize) % maxListSize;\n  };\n  // Returns `maxListSize` - the maximum number of records to keep in the buffer.\n  this.maxSize = function maxSize() {\n    return maxListSize;\n  };\n  // Returns the highest number of items saved.<br>\n  // (The number of items is the actual number of records processed\n  // even though only `maxListSize` records are actually retained.)\n  this.items = function items() {\n    return itemIndex + 1;\n  };\n  // Returns the record number associated with this item index.\n  this.getListIndex = function getListIndex(item) {\n    if (itemIndex === -1) {\n      return -1;\n    }\n    if (item < 0 || item > itemIndex) {\n      return -1;\n    }\n    if (itemIndex - item >= maxListSize) {\n      return -1;\n    }\n    return (item + maxListSize) % maxListSize;\n  };\n  // The iterator over the circular buffer.\n  // The user's function, `fn`, will be called with arguments `fn(listIndex, itemIndex)`\n  // where `listIndex` is the saved record index and `itemIndex` is the actual item index.\n  this.forEach = function forEach(fn) {\n    if (itemIndex === -1) {\n      /* no records have been collected */\n      return;\n    }\n    if (itemIndex < maxListSize) {\n      /* fewer than maxListSize records have been collected - number of items = number of records */\n      for (let i = 0; i <= itemIndex; i += 1) {\n        fn(i, i);\n      }\n      return;\n    }\n    /* start with the oldest record saved and finish with the most recent record saved */\n    for (let i = itemIndex - maxListSize + 1; i <= itemIndex; i += 1) {\n      const listIndex = (i + maxListSize) % maxListSize;\n      fn(listIndex, i);\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2NpcmN1bGFyLWJ1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvY2lyY3VsYXItYnVmZmVyLmpzPzY0YzUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgYWN0cyBhcyBhIFwiY2lyY3VsYXIgYnVmZmVyXCIuIEl0IGlzIHVzZWQgdG8ga2VlcCB0cmFja1xuLy8gb25seSB0aGUgbGFzdCBOIHJlY29yZHMgaW4gYW4gYXJyYXkgb2YgcmVjb3Jkcy4gSWYgbW9yZSB0aGFuIE4gcmVjb3Jkc1xuLy8gYXJlIHNhdmVkLCBlYWNoIGFkZGl0aW9uYWwgcmVjb3JkIG92ZXJ3cml0ZXMgdGhlIHByZXZpb3VzbHkgb2xkZXN0IHJlY29yZC5cbi8vIFRoaXMgbW9kdWxlIGRlYWxzIG9ubHkgd2l0aCB0aGUgcmVjb3JkIGluZGV4ZXMgYW5kIGRvZXMgbm90IHNhdmVcbi8vIGFueSBhY3R1YWwgcmVjb3Jkcy4gSXQgaXMgdXNlZCBieSBbYHRyYWNlLmpzYF0oLi90cmFjZS5odG1sKSBmb3IgbGltaXRpbmcgdGhlIG51bWJlciBvZlxuLy8gdHJhY2UgcmVjb3JkcyBzYXZlZC5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwb3J0c0NpcmN1bGFyQnVmZmVyKCkge1xuICAndXNlIHN0cmljdDsnO1xuXG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdjaXJjdWxhci1idWZmZXIuanM6ICc7XG4gIGxldCBpdGVtSW5kZXggPSAtMTtcbiAgbGV0IG1heExpc3RTaXplID0gMDtcbiAgLy8gSW5pdGlhbGl6ZSBidWZmZXIuPGJyPlxuICAvLyAqc2l6ZSogaXMgYG1heExpc3RTaXplYCwgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgc2F2ZWQgYmVmb3JlIG92ZXJ3cml0aW5nIGJlZ2lucy5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24gaW5pdChzaXplKSB7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJyB8fCBzaXplIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9aW5pdDogY2lyY3VsYXIgYnVmZmVyIHNpemUgbXVzdCBhbiBpbnRlZ2VyID4gMGApO1xuICAgIH1cbiAgICBtYXhMaXN0U2l6ZSA9IE1hdGguY2VpbChzaXplKTtcbiAgICBpdGVtSW5kZXggPSAtMTtcbiAgfTtcbiAgLy8gQ2FsbCB0aGlzIHRvIGluY3JlbWVudCB0aGUgbnVtYmVyIG9mIHJlY29yZHMgY29sbGVjdGVkLjxicj5cbiAgLy8gUmV0dXJucyB0aGUgYXJyYXkgaW5kZXggbnVtYmVyIHRvIHN0b3JlIHRoZSBuZXh0IHJlY29yZCBpbi5cbiAgdGhpcy5pbmNyZW1lbnQgPSBmdW5jdGlvbiBpbmNyZW1lbnQoKSB7XG4gICAgaXRlbUluZGV4ICs9IDE7XG4gICAgcmV0dXJuIChpdGVtSW5kZXggKyBtYXhMaXN0U2l6ZSkgJSBtYXhMaXN0U2l6ZTtcbiAgfTtcbiAgLy8gUmV0dXJucyBgbWF4TGlzdFNpemVgIC0gdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLlxuICB0aGlzLm1heFNpemUgPSBmdW5jdGlvbiBtYXhTaXplKCkge1xuICAgIHJldHVybiBtYXhMaXN0U2l6ZTtcbiAgfTtcbiAgLy8gUmV0dXJucyB0aGUgaGlnaGVzdCBudW1iZXIgb2YgaXRlbXMgc2F2ZWQuPGJyPlxuICAvLyAoVGhlIG51bWJlciBvZiBpdGVtcyBpcyB0aGUgYWN0dWFsIG51bWJlciBvZiByZWNvcmRzIHByb2Nlc3NlZFxuICAvLyBldmVuIHRob3VnaCBvbmx5IGBtYXhMaXN0U2l6ZWAgcmVjb3JkcyBhcmUgYWN0dWFsbHkgcmV0YWluZWQuKVxuICB0aGlzLml0ZW1zID0gZnVuY3Rpb24gaXRlbXMoKSB7XG4gICAgcmV0dXJuIGl0ZW1JbmRleCArIDE7XG4gIH07XG4gIC8vIFJldHVybnMgdGhlIHJlY29yZCBudW1iZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaXRlbSBpbmRleC5cbiAgdGhpcy5nZXRMaXN0SW5kZXggPSBmdW5jdGlvbiBnZXRMaXN0SW5kZXgoaXRlbSkge1xuICAgIGlmIChpdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChpdGVtIDwgMCB8fCBpdGVtID4gaXRlbUluZGV4KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChpdGVtSW5kZXggLSBpdGVtID49IG1heExpc3RTaXplKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiAoaXRlbSArIG1heExpc3RTaXplKSAlIG1heExpc3RTaXplO1xuICB9O1xuICAvLyBUaGUgaXRlcmF0b3Igb3ZlciB0aGUgY2lyY3VsYXIgYnVmZmVyLlxuICAvLyBUaGUgdXNlcidzIGZ1bmN0aW9uLCBgZm5gLCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFyZ3VtZW50cyBgZm4obGlzdEluZGV4LCBpdGVtSW5kZXgpYFxuICAvLyB3aGVyZSBgbGlzdEluZGV4YCBpcyB0aGUgc2F2ZWQgcmVjb3JkIGluZGV4IGFuZCBgaXRlbUluZGV4YCBpcyB0aGUgYWN0dWFsIGl0ZW0gaW5kZXguXG4gIHRoaXMuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICBpZiAoaXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgLyogbm8gcmVjb3JkcyBoYXZlIGJlZW4gY29sbGVjdGVkICovXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpdGVtSW5kZXggPCBtYXhMaXN0U2l6ZSkge1xuICAgICAgLyogZmV3ZXIgdGhhbiBtYXhMaXN0U2l6ZSByZWNvcmRzIGhhdmUgYmVlbiBjb2xsZWN0ZWQgLSBudW1iZXIgb2YgaXRlbXMgPSBudW1iZXIgb2YgcmVjb3JkcyAqL1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaXRlbUluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgZm4oaSwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIHN0YXJ0IHdpdGggdGhlIG9sZGVzdCByZWNvcmQgc2F2ZWQgYW5kIGZpbmlzaCB3aXRoIHRoZSBtb3N0IHJlY2VudCByZWNvcmQgc2F2ZWQgKi9cbiAgICBmb3IgKGxldCBpID0gaXRlbUluZGV4IC0gbWF4TGlzdFNpemUgKyAxOyBpIDw9IGl0ZW1JbmRleDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBsaXN0SW5kZXggPSAoaSArIG1heExpc3RTaXplKSAlIG1heExpc3RTaXplO1xuICAgICAgZm4obGlzdEluZGV4LCBpKTtcbiAgICB9XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/circular-buffer.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/emitcss.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/emitcss.js ***!
  \****************************************************************************************/
/***/ ((module) => {

eval("// This module has been developed programmatically in the `apg-lib` build process.\n// It is used to build web pages programatically on the fly without the need for <script> or <style> tags.\n\nmodule.exports = function emittcss(){\nreturn '/* This file automatically generated by jsonToless() and LESS. */\\n.apg-mono {\\n  font-family: monospace;\\n}\\n.apg-active {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-match {\\n  font-weight: bold;\\n  color: #264BFF;\\n}\\n.apg-empty {\\n  font-weight: bold;\\n  color: #0fbd0f;\\n}\\n.apg-nomatch {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-lh-match {\\n  font-weight: bold;\\n  color: #1A97BA;\\n}\\n.apg-lb-match {\\n  font-weight: bold;\\n  color: #5F1687;\\n}\\n.apg-remainder {\\n  font-weight: bold;\\n  color: #999999;\\n}\\n.apg-ctrl-char {\\n  font-weight: bolder;\\n  font-style: italic;\\n  font-size: 0.6em;\\n}\\n.apg-line-end {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-error {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-phrase {\\n  color: #000000;\\n  background-color: #8caae6;\\n}\\n.apg-empty-phrase {\\n  color: #0fbd0f;\\n}\\ntable.apg-state {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th,\\ntable.apg-state td {\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th:nth-last-child(2),\\ntable.apg-state td:nth-last-child(2) {\\n  text-align: right;\\n}\\ntable.apg-state caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-stats {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats th,\\ntable.apg-stats td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace th,\\ntable.apg-trace td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace th:last-child,\\ntable.apg-trace th:nth-last-child(2),\\ntable.apg-trace td:last-child,\\ntable.apg-trace td:nth-last-child(2) {\\n  text-align: left;\\n}\\ntable.apg-grammar {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-grammar th,\\ntable.apg-grammar td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar th:last-child,\\ntable.apg-grammar td:last-child {\\n  text-align: left;\\n}\\ntable.apg-rules {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-rules th,\\ntable.apg-rules td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules a {\\n  color: #003399 !important;\\n}\\ntable.apg-rules a:hover {\\n  color: #8caae6 !important;\\n}\\ntable.apg-attrs {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-attrs th,\\ntable.apg-attrs td {\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs th:nth-child(1),\\ntable.apg-attrs th:nth-child(2),\\ntable.apg-attrs th:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs td:nth-child(1),\\ntable.apg-attrs td:nth-child(2),\\ntable.apg-attrs td:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs a {\\n  color: #003399 !important;\\n}\\ntable.apg-attrs a:hover {\\n  color: #8caae6 !important;\\n}\\n';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2VtaXRjc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRiwyQkFBMkIsR0FBRyxlQUFlLHNCQUFzQixtQkFBbUIsR0FBRyxjQUFjLHNCQUFzQixtQkFBbUIsR0FBRyxjQUFjLHNCQUFzQixtQkFBbUIsR0FBRyxnQkFBZ0Isc0JBQXNCLG1CQUFtQixHQUFHLGlCQUFpQixzQkFBc0IsbUJBQW1CLEdBQUcsaUJBQWlCLHNCQUFzQixtQkFBbUIsR0FBRyxrQkFBa0Isc0JBQXNCLG1CQUFtQixHQUFHLGtCQUFrQix3QkFBd0IsdUJBQXVCLHFCQUFxQixHQUFHLGlCQUFpQixzQkFBc0IsbUJBQW1CLEdBQUcsY0FBYyxzQkFBc0IsbUJBQW1CLEdBQUcsZUFBZSxtQkFBbUIsOEJBQThCLEdBQUcscUJBQXFCLG1CQUFtQixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0IscUJBQXFCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQ0FBMkMscUJBQXFCLDRCQUE0Qiw4QkFBOEIsR0FBRywrRUFBK0Usc0JBQXNCLEdBQUcsMkJBQTJCLG9CQUFvQixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0Isc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQkFBMkIsb0JBQW9CLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUcsbUJBQW1CLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDJCQUEyQixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywrSUFBK0kscUJBQXFCLEdBQUcscUJBQXFCLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDZCQUE2QixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywrQ0FBK0Msc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRyxxRUFBcUUscUJBQXFCLEdBQUcsbUJBQW1CLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDJCQUEyQixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRyxxQkFBcUIsOEJBQThCLEdBQUcsMkJBQTJCLDhCQUE4QixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0IsdUJBQXVCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQkFBMkIsb0JBQW9CLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUcsMkNBQTJDLHVCQUF1Qiw0QkFBNEIsOEJBQThCLEdBQUcsdUdBQXVHLHNCQUFzQixHQUFHLHVHQUF1RyxzQkFBc0IsR0FBRyxxQkFBcUIsOEJBQThCLEdBQUcsMkJBQTJCLDhCQUE4QixHQUFHO0FBQzdzSSIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2VtaXRjc3MuanM/ODNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIG1vZHVsZSBoYXMgYmVlbiBkZXZlbG9wZWQgcHJvZ3JhbW1hdGljYWxseSBpbiB0aGUgYGFwZy1saWJgIGJ1aWxkIHByb2Nlc3MuXG4vLyBJdCBpcyB1c2VkIHRvIGJ1aWxkIHdlYiBwYWdlcyBwcm9ncmFtYXRpY2FsbHkgb24gdGhlIGZseSB3aXRob3V0IHRoZSBuZWVkIGZvciA8c2NyaXB0PiBvciA8c3R5bGU+IHRhZ3MuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW1pdHRjc3MoKXtcbnJldHVybiAnLyogVGhpcyBmaWxlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IGpzb25Ub2xlc3MoKSBhbmQgTEVTUy4gKi9cXG4uYXBnLW1vbm8ge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG59XFxuLmFwZy1hY3RpdmUge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzAwMDAwMDtcXG59XFxuLmFwZy1tYXRjaCB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjMjY0QkZGO1xcbn1cXG4uYXBnLWVtcHR5IHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICMwZmJkMGY7XFxufVxcbi5hcGctbm9tYXRjaCB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjRkY0MDAwO1xcbn1cXG4uYXBnLWxoLW1hdGNoIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICMxQTk3QkE7XFxufVxcbi5hcGctbGItbWF0Y2gge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzVGMTY4NztcXG59XFxuLmFwZy1yZW1haW5kZXIge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzk5OTk5OTtcXG59XFxuLmFwZy1jdHJsLWNoYXIge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gIGZvbnQtc2l6ZTogMC42ZW07XFxufVxcbi5hcGctbGluZS1lbmQge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzAwMDAwMDtcXG59XFxuLmFwZy1lcnJvciB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjRkY0MDAwO1xcbn1cXG4uYXBnLXBocmFzZSB7XFxuICBjb2xvcjogIzAwMDAwMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM4Y2FhZTY7XFxufVxcbi5hcGctZW1wdHktcGhyYXNlIHtcXG4gIGNvbG9yOiAjMGZiZDBmO1xcbn1cXG50YWJsZS5hcGctc3RhdGUge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXN0YXRlIHRoLFxcbnRhYmxlLmFwZy1zdGF0ZSB0ZCB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctc3RhdGUgdGg6bnRoLWxhc3QtY2hpbGQoMiksXFxudGFibGUuYXBnLXN0YXRlIHRkOm50aC1sYXN0LWNoaWxkKDIpIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG50YWJsZS5hcGctc3RhdGUgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLXN0YXRzIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctc3RhdHMgdGgsXFxudGFibGUuYXBnLXN0YXRzIHRkIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctc3RhdHMgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLXRyYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctdHJhY2UgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLXRyYWNlIHRoLFxcbnRhYmxlLmFwZy10cmFjZSB0ZCB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXRyYWNlIHRoOmxhc3QtY2hpbGQsXFxudGFibGUuYXBnLXRyYWNlIHRoOm50aC1sYXN0LWNoaWxkKDIpLFxcbnRhYmxlLmFwZy10cmFjZSB0ZDpsYXN0LWNoaWxkLFxcbnRhYmxlLmFwZy10cmFjZSB0ZDpudGgtbGFzdC1jaGlsZCgyKSB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50YWJsZS5hcGctZ3JhbW1hciB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLXRvcDogNXB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLWdyYW1tYXIgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLWdyYW1tYXIgdGgsXFxudGFibGUuYXBnLWdyYW1tYXIgdGQge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1ncmFtbWFyIHRoOmxhc3QtY2hpbGQsXFxudGFibGUuYXBnLWdyYW1tYXIgdGQ6bGFzdC1jaGlsZCB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50YWJsZS5hcGctcnVsZXMge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1ydWxlcyBjYXB0aW9uIHtcXG4gIGZvbnQtc2l6ZTogMTI1JTtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50YWJsZS5hcGctcnVsZXMgdGgsXFxudGFibGUuYXBnLXJ1bGVzIHRkIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctcnVsZXMgYSB7XFxuICBjb2xvcjogIzAwMzM5OSAhaW1wb3J0YW50O1xcbn1cXG50YWJsZS5hcGctcnVsZXMgYTpob3ZlciB7XFxuICBjb2xvcjogIzhjYWFlNiAhaW1wb3J0YW50O1xcbn1cXG50YWJsZS5hcGctYXR0cnMge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctYXR0cnMgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLWF0dHJzIHRoLFxcbnRhYmxlLmFwZy1hdHRycyB0ZCB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1hdHRycyB0aDpudGgtY2hpbGQoMSksXFxudGFibGUuYXBnLWF0dHJzIHRoOm50aC1jaGlsZCgyKSxcXG50YWJsZS5hcGctYXR0cnMgdGg6bnRoLWNoaWxkKDMpIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG50YWJsZS5hcGctYXR0cnMgdGQ6bnRoLWNoaWxkKDEpLFxcbnRhYmxlLmFwZy1hdHRycyB0ZDpudGgtY2hpbGQoMiksXFxudGFibGUuYXBnLWF0dHJzIHRkOm50aC1jaGlsZCgzKSB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxudGFibGUuYXBnLWF0dHJzIGEge1xcbiAgY29sb3I6ICMwMDMzOTkgIWltcG9ydGFudDtcXG59XFxudGFibGUuYXBnLWF0dHJzIGE6aG92ZXIge1xcbiAgY29sb3I6ICM4Y2FhZTYgIWltcG9ydGFudDtcXG59XFxuJztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/emitcss.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js ***!
  \********************************************************************************************/
/***/ ((module) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes a list of named identifiers, shared across the parser generator\n// and the parsers that are generated.\n\nmodule.exports = {\n  // Identifies the operator type. Used by the generator\n  // to indicate operator types in the grammar object.\n  // Used by the [parser](./parser.html) when interpreting the grammar object.\n  /* the original ABNF operators */\n  ALT: 1 /* alternation */,\n  CAT: 2 /* concatenation */,\n  REP: 3 /* repetition */,\n  RNM: 4 /* rule name */,\n  TRG: 5 /* terminal range */,\n  TBS: 6 /* terminal binary string, case sensitive */,\n  TLS: 7 /* terminal literal string, case insensitive */,\n  /* the super set, SABNF operators */\n  UDT: 11 /* user-defined terminal */,\n  AND: 12 /* positive look ahead */,\n  NOT: 13 /* negative look ahead */,\n  BKR: 14 /* back reference to a previously matched rule name */,\n  BKA: 15 /* positive look behind */,\n  BKN: 16 /* negative look behind */,\n  ABG: 17 /* anchor - begin of string */,\n  AEN: 18 /* anchor - end of string */,\n  // Used by the parser and the user's `RNM` and `UDT` callback functions.\n  // Identifies the parser state as it traverses the parse tree nodes.\n  // - *ACTIVE* - indicates the downward direction through the parse tree node.\n  // - *MATCH* - indicates the upward direction and a phrase, of length \\> 0, has been successfully matched\n  // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched\n  // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all\n  ACTIVE: 100,\n  MATCH: 101,\n  EMPTY: 102,\n  NOMATCH: 103,\n  // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions\n  // to indicate the direction of flow through the `AST` nodes.\n  // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.\n  // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.\n  SEM_PRE: 200,\n  SEM_POST: 201,\n  // Used by the user's callback functions to indicate to the `AST` translator (semantic analysis) how to proceed.\n  // - *SEM_OK* - normal return value\n  // - *SEM_SKIP* - if a callback function returns this value from the SEM_PRE state,\n  // the translator will skip processing all `AST` nodes in the branch below the current node.\n  // Ignored if returned from the SEM_POST state.\n  SEM_OK: 300,\n  SEM_SKIP: 301,\n  // Used in attribute generation to distinguish the necessary attribute categories.\n  // - *ATTR_N* - non-recursive\n  // - *ATTR_R* - recursive\n  // - *ATTR_MR* - belongs to a mutually-recursive set\n  ATTR_N: 400,\n  ATTR_R: 401,\n  ATTR_MR: 402,\n  // Look around values indicate whether the parser is in look ahead or look behind mode.\n  // Used by the tracing facility to indicate the look around mode in the trace records display.\n  // - *LOOKAROUND_NONE* - the parser is in normal parsing mode\n  // - *LOOKAROUND_AHEAD* - the parse is in look-ahead mode, phrase matching for operator `AND(&)` or `NOT(!)`\n  // - *LOOKAROUND_BEHIND* - the parse is in look-behind mode, phrase matching for operator `BKA(&&)` or `BKN(!!)`\n  LOOKAROUND_NONE: 500,\n  LOOKAROUND_AHEAD: 501,\n  LOOKAROUND_BEHIND: 502,\n  // Back reference rule mode indicators\n  // - *BKR_MODE_UM* - the back reference is using universal mode\n  // - *BKR_MODE_PM* - the back reference is using parent frame mode\n  // - *BKR_MODE_CS* - the back reference is using case-sensitive phrase matching\n  // - *BKR_MODE_CI* - the back reference is using case-insensitive phrase matching\n  BKR_MODE_UM: 601,\n  BKR_MODE_PM: 602,\n  BKR_MODE_CS: 603,\n  BKR_MODE_CI: 604,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2lkZW50aWZpZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9pZGVudGlmaWVycy5qcz81ZWNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGV4cG9zZXMgYSBsaXN0IG9mIG5hbWVkIGlkZW50aWZpZXJzLCBzaGFyZWQgYWNyb3NzIHRoZSBwYXJzZXIgZ2VuZXJhdG9yXG4vLyBhbmQgdGhlIHBhcnNlcnMgdGhhdCBhcmUgZ2VuZXJhdGVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gSWRlbnRpZmllcyB0aGUgb3BlcmF0b3IgdHlwZS4gVXNlZCBieSB0aGUgZ2VuZXJhdG9yXG4gIC8vIHRvIGluZGljYXRlIG9wZXJhdG9yIHR5cGVzIGluIHRoZSBncmFtbWFyIG9iamVjdC5cbiAgLy8gVXNlZCBieSB0aGUgW3BhcnNlcl0oLi9wYXJzZXIuaHRtbCkgd2hlbiBpbnRlcnByZXRpbmcgdGhlIGdyYW1tYXIgb2JqZWN0LlxuICAvKiB0aGUgb3JpZ2luYWwgQUJORiBvcGVyYXRvcnMgKi9cbiAgQUxUOiAxIC8qIGFsdGVybmF0aW9uICovLFxuICBDQVQ6IDIgLyogY29uY2F0ZW5hdGlvbiAqLyxcbiAgUkVQOiAzIC8qIHJlcGV0aXRpb24gKi8sXG4gIFJOTTogNCAvKiBydWxlIG5hbWUgKi8sXG4gIFRSRzogNSAvKiB0ZXJtaW5hbCByYW5nZSAqLyxcbiAgVEJTOiA2IC8qIHRlcm1pbmFsIGJpbmFyeSBzdHJpbmcsIGNhc2Ugc2Vuc2l0aXZlICovLFxuICBUTFM6IDcgLyogdGVybWluYWwgbGl0ZXJhbCBzdHJpbmcsIGNhc2UgaW5zZW5zaXRpdmUgKi8sXG4gIC8qIHRoZSBzdXBlciBzZXQsIFNBQk5GIG9wZXJhdG9ycyAqL1xuICBVRFQ6IDExIC8qIHVzZXItZGVmaW5lZCB0ZXJtaW5hbCAqLyxcbiAgQU5EOiAxMiAvKiBwb3NpdGl2ZSBsb29rIGFoZWFkICovLFxuICBOT1Q6IDEzIC8qIG5lZ2F0aXZlIGxvb2sgYWhlYWQgKi8sXG4gIEJLUjogMTQgLyogYmFjayByZWZlcmVuY2UgdG8gYSBwcmV2aW91c2x5IG1hdGNoZWQgcnVsZSBuYW1lICovLFxuICBCS0E6IDE1IC8qIHBvc2l0aXZlIGxvb2sgYmVoaW5kICovLFxuICBCS046IDE2IC8qIG5lZ2F0aXZlIGxvb2sgYmVoaW5kICovLFxuICBBQkc6IDE3IC8qIGFuY2hvciAtIGJlZ2luIG9mIHN0cmluZyAqLyxcbiAgQUVOOiAxOCAvKiBhbmNob3IgLSBlbmQgb2Ygc3RyaW5nICovLFxuICAvLyBVc2VkIGJ5IHRoZSBwYXJzZXIgYW5kIHRoZSB1c2VyJ3MgYFJOTWAgYW5kIGBVRFRgIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgLy8gSWRlbnRpZmllcyB0aGUgcGFyc2VyIHN0YXRlIGFzIGl0IHRyYXZlcnNlcyB0aGUgcGFyc2UgdHJlZSBub2Rlcy5cbiAgLy8gLSAqQUNUSVZFKiAtIGluZGljYXRlcyB0aGUgZG93bndhcmQgZGlyZWN0aW9uIHRocm91Z2ggdGhlIHBhcnNlIHRyZWUgbm9kZS5cbiAgLy8gLSAqTUFUQ0gqIC0gaW5kaWNhdGVzIHRoZSB1cHdhcmQgZGlyZWN0aW9uIGFuZCBhIHBocmFzZSwgb2YgbGVuZ3RoIFxcPiAwLCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbWF0Y2hlZFxuICAvLyAtICpFTVBUWSogLSBpbmRpY2F0ZXMgdGhlIHVwd2FyZCBkaXJlY3Rpb24gYW5kIGEgcGhyYXNlLCBvZiBsZW5ndGggPSAwLCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbWF0Y2hlZFxuICAvLyAtICpOT01BVENIKiAtIGluZGljYXRlcyB0aGUgdXB3YXJkIGRpcmVjdGlvbiBhbmQgdGhlIHBhcnNlciBmYWlsZWQgdG8gbWF0Y2ggYW55IHBocmFzZSBhdCBhbGxcbiAgQUNUSVZFOiAxMDAsXG4gIE1BVENIOiAxMDEsXG4gIEVNUFRZOiAxMDIsXG4gIE5PTUFUQ0g6IDEwMyxcbiAgLy8gVXNlZCBieSBbYEFTVGAgdHJhbnNsYXRvcl0oLi9hc3QuaHRtbCkgKHNlbWFudGljIGFuYWx5c2lzKSBhbmQgdGhlIHVzZXIncyBjYWxsYmFjayBmdW5jdGlvbnNcbiAgLy8gdG8gaW5kaWNhdGUgdGhlIGRpcmVjdGlvbiBvZiBmbG93IHRocm91Z2ggdGhlIGBBU1RgIG5vZGVzLlxuICAvLyAtICpTRU1fUFJFKiAtIGluZGljYXRlcyB0aGUgZG93bndhcmQgKHByZS1icmFuY2gpIGRpcmVjdGlvbiB0aHJvdWdoIHRoZSBgQVNUYCBub2RlLlxuICAvLyAtICpTRU1fUE9TVCogLSBpbmRpY2F0ZXMgdGhlIHVwd2FyZCAocG9zdC1icmFuY2gpIGRpcmVjdGlvbiB0aHJvdWdoIHRoZSBgQVNUYCBub2RlLlxuICBTRU1fUFJFOiAyMDAsXG4gIFNFTV9QT1NUOiAyMDEsXG4gIC8vIFVzZWQgYnkgdGhlIHVzZXIncyBjYWxsYmFjayBmdW5jdGlvbnMgdG8gaW5kaWNhdGUgdG8gdGhlIGBBU1RgIHRyYW5zbGF0b3IgKHNlbWFudGljIGFuYWx5c2lzKSBob3cgdG8gcHJvY2VlZC5cbiAgLy8gLSAqU0VNX09LKiAtIG5vcm1hbCByZXR1cm4gdmFsdWVcbiAgLy8gLSAqU0VNX1NLSVAqIC0gaWYgYSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRoaXMgdmFsdWUgZnJvbSB0aGUgU0VNX1BSRSBzdGF0ZSxcbiAgLy8gdGhlIHRyYW5zbGF0b3Igd2lsbCBza2lwIHByb2Nlc3NpbmcgYWxsIGBBU1RgIG5vZGVzIGluIHRoZSBicmFuY2ggYmVsb3cgdGhlIGN1cnJlbnQgbm9kZS5cbiAgLy8gSWdub3JlZCBpZiByZXR1cm5lZCBmcm9tIHRoZSBTRU1fUE9TVCBzdGF0ZS5cbiAgU0VNX09LOiAzMDAsXG4gIFNFTV9TS0lQOiAzMDEsXG4gIC8vIFVzZWQgaW4gYXR0cmlidXRlIGdlbmVyYXRpb24gdG8gZGlzdGluZ3Vpc2ggdGhlIG5lY2Vzc2FyeSBhdHRyaWJ1dGUgY2F0ZWdvcmllcy5cbiAgLy8gLSAqQVRUUl9OKiAtIG5vbi1yZWN1cnNpdmVcbiAgLy8gLSAqQVRUUl9SKiAtIHJlY3Vyc2l2ZVxuICAvLyAtICpBVFRSX01SKiAtIGJlbG9uZ3MgdG8gYSBtdXR1YWxseS1yZWN1cnNpdmUgc2V0XG4gIEFUVFJfTjogNDAwLFxuICBBVFRSX1I6IDQwMSxcbiAgQVRUUl9NUjogNDAyLFxuICAvLyBMb29rIGFyb3VuZCB2YWx1ZXMgaW5kaWNhdGUgd2hldGhlciB0aGUgcGFyc2VyIGlzIGluIGxvb2sgYWhlYWQgb3IgbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gVXNlZCBieSB0aGUgdHJhY2luZyBmYWNpbGl0eSB0byBpbmRpY2F0ZSB0aGUgbG9vayBhcm91bmQgbW9kZSBpbiB0aGUgdHJhY2UgcmVjb3JkcyBkaXNwbGF5LlxuICAvLyAtICpMT09LQVJPVU5EX05PTkUqIC0gdGhlIHBhcnNlciBpcyBpbiBub3JtYWwgcGFyc2luZyBtb2RlXG4gIC8vIC0gKkxPT0tBUk9VTkRfQUhFQUQqIC0gdGhlIHBhcnNlIGlzIGluIGxvb2stYWhlYWQgbW9kZSwgcGhyYXNlIG1hdGNoaW5nIGZvciBvcGVyYXRvciBgQU5EKCYpYCBvciBgTk9UKCEpYFxuICAvLyAtICpMT09LQVJPVU5EX0JFSElORCogLSB0aGUgcGFyc2UgaXMgaW4gbG9vay1iZWhpbmQgbW9kZSwgcGhyYXNlIG1hdGNoaW5nIGZvciBvcGVyYXRvciBgQktBKCYmKWAgb3IgYEJLTighISlgXG4gIExPT0tBUk9VTkRfTk9ORTogNTAwLFxuICBMT09LQVJPVU5EX0FIRUFEOiA1MDEsXG4gIExPT0tBUk9VTkRfQkVISU5EOiA1MDIsXG4gIC8vIEJhY2sgcmVmZXJlbmNlIHJ1bGUgbW9kZSBpbmRpY2F0b3JzXG4gIC8vIC0gKkJLUl9NT0RFX1VNKiAtIHRoZSBiYWNrIHJlZmVyZW5jZSBpcyB1c2luZyB1bml2ZXJzYWwgbW9kZVxuICAvLyAtICpCS1JfTU9ERV9QTSogLSB0aGUgYmFjayByZWZlcmVuY2UgaXMgdXNpbmcgcGFyZW50IGZyYW1lIG1vZGVcbiAgLy8gLSAqQktSX01PREVfQ1MqIC0gdGhlIGJhY2sgcmVmZXJlbmNlIGlzIHVzaW5nIGNhc2Utc2Vuc2l0aXZlIHBocmFzZSBtYXRjaGluZ1xuICAvLyAtICpCS1JfTU9ERV9DSSogLSB0aGUgYmFjayByZWZlcmVuY2UgaXMgdXNpbmcgY2FzZS1pbnNlbnNpdGl2ZSBwaHJhc2UgbWF0Y2hpbmdcbiAgQktSX01PREVfVU06IDYwMSxcbiAgQktSX01PREVfUE06IDYwMixcbiAgQktSX01PREVfQ1M6IDYwMyxcbiAgQktSX01PREVfQ0k6IDYwNCxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module serves to export all library objects and object constructors with the `require(\"apg-lib\")` statement.\n// For example, to create a new parser in your program,\n// ````\n// let apglib = require(\"../apg-lib/node-exports\");\n// let my-parser = new apglib.parser();\n// ````\nmodule.exports = {\n  ast: __webpack_require__(/*! ./ast */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/ast.js\"),\n  circular: __webpack_require__(/*! ./circular-buffer */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/circular-buffer.js\"),\n  ids: __webpack_require__(/*! ./identifiers */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\"),\n  parser: __webpack_require__(/*! ./parser */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/parser.js\"),\n  stats: __webpack_require__(/*! ./stats */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/stats.js\"),\n  trace: __webpack_require__(/*! ./trace */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/trace.js\"),\n  utils: __webpack_require__(/*! ./utilities */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\"),\n  emitcss: __webpack_require__(/*! ./emitcss */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/emitcss.js\"),\n  style: __webpack_require__(/*! ./style */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js\"),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL25vZGUtZXhwb3J0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLGlHQUFPO0FBQ3RCLFlBQVksbUJBQU8sQ0FBQyx5SEFBbUI7QUFDdkMsT0FBTyxtQkFBTyxDQUFDLGlIQUFlO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyx1R0FBVTtBQUM1QixTQUFTLG1CQUFPLENBQUMscUdBQVM7QUFDMUIsU0FBUyxtQkFBTyxDQUFDLHFHQUFTO0FBQzFCLFNBQVMsbUJBQU8sQ0FBQyw2R0FBYTtBQUM5QixXQUFXLG1CQUFPLENBQUMseUdBQVc7QUFDOUIsU0FBUyxtQkFBTyxDQUFDLHFHQUFTO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvbm9kZS1leHBvcnRzLmpzPzA5ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgc2VydmVzIHRvIGV4cG9ydCBhbGwgbGlicmFyeSBvYmplY3RzIGFuZCBvYmplY3QgY29uc3RydWN0b3JzIHdpdGggdGhlIGByZXF1aXJlKFwiYXBnLWxpYlwiKWAgc3RhdGVtZW50LlxuLy8gRm9yIGV4YW1wbGUsIHRvIGNyZWF0ZSBhIG5ldyBwYXJzZXIgaW4geW91ciBwcm9ncmFtLFxuLy8gYGBgYFxuLy8gbGV0IGFwZ2xpYiA9IHJlcXVpcmUoXCIuLi9hcGctbGliL25vZGUtZXhwb3J0c1wiKTtcbi8vIGxldCBteS1wYXJzZXIgPSBuZXcgYXBnbGliLnBhcnNlcigpO1xuLy8gYGBgYFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzdDogcmVxdWlyZSgnLi9hc3QnKSxcbiAgY2lyY3VsYXI6IHJlcXVpcmUoJy4vY2lyY3VsYXItYnVmZmVyJyksXG4gIGlkczogcmVxdWlyZSgnLi9pZGVudGlmaWVycycpLFxuICBwYXJzZXI6IHJlcXVpcmUoJy4vcGFyc2VyJyksXG4gIHN0YXRzOiByZXF1aXJlKCcuL3N0YXRzJyksXG4gIHRyYWNlOiByZXF1aXJlKCcuL3RyYWNlJyksXG4gIHV0aWxzOiByZXF1aXJlKCcuL3V0aWxpdGllcycpLFxuICBlbWl0Y3NzOiByZXF1aXJlKCcuL2VtaXRjc3MnKSxcbiAgc3R5bGU6IHJlcXVpcmUoJy4vc3R5bGUnKSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/parser.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/parser.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable new-cap */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This is the primary object of `apg-lib`. Calling its `parse()` member function\n// walks the parse tree of opcodes, matching phrases from the input string as it goes.\n// The working code for all of the operators, `ALT`, `CAT`, etc. is in this module.\nmodule.exports = function parser() {\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\");\n\n  const thisFileName = 'parser.js: ';\n  const thisThis = this;\n  let opExecute;\n  this.ast = null;\n  this.stats = null;\n  this.trace = null;\n  this.callbacks = [];\n  let opcodes = null;\n  let chars = null;\n  let charsBegin;\n  let charsLength;\n  let charsEnd;\n  let lookAround;\n  let treeDepth = 0;\n  let maxTreeDepth = 0;\n  let nodeHits = 0;\n  let ruleCallbacks = null;\n  let udtCallbacks = null;\n  let rules = null;\n  let udts = null;\n  let syntaxData = null;\n  let maxMatched = 0;\n  let limitTreeDepth = Infinity;\n  let limitNodeHits = Infinity;\n  // Evaluates any given rule. This can be called from the syntax callback\n  // functions to evaluate any rule in the grammar's rule list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateRule = function evaluateRule(ruleIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateRule(): `;\n    if (ruleIndex >= rules.length) {\n      throw new Error(`${functionName}rule index: ${ruleIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.RNM,\n      index: ruleIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  // Evaluates any given UDT. This can be called from the syntax callback\n  // functions to evaluate any UDT in the grammar's UDT list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateUdt = function (udtIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateUdt(): `;\n    if (udtIndex >= udts.length) {\n      throw new Error(`${functionName}udt index: ${udtIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.UDT,\n      empty: udts[udtIndex].empty,\n      index: udtIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  /* Clears this object of any/all data that has been initialized or added to it. */\n  /* Called by parse() on initialization, allowing this object to be re-used for multiple parsing calls. */\n  const clear = function () {\n    treeDepth = 0;\n    maxTreeDepth = 0;\n    nodeHits = 0;\n    maxMatched = 0;\n    lookAround = [\n      {\n        lookAround: id.LOOKAROUND_NONE,\n        anchor: 0,\n        charsEnd: 0,\n        charsLength: 0,\n      },\n    ];\n    rules = null;\n    udts = null;\n    chars = null;\n    charsBegin = 0;\n    charsLength = 0;\n    charsEnd = 0;\n    ruleCallbacks = null;\n    udtCallbacks = null;\n    syntaxData = null;\n    opcodes = null;\n  };\n  /* object for maintaining a stack of back reference frames */\n  const backRef = function () {\n    const stack = [];\n    const init = function () {\n      const obj = {};\n      rules.forEach((rule) => {\n        if (rule.isBkr) {\n          obj[rule.lower] = null;\n        }\n      });\n      if (udts.length > 0) {\n        udts.forEach((udt) => {\n          if (udt.isBkr) {\n            obj[udt.lower] = null;\n          }\n        });\n      }\n      stack.push(obj);\n    };\n    const copy = function () {\n      const top = stack[stack.length - 1];\n      const obj = {};\n      /* // eslint-disable-next-line no-restricted-syntax */\n      for (const name in top) {\n        obj[name] = top[name];\n      }\n      return obj;\n    };\n    this.push = function push() {\n      stack.push(copy());\n    };\n    this.pop = function pop(lengthArg) {\n      let length = lengthArg;\n      if (!length) {\n        length = stack.length - 1;\n      }\n      if (length < 1 || length > stack.length) {\n        throw new Error(`${thisFileName}backRef.pop(): bad length: ${length}`);\n      }\n      stack.length = length;\n      return stack[stack.length - 1];\n    };\n    this.length = function length() {\n      return stack.length;\n    };\n    this.savePhrase = function savePhrase(name, index, length) {\n      stack[stack.length - 1][name] = {\n        phraseIndex: index,\n        phraseLength: length,\n      };\n    };\n    this.getPhrase = function (name) {\n      return stack[stack.length - 1][name];\n    };\n    /* constructor */\n    init();\n  };\n  // The system data structure that relays system information to and from the rule and UDT callback functions.\n  // - *state* - the state of the parser, ACTIVE, MATCH, EMPTY or NOMATCH (see the `identifiers` object in\n  // [`apg-lib`](https://github.com/ldthomas/apg-js2-lib))\n  // - *phraseLength* - the number of characters matched if the state is MATCHED or EMPTY\n  // - *lookaround* - the top of the stack holds the current look around state,\n  // LOOKAROUND_NONE, LOOKAROUND_AHEAD or LOOKAROUND_BEHIND,\n  // - *uFrame* - the \"universal\" back reference frame.\n  // Holds the last matched phrase for each of the back referenced rules and UDTs.\n  // - *pFrame* - the stack of \"parent\" back reference frames.\n  // Holds the matched phrase from the parent frame of each back referenced rules and UDTs.\n  // - *evaluateRule* - a reference to this object's `evaluateRule()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  // - *evaluateUdt* - a reference to this object's `evaluateUdt()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  const systemData = function systemData() {\n    const thisData = this;\n    this.state = id.ACTIVE;\n    this.phraseLength = 0;\n    this.ruleIndex = 0;\n    this.udtIndex = 0;\n    this.lookAround = lookAround[lookAround.length - 1];\n    this.uFrame = new backRef();\n    this.pFrame = new backRef();\n    this.evaluateRule = evaluateRule;\n    this.evaluateUdt = evaluateUdt;\n    /* refresh the parser state for the next operation */\n    this.refresh = function refresh() {\n      thisData.state = id.ACTIVE;\n      thisData.phraseLength = 0;\n      thisData.lookAround = lookAround[lookAround.length - 1];\n    };\n  };\n  /* some look around helper functions */\n  const lookAroundValue = function lookAroundValue() {\n    return lookAround[lookAround.length - 1];\n  };\n  /* return true if parser is in look around (ahead or behind) state */\n  const inLookAround = function inLookAround() {\n    return lookAround.length > 1;\n  };\n  /* return true if parser is in look behind state */\n  const inLookBehind = function () {\n    return lookAround[lookAround.length - 1].lookAround === id.LOOKAROUND_BEHIND;\n  };\n  /* called by parse() to initialize the AST object, if one has been defined */\n  const initializeAst = function () {\n    const functionName = `${thisFileName}initializeAst(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.ast === undefined) {\n        thisThis.ast = null;\n        break;\n      }\n      if (thisThis.ast === null) {\n        break;\n      }\n      if (thisThis.ast.astObject !== 'astObject') {\n        throw new Error(`${functionName}ast object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.ast !== null) {\n      thisThis.ast.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the trace object, if one has been defined */\n  const initializeTrace = function () {\n    const functionName = `${thisFileName}initializeTrace(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.trace === undefined) {\n        thisThis.trace = null;\n        break;\n      }\n      if (thisThis.trace === null) {\n        break;\n      }\n      if (thisThis.trace.traceObject !== 'traceObject') {\n        throw new Error(`${functionName}trace object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.trace !== null) {\n      thisThis.trace.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the statistics object, if one has been defined */\n  const initializeStats = function () {\n    const functionName = `${thisFileName}initializeStats(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.stats === undefined) {\n        thisThis.stats = null;\n        break;\n      }\n      if (thisThis.stats === null) {\n        break;\n      }\n      if (thisThis.stats.statsObject !== 'statsObject') {\n        throw new Error(`${functionName}stats object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.stats !== null) {\n      thisThis.stats.init(rules, udts);\n    }\n  };\n  /* called by parse() to initialize the rules & udts from the grammar object */\n  /* (the grammar object generated previously by apg) */\n  const initializeGrammar = function (grammar) {\n    const functionName = `${thisFileName}initializeGrammar(): `;\n    if (!grammar) {\n      throw new Error(`${functionName}grammar object undefined`);\n    }\n    if (grammar.grammarObject !== 'grammarObject') {\n      throw new Error(`${functionName}bad grammar object`);\n    }\n    rules = grammar.rules;\n    udts = grammar.udts;\n  };\n  /* called by parse() to initialize the start rule */\n  const initializeStartRule = function (startRule) {\n    const functionName = `${thisFileName}initializeStartRule(): `;\n    let start = null;\n    if (typeof startRule === 'number') {\n      if (startRule >= rules.length) {\n        throw new Error(`${functionName}start rule index too large: max: ${rules.length}: index: ${startRule}`);\n      }\n      start = startRule;\n    } else if (typeof startRule === 'string') {\n      const lower = startRule.toLowerCase();\n      for (let i = 0; i < rules.length; i += 1) {\n        if (lower === rules[i].lower) {\n          start = rules[i].index;\n          break;\n        }\n      }\n      if (start === null) {\n        throw new Error(`${functionName}start rule name '${startRule}' not recognized`);\n      }\n    } else {\n      throw new Error(`${functionName}type of start rule '${typeof startRule}' not recognized`);\n    }\n    return start;\n  };\n  /* called by parse() to initialize the array of characters codes representing the input string */\n  const initializeInputChars = function initializeInputChars(inputArg, begArg, lenArg) {\n    const functionName = `${thisFileName}initializeInputChars(): `;\n    /* varify and normalize input */\n    let input = inputArg;\n    let beg = begArg;\n    let len = lenArg;\n    if (input === undefined) {\n      throw new Error(`${functionName}input string is undefined`);\n    }\n    if (input === null) {\n      throw new Error(`${functionName}input string is null`);\n    }\n    if (typeof input === 'string') {\n      input = utils.stringToChars(input);\n    } else if (!Array.isArray(input)) {\n      throw new Error(`${functionName}input string is not a string or array`);\n    }\n    if (input.length > 0) {\n      if (typeof input[0] !== 'number') {\n        throw new Error(`${functionName}input string not an array of integers`);\n      }\n    }\n    /* verify and normalize beginning index */\n    if (typeof beg !== 'number') {\n      beg = 0;\n    } else {\n      beg = Math.floor(beg);\n      if (beg < 0 || beg > input.length) {\n        throw new Error(`${functionName}input beginning index out of range: ${beg}`);\n      }\n    }\n    /* verify and normalize input length */\n    if (typeof len !== 'number') {\n      len = input.length - beg;\n    } else {\n      len = Math.floor(len);\n      if (len < 0 || len > input.length - beg) {\n        throw new Error(`${functionName}input length out of range: ${len}`);\n      }\n    }\n    chars = input;\n    charsBegin = beg;\n    charsLength = len;\n    charsEnd = charsBegin + charsLength;\n  };\n  /* called by parse() to initialize the user-written, syntax callback functions, if any */\n  const initializeCallbacks = function () {\n    const functionName = `${thisFileName}initializeCallbacks(): `;\n    let i;\n    ruleCallbacks = [];\n    udtCallbacks = [];\n    for (i = 0; i < rules.length; i += 1) {\n      ruleCallbacks[i] = null;\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      udtCallbacks[i] = null;\n    }\n    let func;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    for (const index in thisThis.callbacks) {\n      i = list.indexOf(index.toLowerCase());\n      if (i < 0) {\n        throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);\n      }\n      func = thisThis.callbacks[index];\n      if (!func) {\n        func = null;\n      }\n      if (typeof func === 'function' || func === null) {\n        if (i < rules.length) {\n          ruleCallbacks[i] = func;\n        } else {\n          udtCallbacks[i - rules.length] = func;\n        }\n      } else {\n        throw new Error(\n          `${functionName}syntax callback[${index}] must be function reference or 'false' (false/null/undefined/etc.)`\n        );\n      }\n    }\n    /* make sure all udts have been defined - the parser can't work without them */\n    for (i = 0; i < udts.length; i += 1) {\n      if (udtCallbacks[i] === null) {\n        throw new Error(\n          `${functionName}all UDT callbacks must be defined. UDT callback[${udts[i].lower}] not a function reference`\n        );\n      }\n    }\n  };\n  // Set the maximum parse tree depth allowed. The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // depth - max allowed parse tree depth. An exception is thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxTreeDepth = function (depth) {\n    if (typeof depth !== 'number') {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n    limitTreeDepth = Math.floor(depth);\n    if (limitTreeDepth <= 0) {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n  };\n  // Set the maximum number of node hits (parser unit steps or opcode function calls) allowed.\n  // The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // hits - maximum number of node hits or parser unit steps allowed.\n  // An exception thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxNodeHits = function (hits) {\n    if (typeof hits !== 'number') {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n    limitNodeHits = Math.floor(hits);\n    if (limitNodeHits <= 0) {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n  };\n  /* the main parser function */\n  const privateParse = function (grammar, startRuleArg, callbackData) {\n    let success;\n    const functionName = `${thisFileName}parse(): `;\n    initializeGrammar(grammar);\n    const startRule = initializeStartRule(startRuleArg);\n    initializeCallbacks();\n    initializeTrace();\n    initializeStats();\n    initializeAst();\n    const sysData = new systemData();\n    if (!(callbackData === undefined || callbackData === null)) {\n      syntaxData = callbackData;\n    }\n    /* create a dummy opcode for the start rule */\n    opcodes = [\n      {\n        type: id.RNM,\n        index: startRule,\n      },\n    ];\n    /* execute the start rule */\n    opExecute(0, charsBegin, sysData);\n    opcodes = null;\n    /* test and return the sysData */\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${functionName}final state should never be 'ACTIVE'`);\n      case id.NOMATCH:\n        success = false;\n        break;\n      case id.EMPTY:\n      case id.MATCH:\n        if (sysData.phraseLength === charsLength) {\n          success = true;\n        } else {\n          success = false;\n        }\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    return {\n      success,\n      state: sysData.state,\n      length: charsLength,\n      matched: sysData.phraseLength,\n      maxMatched,\n      maxTreeDepth,\n      nodeHits,\n      inputLength: chars.length,\n      subBegin: charsBegin,\n      subEnd: charsEnd,\n      subLength: charsLength,\n    };\n  };\n\n  // This form allows parsing of a sub-string of the full input string.\n  // <ul>\n  // <li>*inputIndex* - index of the first character in the sub-string</li>\n  // <li>*inputLength* - length of the sub-string</li>\n  // </ul>\n  // All other parameters as for the above function `parse()`.\n  this.parseSubstring = function parseSubstring(grammar, startRule, inputChars, inputIndex, inputLength, callbackData) {\n    clear();\n    initializeInputChars(inputChars, inputIndex, inputLength);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // This is the main function, called to parse an input string.\n  // <ul>\n  // <li>*grammar* - an instantiated grammar object - the output of `apg` for a\n  // specific SABNF grammar</li>\n  // <li>*startRule* - the rule name or rule index to be used as the root of the\n  // parse tree. This is usually the first rule, index = 0, of the grammar\n  // but can be any rule defined in the above grammar object.</li>\n  // <li>*inputChars* - the input string. Can be a string or an array of integer character codes representing the\n  // string.</li>\n  // <li>*callbackData* - user-defined data object to be passed to the user's\n  // callback functions.\n  // This is not used by the parser in any way, merely passed on to the user.\n  // May be `null` or omitted.</li>\n  // </ul>\n  this.parse = function parse(grammar, startRule, inputChars, callbackData) {\n    clear();\n    initializeInputChars(inputChars, 0, inputChars.length);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // The `ALT` operator.<br>\n  // Executes its child nodes, from left to right, until it finds a match.\n  // Fails if *all* of its child nodes fail.\n  const opALT = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], phraseIndex, sysData);\n      if (sysData.state !== id.NOMATCH) {\n        break;\n      }\n    }\n  };\n  // The `CAT` operator.<br>\n  // Executes all of its child nodes, from left to right,\n  // concatenating the matched phrases.\n  // Fails if *any* child nodes fail.\n  const opCAT = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catPhrase;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catPhrase = 0;\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      } else {\n        catCharIndex += sysData.phraseLength;\n        catPhrase += sysData.phraseLength;\n      }\n    }\n    if (success) {\n      sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The `REP` operator.<br>\n  // Repeatedly executes its single child node,\n  // concatenating each of the matched phrases found.\n  // The number of repetitions executed and its final sysData depends\n  // on its `min` & `max` repetition values.\n  const opREP = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    if (op.max === 0) {\n      // this is an empty-string acceptor\n      // deprecated: use the TLS empty string operator, \"\", instead\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex >= charsEnd) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex += sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get them right\n  // but `RNM` fails if not.\n  const validateRnmCallbackResult = function (rule, sysData, charsLeft, down) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        if (down !== true) {\n          throw new Error(\n            `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`\n          );\n        }\n        break;\n      case id.EMPTY:\n        sysData.phraseLength = 0;\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          sysData.state = id.EMPTY;\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `RNM` operator.<br>\n  // This operator will acts as a root node for a parse tree branch below and\n  // returns the matched phrase to its parent.\n  // However, its larger responsibility is handling user-defined callback functions, back references and `AST` nodes.\n  // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.\n  // See [`ast.js`](./ast.html) for usage.\n  const opRNM = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astDefined;\n    let savedOpcodes;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const rule = rules[op.index];\n    const callback = ruleCallbacks[rule.index];\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back references */\n      astDefined = thisThis.ast && thisThis.ast.ruleDefined(op.index);\n      if (astDefined) {\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(op.index, rules[op.index].name);\n      }\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    if (callback === null) {\n      /* no callback - just execute the rule */\n      savedOpcodes = opcodes;\n      opcodes = rule.opcodes;\n      opExecute(0, phraseIndex, sysData);\n      opcodes = savedOpcodes;\n    } else {\n      /* call user's callback */\n      const charsLeft = charsEnd - phraseIndex;\n      sysData.ruleIndex = rule.index;\n      callback(sysData, chars, phraseIndex, syntaxData);\n      validateRnmCallbackResult(rule, sysData, charsLeft, true);\n      if (sysData.state === id.ACTIVE) {\n        savedOpcodes = opcodes;\n        opcodes = rule.opcodes;\n        opExecute(0, phraseIndex, sysData);\n        opcodes = savedOpcodes;\n        sysData.ruleIndex = rule.index;\n        callback(sysData, chars, phraseIndex, syntaxData);\n        validateRnmCallbackResult(rule, sysData, charsLeft, false);\n      } /* implied else clause: just accept the callback sysData - RNM acting as UDT */\n    }\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (rule.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get it right but `UDT` fails if not.\n  const validateUdtCallbackResult = function (udt, sysData, charsLeft) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. ACTIVE state not allowed.`);\n      case id.EMPTY:\n        if (udt.empty === false) {\n          throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n        } else {\n          sysData.phraseLength = 0;\n        }\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          if (udt.empty === false) {\n            throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n          } else {\n            sysData.state = id.EMPTY;\n          }\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `UDT` operator.<br>\n  // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`\n  // and back referencing.\n  // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules\n  // for `AST` nodes and back referencing.\n  // See [`ast.js`](./ast.html) for usage.\n  const opUDT = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astIndex;\n    let astDefined;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const udt = udts[op.index];\n    sysData.UdtIndex = udt.index;\n\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back reference */\n      astDefined = thisThis.ast && thisThis.ast.udtDefined(op.index);\n      if (astDefined) {\n        astIndex = rules.length + op.index;\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(astIndex, udt.name);\n      }\n      /* NOTE: push and pop of the back reference frame is normally not necessary */\n      /* only in the case that the UDT calls evaluateRule() or evaluateUdt() */\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    /* call the UDT */\n    const charsLeft = charsEnd - phraseIndex;\n    udtCallbacks[op.index](sysData, chars, phraseIndex, syntaxData);\n    validateUdtCallbackResult(udt, sysData, charsLeft);\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (udt.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // The `AND` operator.<br>\n  // This is the positive `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it succeedsand NOMATCH if it fails.\n  // *Always* backtracks on any matched phrase and returns EMPTY on success.\n  const opAND = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opAND: invalid state ${sysData.state}`);\n    }\n  };\n  // The `NOT` operator.<br>\n  // This is the negative `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it *fails* and NOMATCH if it succeeds.\n  // *Always* backtracks on any matched phrase and returns EMPTY\n  // on success (failure of its child node).\n  const opNOT = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opNOT: invalid state ${sysData.state}`);\n    }\n  };\n  // The `TRG` operator.<br>\n  // Succeeds if the single first character of the phrase is\n  // within the `min - max` range.\n  const opTRG = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (phraseIndex < charsEnd) {\n      if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The `TBS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // All characters must match exactly.\n  // Case-sensitive literal strings (`'string'` & `%s\"string\"`) are translated to `TBS`\n  // operators by `apg`.\n  // Phrase length of zero is not allowed.\n  // Empty phrases can only be defined with `TLS` operators.\n  const opTBS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    const len = op.string.length;\n    sysData.state = id.NOMATCH;\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[phraseIndex + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `TLS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // A case-insensitive match is attempted for ASCII alphbetical characters.\n  // `TLS` is the only operator that explicitly allows empty phrases.\n  // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or\n  // zero repetitions (`0*0RuleName` or `0RuleName`).\n  const opTLS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        code = chars[phraseIndex + i];\n        if (code >= 65 && code <= 90) {\n          code += 32;\n        }\n        if (code !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `ABG` operator.<br>\n  // This is an \"anchor\" for the beginning of the string, similar to the familiar regex `^` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` is 0, NOMATCH otherwise.\n  const opABG = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === 0 ? id.EMPTY : id.NOMATCH;\n  };\n  // The `AEN` operator.<br>\n  // This is an \"anchor\" for the end of the string, similar to the familiar regex `$` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` equals the input string length, NOMATCH otherwise.\n  const opAEN = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === chars.length ? id.EMPTY : id.NOMATCH;\n  };\n  // The `BKR` operator.<br>\n  // The back reference operator.\n  // Matches the last matched phrase of the named rule or UDT against the input string.\n  // For ASCII alphbetical characters the match may be case sensitive (`%s`) or insensitive (`%i`),\n  // depending on the back reference definition.\n  // For `universal` mode (`%u`) matches the last phrase found anywhere in the grammar.\n  // For `parent frame` mode (`%p`) matches the last phrase found in the parent rule only.\n  const opBKR = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The `BKA` operator.<br>\n  // This is the positive `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKA = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opBKA: invalid state ${sysData.state}`);\n    }\n  };\n  // The `BKN` operator.<br>\n  // This is the negative `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is *not* found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKN = function (opIndex, phraseIndex, sysData) {\n    // let op;\n    // op = opcodes[opIndex];\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opBKN: invalid state ${sysData.state}`);\n    }\n  };\n  // The right-to-left `CAT` operator.<br>\n  // Called for `CAT` operators when in look behind mode.\n  // Calls its child nodes from right to left concatenating matched phrases right to left.\n  const opCATBehind = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catMatched;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catMatched = 0;\n    // catPhrase = 0;\n    for (let i = op.children.length - 1; i >= 0; i -= 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      catCharIndex -= sysData.phraseLength;\n      catMatched += sysData.phraseLength;\n      // catPhrase += sysData.phraseLength;\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      }\n    }\n    if (success) {\n      sysData.state = catMatched === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catMatched;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `REP` operator.<br>\n  // Called for `REP` operators in look behind mode.\n  // Makes repeated calls to its child node, concatenating matched phrases right to left.\n  const opREPBehind = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex <= 0) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex -= sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `TRG` operator.<br>\n  // Called for `TRG` operators in look behind mode.\n  // Matches a single character at `phraseIndex - 1` to the `min` - `max` range.\n  const opTRGBehind = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (phraseIndex > 0) {\n      const char = chars[phraseIndex - 1];\n      if (op.min <= char && char <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The right-to-left `TBS` operator.<br>\n  // Called for `TBS` operators in look behind mode.\n  // Matches the `TBS` phrase to the left of `phraseIndex`.\n  const opTBSBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[beg + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left `TLS` operator.<br>\n  // Called for `TLS` operators in look behind mode.\n  // Matches the `TLS` phrase to the left of `phraseIndex`.\n  const opTLSBehind = function (opIndex, phraseIndex, sysData) {\n    let char;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (let i = 0; i < len; i += 1) {\n        char = chars[beg + i];\n        if (char >= 65 && char <= 90) {\n          char += 32;\n        }\n        if (char !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left back reference operator.<br>\n  // Matches the back referenced phrase to the left of `phraseIndex`.\n  const opBKRBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    /* NOMATCH default */\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // Generalized execution function.<br>\n  // Having a single, generalized function, allows a single location\n  // for tracing and statistics gathering functions to be called.\n  // Tracing and statistics are handled in separate objects.\n  // However, the parser calls their API to build the object data records.\n  // See [`trace.js`](./trace.html) and [`stats.js`](./stats.html) for their\n  // usage.\n  opExecute = function opExecuteFunc(opIndex, phraseIndex, sysData) {\n    let ret = true;\n    const op = opcodes[opIndex];\n    nodeHits += 1;\n    if (nodeHits > limitNodeHits) {\n      throw new Error(`parser: maximum number of node hits exceeded: ${limitNodeHits}`);\n    }\n    treeDepth += 1;\n    if (treeDepth > maxTreeDepth) {\n      maxTreeDepth = treeDepth;\n      if (maxTreeDepth > limitTreeDepth) {\n        throw new Error(`parser: maximum parse tree depth exceeded: ${limitTreeDepth}`);\n      }\n    }\n    sysData.refresh();\n    if (thisThis.trace !== null) {\n      /* collect the trace record for down the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.down(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    if (inLookBehind()) {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCATBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREPBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRGBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKRBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    } else {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCAT(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREP(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRG(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBS(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLS(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKR(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    }\n    if (!inLookAround() && phraseIndex + sysData.phraseLength > maxMatched) {\n      maxMatched = phraseIndex + sysData.phraseLength;\n    }\n    if (thisThis.stats !== null) {\n      /* collect the statistics */\n      thisThis.stats.collect(op, sysData);\n    }\n    if (thisThis.trace !== null) {\n      /* collect the trace record for up the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    treeDepth -= 1;\n    return ret;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsaUhBQWU7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsNkdBQWE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBLHlCQUF5QixhQUFhLGNBQWMsV0FBVztBQUMvRDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsZ0JBQWdCLGFBQWE7QUFDbkU7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBLHlCQUF5QixhQUFhLGFBQWEsVUFBVTtBQUM3RDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsZ0JBQWdCLGFBQWE7QUFDbkU7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsNkJBQTZCLE9BQU87QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZUFBZTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvcGFyc2VyLmpzP2M3YTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgZnVuYy1uYW1lcyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cbi8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cbi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBpcyB0aGUgcHJpbWFyeSBvYmplY3Qgb2YgYGFwZy1saWJgLiBDYWxsaW5nIGl0cyBgcGFyc2UoKWAgbWVtYmVyIGZ1bmN0aW9uXG4vLyB3YWxrcyB0aGUgcGFyc2UgdHJlZSBvZiBvcGNvZGVzLCBtYXRjaGluZyBwaHJhc2VzIGZyb20gdGhlIGlucHV0IHN0cmluZyBhcyBpdCBnb2VzLlxuLy8gVGhlIHdvcmtpbmcgY29kZSBmb3IgYWxsIG9mIHRoZSBvcGVyYXRvcnMsIGBBTFRgLCBgQ0FUYCwgZXRjLiBpcyBpbiB0aGlzIG1vZHVsZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VyKCkge1xuICBjb25zdCBpZCA9IHJlcXVpcmUoJy4vaWRlbnRpZmllcnMnKTtcbiAgY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxpdGllcycpO1xuXG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdwYXJzZXIuanM6ICc7XG4gIGNvbnN0IHRoaXNUaGlzID0gdGhpcztcbiAgbGV0IG9wRXhlY3V0ZTtcbiAgdGhpcy5hc3QgPSBudWxsO1xuICB0aGlzLnN0YXRzID0gbnVsbDtcbiAgdGhpcy50cmFjZSA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tzID0gW107XG4gIGxldCBvcGNvZGVzID0gbnVsbDtcbiAgbGV0IGNoYXJzID0gbnVsbDtcbiAgbGV0IGNoYXJzQmVnaW47XG4gIGxldCBjaGFyc0xlbmd0aDtcbiAgbGV0IGNoYXJzRW5kO1xuICBsZXQgbG9va0Fyb3VuZDtcbiAgbGV0IHRyZWVEZXB0aCA9IDA7XG4gIGxldCBtYXhUcmVlRGVwdGggPSAwO1xuICBsZXQgbm9kZUhpdHMgPSAwO1xuICBsZXQgcnVsZUNhbGxiYWNrcyA9IG51bGw7XG4gIGxldCB1ZHRDYWxsYmFja3MgPSBudWxsO1xuICBsZXQgcnVsZXMgPSBudWxsO1xuICBsZXQgdWR0cyA9IG51bGw7XG4gIGxldCBzeW50YXhEYXRhID0gbnVsbDtcbiAgbGV0IG1heE1hdGNoZWQgPSAwO1xuICBsZXQgbGltaXRUcmVlRGVwdGggPSBJbmZpbml0eTtcbiAgbGV0IGxpbWl0Tm9kZUhpdHMgPSBJbmZpbml0eTtcbiAgLy8gRXZhbHVhdGVzIGFueSBnaXZlbiBydWxlLiBUaGlzIGNhbiBiZSBjYWxsZWQgZnJvbSB0aGUgc3ludGF4IGNhbGxiYWNrXG4gIC8vIGZ1bmN0aW9ucyB0byBldmFsdWF0ZSBhbnkgcnVsZSBpbiB0aGUgZ3JhbW1hcidzIHJ1bGUgbGlzdC4gR3JlYXQgY2F1dGlvblxuICAvLyBzaG91bGQgYmUgdXNlZC4gVXNlIG9mIHRoaXMgZnVuY3Rpb24gd2lsbCBhbHRlciB0aGUgbGFuZ3VhZ2UgdGhhdCB0aGVcbiAgLy8gcGFyc2VyIGFjY2VwdHMuXG4gIGNvbnN0IGV2YWx1YXRlUnVsZSA9IGZ1bmN0aW9uIGV2YWx1YXRlUnVsZShydWxlSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWV2YWx1YXRlUnVsZSgpOiBgO1xuICAgIGlmIChydWxlSW5kZXggPj0gcnVsZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfXJ1bGUgaW5kZXg6ICR7cnVsZUluZGV4fSBvdXQgb2YgcmFuZ2VgKTtcbiAgICB9XG4gICAgaWYgKHBocmFzZUluZGV4ID49IGNoYXJzRW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfXBocmFzZSBpbmRleDogJHtwaHJhc2VJbmRleH0gb3V0IG9mIHJhbmdlYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBvcGNvZGVzO1xuICAgIG9wY29kZXMucHVzaCh7XG4gICAgICB0eXBlOiBpZC5STk0sXG4gICAgICBpbmRleDogcnVsZUluZGV4LFxuICAgIH0pO1xuICAgIG9wRXhlY3V0ZShsZW5ndGgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICBvcGNvZGVzLnBvcCgpO1xuICB9O1xuICAvLyBFdmFsdWF0ZXMgYW55IGdpdmVuIFVEVC4gVGhpcyBjYW4gYmUgY2FsbGVkIGZyb20gdGhlIHN5bnRheCBjYWxsYmFja1xuICAvLyBmdW5jdGlvbnMgdG8gZXZhbHVhdGUgYW55IFVEVCBpbiB0aGUgZ3JhbW1hcidzIFVEVCBsaXN0LiBHcmVhdCBjYXV0aW9uXG4gIC8vIHNob3VsZCBiZSB1c2VkLiBVc2Ugb2YgdGhpcyBmdW5jdGlvbiB3aWxsIGFsdGVyIHRoZSBsYW5ndWFnZSB0aGF0IHRoZVxuICAvLyBwYXJzZXIgYWNjZXB0cy5cbiAgY29uc3QgZXZhbHVhdGVVZHQgPSBmdW5jdGlvbiAodWR0SW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWV2YWx1YXRlVWR0KCk6IGA7XG4gICAgaWYgKHVkdEluZGV4ID49IHVkdHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfXVkdCBpbmRleDogJHt1ZHRJbmRleH0gb3V0IG9mIHJhbmdlYCk7XG4gICAgfVxuICAgIGlmIChwaHJhc2VJbmRleCA+PSBjaGFyc0VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1waHJhc2UgaW5kZXg6ICR7cGhyYXNlSW5kZXh9IG91dCBvZiByYW5nZWApO1xuICAgIH1cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gb3Bjb2RlcztcbiAgICBvcGNvZGVzLnB1c2goe1xuICAgICAgdHlwZTogaWQuVURULFxuICAgICAgZW1wdHk6IHVkdHNbdWR0SW5kZXhdLmVtcHR5LFxuICAgICAgaW5kZXg6IHVkdEluZGV4LFxuICAgIH0pO1xuICAgIG9wRXhlY3V0ZShsZW5ndGgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICBvcGNvZGVzLnBvcCgpO1xuICB9O1xuICAvKiBDbGVhcnMgdGhpcyBvYmplY3Qgb2YgYW55L2FsbCBkYXRhIHRoYXQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgb3IgYWRkZWQgdG8gaXQuICovXG4gIC8qIENhbGxlZCBieSBwYXJzZSgpIG9uIGluaXRpYWxpemF0aW9uLCBhbGxvd2luZyB0aGlzIG9iamVjdCB0byBiZSByZS11c2VkIGZvciBtdWx0aXBsZSBwYXJzaW5nIGNhbGxzLiAqL1xuICBjb25zdCBjbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cmVlRGVwdGggPSAwO1xuICAgIG1heFRyZWVEZXB0aCA9IDA7XG4gICAgbm9kZUhpdHMgPSAwO1xuICAgIG1heE1hdGNoZWQgPSAwO1xuICAgIGxvb2tBcm91bmQgPSBbXG4gICAgICB7XG4gICAgICAgIGxvb2tBcm91bmQ6IGlkLkxPT0tBUk9VTkRfTk9ORSxcbiAgICAgICAgYW5jaG9yOiAwLFxuICAgICAgICBjaGFyc0VuZDogMCxcbiAgICAgICAgY2hhcnNMZW5ndGg6IDAsXG4gICAgICB9LFxuICAgIF07XG4gICAgcnVsZXMgPSBudWxsO1xuICAgIHVkdHMgPSBudWxsO1xuICAgIGNoYXJzID0gbnVsbDtcbiAgICBjaGFyc0JlZ2luID0gMDtcbiAgICBjaGFyc0xlbmd0aCA9IDA7XG4gICAgY2hhcnNFbmQgPSAwO1xuICAgIHJ1bGVDYWxsYmFja3MgPSBudWxsO1xuICAgIHVkdENhbGxiYWNrcyA9IG51bGw7XG4gICAgc3ludGF4RGF0YSA9IG51bGw7XG4gICAgb3Bjb2RlcyA9IG51bGw7XG4gIH07XG4gIC8qIG9iamVjdCBmb3IgbWFpbnRhaW5pbmcgYSBzdGFjayBvZiBiYWNrIHJlZmVyZW5jZSBmcmFtZXMgKi9cbiAgY29uc3QgYmFja1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGNvbnN0IGluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgIHJ1bGVzLmZvckVhY2goKHJ1bGUpID0+IHtcbiAgICAgICAgaWYgKHJ1bGUuaXNCa3IpIHtcbiAgICAgICAgICBvYmpbcnVsZS5sb3dlcl0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdWR0cy5mb3JFYWNoKCh1ZHQpID0+IHtcbiAgICAgICAgICBpZiAodWR0LmlzQmtyKSB7XG4gICAgICAgICAgICBvYmpbdWR0Lmxvd2VyXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnB1c2gob2JqKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0b3AgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgLyogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdG9wKSB7XG4gICAgICAgIG9ialtuYW1lXSA9IHRvcFtuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbiBwdXNoKCkge1xuICAgICAgc3RhY2sucHVzaChjb3B5KCkpO1xuICAgIH07XG4gICAgdGhpcy5wb3AgPSBmdW5jdGlvbiBwb3AobGVuZ3RoQXJnKSB7XG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoQXJnO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPCAxIHx8IGxlbmd0aCA+IHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWJhY2tSZWYucG9wKCk6IGJhZCBsZW5ndGg6ICR7bGVuZ3RofWApO1xuICAgICAgfVxuICAgICAgc3RhY2subGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgdGhpcy5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gc3RhY2subGVuZ3RoO1xuICAgIH07XG4gICAgdGhpcy5zYXZlUGhyYXNlID0gZnVuY3Rpb24gc2F2ZVBocmFzZShuYW1lLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBzdGFja1tzdGFjay5sZW5ndGggLSAxXVtuYW1lXSA9IHtcbiAgICAgICAgcGhyYXNlSW5kZXg6IGluZGV4LFxuICAgICAgICBwaHJhc2VMZW5ndGg6IGxlbmd0aCxcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLmdldFBocmFzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1bbmFtZV07XG4gICAgfTtcbiAgICAvKiBjb25zdHJ1Y3RvciAqL1xuICAgIGluaXQoKTtcbiAgfTtcbiAgLy8gVGhlIHN5c3RlbSBkYXRhIHN0cnVjdHVyZSB0aGF0IHJlbGF5cyBzeXN0ZW0gaW5mb3JtYXRpb24gdG8gYW5kIGZyb20gdGhlIHJ1bGUgYW5kIFVEVCBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIC8vIC0gKnN0YXRlKiAtIHRoZSBzdGF0ZSBvZiB0aGUgcGFyc2VyLCBBQ1RJVkUsIE1BVENILCBFTVBUWSBvciBOT01BVENIIChzZWUgdGhlIGBpZGVudGlmaWVyc2Agb2JqZWN0IGluXG4gIC8vIFtgYXBnLWxpYmBdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMyLWxpYikpXG4gIC8vIC0gKnBocmFzZUxlbmd0aCogLSB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgbWF0Y2hlZCBpZiB0aGUgc3RhdGUgaXMgTUFUQ0hFRCBvciBFTVBUWVxuICAvLyAtICpsb29rYXJvdW5kKiAtIHRoZSB0b3Agb2YgdGhlIHN0YWNrIGhvbGRzIHRoZSBjdXJyZW50IGxvb2sgYXJvdW5kIHN0YXRlLFxuICAvLyBMT09LQVJPVU5EX05PTkUsIExPT0tBUk9VTkRfQUhFQUQgb3IgTE9PS0FST1VORF9CRUhJTkQsXG4gIC8vIC0gKnVGcmFtZSogLSB0aGUgXCJ1bml2ZXJzYWxcIiBiYWNrIHJlZmVyZW5jZSBmcmFtZS5cbiAgLy8gSG9sZHMgdGhlIGxhc3QgbWF0Y2hlZCBwaHJhc2UgZm9yIGVhY2ggb2YgdGhlIGJhY2sgcmVmZXJlbmNlZCBydWxlcyBhbmQgVURUcy5cbiAgLy8gLSAqcEZyYW1lKiAtIHRoZSBzdGFjayBvZiBcInBhcmVudFwiIGJhY2sgcmVmZXJlbmNlIGZyYW1lcy5cbiAgLy8gSG9sZHMgdGhlIG1hdGNoZWQgcGhyYXNlIGZyb20gdGhlIHBhcmVudCBmcmFtZSBvZiBlYWNoIGJhY2sgcmVmZXJlbmNlZCBydWxlcyBhbmQgVURUcy5cbiAgLy8gLSAqZXZhbHVhdGVSdWxlKiAtIGEgcmVmZXJlbmNlIHRvIHRoaXMgb2JqZWN0J3MgYGV2YWx1YXRlUnVsZSgpYCBmdW5jdGlvbi5cbiAgLy8gQ2FuIGJlIGNhbGxlZCBmcm9tIGEgY2FsbGJhY2sgZnVuY3Rpb24gKHVzZSB3aXRoIGV4dHJlbWUgY2F1dGlvbiEpXG4gIC8vIC0gKmV2YWx1YXRlVWR0KiAtIGEgcmVmZXJlbmNlIHRvIHRoaXMgb2JqZWN0J3MgYGV2YWx1YXRlVWR0KClgIGZ1bmN0aW9uLlxuICAvLyBDYW4gYmUgY2FsbGVkIGZyb20gYSBjYWxsYmFjayBmdW5jdGlvbiAodXNlIHdpdGggZXh0cmVtZSBjYXV0aW9uISlcbiAgY29uc3Qgc3lzdGVtRGF0YSA9IGZ1bmN0aW9uIHN5c3RlbURhdGEoKSB7XG4gICAgY29uc3QgdGhpc0RhdGEgPSB0aGlzO1xuICAgIHRoaXMuc3RhdGUgPSBpZC5BQ1RJVkU7XG4gICAgdGhpcy5waHJhc2VMZW5ndGggPSAwO1xuICAgIHRoaXMucnVsZUluZGV4ID0gMDtcbiAgICB0aGlzLnVkdEluZGV4ID0gMDtcbiAgICB0aGlzLmxvb2tBcm91bmQgPSBsb29rQXJvdW5kW2xvb2tBcm91bmQubGVuZ3RoIC0gMV07XG4gICAgdGhpcy51RnJhbWUgPSBuZXcgYmFja1JlZigpO1xuICAgIHRoaXMucEZyYW1lID0gbmV3IGJhY2tSZWYoKTtcbiAgICB0aGlzLmV2YWx1YXRlUnVsZSA9IGV2YWx1YXRlUnVsZTtcbiAgICB0aGlzLmV2YWx1YXRlVWR0ID0gZXZhbHVhdGVVZHQ7XG4gICAgLyogcmVmcmVzaCB0aGUgcGFyc2VyIHN0YXRlIGZvciB0aGUgbmV4dCBvcGVyYXRpb24gKi9cbiAgICB0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgdGhpc0RhdGEuc3RhdGUgPSBpZC5BQ1RJVkU7XG4gICAgICB0aGlzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgdGhpc0RhdGEubG9va0Fyb3VuZCA9IGxvb2tBcm91bmRbbG9va0Fyb3VuZC5sZW5ndGggLSAxXTtcbiAgICB9O1xuICB9O1xuICAvKiBzb21lIGxvb2sgYXJvdW5kIGhlbHBlciBmdW5jdGlvbnMgKi9cbiAgY29uc3QgbG9va0Fyb3VuZFZhbHVlID0gZnVuY3Rpb24gbG9va0Fyb3VuZFZhbHVlKCkge1xuICAgIHJldHVybiBsb29rQXJvdW5kW2xvb2tBcm91bmQubGVuZ3RoIC0gMV07XG4gIH07XG4gIC8qIHJldHVybiB0cnVlIGlmIHBhcnNlciBpcyBpbiBsb29rIGFyb3VuZCAoYWhlYWQgb3IgYmVoaW5kKSBzdGF0ZSAqL1xuICBjb25zdCBpbkxvb2tBcm91bmQgPSBmdW5jdGlvbiBpbkxvb2tBcm91bmQoKSB7XG4gICAgcmV0dXJuIGxvb2tBcm91bmQubGVuZ3RoID4gMTtcbiAgfTtcbiAgLyogcmV0dXJuIHRydWUgaWYgcGFyc2VyIGlzIGluIGxvb2sgYmVoaW5kIHN0YXRlICovXG4gIGNvbnN0IGluTG9va0JlaGluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9va0Fyb3VuZFtsb29rQXJvdW5kLmxlbmd0aCAtIDFdLmxvb2tBcm91bmQgPT09IGlkLkxPT0tBUk9VTkRfQkVISU5EO1xuICB9O1xuICAvKiBjYWxsZWQgYnkgcGFyc2UoKSB0byBpbml0aWFsaXplIHRoZSBBU1Qgb2JqZWN0LCBpZiBvbmUgaGFzIGJlZW4gZGVmaW5lZCAqL1xuICBjb25zdCBpbml0aWFsaXplQXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1pbml0aWFsaXplQXN0KCk6IGA7XG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIGlmICh0aGlzVGhpcy5hc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzVGhpcy5hc3QgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzVGhpcy5hc3QgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMuYXN0LmFzdE9iamVjdCAhPT0gJ2FzdE9iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1hc3Qgb2JqZWN0IG5vdCByZWNvZ25pemVkYCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXNUaGlzLmFzdCAhPT0gbnVsbCkge1xuICAgICAgdGhpc1RoaXMuYXN0LmluaXQocnVsZXMsIHVkdHMsIGNoYXJzKTtcbiAgICB9XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIHRyYWNlIG9iamVjdCwgaWYgb25lIGhhcyBiZWVuIGRlZmluZWQgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZVRyYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1pbml0aWFsaXplVHJhY2UoKTogYDtcbiAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgaWYgKHRoaXNUaGlzLnRyYWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpc1RoaXMudHJhY2UgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzVGhpcy50cmFjZSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzVGhpcy50cmFjZS50cmFjZU9iamVjdCAhPT0gJ3RyYWNlT2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfXRyYWNlIG9iamVjdCBub3QgcmVjb2duaXplZGApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzVGhpcy50cmFjZSAhPT0gbnVsbCkge1xuICAgICAgdGhpc1RoaXMudHJhY2UuaW5pdChydWxlcywgdWR0cywgY2hhcnMpO1xuICAgIH1cbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHBhcnNlKCkgdG8gaW5pdGlhbGl6ZSB0aGUgc3RhdGlzdGljcyBvYmplY3QsIGlmIG9uZSBoYXMgYmVlbiBkZWZpbmVkICovXG4gIGNvbnN0IGluaXRpYWxpemVTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZVN0YXRzKCk6IGA7XG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIGlmICh0aGlzVGhpcy5zdGF0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXNUaGlzLnN0YXRzID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMuc3RhdHMgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMuc3RhdHMuc3RhdHNPYmplY3QgIT09ICdzdGF0c09iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1zdGF0cyBvYmplY3Qgbm90IHJlY29nbml6ZWRgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpc1RoaXMuc3RhdHMgIT09IG51bGwpIHtcbiAgICAgIHRoaXNUaGlzLnN0YXRzLmluaXQocnVsZXMsIHVkdHMpO1xuICAgIH1cbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHBhcnNlKCkgdG8gaW5pdGlhbGl6ZSB0aGUgcnVsZXMgJiB1ZHRzIGZyb20gdGhlIGdyYW1tYXIgb2JqZWN0ICovXG4gIC8qICh0aGUgZ3JhbW1hciBvYmplY3QgZ2VuZXJhdGVkIHByZXZpb3VzbHkgYnkgYXBnKSAqL1xuICBjb25zdCBpbml0aWFsaXplR3JhbW1hciA9IGZ1bmN0aW9uIChncmFtbWFyKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWluaXRpYWxpemVHcmFtbWFyKCk6IGA7XG4gICAgaWYgKCFncmFtbWFyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWdyYW1tYXIgb2JqZWN0IHVuZGVmaW5lZGApO1xuICAgIH1cbiAgICBpZiAoZ3JhbW1hci5ncmFtbWFyT2JqZWN0ICE9PSAnZ3JhbW1hck9iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9YmFkIGdyYW1tYXIgb2JqZWN0YCk7XG4gICAgfVxuICAgIHJ1bGVzID0gZ3JhbW1hci5ydWxlcztcbiAgICB1ZHRzID0gZ3JhbW1hci51ZHRzO1xuICB9O1xuICAvKiBjYWxsZWQgYnkgcGFyc2UoKSB0byBpbml0aWFsaXplIHRoZSBzdGFydCBydWxlICovXG4gIGNvbnN0IGluaXRpYWxpemVTdGFydFJ1bGUgPSBmdW5jdGlvbiAoc3RhcnRSdWxlKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWluaXRpYWxpemVTdGFydFJ1bGUoKTogYDtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIGlmICh0eXBlb2Ygc3RhcnRSdWxlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHN0YXJ0UnVsZSA+PSBydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1zdGFydCBydWxlIGluZGV4IHRvbyBsYXJnZTogbWF4OiAke3J1bGVzLmxlbmd0aH06IGluZGV4OiAke3N0YXJ0UnVsZX1gKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnRSdWxlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0YXJ0UnVsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGxvd2VyID0gc3RhcnRSdWxlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChsb3dlciA9PT0gcnVsZXNbaV0ubG93ZXIpIHtcbiAgICAgICAgICBzdGFydCA9IHJ1bGVzW2ldLmluZGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1zdGFydCBydWxlIG5hbWUgJyR7c3RhcnRSdWxlfScgbm90IHJlY29nbml6ZWRgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX10eXBlIG9mIHN0YXJ0IHJ1bGUgJyR7dHlwZW9mIHN0YXJ0UnVsZX0nIG5vdCByZWNvZ25pemVkYCk7XG4gICAgfVxuICAgIHJldHVybiBzdGFydDtcbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHBhcnNlKCkgdG8gaW5pdGlhbGl6ZSB0aGUgYXJyYXkgb2YgY2hhcmFjdGVycyBjb2RlcyByZXByZXNlbnRpbmcgdGhlIGlucHV0IHN0cmluZyAqL1xuICBjb25zdCBpbml0aWFsaXplSW5wdXRDaGFycyA9IGZ1bmN0aW9uIGluaXRpYWxpemVJbnB1dENoYXJzKGlucHV0QXJnLCBiZWdBcmcsIGxlbkFyZykge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1pbml0aWFsaXplSW5wdXRDaGFycygpOiBgO1xuICAgIC8qIHZhcmlmeSBhbmQgbm9ybWFsaXplIGlucHV0ICovXG4gICAgbGV0IGlucHV0ID0gaW5wdXRBcmc7XG4gICAgbGV0IGJlZyA9IGJlZ0FyZztcbiAgICBsZXQgbGVuID0gbGVuQXJnO1xuICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWlucHV0IHN0cmluZyBpcyB1bmRlZmluZWRgKTtcbiAgICB9XG4gICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWlucHV0IHN0cmluZyBpcyBudWxsYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnB1dCA9IHV0aWxzLnN0cmluZ1RvQ2hhcnMoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWlucHV0IHN0cmluZyBpcyBub3QgYSBzdHJpbmcgb3IgYXJyYXlgKTtcbiAgICB9XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXRbMF0gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9aW5wdXQgc3RyaW5nIG5vdCBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiB2ZXJpZnkgYW5kIG5vcm1hbGl6ZSBiZWdpbm5pbmcgaW5kZXggKi9cbiAgICBpZiAodHlwZW9mIGJlZyAhPT0gJ251bWJlcicpIHtcbiAgICAgIGJlZyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJlZyA9IE1hdGguZmxvb3IoYmVnKTtcbiAgICAgIGlmIChiZWcgPCAwIHx8IGJlZyA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWlucHV0IGJlZ2lubmluZyBpbmRleCBvdXQgb2YgcmFuZ2U6ICR7YmVnfWApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiB2ZXJpZnkgYW5kIG5vcm1hbGl6ZSBpbnB1dCBsZW5ndGggKi9cbiAgICBpZiAodHlwZW9mIGxlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgIGxlbiA9IGlucHV0Lmxlbmd0aCAtIGJlZztcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuID0gTWF0aC5mbG9vcihsZW4pO1xuICAgICAgaWYgKGxlbiA8IDAgfHwgbGVuID4gaW5wdXQubGVuZ3RoIC0gYmVnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9aW5wdXQgbGVuZ3RoIG91dCBvZiByYW5nZTogJHtsZW59YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoYXJzID0gaW5wdXQ7XG4gICAgY2hhcnNCZWdpbiA9IGJlZztcbiAgICBjaGFyc0xlbmd0aCA9IGxlbjtcbiAgICBjaGFyc0VuZCA9IGNoYXJzQmVnaW4gKyBjaGFyc0xlbmd0aDtcbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHBhcnNlKCkgdG8gaW5pdGlhbGl6ZSB0aGUgdXNlci13cml0dGVuLCBzeW50YXggY2FsbGJhY2sgZnVuY3Rpb25zLCBpZiBhbnkgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZUNhbGxiYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZUNhbGxiYWNrcygpOiBgO1xuICAgIGxldCBpO1xuICAgIHJ1bGVDYWxsYmFja3MgPSBbXTtcbiAgICB1ZHRDYWxsYmFja3MgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHJ1bGVDYWxsYmFja3NbaV0gPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdWR0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdWR0Q2FsbGJhY2tzW2ldID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IGZ1bmM7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGlzdC5wdXNoKHJ1bGVzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaCh1ZHRzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpbmRleCBpbiB0aGlzVGhpcy5jYWxsYmFja3MpIHtcbiAgICAgIGkgPSBsaXN0LmluZGV4T2YoaW5kZXgudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1zeW50YXggY2FsbGJhY2sgJyR7aW5kZXh9JyBub3QgYSBydWxlIG9yIHVkdCBuYW1lYCk7XG4gICAgICB9XG4gICAgICBmdW5jID0gdGhpc1RoaXMuY2FsbGJhY2tzW2luZGV4XTtcbiAgICAgIGlmICghZnVuYykge1xuICAgICAgICBmdW5jID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJyB8fCBmdW5jID09PSBudWxsKSB7XG4gICAgICAgIGlmIChpIDwgcnVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcnVsZUNhbGxiYWNrc1tpXSA9IGZ1bmM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdWR0Q2FsbGJhY2tzW2kgLSBydWxlcy5sZW5ndGhdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2Z1bmN0aW9uTmFtZX1zeW50YXggY2FsbGJhY2tbJHtpbmRleH1dIG11c3QgYmUgZnVuY3Rpb24gcmVmZXJlbmNlIG9yICdmYWxzZScgKGZhbHNlL251bGwvdW5kZWZpbmVkL2V0Yy4pYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBtYWtlIHN1cmUgYWxsIHVkdHMgaGF2ZSBiZWVuIGRlZmluZWQgLSB0aGUgcGFyc2VyIGNhbid0IHdvcmsgd2l0aG91dCB0aGVtICovXG4gICAgZm9yIChpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICh1ZHRDYWxsYmFja3NbaV0gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2Z1bmN0aW9uTmFtZX1hbGwgVURUIGNhbGxiYWNrcyBtdXN0IGJlIGRlZmluZWQuIFVEVCBjYWxsYmFja1ske3VkdHNbaV0ubG93ZXJ9XSBub3QgYSBmdW5jdGlvbiByZWZlcmVuY2VgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBTZXQgdGhlIG1heGltdW0gcGFyc2UgdHJlZSBkZXB0aCBhbGxvd2VkLiBUaGUgZGVmYXVsdCBpcyBgSW5maW5pdHlgLlxuICAvLyBBIGxpbWl0IGlzIG5vdCBub3JtYWxseSBuZWVkZWQsIGJ1dCBjYW4gYmUgdXNlZCB0byBwcm90ZWN0IGFnYWluc3QgYW5cbiAgLy8gZXhwb25lbnR1YWwgb3IgXCJjYXRhc3Ryb3BoaWNhbGx5IGJhY2t0cmFja2luZ1wiIGdyYW1tYXIuXG4gIC8vIDx1bD5cbiAgLy8gPGxpPlxuICAvLyBkZXB0aCAtIG1heCBhbGxvd2VkIHBhcnNlIHRyZWUgZGVwdGguIEFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgZXhjZWVkZWQuXG4gIC8vIDwvbGk+XG4gIC8vIDwvdWw+XG4gIHRoaXMuc2V0TWF4VHJlZURlcHRoID0gZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgaWYgKHR5cGVvZiBkZXB0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyc2VyOiBtYXggdHJlZSBkZXB0aCBtdXN0IGJlIGludGVnZXIgPiAwOiAke2RlcHRofWApO1xuICAgIH1cbiAgICBsaW1pdFRyZWVEZXB0aCA9IE1hdGguZmxvb3IoZGVwdGgpO1xuICAgIGlmIChsaW1pdFRyZWVEZXB0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlcjogbWF4IHRyZWUgZGVwdGggbXVzdCBiZSBpbnRlZ2VyID4gMDogJHtkZXB0aH1gKTtcbiAgICB9XG4gIH07XG4gIC8vIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygbm9kZSBoaXRzIChwYXJzZXIgdW5pdCBzdGVwcyBvciBvcGNvZGUgZnVuY3Rpb24gY2FsbHMpIGFsbG93ZWQuXG4gIC8vIFRoZSBkZWZhdWx0IGlzIGBJbmZpbml0eWAuXG4gIC8vIEEgbGltaXQgaXMgbm90IG5vcm1hbGx5IG5lZWRlZCwgYnV0IGNhbiBiZSB1c2VkIHRvIHByb3RlY3QgYWdhaW5zdCBhblxuICAvLyBleHBvbmVudHVhbCBvciBcImNhdGFzdHJvcGhpY2FsbHkgYmFja3RyYWNraW5nXCIgZ3JhbW1hci5cbiAgLy8gPHVsPlxuICAvLyA8bGk+XG4gIC8vIGhpdHMgLSBtYXhpbXVtIG51bWJlciBvZiBub2RlIGhpdHMgb3IgcGFyc2VyIHVuaXQgc3RlcHMgYWxsb3dlZC5cbiAgLy8gQW4gZXhjZXB0aW9uIHRocm93biBpZiBleGNlZWRlZC5cbiAgLy8gPC9saT5cbiAgLy8gPC91bD5cbiAgdGhpcy5zZXRNYXhOb2RlSGl0cyA9IGZ1bmN0aW9uIChoaXRzKSB7XG4gICAgaWYgKHR5cGVvZiBoaXRzICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heCBub2RlIGhpdHMgbXVzdCBiZSBpbnRlZ2VyID4gMDogJHtoaXRzfWApO1xuICAgIH1cbiAgICBsaW1pdE5vZGVIaXRzID0gTWF0aC5mbG9vcihoaXRzKTtcbiAgICBpZiAobGltaXROb2RlSGl0cyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlcjogbWF4IG5vZGUgaGl0cyBtdXN0IGJlIGludGVnZXIgPiAwOiAke2hpdHN9YCk7XG4gICAgfVxuICB9O1xuICAvKiB0aGUgbWFpbiBwYXJzZXIgZnVuY3Rpb24gKi9cbiAgY29uc3QgcHJpdmF0ZVBhcnNlID0gZnVuY3Rpb24gKGdyYW1tYXIsIHN0YXJ0UnVsZUFyZywgY2FsbGJhY2tEYXRhKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfXBhcnNlKCk6IGA7XG4gICAgaW5pdGlhbGl6ZUdyYW1tYXIoZ3JhbW1hcik7XG4gICAgY29uc3Qgc3RhcnRSdWxlID0gaW5pdGlhbGl6ZVN0YXJ0UnVsZShzdGFydFJ1bGVBcmcpO1xuICAgIGluaXRpYWxpemVDYWxsYmFja3MoKTtcbiAgICBpbml0aWFsaXplVHJhY2UoKTtcbiAgICBpbml0aWFsaXplU3RhdHMoKTtcbiAgICBpbml0aWFsaXplQXN0KCk7XG4gICAgY29uc3Qgc3lzRGF0YSA9IG5ldyBzeXN0ZW1EYXRhKCk7XG4gICAgaWYgKCEoY2FsbGJhY2tEYXRhID09PSB1bmRlZmluZWQgfHwgY2FsbGJhY2tEYXRhID09PSBudWxsKSkge1xuICAgICAgc3ludGF4RGF0YSA9IGNhbGxiYWNrRGF0YTtcbiAgICB9XG4gICAgLyogY3JlYXRlIGEgZHVtbXkgb3Bjb2RlIGZvciB0aGUgc3RhcnQgcnVsZSAqL1xuICAgIG9wY29kZXMgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IGlkLlJOTSxcbiAgICAgICAgaW5kZXg6IHN0YXJ0UnVsZSxcbiAgICAgIH0sXG4gICAgXTtcbiAgICAvKiBleGVjdXRlIHRoZSBzdGFydCBydWxlICovXG4gICAgb3BFeGVjdXRlKDAsIGNoYXJzQmVnaW4sIHN5c0RhdGEpO1xuICAgIG9wY29kZXMgPSBudWxsO1xuICAgIC8qIHRlc3QgYW5kIHJldHVybiB0aGUgc3lzRGF0YSAqL1xuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9ZmluYWwgc3RhdGUgc2hvdWxkIG5ldmVyIGJlICdBQ1RJVkUnYCk7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKHN5c0RhdGEucGhyYXNlTGVuZ3RoID09PSBjaGFyc0xlbmd0aCkge1xuICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHN0YXRlJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzLFxuICAgICAgc3RhdGU6IHN5c0RhdGEuc3RhdGUsXG4gICAgICBsZW5ndGg6IGNoYXJzTGVuZ3RoLFxuICAgICAgbWF0Y2hlZDogc3lzRGF0YS5waHJhc2VMZW5ndGgsXG4gICAgICBtYXhNYXRjaGVkLFxuICAgICAgbWF4VHJlZURlcHRoLFxuICAgICAgbm9kZUhpdHMsXG4gICAgICBpbnB1dExlbmd0aDogY2hhcnMubGVuZ3RoLFxuICAgICAgc3ViQmVnaW46IGNoYXJzQmVnaW4sXG4gICAgICBzdWJFbmQ6IGNoYXJzRW5kLFxuICAgICAgc3ViTGVuZ3RoOiBjaGFyc0xlbmd0aCxcbiAgICB9O1xuICB9O1xuXG4gIC8vIFRoaXMgZm9ybSBhbGxvd3MgcGFyc2luZyBvZiBhIHN1Yi1zdHJpbmcgb2YgdGhlIGZ1bGwgaW5wdXQgc3RyaW5nLlxuICAvLyA8dWw+XG4gIC8vIDxsaT4qaW5wdXRJbmRleCogLSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBzdWItc3RyaW5nPC9saT5cbiAgLy8gPGxpPippbnB1dExlbmd0aCogLSBsZW5ndGggb2YgdGhlIHN1Yi1zdHJpbmc8L2xpPlxuICAvLyA8L3VsPlxuICAvLyBBbGwgb3RoZXIgcGFyYW1ldGVycyBhcyBmb3IgdGhlIGFib3ZlIGZ1bmN0aW9uIGBwYXJzZSgpYC5cbiAgdGhpcy5wYXJzZVN1YnN0cmluZyA9IGZ1bmN0aW9uIHBhcnNlU3Vic3RyaW5nKGdyYW1tYXIsIHN0YXJ0UnVsZSwgaW5wdXRDaGFycywgaW5wdXRJbmRleCwgaW5wdXRMZW5ndGgsIGNhbGxiYWNrRGF0YSkge1xuICAgIGNsZWFyKCk7XG4gICAgaW5pdGlhbGl6ZUlucHV0Q2hhcnMoaW5wdXRDaGFycywgaW5wdXRJbmRleCwgaW5wdXRMZW5ndGgpO1xuICAgIHJldHVybiBwcml2YXRlUGFyc2UoZ3JhbW1hciwgc3RhcnRSdWxlLCBjYWxsYmFja0RhdGEpO1xuICB9O1xuICAvLyBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uLCBjYWxsZWQgdG8gcGFyc2UgYW4gaW5wdXQgc3RyaW5nLlxuICAvLyA8dWw+XG4gIC8vIDxsaT4qZ3JhbW1hciogLSBhbiBpbnN0YW50aWF0ZWQgZ3JhbW1hciBvYmplY3QgLSB0aGUgb3V0cHV0IG9mIGBhcGdgIGZvciBhXG4gIC8vIHNwZWNpZmljIFNBQk5GIGdyYW1tYXI8L2xpPlxuICAvLyA8bGk+KnN0YXJ0UnVsZSogLSB0aGUgcnVsZSBuYW1lIG9yIHJ1bGUgaW5kZXggdG8gYmUgdXNlZCBhcyB0aGUgcm9vdCBvZiB0aGVcbiAgLy8gcGFyc2UgdHJlZS4gVGhpcyBpcyB1c3VhbGx5IHRoZSBmaXJzdCBydWxlLCBpbmRleCA9IDAsIG9mIHRoZSBncmFtbWFyXG4gIC8vIGJ1dCBjYW4gYmUgYW55IHJ1bGUgZGVmaW5lZCBpbiB0aGUgYWJvdmUgZ3JhbW1hciBvYmplY3QuPC9saT5cbiAgLy8gPGxpPippbnB1dENoYXJzKiAtIHRoZSBpbnB1dCBzdHJpbmcuIENhbiBiZSBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBpbnRlZ2VyIGNoYXJhY3RlciBjb2RlcyByZXByZXNlbnRpbmcgdGhlXG4gIC8vIHN0cmluZy48L2xpPlxuICAvLyA8bGk+KmNhbGxiYWNrRGF0YSogLSB1c2VyLWRlZmluZWQgZGF0YSBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIHRoZSB1c2VyJ3NcbiAgLy8gY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAvLyBUaGlzIGlzIG5vdCB1c2VkIGJ5IHRoZSBwYXJzZXIgaW4gYW55IHdheSwgbWVyZWx5IHBhc3NlZCBvbiB0byB0aGUgdXNlci5cbiAgLy8gTWF5IGJlIGBudWxsYCBvciBvbWl0dGVkLjwvbGk+XG4gIC8vIDwvdWw+XG4gIHRoaXMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShncmFtbWFyLCBzdGFydFJ1bGUsIGlucHV0Q2hhcnMsIGNhbGxiYWNrRGF0YSkge1xuICAgIGNsZWFyKCk7XG4gICAgaW5pdGlhbGl6ZUlucHV0Q2hhcnMoaW5wdXRDaGFycywgMCwgaW5wdXRDaGFycy5sZW5ndGgpO1xuICAgIHJldHVybiBwcml2YXRlUGFyc2UoZ3JhbW1hciwgc3RhcnRSdWxlLCBjYWxsYmFja0RhdGEpO1xuICB9O1xuICAvLyBUaGUgYEFMVGAgb3BlcmF0b3IuPGJyPlxuICAvLyBFeGVjdXRlcyBpdHMgY2hpbGQgbm9kZXMsIGZyb20gbGVmdCB0byByaWdodCwgdW50aWwgaXQgZmluZHMgYSBtYXRjaC5cbiAgLy8gRmFpbHMgaWYgKmFsbCogb2YgaXRzIGNoaWxkIG5vZGVzIGZhaWwuXG4gIGNvbnN0IG9wQUxUID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3AuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG9wRXhlY3V0ZShvcC5jaGlsZHJlbltpXSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgIT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYENBVGAgb3BlcmF0b3IuPGJyPlxuICAvLyBFeGVjdXRlcyBhbGwgb2YgaXRzIGNoaWxkIG5vZGVzLCBmcm9tIGxlZnQgdG8gcmlnaHQsXG4gIC8vIGNvbmNhdGVuYXRpbmcgdGhlIG1hdGNoZWQgcGhyYXNlcy5cbiAgLy8gRmFpbHMgaWYgKmFueSogY2hpbGQgbm9kZXMgZmFpbC5cbiAgY29uc3Qgb3BDQVQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgc3VjY2VzcztcbiAgICBsZXQgYXN0TGVuZ3RoO1xuICAgIGxldCBjYXRDaGFySW5kZXg7XG4gICAgbGV0IGNhdFBocmFzZTtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgY29uc3QgdWxlbiA9IHN5c0RhdGEudUZyYW1lLmxlbmd0aCgpO1xuICAgIGNvbnN0IHBsZW4gPSBzeXNEYXRhLnBGcmFtZS5sZW5ndGgoKTtcbiAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICBhc3RMZW5ndGggPSB0aGlzVGhpcy5hc3QuZ2V0TGVuZ3RoKCk7XG4gICAgfVxuICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgIGNhdENoYXJJbmRleCA9IHBocmFzZUluZGV4O1xuICAgIGNhdFBocmFzZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgb3BFeGVjdXRlKG9wLmNoaWxkcmVuW2ldLCBjYXRDaGFySW5kZXgsIHN5c0RhdGEpO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhdENoYXJJbmRleCArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgICAgY2F0UGhyYXNlICs9IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGNhdFBocmFzZSA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGNhdFBocmFzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICAvKiByZXNldCB0aGUgYmFjayByZWZlcmVuY2luZyBmcmFtZXMgb24gZmFpbHVyZSAqL1xuICAgICAgc3lzRGF0YS51RnJhbWUucG9wKHVsZW4pO1xuICAgICAgc3lzRGF0YS5wRnJhbWUucG9wKHBsZW4pO1xuICAgICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgICB0aGlzVGhpcy5hc3Quc2V0TGVuZ3RoKGFzdExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYFJFUGAgb3BlcmF0b3IuPGJyPlxuICAvLyBSZXBlYXRlZGx5IGV4ZWN1dGVzIGl0cyBzaW5nbGUgY2hpbGQgbm9kZSxcbiAgLy8gY29uY2F0ZW5hdGluZyBlYWNoIG9mIHRoZSBtYXRjaGVkIHBocmFzZXMgZm91bmQuXG4gIC8vIFRoZSBudW1iZXIgb2YgcmVwZXRpdGlvbnMgZXhlY3V0ZWQgYW5kIGl0cyBmaW5hbCBzeXNEYXRhIGRlcGVuZHNcbiAgLy8gb24gaXRzIGBtaW5gICYgYG1heGAgcmVwZXRpdGlvbiB2YWx1ZXMuXG4gIGNvbnN0IG9wUkVQID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGFzdExlbmd0aDtcbiAgICBsZXQgcmVwQ2hhckluZGV4O1xuICAgIGxldCByZXBQaHJhc2U7XG4gICAgbGV0IHJlcENvdW50O1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBpZiAob3AubWF4ID09PSAwKSB7XG4gICAgICAvLyB0aGlzIGlzIGFuIGVtcHR5LXN0cmluZyBhY2NlcHRvclxuICAgICAgLy8gZGVwcmVjYXRlZDogdXNlIHRoZSBUTFMgZW1wdHkgc3RyaW5nIG9wZXJhdG9yLCBcIlwiLCBpbnN0ZWFkXG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlcENoYXJJbmRleCA9IHBocmFzZUluZGV4O1xuICAgIHJlcFBocmFzZSA9IDA7XG4gICAgcmVwQ291bnQgPSAwO1xuICAgIGNvbnN0IHVsZW4gPSBzeXNEYXRhLnVGcmFtZS5sZW5ndGgoKTtcbiAgICBjb25zdCBwbGVuID0gc3lzRGF0YS5wRnJhbWUubGVuZ3RoKCk7XG4gICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgYXN0TGVuZ3RoID0gdGhpc1RoaXMuYXN0LmdldExlbmd0aCgpO1xuICAgIH1cbiAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgaWYgKHJlcENoYXJJbmRleCA+PSBjaGFyc0VuZCkge1xuICAgICAgICAvKiBleGl0IG9uIGVuZCBvZiBpbnB1dCBzdHJpbmcgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvcEV4ZWN1dGUob3BJbmRleCArIDEsIHJlcENoYXJJbmRleCwgc3lzRGF0YSk7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICAvKiBhbHdheXMgZW5kIGlmIHRoZSBjaGlsZCBub2RlIGZhaWxzICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLkVNUFRZKSB7XG4gICAgICAgIC8qIFJFUCBhbHdheXMgc3VjY2VlZHMgd2hlbiB0aGUgY2hpbGQgbm9kZSByZXR1cm5zIGFuIGVtcHR5IHBocmFzZSAqL1xuICAgICAgICAvKiB0aGlzIG1heSBub3Qgc2VlbSBvYnZpb3VzLCBidXQgdGhhdCdzIHRoZSB3YXkgaXQgd29ya3Mgb3V0ICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVwQ291bnQgKz0gMTtcbiAgICAgIHJlcFBocmFzZSArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIHJlcENoYXJJbmRleCArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIGlmIChyZXBDb3VudCA9PT0gb3AubWF4KSB7XG4gICAgICAgIC8qIGVuZCBvbiBtYXhlZCBvdXQgcmVwcyAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLyogZXZhbHVhdGUgdGhlIG1hdGNoIGNvdW50IGFjY29yZGluZyB0byB0aGUgbWluLCBtYXggdmFsdWVzICovXG4gICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLkVNUFRZKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gcmVwUGhyYXNlID09PSAwID8gaWQuRU1QVFkgOiBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gcmVwUGhyYXNlO1xuICAgIH0gZWxzZSBpZiAocmVwQ291bnQgPj0gb3AubWluKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gcmVwUGhyYXNlID09PSAwID8gaWQuRU1QVFkgOiBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gcmVwUGhyYXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgIC8qIHJlc2V0IHRoZSBiYWNrIHJlZmVyZW5jaW5nIGZyYW1lcyBvbiBmYWlsdXJlICovXG4gICAgICBzeXNEYXRhLnVGcmFtZS5wb3AodWxlbik7XG4gICAgICBzeXNEYXRhLnBGcmFtZS5wb3AocGxlbik7XG4gICAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICAgIHRoaXNUaGlzLmFzdC5zZXRMZW5ndGgoYXN0TGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFZhbGlkYXRlIHRoZSBjYWxsYmFjayBmdW5jdGlvbidzIHJldHVybmVkIHN5c0RhdGEgdmFsdWVzLlxuICAvLyBJdCdzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gZ2V0IHRoZW0gcmlnaHRcbiAgLy8gYnV0IGBSTk1gIGZhaWxzIGlmIG5vdC5cbiAgY29uc3QgdmFsaWRhdGVSbm1DYWxsYmFja1Jlc3VsdCA9IGZ1bmN0aW9uIChydWxlLCBzeXNEYXRhLCBjaGFyc0xlZnQsIGRvd24pIHtcbiAgICBpZiAoc3lzRGF0YS5waHJhc2VMZW5ndGggPiBjaGFyc0xlZnQpIHtcbiAgICAgIGxldCBzdHIgPSBgJHt0aGlzRmlsZU5hbWV9b3BSTk0oJHtydWxlLm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gZXJyb3I6IGA7XG4gICAgICBzdHIgKz0gYHN5c0RhdGEucGhyYXNlTGVuZ3RoOiAke3N5c0RhdGEucGhyYXNlTGVuZ3RofWA7XG4gICAgICBzdHIgKz0gYCBtdXN0IGJlIDw9IHJlbWFpbmluZyBjaGFyczogJHtjaGFyc0xlZnR9YDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN5c0RhdGEuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBpZiAoZG93biAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGAke3RoaXNGaWxlTmFtZX1vcFJOTSgke3J1bGUubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm4gZXJyb3IuIEFDVElWRSBzdGF0ZSBub3QgYWxsb3dlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoc3lzRGF0YS5waHJhc2VMZW5ndGggPT09IDApIHtcbiAgICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7dGhpc0ZpbGVOYW1lfW9wUk5NKCR7cnVsZS5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybiBlcnJvci4gVW5yZWNvZ25pemVkIHJldHVybiBzdGF0ZTogJHtzeXNEYXRhLnN0YXRlfWBcbiAgICAgICAgKTtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgUk5NYCBvcGVyYXRvci48YnI+XG4gIC8vIFRoaXMgb3BlcmF0b3Igd2lsbCBhY3RzIGFzIGEgcm9vdCBub2RlIGZvciBhIHBhcnNlIHRyZWUgYnJhbmNoIGJlbG93IGFuZFxuICAvLyByZXR1cm5zIHRoZSBtYXRjaGVkIHBocmFzZSB0byBpdHMgcGFyZW50LlxuICAvLyBIb3dldmVyLCBpdHMgbGFyZ2VyIHJlc3BvbnNpYmlsaXR5IGlzIGhhbmRsaW5nIHVzZXItZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbnMsIGJhY2sgcmVmZXJlbmNlcyBhbmQgYEFTVGAgbm9kZXMuXG4gIC8vIE5vdGUgdGhhdCB0aGUgYEFTVGAgaXMgYSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBgUk5NYCBjYWxscyBpdHMgZnVuY3Rpb25zIHRvIGNyZWF0ZSBpdHMgbm9kZXMuXG4gIC8vIFNlZSBbYGFzdC5qc2BdKC4vYXN0Lmh0bWwpIGZvciB1c2FnZS5cbiAgY29uc3Qgb3BSTk0gPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgYXN0TGVuZ3RoO1xuICAgIGxldCBhc3REZWZpbmVkO1xuICAgIGxldCBzYXZlZE9wY29kZXM7XG4gICAgbGV0IHVsZW47XG4gICAgbGV0IHBsZW47XG4gICAgbGV0IHNhdmVGcmFtZTtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgY29uc3QgcnVsZSA9IHJ1bGVzW29wLmluZGV4XTtcbiAgICBjb25zdCBjYWxsYmFjayA9IHJ1bGVDYWxsYmFja3NbcnVsZS5pbmRleF07XG4gICAgY29uc3Qgbm90TG9va0Fyb3VuZCA9ICFpbkxvb2tBcm91bmQoKTtcbiAgICAvKiBpZ25vcmUgQVNUIGFuZCBiYWNrIHJlZmVyZW5jZXMgaW4gbG9va2Fyb3VuZCAqL1xuICAgIGlmIChub3RMb29rQXJvdW5kKSB7XG4gICAgICAvKiBiZWdpbiBBU1QgYW5kIGJhY2sgcmVmZXJlbmNlcyAqL1xuICAgICAgYXN0RGVmaW5lZCA9IHRoaXNUaGlzLmFzdCAmJiB0aGlzVGhpcy5hc3QucnVsZURlZmluZWQob3AuaW5kZXgpO1xuICAgICAgaWYgKGFzdERlZmluZWQpIHtcbiAgICAgICAgYXN0TGVuZ3RoID0gdGhpc1RoaXMuYXN0LmdldExlbmd0aCgpO1xuICAgICAgICB0aGlzVGhpcy5hc3QuZG93bihvcC5pbmRleCwgcnVsZXNbb3AuaW5kZXhdLm5hbWUpO1xuICAgICAgfVxuICAgICAgdWxlbiA9IHN5c0RhdGEudUZyYW1lLmxlbmd0aCgpO1xuICAgICAgcGxlbiA9IHN5c0RhdGEucEZyYW1lLmxlbmd0aCgpO1xuICAgICAgc3lzRGF0YS51RnJhbWUucHVzaCgpO1xuICAgICAgc3lzRGF0YS5wRnJhbWUucHVzaCgpO1xuICAgICAgc2F2ZUZyYW1lID0gc3lzRGF0YS5wRnJhbWU7XG4gICAgICBzeXNEYXRhLnBGcmFtZSA9IG5ldyBiYWNrUmVmKCk7XG4gICAgfVxuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgLyogbm8gY2FsbGJhY2sgLSBqdXN0IGV4ZWN1dGUgdGhlIHJ1bGUgKi9cbiAgICAgIHNhdmVkT3Bjb2RlcyA9IG9wY29kZXM7XG4gICAgICBvcGNvZGVzID0gcnVsZS5vcGNvZGVzO1xuICAgICAgb3BFeGVjdXRlKDAsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgIG9wY29kZXMgPSBzYXZlZE9wY29kZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGNhbGwgdXNlcidzIGNhbGxiYWNrICovXG4gICAgICBjb25zdCBjaGFyc0xlZnQgPSBjaGFyc0VuZCAtIHBocmFzZUluZGV4O1xuICAgICAgc3lzRGF0YS5ydWxlSW5kZXggPSBydWxlLmluZGV4O1xuICAgICAgY2FsbGJhY2soc3lzRGF0YSwgY2hhcnMsIHBocmFzZUluZGV4LCBzeW50YXhEYXRhKTtcbiAgICAgIHZhbGlkYXRlUm5tQ2FsbGJhY2tSZXN1bHQocnVsZSwgc3lzRGF0YSwgY2hhcnNMZWZ0LCB0cnVlKTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5BQ1RJVkUpIHtcbiAgICAgICAgc2F2ZWRPcGNvZGVzID0gb3Bjb2RlcztcbiAgICAgICAgb3Bjb2RlcyA9IHJ1bGUub3Bjb2RlcztcbiAgICAgICAgb3BFeGVjdXRlKDAsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgb3Bjb2RlcyA9IHNhdmVkT3Bjb2RlcztcbiAgICAgICAgc3lzRGF0YS5ydWxlSW5kZXggPSBydWxlLmluZGV4O1xuICAgICAgICBjYWxsYmFjayhzeXNEYXRhLCBjaGFycywgcGhyYXNlSW5kZXgsIHN5bnRheERhdGEpO1xuICAgICAgICB2YWxpZGF0ZVJubUNhbGxiYWNrUmVzdWx0KHJ1bGUsIHN5c0RhdGEsIGNoYXJzTGVmdCwgZmFsc2UpO1xuICAgICAgfSAvKiBpbXBsaWVkIGVsc2UgY2xhdXNlOiBqdXN0IGFjY2VwdCB0aGUgY2FsbGJhY2sgc3lzRGF0YSAtIFJOTSBhY3RpbmcgYXMgVURUICovXG4gICAgfVxuICAgIGlmIChub3RMb29rQXJvdW5kKSB7XG4gICAgICAvKiBlbmQgQVNUICovXG4gICAgICBpZiAoYXN0RGVmaW5lZCkge1xuICAgICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICAgIHRoaXNUaGlzLmFzdC5zZXRMZW5ndGgoYXN0TGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzVGhpcy5hc3QudXAob3AuaW5kZXgsIHJ1bGUubmFtZSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogZW5kIGJhY2sgcmVmZXJlbmNlICovXG4gICAgICBzeXNEYXRhLnBGcmFtZSA9IHNhdmVGcmFtZTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgIHN5c0RhdGEudUZyYW1lLnBvcCh1bGVuKTtcbiAgICAgICAgc3lzRGF0YS5wRnJhbWUucG9wKHBsZW4pO1xuICAgICAgfSBlbHNlIGlmIChydWxlLmlzQmtyKSB7XG4gICAgICAgIC8qIHNhdmUgcGhyYXNlIG9uIGJvdGggdGhlIHBhcmVudCBhbmQgdW5pdmVyc2FsIGZyYW1lcyAqL1xuICAgICAgICAvKiBCS1Igb3BlcmF0b3Igd2lsbCBkZWNpZGUgd2hpY2ggdG8gdXNlIGxhdGVyICovXG4gICAgICAgIHN5c0RhdGEucEZyYW1lLnNhdmVQaHJhc2UocnVsZS5sb3dlciwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgc3lzRGF0YS51RnJhbWUuc2F2ZVBocmFzZShydWxlLmxvd2VyLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVmFsaWRhdGUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uJ3MgcmV0dXJuZWQgc3lzRGF0YSB2YWx1ZXMuXG4gIC8vIEl0J3MgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byBnZXQgaXQgcmlnaHQgYnV0IGBVRFRgIGZhaWxzIGlmIG5vdC5cbiAgY29uc3QgdmFsaWRhdGVVZHRDYWxsYmFja1Jlc3VsdCA9IGZ1bmN0aW9uICh1ZHQsIHN5c0RhdGEsIGNoYXJzTGVmdCkge1xuICAgIGlmIChzeXNEYXRhLnBocmFzZUxlbmd0aCA+IGNoYXJzTGVmdCkge1xuICAgICAgbGV0IHN0ciA9IGAke3RoaXNGaWxlTmFtZX1vcFVEVCgke3VkdC5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIGVycm9yOiBgO1xuICAgICAgc3RyICs9IGBzeXNEYXRhLnBocmFzZUxlbmd0aDogJHtzeXNEYXRhLnBocmFzZUxlbmd0aH1gO1xuICAgICAgc3RyICs9IGAgbXVzdCBiZSA8PSByZW1haW5pbmcgY2hhcnM6ICR7Y2hhcnNMZWZ0fWA7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICB9XG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1vcFVEVCgke3VkdC5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybiBlcnJvci4gQUNUSVZFIHN0YXRlIG5vdCBhbGxvd2VkLmApO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgaWYgKHVkdC5lbXB0eSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfW9wVURUKCR7dWR0Lm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJuIGVycm9yLiBNYXkgbm90IHJldHVybiBFTVBUWS5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoc3lzRGF0YS5waHJhc2VMZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodWR0LmVtcHR5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1vcFVEVCgke3VkdC5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybiBlcnJvci4gTWF5IG5vdCByZXR1cm4gRU1QVFkuYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7dGhpc0ZpbGVOYW1lfW9wVURUKCR7dWR0Lm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJuIGVycm9yLiBVbnJlY29nbml6ZWQgcmV0dXJuIHN0YXRlOiAke3N5c0RhdGEuc3RhdGV9YFxuICAgICAgICApO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBVRFRgIG9wZXJhdG9yLjxicj5cbiAgLy8gU2ltcGx5IGNhbGxzIHRoZSB1c2VyJ3MgY2FsbGJhY2sgZnVuY3Rpb24sIGJ1dCBvcGVyYXRlcyBsaWtlIGBSTk1gIHdpdGggcmVnYXJkIHRvIHRoZSBgQVNUYFxuICAvLyBhbmQgYmFjayByZWZlcmVuY2luZy5cbiAgLy8gVGhlcmUgaXMgc29tZSBhbWJpZ3VpdHkgaGVyZS4gYFVEVGBzIGFjdCBhcyB0ZXJtaW5hbHMgZm9yIHBocmFzZSByZWNvZ25pdGlvbiBidXQgYXMgbmFtZWQgcnVsZXNcbiAgLy8gZm9yIGBBU1RgIG5vZGVzIGFuZCBiYWNrIHJlZmVyZW5jaW5nLlxuICAvLyBTZWUgW2Bhc3QuanNgXSguL2FzdC5odG1sKSBmb3IgdXNhZ2UuXG4gIGNvbnN0IG9wVURUID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGFzdExlbmd0aDtcbiAgICBsZXQgYXN0SW5kZXg7XG4gICAgbGV0IGFzdERlZmluZWQ7XG4gICAgbGV0IHVsZW47XG4gICAgbGV0IHBsZW47XG4gICAgbGV0IHNhdmVGcmFtZTtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgY29uc3QgdWR0ID0gdWR0c1tvcC5pbmRleF07XG4gICAgc3lzRGF0YS5VZHRJbmRleCA9IHVkdC5pbmRleDtcblxuICAgIGNvbnN0IG5vdExvb2tBcm91bmQgPSAhaW5Mb29rQXJvdW5kKCk7XG4gICAgLyogaWdub3JlIEFTVCBhbmQgYmFjayByZWZlcmVuY2VzIGluIGxvb2thcm91bmQgKi9cbiAgICBpZiAobm90TG9va0Fyb3VuZCkge1xuICAgICAgLyogYmVnaW4gQVNUIGFuZCBiYWNrIHJlZmVyZW5jZSAqL1xuICAgICAgYXN0RGVmaW5lZCA9IHRoaXNUaGlzLmFzdCAmJiB0aGlzVGhpcy5hc3QudWR0RGVmaW5lZChvcC5pbmRleCk7XG4gICAgICBpZiAoYXN0RGVmaW5lZCkge1xuICAgICAgICBhc3RJbmRleCA9IHJ1bGVzLmxlbmd0aCArIG9wLmluZGV4O1xuICAgICAgICBhc3RMZW5ndGggPSB0aGlzVGhpcy5hc3QuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIHRoaXNUaGlzLmFzdC5kb3duKGFzdEluZGV4LCB1ZHQubmFtZSk7XG4gICAgICB9XG4gICAgICAvKiBOT1RFOiBwdXNoIGFuZCBwb3Agb2YgdGhlIGJhY2sgcmVmZXJlbmNlIGZyYW1lIGlzIG5vcm1hbGx5IG5vdCBuZWNlc3NhcnkgKi9cbiAgICAgIC8qIG9ubHkgaW4gdGhlIGNhc2UgdGhhdCB0aGUgVURUIGNhbGxzIGV2YWx1YXRlUnVsZSgpIG9yIGV2YWx1YXRlVWR0KCkgKi9cbiAgICAgIHVsZW4gPSBzeXNEYXRhLnVGcmFtZS5sZW5ndGgoKTtcbiAgICAgIHBsZW4gPSBzeXNEYXRhLnBGcmFtZS5sZW5ndGgoKTtcbiAgICAgIHN5c0RhdGEudUZyYW1lLnB1c2goKTtcbiAgICAgIHN5c0RhdGEucEZyYW1lLnB1c2goKTtcbiAgICAgIHNhdmVGcmFtZSA9IHN5c0RhdGEucEZyYW1lO1xuICAgICAgc3lzRGF0YS5wRnJhbWUgPSBuZXcgYmFja1JlZigpO1xuICAgIH1cbiAgICAvKiBjYWxsIHRoZSBVRFQgKi9cbiAgICBjb25zdCBjaGFyc0xlZnQgPSBjaGFyc0VuZCAtIHBocmFzZUluZGV4O1xuICAgIHVkdENhbGxiYWNrc1tvcC5pbmRleF0oc3lzRGF0YSwgY2hhcnMsIHBocmFzZUluZGV4LCBzeW50YXhEYXRhKTtcbiAgICB2YWxpZGF0ZVVkdENhbGxiYWNrUmVzdWx0KHVkdCwgc3lzRGF0YSwgY2hhcnNMZWZ0KTtcbiAgICBpZiAobm90TG9va0Fyb3VuZCkge1xuICAgICAgLyogZW5kIEFTVCAqL1xuICAgICAgaWYgKGFzdERlZmluZWQpIHtcbiAgICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgICB0aGlzVGhpcy5hc3Quc2V0TGVuZ3RoKGFzdExlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1RoaXMuYXN0LnVwKGFzdEluZGV4LCB1ZHQubmFtZSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogZW5kIGJhY2sgcmVmZXJlbmNlICovXG4gICAgICBzeXNEYXRhLnBGcmFtZSA9IHNhdmVGcmFtZTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgIHN5c0RhdGEudUZyYW1lLnBvcCh1bGVuKTtcbiAgICAgICAgc3lzRGF0YS5wRnJhbWUucG9wKHBsZW4pO1xuICAgICAgfSBlbHNlIGlmICh1ZHQuaXNCa3IpIHtcbiAgICAgICAgLyogc2F2ZSBwaHJhc2Ugb24gYm90aCB0aGUgcGFyZW50IGFuZCB1bml2ZXJzYWwgZnJhbWVzICovXG4gICAgICAgIC8qIEJLUiBvcGVyYXRvciB3aWxsIGRlY2lkZSB3aGljaCB0byB1c2UgbGF0ZXIgKi9cbiAgICAgICAgc3lzRGF0YS5wRnJhbWUuc2F2ZVBocmFzZSh1ZHQubG93ZXIsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCk7XG4gICAgICAgIHN5c0RhdGEudUZyYW1lLnNhdmVQaHJhc2UodWR0Lmxvd2VyLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBBTkRgIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBpcyB0aGUgcG9zaXRpdmUgYGxvb2sgYWhlYWRgIG9wZXJhdG9yLlxuICAvLyBFeGVjdXRlcyBpdHMgc2luZ2xlIGNoaWxkIG5vZGUsIHJldHVybmluZyB0aGUgRU1QVFkgc3RhdGVcbiAgLy8gaWYgaXQgc3VjY2VlZHNhbmQgTk9NQVRDSCBpZiBpdCBmYWlscy5cbiAgLy8gKkFsd2F5cyogYmFja3RyYWNrcyBvbiBhbnkgbWF0Y2hlZCBwaHJhc2UgYW5kIHJldHVybnMgRU1QVFkgb24gc3VjY2Vzcy5cbiAgY29uc3Qgb3BBTkQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsb29rQXJvdW5kLnB1c2goe1xuICAgICAgbG9va0Fyb3VuZDogaWQuTE9PS0FST1VORF9BSEVBRCxcbiAgICAgIGFuY2hvcjogcGhyYXNlSW5kZXgsXG4gICAgICBjaGFyc0VuZCxcbiAgICAgIGNoYXJzTGVuZ3RoLFxuICAgIH0pO1xuICAgIGNoYXJzRW5kID0gY2hhcnMubGVuZ3RoO1xuICAgIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoIC0gY2hhcnNCZWdpbjtcbiAgICBvcEV4ZWN1dGUob3BJbmRleCArIDEsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICBjb25zdCBwb3AgPSBsb29rQXJvdW5kLnBvcCgpO1xuICAgIGNoYXJzRW5kID0gcG9wLmNoYXJzRW5kO1xuICAgIGNoYXJzTGVuZ3RoID0gcG9wLmNoYXJzTGVuZ3RoO1xuICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICBzd2l0Y2ggKHN5c0RhdGEuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9wQU5EOiBpbnZhbGlkIHN0YXRlICR7c3lzRGF0YS5zdGF0ZX1gKTtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgTk9UYCBvcGVyYXRvci48YnI+XG4gIC8vIFRoaXMgaXMgdGhlIG5lZ2F0aXZlIGBsb29rIGFoZWFkYCBvcGVyYXRvci5cbiAgLy8gRXhlY3V0ZXMgaXRzIHNpbmdsZSBjaGlsZCBub2RlLCByZXR1cm5pbmcgdGhlIEVNUFRZIHN0YXRlXG4gIC8vIGlmIGl0ICpmYWlscyogYW5kIE5PTUFUQ0ggaWYgaXQgc3VjY2VlZHMuXG4gIC8vICpBbHdheXMqIGJhY2t0cmFja3Mgb24gYW55IG1hdGNoZWQgcGhyYXNlIGFuZCByZXR1cm5zIEVNUFRZXG4gIC8vIG9uIHN1Y2Nlc3MgKGZhaWx1cmUgb2YgaXRzIGNoaWxkIG5vZGUpLlxuICBjb25zdCBvcE5PVCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxvb2tBcm91bmQucHVzaCh7XG4gICAgICBsb29rQXJvdW5kOiBpZC5MT09LQVJPVU5EX0FIRUFELFxuICAgICAgYW5jaG9yOiBwaHJhc2VJbmRleCxcbiAgICAgIGNoYXJzRW5kLFxuICAgICAgY2hhcnNMZW5ndGgsXG4gICAgfSk7XG4gICAgY2hhcnNFbmQgPSBjaGFycy5sZW5ndGg7XG4gICAgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGggLSBjaGFyc0JlZ2luO1xuICAgIG9wRXhlY3V0ZShvcEluZGV4ICsgMSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgIGNvbnN0IHBvcCA9IGxvb2tBcm91bmQucG9wKCk7XG4gICAgY2hhcnNFbmQgPSBwb3AuY2hhcnNFbmQ7XG4gICAgY2hhcnNMZW5ndGggPSBwb3AuY2hhcnNMZW5ndGg7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3BOT1Q6IGludmFsaWQgc3RhdGUgJHtzeXNEYXRhLnN0YXRlfWApO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBUUkdgIG9wZXJhdG9yLjxicj5cbiAgLy8gU3VjY2VlZHMgaWYgdGhlIHNpbmdsZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHBocmFzZSBpc1xuICAvLyB3aXRoaW4gdGhlIGBtaW4gLSBtYXhgIHJhbmdlLlxuICBjb25zdCBvcFRSRyA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBpZiAocGhyYXNlSW5kZXggPCBjaGFyc0VuZCkge1xuICAgICAgaWYgKG9wLm1pbiA8PSBjaGFyc1twaHJhc2VJbmRleF0gJiYgY2hhcnNbcGhyYXNlSW5kZXhdIDw9IG9wLm1heCkge1xuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgVEJTYCBvcGVyYXRvci48YnI+XG4gIC8vIE1hdGNoZXMgaXRzIHByZS1kZWZpbmVkIHBocmFzZSBhZ2FpbnN0IHRoZSBpbnB1dCBzdHJpbmcuXG4gIC8vIEFsbCBjaGFyYWN0ZXJzIG11c3QgbWF0Y2ggZXhhY3RseS5cbiAgLy8gQ2FzZS1zZW5zaXRpdmUgbGl0ZXJhbCBzdHJpbmdzIChgJ3N0cmluZydgICYgYCVzXCJzdHJpbmdcImApIGFyZSB0cmFuc2xhdGVkIHRvIGBUQlNgXG4gIC8vIG9wZXJhdG9ycyBieSBgYXBnYC5cbiAgLy8gUGhyYXNlIGxlbmd0aCBvZiB6ZXJvIGlzIG5vdCBhbGxvd2VkLlxuICAvLyBFbXB0eSBwaHJhc2VzIGNhbiBvbmx5IGJlIGRlZmluZWQgd2l0aCBgVExTYCBvcGVyYXRvcnMuXG4gIGNvbnN0IG9wVEJTID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IGxlbiA9IG9wLnN0cmluZy5sZW5ndGg7XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgaWYgKHBocmFzZUluZGV4ICsgbGVuIDw9IGNoYXJzRW5kKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGNoYXJzW3BocmFzZUluZGV4ICsgaV0gIT09IG9wLnN0cmluZ1tpXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgfSAvKiBpbXBsaWVkIGVsc2UgTk9NQVRDSCAqL1xuICB9O1xuICAvLyBUaGUgYFRMU2Agb3BlcmF0b3IuPGJyPlxuICAvLyBNYXRjaGVzIGl0cyBwcmUtZGVmaW5lZCBwaHJhc2UgYWdhaW5zdCB0aGUgaW5wdXQgc3RyaW5nLlxuICAvLyBBIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggaXMgYXR0ZW1wdGVkIGZvciBBU0NJSSBhbHBoYmV0aWNhbCBjaGFyYWN0ZXJzLlxuICAvLyBgVExTYCBpcyB0aGUgb25seSBvcGVyYXRvciB0aGF0IGV4cGxpY2l0bHkgYWxsb3dzIGVtcHR5IHBocmFzZXMuXG4gIC8vIGBhcGdgIHdpbGwgZmFpbCBmb3IgZW1wdHkgYFRCU2AsIGNhc2Utc2Vuc2l0aXZlIHN0cmluZ3MgKGAnJ2ApIG9yXG4gIC8vIHplcm8gcmVwZXRpdGlvbnMgKGAwKjBSdWxlTmFtZWAgb3IgYDBSdWxlTmFtZWApLlxuICBjb25zdCBvcFRMUyA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBpO1xuICAgIGxldCBjb2RlO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBjb25zdCBsZW4gPSBvcC5zdHJpbmcubGVuZ3RoO1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIC8qIEVNUFRZIG1hdGNoIGFsbG93ZWQgZm9yIFRMUyAqL1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGhyYXNlSW5kZXggKyBsZW4gPD0gY2hhcnNFbmQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBjb2RlID0gY2hhcnNbcGhyYXNlSW5kZXggKyBpXTtcbiAgICAgICAgaWYgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkge1xuICAgICAgICAgIGNvZGUgKz0gMzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUgIT09IG9wLnN0cmluZ1tpXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgfSAvKiBpbXBsaWVkIGVsc2UgTk9NQVRDSCAqL1xuICB9O1xuICAvLyBUaGUgYEFCR2Agb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIGlzIGFuIFwiYW5jaG9yXCIgZm9yIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZywgc2ltaWxhciB0byB0aGUgZmFtaWxpYXIgcmVnZXggYF5gIGFuY2hvci5cbiAgLy8gQW4gYW5jaG9yIG1hdGNoZXMgYSBwb3NpdGlvbiByYXRoZXIgdGhhbiBhIHBocmFzZS5cbiAgLy8gUmV0dXJucyBFTVBUWSBpZiBgcGhyYXNlSW5kZXhgIGlzIDAsIE5PTUFUQ0ggb3RoZXJ3aXNlLlxuICBjb25zdCBvcEFCRyA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICBzeXNEYXRhLnN0YXRlID0gcGhyYXNlSW5kZXggPT09IDAgPyBpZC5FTVBUWSA6IGlkLk5PTUFUQ0g7XG4gIH07XG4gIC8vIFRoZSBgQUVOYCBvcGVyYXRvci48YnI+XG4gIC8vIFRoaXMgaXMgYW4gXCJhbmNob3JcIiBmb3IgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzaW1pbGFyIHRvIHRoZSBmYW1pbGlhciByZWdleCBgJGAgYW5jaG9yLlxuICAvLyBBbiBhbmNob3IgbWF0Y2hlcyBhIHBvc2l0aW9uIHJhdGhlciB0aGFuIGEgcGhyYXNlLlxuICAvLyBSZXR1cm5zIEVNUFRZIGlmIGBwaHJhc2VJbmRleGAgZXF1YWxzIHRoZSBpbnB1dCBzdHJpbmcgbGVuZ3RoLCBOT01BVENIIG90aGVyd2lzZS5cbiAgY29uc3Qgb3BBRU4gPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgc3lzRGF0YS5zdGF0ZSA9IHBocmFzZUluZGV4ID09PSBjaGFycy5sZW5ndGggPyBpZC5FTVBUWSA6IGlkLk5PTUFUQ0g7XG4gIH07XG4gIC8vIFRoZSBgQktSYCBvcGVyYXRvci48YnI+XG4gIC8vIFRoZSBiYWNrIHJlZmVyZW5jZSBvcGVyYXRvci5cbiAgLy8gTWF0Y2hlcyB0aGUgbGFzdCBtYXRjaGVkIHBocmFzZSBvZiB0aGUgbmFtZWQgcnVsZSBvciBVRFQgYWdhaW5zdCB0aGUgaW5wdXQgc3RyaW5nLlxuICAvLyBGb3IgQVNDSUkgYWxwaGJldGljYWwgY2hhcmFjdGVycyB0aGUgbWF0Y2ggbWF5IGJlIGNhc2Ugc2Vuc2l0aXZlIChgJXNgKSBvciBpbnNlbnNpdGl2ZSAoYCVpYCksXG4gIC8vIGRlcGVuZGluZyBvbiB0aGUgYmFjayByZWZlcmVuY2UgZGVmaW5pdGlvbi5cbiAgLy8gRm9yIGB1bml2ZXJzYWxgIG1vZGUgKGAldWApIG1hdGNoZXMgdGhlIGxhc3QgcGhyYXNlIGZvdW5kIGFueXdoZXJlIGluIHRoZSBncmFtbWFyLlxuICAvLyBGb3IgYHBhcmVudCBmcmFtZWAgbW9kZSAoYCVwYCkgbWF0Y2hlcyB0aGUgbGFzdCBwaHJhc2UgZm91bmQgaW4gdGhlIHBhcmVudCBydWxlIG9ubHkuXG4gIGNvbnN0IG9wQktSID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGNvZGU7XG4gICAgbGV0IGxtY29kZTtcbiAgICBsZXQgbG93ZXI7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIGlmIChvcC5pbmRleCA8IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgbG93ZXIgPSBydWxlc1tvcC5pbmRleF0ubG93ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvd2VyID0gdWR0c1tvcC5pbmRleCAtIHJ1bGVzLmxlbmd0aF0ubG93ZXI7XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lID0gb3AuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfUE0gPyBzeXNEYXRhLnBGcmFtZS5nZXRQaHJhc2UobG93ZXIpIDogc3lzRGF0YS51RnJhbWUuZ2V0UGhyYXNlKGxvd2VyKTtcbiAgICBjb25zdCBpbnNlbnNpdGl2ZSA9IG9wLmJrckNhc2UgPT09IGlkLkJLUl9NT0RFX0NJO1xuICAgIGlmIChmcmFtZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsbUluZGV4ID0gZnJhbWUucGhyYXNlSW5kZXg7XG4gICAgY29uc3QgbGVuID0gZnJhbWUucGhyYXNlTGVuZ3RoO1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBocmFzZUluZGV4ICsgbGVuIDw9IGNoYXJzRW5kKSB7XG4gICAgICBpZiAoaW5zZW5zaXRpdmUpIHtcbiAgICAgICAgLyogY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCAqL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBjb2RlID0gY2hhcnNbcGhyYXNlSW5kZXggKyBpXTtcbiAgICAgICAgICBsbWNvZGUgPSBjaGFyc1tsbUluZGV4ICsgaV07XG4gICAgICAgICAgaWYgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkge1xuICAgICAgICAgICAgY29kZSArPSAzMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxtY29kZSA+PSA2NSAmJiBsbWNvZGUgPD0gOTApIHtcbiAgICAgICAgICAgIGxtY29kZSArPSAzMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGUgIT09IGxtY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogY2FzZS1zZW5zaXRpdmUgbWF0Y2ggKi9cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgY29kZSA9IGNoYXJzW3BocmFzZUluZGV4ICsgaV07XG4gICAgICAgICAgbG1jb2RlID0gY2hhcnNbbG1JbmRleCArIGldO1xuICAgICAgICAgIGlmIChjb2RlICE9PSBsbWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBCS0FgIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBpcyB0aGUgcG9zaXRpdmUgYGxvb2sgYmVoaW5kYCBvcGVyYXRvci5cbiAgLy8gSXQncyBjaGlsZCBub2RlIGlzIHBhcnNlZCByaWdodC10by1sZWZ0LlxuICAvLyBSZXR1cm5zIHRoZSBFTVBUWSBzdGF0ZSBpZiBhIG1hdGNoIGlzIGZvdW5kLCBOT01BVENIIG90aGVyd2lzZS5cbiAgLy8gTGlrZSB0aGUgbG9vayBhaGVhZCBvcGVyYXRvcnMsIGl0IGFsd2F5cyBiYWNrdHJhY2tzIHRvIGBwaHJhc2VJbmRleGAuXG4gIGNvbnN0IG9wQktBID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbG9va0Fyb3VuZC5wdXNoKHtcbiAgICAgIGxvb2tBcm91bmQ6IGlkLkxPT0tBUk9VTkRfQkVISU5ELFxuICAgICAgYW5jaG9yOiBwaHJhc2VJbmRleCxcbiAgICB9KTtcbiAgICBvcEV4ZWN1dGUob3BJbmRleCArIDEsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICBsb29rQXJvdW5kLnBvcCgpO1xuICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICBzd2l0Y2ggKHN5c0RhdGEuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9wQktBOiBpbnZhbGlkIHN0YXRlICR7c3lzRGF0YS5zdGF0ZX1gKTtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgQktOYCBvcGVyYXRvci48YnI+XG4gIC8vIFRoaXMgaXMgdGhlIG5lZ2F0aXZlIGBsb29rIGJlaGluZGAgb3BlcmF0b3IuXG4gIC8vIEl0J3MgY2hpbGQgbm9kZSBpcyBwYXJzZWQgcmlnaHQtdG8tbGVmdC5cbiAgLy8gUmV0dXJucyB0aGUgRU1QVFkgc3RhdGUgaWYgYSBtYXRjaCBpcyAqbm90KiBmb3VuZCwgTk9NQVRDSCBvdGhlcndpc2UuXG4gIC8vIExpa2UgdGhlIGxvb2sgYWhlYWQgb3BlcmF0b3JzLCBpdCBhbHdheXMgYmFja3RyYWNrcyB0byBgcGhyYXNlSW5kZXhgLlxuICBjb25zdCBvcEJLTiA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIC8vIGxldCBvcDtcbiAgICAvLyBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgbG9va0Fyb3VuZC5wdXNoKHtcbiAgICAgIGxvb2tBcm91bmQ6IGlkLkxPT0tBUk9VTkRfQkVISU5ELFxuICAgICAgYW5jaG9yOiBwaHJhc2VJbmRleCxcbiAgICB9KTtcbiAgICBvcEV4ZWN1dGUob3BJbmRleCArIDEsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICBsb29rQXJvdW5kLnBvcCgpO1xuICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICBzd2l0Y2ggKHN5c0RhdGEuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9wQktOOiBpbnZhbGlkIHN0YXRlICR7c3lzRGF0YS5zdGF0ZX1gKTtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSByaWdodC10by1sZWZ0IGBDQVRgIG9wZXJhdG9yLjxicj5cbiAgLy8gQ2FsbGVkIGZvciBgQ0FUYCBvcGVyYXRvcnMgd2hlbiBpbiBsb29rIGJlaGluZCBtb2RlLlxuICAvLyBDYWxscyBpdHMgY2hpbGQgbm9kZXMgZnJvbSByaWdodCB0byBsZWZ0IGNvbmNhdGVuYXRpbmcgbWF0Y2hlZCBwaHJhc2VzIHJpZ2h0IHRvIGxlZnQuXG4gIGNvbnN0IG9wQ0FUQmVoaW5kID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG4gICAgbGV0IGFzdExlbmd0aDtcbiAgICBsZXQgY2F0Q2hhckluZGV4O1xuICAgIGxldCBjYXRNYXRjaGVkO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBjb25zdCB1bGVuID0gc3lzRGF0YS51RnJhbWUubGVuZ3RoKCk7XG4gICAgY29uc3QgcGxlbiA9IHN5c0RhdGEucEZyYW1lLmxlbmd0aCgpO1xuICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgIGFzdExlbmd0aCA9IHRoaXNUaGlzLmFzdC5nZXRMZW5ndGgoKTtcbiAgICB9XG4gICAgc3VjY2VzcyA9IHRydWU7XG4gICAgY2F0Q2hhckluZGV4ID0gcGhyYXNlSW5kZXg7XG4gICAgY2F0TWF0Y2hlZCA9IDA7XG4gICAgLy8gY2F0UGhyYXNlID0gMDtcbiAgICBmb3IgKGxldCBpID0gb3AuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIG9wRXhlY3V0ZShvcC5jaGlsZHJlbltpXSwgY2F0Q2hhckluZGV4LCBzeXNEYXRhKTtcbiAgICAgIGNhdENoYXJJbmRleCAtPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIGNhdE1hdGNoZWQgKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICAvLyBjYXRQaHJhc2UgKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGNhdE1hdGNoZWQgPT09IDAgPyBpZC5FTVBUWSA6IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBjYXRNYXRjaGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgIHN5c0RhdGEudUZyYW1lLnBvcCh1bGVuKTtcbiAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIHJpZ2h0LXRvLWxlZnQgYFJFUGAgb3BlcmF0b3IuPGJyPlxuICAvLyBDYWxsZWQgZm9yIGBSRVBgIG9wZXJhdG9ycyBpbiBsb29rIGJlaGluZCBtb2RlLlxuICAvLyBNYWtlcyByZXBlYXRlZCBjYWxscyB0byBpdHMgY2hpbGQgbm9kZSwgY29uY2F0ZW5hdGluZyBtYXRjaGVkIHBocmFzZXMgcmlnaHQgdG8gbGVmdC5cbiAgY29uc3Qgb3BSRVBCZWhpbmQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgYXN0TGVuZ3RoO1xuICAgIGxldCByZXBDaGFySW5kZXg7XG4gICAgbGV0IHJlcFBocmFzZTtcbiAgICBsZXQgcmVwQ291bnQ7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHJlcENoYXJJbmRleCA9IHBocmFzZUluZGV4O1xuICAgIHJlcFBocmFzZSA9IDA7XG4gICAgcmVwQ291bnQgPSAwO1xuICAgIGNvbnN0IHVsZW4gPSBzeXNEYXRhLnVGcmFtZS5sZW5ndGgoKTtcbiAgICBjb25zdCBwbGVuID0gc3lzRGF0YS5wRnJhbWUubGVuZ3RoKCk7XG4gICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgYXN0TGVuZ3RoID0gdGhpc1RoaXMuYXN0LmdldExlbmd0aCgpO1xuICAgIH1cbiAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgaWYgKHJlcENoYXJJbmRleCA8PSAwKSB7XG4gICAgICAgIC8qIGV4aXQgb24gZW5kIG9mIGlucHV0IHN0cmluZyAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9wRXhlY3V0ZShvcEluZGV4ICsgMSwgcmVwQ2hhckluZGV4LCBzeXNEYXRhKTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgIC8qIGFsd2F5cyBlbmQgaWYgdGhlIGNoaWxkIG5vZGUgZmFpbHMgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuRU1QVFkpIHtcbiAgICAgICAgLyogUkVQIGFsd2F5cyBzdWNjZWVkcyB3aGVuIHRoZSBjaGlsZCBub2RlIHJldHVybnMgYW4gZW1wdHkgcGhyYXNlICovXG4gICAgICAgIC8qIHRoaXMgbWF5IG5vdCBzZWVtIG9idmlvdXMsIGJ1dCB0aGF0J3MgdGhlIHdheSBpdCB3b3JrcyBvdXQgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXBDb3VudCArPSAxO1xuICAgICAgcmVwUGhyYXNlICs9IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgcmVwQ2hhckluZGV4IC09IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgaWYgKHJlcENvdW50ID09PSBvcC5tYXgpIHtcbiAgICAgICAgLyogZW5kIG9uIG1heGVkIG91dCByZXBzICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBldmFsdWF0ZSB0aGUgbWF0Y2ggY291bnQgYWNjb3JkaW5nIHRvIHRoZSBtaW4sIG1heCB2YWx1ZXMgKi9cbiAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuRU1QVFkpIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSByZXBQaHJhc2UgPT09IDAgPyBpZC5FTVBUWSA6IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSByZXBQaHJhc2U7XG4gICAgfSBlbHNlIGlmIChyZXBDb3VudCA+PSBvcC5taW4pIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSByZXBQaHJhc2UgPT09IDAgPyBpZC5FTVBUWSA6IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSByZXBQaHJhc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgc3lzRGF0YS51RnJhbWUucG9wKHVsZW4pO1xuICAgICAgc3lzRGF0YS5wRnJhbWUucG9wKHBsZW4pO1xuICAgICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgICB0aGlzVGhpcy5hc3Quc2V0TGVuZ3RoKGFzdExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGUgcmlnaHQtdG8tbGVmdCBgVFJHYCBvcGVyYXRvci48YnI+XG4gIC8vIENhbGxlZCBmb3IgYFRSR2Agb3BlcmF0b3JzIGluIGxvb2sgYmVoaW5kIG1vZGUuXG4gIC8vIE1hdGNoZXMgYSBzaW5nbGUgY2hhcmFjdGVyIGF0IGBwaHJhc2VJbmRleCAtIDFgIHRvIHRoZSBgbWluYCAtIGBtYXhgIHJhbmdlLlxuICBjb25zdCBvcFRSR0JlaGluZCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgaWYgKHBocmFzZUluZGV4ID4gMCkge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW3BocmFzZUluZGV4IC0gMV07XG4gICAgICBpZiAob3AubWluIDw9IGNoYXIgJiYgY2hhciA8PSBvcC5tYXgpIHtcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGUgcmlnaHQtdG8tbGVmdCBgVEJTYCBvcGVyYXRvci48YnI+XG4gIC8vIENhbGxlZCBmb3IgYFRCU2Agb3BlcmF0b3JzIGluIGxvb2sgYmVoaW5kIG1vZGUuXG4gIC8vIE1hdGNoZXMgdGhlIGBUQlNgIHBocmFzZSB0byB0aGUgbGVmdCBvZiBgcGhyYXNlSW5kZXhgLlxuICBjb25zdCBvcFRCU0JlaGluZCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBjb25zdCBsZW4gPSBvcC5zdHJpbmcubGVuZ3RoO1xuICAgIGNvbnN0IGJlZyA9IHBocmFzZUluZGV4IC0gbGVuO1xuICAgIGlmIChiZWcgPj0gMCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmIChjaGFyc1tiZWcgKyBpXSAhPT0gb3Auc3RyaW5nW2ldKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSByaWdodC10by1sZWZ0IGBUTFNgIG9wZXJhdG9yLjxicj5cbiAgLy8gQ2FsbGVkIGZvciBgVExTYCBvcGVyYXRvcnMgaW4gbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gTWF0Y2hlcyB0aGUgYFRMU2AgcGhyYXNlIHRvIHRoZSBsZWZ0IG9mIGBwaHJhc2VJbmRleGAuXG4gIGNvbnN0IG9wVExTQmVoaW5kID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGNoYXI7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIGNvbnN0IGxlbiA9IG9wLnN0cmluZy5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgLyogRU1QVFkgbWF0Y2ggYWxsb3dlZCBmb3IgVExTICovXG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJlZyA9IHBocmFzZUluZGV4IC0gbGVuO1xuICAgIGlmIChiZWcgPj0gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBjaGFyID0gY2hhcnNbYmVnICsgaV07XG4gICAgICAgIGlmIChjaGFyID49IDY1ICYmIGNoYXIgPD0gOTApIHtcbiAgICAgICAgICBjaGFyICs9IDMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyICE9PSBvcC5zdHJpbmdbaV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfTtcbiAgLy8gVGhlIHJpZ2h0LXRvLWxlZnQgYmFjayByZWZlcmVuY2Ugb3BlcmF0b3IuPGJyPlxuICAvLyBNYXRjaGVzIHRoZSBiYWNrIHJlZmVyZW5jZWQgcGhyYXNlIHRvIHRoZSBsZWZ0IG9mIGBwaHJhc2VJbmRleGAuXG4gIGNvbnN0IG9wQktSQmVoaW5kID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGNvZGU7XG4gICAgbGV0IGxtY29kZTtcbiAgICBsZXQgbG93ZXI7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIC8qIE5PTUFUQ0ggZGVmYXVsdCAqL1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICBpZiAob3AuaW5kZXggPCBydWxlcy5sZW5ndGgpIHtcbiAgICAgIGxvd2VyID0gcnVsZXNbb3AuaW5kZXhdLmxvd2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb3dlciA9IHVkdHNbb3AuaW5kZXggLSBydWxlcy5sZW5ndGhdLmxvd2VyO1xuICAgIH1cbiAgICBjb25zdCBmcmFtZSA9IG9wLmJrck1vZGUgPT09IGlkLkJLUl9NT0RFX1BNID8gc3lzRGF0YS5wRnJhbWUuZ2V0UGhyYXNlKGxvd2VyKSA6IHN5c0RhdGEudUZyYW1lLmdldFBocmFzZShsb3dlcik7XG4gICAgY29uc3QgaW5zZW5zaXRpdmUgPSBvcC5ia3JDYXNlID09PSBpZC5CS1JfTU9ERV9DSTtcbiAgICBpZiAoZnJhbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbG1JbmRleCA9IGZyYW1lLnBocmFzZUluZGV4O1xuICAgIGNvbnN0IGxlbiA9IGZyYW1lLnBocmFzZUxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJlZyA9IHBocmFzZUluZGV4IC0gbGVuO1xuICAgIGlmIChiZWcgPj0gMCkge1xuICAgICAgaWYgKGluc2Vuc2l0aXZlKSB7XG4gICAgICAgIC8qIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggKi9cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgY29kZSA9IGNoYXJzW2JlZyArIGldO1xuICAgICAgICAgIGxtY29kZSA9IGNoYXJzW2xtSW5kZXggKyBpXTtcbiAgICAgICAgICBpZiAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB7XG4gICAgICAgICAgICBjb2RlICs9IDMyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG1jb2RlID49IDY1ICYmIGxtY29kZSA8PSA5MCkge1xuICAgICAgICAgICAgbG1jb2RlICs9IDMyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZSAhPT0gbG1jb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBjYXNlLXNlbnNpdGl2ZSBtYXRjaCAqL1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBjb2RlID0gY2hhcnNbYmVnICsgaV07XG4gICAgICAgICAgbG1jb2RlID0gY2hhcnNbbG1JbmRleCArIGldO1xuICAgICAgICAgIGlmIChjb2RlICE9PSBsbWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfTtcbiAgLy8gR2VuZXJhbGl6ZWQgZXhlY3V0aW9uIGZ1bmN0aW9uLjxicj5cbiAgLy8gSGF2aW5nIGEgc2luZ2xlLCBnZW5lcmFsaXplZCBmdW5jdGlvbiwgYWxsb3dzIGEgc2luZ2xlIGxvY2F0aW9uXG4gIC8vIGZvciB0cmFjaW5nIGFuZCBzdGF0aXN0aWNzIGdhdGhlcmluZyBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkLlxuICAvLyBUcmFjaW5nIGFuZCBzdGF0aXN0aWNzIGFyZSBoYW5kbGVkIGluIHNlcGFyYXRlIG9iamVjdHMuXG4gIC8vIEhvd2V2ZXIsIHRoZSBwYXJzZXIgY2FsbHMgdGhlaXIgQVBJIHRvIGJ1aWxkIHRoZSBvYmplY3QgZGF0YSByZWNvcmRzLlxuICAvLyBTZWUgW2B0cmFjZS5qc2BdKC4vdHJhY2UuaHRtbCkgYW5kIFtgc3RhdHMuanNgXSguL3N0YXRzLmh0bWwpIGZvciB0aGVpclxuICAvLyB1c2FnZS5cbiAgb3BFeGVjdXRlID0gZnVuY3Rpb24gb3BFeGVjdXRlRnVuYyhvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCByZXQgPSB0cnVlO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBub2RlSGl0cyArPSAxO1xuICAgIGlmIChub2RlSGl0cyA+IGxpbWl0Tm9kZUhpdHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyc2VyOiBtYXhpbXVtIG51bWJlciBvZiBub2RlIGhpdHMgZXhjZWVkZWQ6ICR7bGltaXROb2RlSGl0c31gKTtcbiAgICB9XG4gICAgdHJlZURlcHRoICs9IDE7XG4gICAgaWYgKHRyZWVEZXB0aCA+IG1heFRyZWVEZXB0aCkge1xuICAgICAgbWF4VHJlZURlcHRoID0gdHJlZURlcHRoO1xuICAgICAgaWYgKG1heFRyZWVEZXB0aCA+IGxpbWl0VHJlZURlcHRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyc2VyOiBtYXhpbXVtIHBhcnNlIHRyZWUgZGVwdGggZXhjZWVkZWQ6ICR7bGltaXRUcmVlRGVwdGh9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN5c0RhdGEucmVmcmVzaCgpO1xuICAgIGlmICh0aGlzVGhpcy50cmFjZSAhPT0gbnVsbCkge1xuICAgICAgLyogY29sbGVjdCB0aGUgdHJhY2UgcmVjb3JkIGZvciBkb3duIHRoZSBwYXJzZSB0cmVlICovXG4gICAgICBjb25zdCBsayA9IGxvb2tBcm91bmRWYWx1ZSgpO1xuICAgICAgdGhpc1RoaXMudHJhY2UuZG93bihvcCwgc3lzRGF0YS5zdGF0ZSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoLCBsay5hbmNob3IsIGxrLmxvb2tBcm91bmQpO1xuICAgIH1cbiAgICBpZiAoaW5Mb29rQmVoaW5kKCkpIHtcbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlIGlkLkFMVDpcbiAgICAgICAgICBvcEFMVChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQ0FUOlxuICAgICAgICAgIG9wQ0FUQmVoaW5kKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5SRVA6XG4gICAgICAgICAgb3BSRVBCZWhpbmQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlJOTTpcbiAgICAgICAgICBvcFJOTShvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVURUOlxuICAgICAgICAgIG9wVURUKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5BTkQ6XG4gICAgICAgICAgb3BBTkQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLk5PVDpcbiAgICAgICAgICBvcE5PVChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVFJHOlxuICAgICAgICAgIG9wVFJHQmVoaW5kKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5UQlM6XG4gICAgICAgICAgb3BUQlNCZWhpbmQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlRMUzpcbiAgICAgICAgICBvcFRMU0JlaGluZChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICAgIG9wQktSQmVoaW5kKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5CS0E6XG4gICAgICAgICAgb3BCS0Eob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkJLTjpcbiAgICAgICAgICBvcEJLTihvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQUJHOlxuICAgICAgICAgIG9wQUJHKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5BRU46XG4gICAgICAgICAgb3BBRU4ob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgY2FzZSBpZC5BTFQ6XG4gICAgICAgICAgb3BBTFQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgICBvcENBVChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuUkVQOlxuICAgICAgICAgIG9wUkVQKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgICAgb3BSTk0ob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlVEVDpcbiAgICAgICAgICBvcFVEVChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQU5EOlxuICAgICAgICAgIG9wQU5EKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5OT1Q6XG4gICAgICAgICAgb3BOT1Qob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlRSRzpcbiAgICAgICAgICBvcFRSRyhvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVEJTOlxuICAgICAgICAgIG9wVEJTKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgICAgb3BUTFMob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkJLUjpcbiAgICAgICAgICBvcEJLUihvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQktBOlxuICAgICAgICAgIG9wQktBKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5CS046XG4gICAgICAgICAgb3BCS04ob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkFCRzpcbiAgICAgICAgICBvcEFCRyhvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQUVOOlxuICAgICAgICAgIG9wQUVOKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbkxvb2tBcm91bmQoKSAmJiBwaHJhc2VJbmRleCArIHN5c0RhdGEucGhyYXNlTGVuZ3RoID4gbWF4TWF0Y2hlZCkge1xuICAgICAgbWF4TWF0Y2hlZCA9IHBocmFzZUluZGV4ICsgc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aGlzVGhpcy5zdGF0cyAhPT0gbnVsbCkge1xuICAgICAgLyogY29sbGVjdCB0aGUgc3RhdGlzdGljcyAqL1xuICAgICAgdGhpc1RoaXMuc3RhdHMuY29sbGVjdChvcCwgc3lzRGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzVGhpcy50cmFjZSAhPT0gbnVsbCkge1xuICAgICAgLyogY29sbGVjdCB0aGUgdHJhY2UgcmVjb3JkIGZvciB1cCB0aGUgcGFyc2UgdHJlZSAqL1xuICAgICAgY29uc3QgbGsgPSBsb29rQXJvdW5kVmFsdWUoKTtcbiAgICAgIHRoaXNUaGlzLnRyYWNlLnVwKG9wLCBzeXNEYXRhLnN0YXRlLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgsIGxrLmFuY2hvciwgbGsubG9va0Fyb3VuZCk7XG4gICAgfVxuICAgIHRyZWVEZXB0aCAtPSAxO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/parser.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/stats.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/stats.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is the constructor for the statistics gathering object.\n// The statistics are nothing more than keeping a count of the\n// number of times each node in the parse tree is traversed.\n//\n// Counts are collected for each of the individual types of operators.\n// Additionally, counts are collected for each of the individually named\n// `RNM` and `UDT` operators.\nmodule.exports = function statsFunc() {\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\");\n  const style = __webpack_require__(/*! ./style */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js\");\n\n  const thisFileName = 'stats.js: ';\n  let rules = [];\n  let udts = [];\n  const stats = [];\n  let totals;\n  const ruleStats = [];\n  const udtStats = [];\n  this.statsObject = 'statsObject';\n  const nameId = 'stats';\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators alphabetically by name. */\n  const sortAlpha = function sortAlpha(lhs, rhs) {\n    if (lhs.lower < rhs.lower) {\n      return -1;\n    }\n    if (lhs.lower > rhs.lower) {\n      return 1;\n    }\n    return 0;\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by hit count. */\n  const sortHits = function sortHits(lhs, rhs) {\n    if (lhs.total < rhs.total) {\n      return 1;\n    }\n    if (lhs.total > rhs.total) {\n      return -1;\n    }\n    return sortAlpha(lhs, rhs);\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by index */\n  /* (in the order in which they appear in the SABNF grammar). */\n  const sortIndex = function sortIndex(lhs, rhs) {\n    if (lhs.index < rhs.index) {\n      return -1;\n    }\n    if (lhs.index > rhs.index) {\n      return 1;\n    }\n    return 0;\n  };\n  const EmptyStat = function EmptyStat() {\n    this.empty = 0;\n    this.match = 0;\n    this.nomatch = 0;\n    this.total = 0;\n  };\n  /* Zero out all stats */\n  const clear = function clear() {\n    stats.length = 0;\n    totals = new EmptyStat();\n    stats[id.ALT] = new EmptyStat();\n    stats[id.CAT] = new EmptyStat();\n    stats[id.REP] = new EmptyStat();\n    stats[id.RNM] = new EmptyStat();\n    stats[id.TRG] = new EmptyStat();\n    stats[id.TBS] = new EmptyStat();\n    stats[id.TLS] = new EmptyStat();\n    stats[id.UDT] = new EmptyStat();\n    stats[id.AND] = new EmptyStat();\n    stats[id.NOT] = new EmptyStat();\n    stats[id.BKR] = new EmptyStat();\n    stats[id.BKA] = new EmptyStat();\n    stats[id.BKN] = new EmptyStat();\n    stats[id.ABG] = new EmptyStat();\n    stats[id.AEN] = new EmptyStat();\n    ruleStats.length = 0;\n    for (let i = 0; i < rules.length; i += 1) {\n      ruleStats.push({\n        empty: 0,\n        match: 0,\n        nomatch: 0,\n        total: 0,\n        name: rules[i].name,\n        lower: rules[i].lower,\n        index: rules[i].index,\n      });\n    }\n    if (udts.length > 0) {\n      udtStats.length = 0;\n      for (let i = 0; i < udts.length; i += 1) {\n        udtStats.push({\n          empty: 0,\n          match: 0,\n          nomatch: 0,\n          total: 0,\n          name: udts[i].name,\n          lower: udts[i].lower,\n          index: udts[i].index,\n        });\n      }\n    }\n  };\n  /* increment the designated operator hit count by one */\n  const incStat = function incStat(stat, state) {\n    stat.total += 1;\n    switch (state) {\n      case id.EMPTY:\n        stat.empty += 1;\n        break;\n      case id.MATCH:\n        stat.match += 1;\n        break;\n      case id.NOMATCH:\n        stat.nomatch += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);\n    }\n  };\n  /* helper for toHtml() */\n  const displayRow = function displayRow(name, stat) {\n    let html = '';\n    html += '<tr>';\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${name}</td>`;\n    html += `<td class=\"${style.CLASS_EMPTY}\">${stat.empty}</td>`;\n    html += `<td class=\"${style.CLASS_MATCH}\">${stat.match}</td>`;\n    html += `<td class=\"${style.CLASS_NOMATCH}\">${stat.nomatch}</td>`;\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${stat.total}</td>`;\n    html += '</tr>\\n';\n    return html;\n  };\n  const displayOpsOnly = function displayOpsOnly() {\n    let html = '';\n    html += displayRow('ALT', stats[id.ALT]);\n    html += displayRow('CAT', stats[id.CAT]);\n    html += displayRow('REP', stats[id.REP]);\n    html += displayRow('RNM', stats[id.RNM]);\n    html += displayRow('TRG', stats[id.TRG]);\n    html += displayRow('TBS', stats[id.TBS]);\n    html += displayRow('TLS', stats[id.TLS]);\n    html += displayRow('UDT', stats[id.UDT]);\n    html += displayRow('AND', stats[id.AND]);\n    html += displayRow('NOT', stats[id.NOT]);\n    html += displayRow('BKR', stats[id.BKR]);\n    html += displayRow('BKA', stats[id.BKA]);\n    html += displayRow('BKN', stats[id.BKN]);\n    html += displayRow('ABG', stats[id.ABG]);\n    html += displayRow('AEN', stats[id.AEN]);\n    html += displayRow('totals', totals);\n    return html;\n  };\n  /* helper for toHtml() */\n  const displayRules = function displayRules() {\n    let html = '';\n    html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n    html += '<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\\n';\n    for (let i = 0; i < rules.length; i += 1) {\n      if (ruleStats[i].total > 0) {\n        html += '<tr>';\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].name}</td>`;\n        html += `<td class=\"${style.CLASS_EMPTY}\">${ruleStats[i].empty}</td>`;\n        html += `<td class=\"${style.CLASS_MATCH}\">${ruleStats[i].match}</td>`;\n        html += `<td class=\"${style.CLASS_NOMATCH}\">${ruleStats[i].nomatch}</td>`;\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].total}</td>`;\n        html += '</tr>\\n';\n      }\n    }\n    if (udts.length > 0) {\n      html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n      html += '<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\\n';\n      for (let i = 0; i < udts.length; i += 1) {\n        if (udtStats[i].total > 0) {\n          html += '<tr>';\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].name}</td>`;\n          html += `<td class=\"${style.CLASS_EMPTY}\">${udtStats[i].empty}</td>`;\n          html += `<td class=\"${style.CLASS_MATCH}\">${udtStats[i].match}</td>`;\n          html += `<td class=\"${style.CLASS_NOMATCH}\">${udtStats[i].nomatch}</td>`;\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].total}</td>`;\n          html += '</tr>\\n';\n        }\n      }\n    }\n    return html;\n  };\n  /* called only by the parser to validate a stats object */\n  this.validate = function validate(name) {\n    let ret = false;\n    if (typeof name === 'string' && nameId === name) {\n      ret = true;\n    }\n    return ret;\n  };\n  /* no verification of input - only called by parser() */\n  this.init = function init(inputRules, inputUdts) {\n    rules = inputRules;\n    udts = inputUdts;\n    clear();\n  };\n  /* This function is the main interaction with the parser. */\n  /* The parser calls it after each node has been traversed. */\n  this.collect = function collect(op, result) {\n    incStat(totals, result.state, result.phraseLength);\n    incStat(stats[op.type], result.state, result.phraseLength);\n    if (op.type === id.RNM) {\n      incStat(ruleStats[op.index], result.state, result.phraseLength);\n    }\n    if (op.type === id.UDT) {\n      incStat(udtStats[op.index], result.state, result.phraseLength);\n    }\n  };\n  // Display the statistics as an HTML table.\n  // - *type*\n  //   - \"ops\" - (default) display only the total hit counts for all operator types.\n  //   - \"index\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators ordered by index.\n  //   - \"hits\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by hit count.\n  //   - \"alpha\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by name alphabetically.\n  // - *caption* - optional caption for the table\n  this.toHtml = function toHtml(type, caption) {\n    let html = '';\n    html += `<table class=\"${style.CLASS_STATS}\">\\n`;\n    if (typeof caption === 'string') {\n      html += `<caption>${caption}</caption>\\n`;\n    }\n    html += `<tr><th class=\"${style.CLASS_ACTIVE}\">ops</th>\\n`;\n    html += `<th class=\"${style.CLASS_EMPTY}\">EMPTY</th>\\n`;\n    html += `<th class=\"${style.CLASS_MATCH}\">MATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_NOMATCH}\">NOMATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_ACTIVE}\">totals</th></tr>\\n`;\n    const test = true;\n    while (test) {\n      if (type === undefined) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === null) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'ops') {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'index') {\n        ruleStats.sort(sortIndex);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'hits') {\n        ruleStats.sort(sortHits);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'alpha') {\n        ruleStats.sort(sortAlpha);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortAlpha);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      break;\n    }\n    html += '</table>\\n';\n    return html;\n  };\n  // Display the stats table in a complete HTML5 page.\n  this.toHtmlPage = function toHtmlPage(type, caption, title) {\n    return utils.htmlToPage(this.toHtml(type, caption), title);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0YXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxpSEFBZTtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2R0FBYTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxR0FBUzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsNENBQTRDLE1BQU07QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQixJQUFJLEtBQUs7QUFDdEQsMEJBQTBCLGtCQUFrQixJQUFJLFdBQVc7QUFDM0QsMEJBQTBCLGtCQUFrQixJQUFJLFdBQVc7QUFDM0QsMEJBQTBCLG9CQUFvQixJQUFJLGFBQWE7QUFDL0QsMEJBQTBCLG1CQUFtQixJQUFJLFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CLElBQUksa0JBQWtCO0FBQ3ZFLDhCQUE4QixrQkFBa0IsSUFBSSxtQkFBbUI7QUFDdkUsOEJBQThCLGtCQUFrQixJQUFJLG1CQUFtQjtBQUN2RSw4QkFBOEIsb0JBQW9CLElBQUkscUJBQXFCO0FBQzNFLDhCQUE4QixtQkFBbUIsSUFBSSxtQkFBbUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQixJQUFJLGlCQUFpQjtBQUN4RSxnQ0FBZ0Msa0JBQWtCLElBQUksa0JBQWtCO0FBQ3hFLGdDQUFnQyxrQkFBa0IsSUFBSSxrQkFBa0I7QUFDeEUsZ0NBQWdDLG9CQUFvQixJQUFJLG9CQUFvQjtBQUM1RSxnQ0FBZ0MsbUJBQW1CLElBQUksa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pELDBCQUEwQixrQkFBa0I7QUFDNUMsMEJBQTBCLGtCQUFrQjtBQUM1QywwQkFBMEIsb0JBQW9CO0FBQzlDLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvc3RhdHMuanM/NTdmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBpcyB0aGUgY29uc3RydWN0b3IgZm9yIHRoZSBzdGF0aXN0aWNzIGdhdGhlcmluZyBvYmplY3QuXG4vLyBUaGUgc3RhdGlzdGljcyBhcmUgbm90aGluZyBtb3JlIHRoYW4ga2VlcGluZyBhIGNvdW50IG9mIHRoZVxuLy8gbnVtYmVyIG9mIHRpbWVzIGVhY2ggbm9kZSBpbiB0aGUgcGFyc2UgdHJlZSBpcyB0cmF2ZXJzZWQuXG4vL1xuLy8gQ291bnRzIGFyZSBjb2xsZWN0ZWQgZm9yIGVhY2ggb2YgdGhlIGluZGl2aWR1YWwgdHlwZXMgb2Ygb3BlcmF0b3JzLlxuLy8gQWRkaXRpb25hbGx5LCBjb3VudHMgYXJlIGNvbGxlY3RlZCBmb3IgZWFjaCBvZiB0aGUgaW5kaXZpZHVhbGx5IG5hbWVkXG4vLyBgUk5NYCBhbmQgYFVEVGAgb3BlcmF0b3JzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdGF0c0Z1bmMoKSB7XG4gIGNvbnN0IGlkID0gcmVxdWlyZSgnLi9pZGVudGlmaWVycycpO1xuICBjb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzJyk7XG4gIGNvbnN0IHN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuXG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdzdGF0cy5qczogJztcbiAgbGV0IHJ1bGVzID0gW107XG4gIGxldCB1ZHRzID0gW107XG4gIGNvbnN0IHN0YXRzID0gW107XG4gIGxldCB0b3RhbHM7XG4gIGNvbnN0IHJ1bGVTdGF0cyA9IFtdO1xuICBjb25zdCB1ZHRTdGF0cyA9IFtdO1xuICB0aGlzLnN0YXRzT2JqZWN0ID0gJ3N0YXRzT2JqZWN0JztcbiAgY29uc3QgbmFtZUlkID0gJ3N0YXRzJztcbiAgLyogYEFycmF5LnNvcnQoKWAgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNvcnRpbmcgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBhbHBoYWJldGljYWxseSBieSBuYW1lLiAqL1xuICBjb25zdCBzb3J0QWxwaGEgPSBmdW5jdGlvbiBzb3J0QWxwaGEobGhzLCByaHMpIHtcbiAgICBpZiAobGhzLmxvd2VyIDwgcmhzLmxvd2VyKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChsaHMubG93ZXIgPiByaHMubG93ZXIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgLyogYEFycmF5LnNvcnQoKWAgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNvcnRpbmcgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBieSBoaXQgY291bnQuICovXG4gIGNvbnN0IHNvcnRIaXRzID0gZnVuY3Rpb24gc29ydEhpdHMobGhzLCByaHMpIHtcbiAgICBpZiAobGhzLnRvdGFsIDwgcmhzLnRvdGFsKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGxocy50b3RhbCA+IHJocy50b3RhbCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gc29ydEFscGhhKGxocywgcmhzKTtcbiAgfTtcbiAgLyogYEFycmF5LnNvcnQoKWAgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNvcnRpbmcgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBieSBpbmRleCAqL1xuICAvKiAoaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyIGluIHRoZSBTQUJORiBncmFtbWFyKS4gKi9cbiAgY29uc3Qgc29ydEluZGV4ID0gZnVuY3Rpb24gc29ydEluZGV4KGxocywgcmhzKSB7XG4gICAgaWYgKGxocy5pbmRleCA8IHJocy5pbmRleCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAobGhzLmluZGV4ID4gcmhzLmluZGV4KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIGNvbnN0IEVtcHR5U3RhdCA9IGZ1bmN0aW9uIEVtcHR5U3RhdCgpIHtcbiAgICB0aGlzLmVtcHR5ID0gMDtcbiAgICB0aGlzLm1hdGNoID0gMDtcbiAgICB0aGlzLm5vbWF0Y2ggPSAwO1xuICAgIHRoaXMudG90YWwgPSAwO1xuICB9O1xuICAvKiBaZXJvIG91dCBhbGwgc3RhdHMgKi9cbiAgY29uc3QgY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBzdGF0cy5sZW5ndGggPSAwO1xuICAgIHRvdGFscyA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5BTFRdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkNBVF0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuUkVQXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5STk1dID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLlRSR10gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuVEJTXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5UTFNdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLlVEVF0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQU5EXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5OT1RdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkJLUl0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQktBXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5CS05dID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkFCR10gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQUVOXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBydWxlU3RhdHMubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBydWxlU3RhdHMucHVzaCh7XG4gICAgICAgIGVtcHR5OiAwLFxuICAgICAgICBtYXRjaDogMCxcbiAgICAgICAgbm9tYXRjaDogMCxcbiAgICAgICAgdG90YWw6IDAsXG4gICAgICAgIG5hbWU6IHJ1bGVzW2ldLm5hbWUsXG4gICAgICAgIGxvd2VyOiBydWxlc1tpXS5sb3dlcixcbiAgICAgICAgaW5kZXg6IHJ1bGVzW2ldLmluZGV4LFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdFN0YXRzLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdWR0U3RhdHMucHVzaCh7XG4gICAgICAgICAgZW1wdHk6IDAsXG4gICAgICAgICAgbWF0Y2g6IDAsXG4gICAgICAgICAgbm9tYXRjaDogMCxcbiAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICBuYW1lOiB1ZHRzW2ldLm5hbWUsXG4gICAgICAgICAgbG93ZXI6IHVkdHNbaV0ubG93ZXIsXG4gICAgICAgICAgaW5kZXg6IHVkdHNbaV0uaW5kZXgsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogaW5jcmVtZW50IHRoZSBkZXNpZ25hdGVkIG9wZXJhdG9yIGhpdCBjb3VudCBieSBvbmUgKi9cbiAgY29uc3QgaW5jU3RhdCA9IGZ1bmN0aW9uIGluY1N0YXQoc3RhdCwgc3RhdGUpIHtcbiAgICBzdGF0LnRvdGFsICs9IDE7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgc3RhdC5lbXB0eSArPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHN0YXQubWF0Y2ggKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN0YXQubm9tYXRjaCArPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y29sbGVjdCgpOiBpbmNTdGF0KCk6IHVucmVjb2duaXplZCBzdGF0ZTogJHtzdGF0ZX1gKTtcbiAgICB9XG4gIH07XG4gIC8qIGhlbHBlciBmb3IgdG9IdG1sKCkgKi9cbiAgY29uc3QgZGlzcGxheVJvdyA9IGZ1bmN0aW9uIGRpc3BsYXlSb3cobmFtZSwgc3RhdCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaHRtbCArPSAnPHRyPic7XG4gICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHtuYW1lfTwvdGQ+YDtcbiAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiR7c3RhdC5lbXB0eX08L3RkPmA7XG4gICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj4ke3N0YXQubWF0Y2h9PC90ZD5gO1xuICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4ke3N0YXQubm9tYXRjaH08L3RkPmA7XG4gICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHtzdGF0LnRvdGFsfTwvdGQ+YDtcbiAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIGNvbnN0IGRpc3BsYXlPcHNPbmx5ID0gZnVuY3Rpb24gZGlzcGxheU9wc09ubHkoKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0FMVCcsIHN0YXRzW2lkLkFMVF0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQ0FUJywgc3RhdHNbaWQuQ0FUXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdSRVAnLCBzdGF0c1tpZC5SRVBdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ1JOTScsIHN0YXRzW2lkLlJOTV0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnVFJHJywgc3RhdHNbaWQuVFJHXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdUQlMnLCBzdGF0c1tpZC5UQlNdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ1RMUycsIHN0YXRzW2lkLlRMU10pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnVURUJywgc3RhdHNbaWQuVURUXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdBTkQnLCBzdGF0c1tpZC5BTkRdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ05PVCcsIHN0YXRzW2lkLk5PVF0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQktSJywgc3RhdHNbaWQuQktSXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdCS0EnLCBzdGF0c1tpZC5CS0FdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0JLTicsIHN0YXRzW2lkLkJLTl0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQUJHJywgc3RhdHNbaWQuQUJHXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdBRU4nLCBzdGF0c1tpZC5BRU5dKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ3RvdGFscycsIHRvdGFscyk7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGhlbHBlciBmb3IgdG9IdG1sKCkgKi9cbiAgY29uc3QgZGlzcGxheVJ1bGVzID0gZnVuY3Rpb24gZGlzcGxheVJ1bGVzKCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaHRtbCArPSAnPHRyPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjwvdHI+XFxuJztcbiAgICBodG1sICs9ICc8dHI+PHRoPnJ1bGVzPC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48L3RyPlxcbic7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHJ1bGVTdGF0c1tpXS50b3RhbCA+IDApIHtcbiAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiR7cnVsZVN0YXRzW2ldLm5hbWV9PC90ZD5gO1xuICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiR7cnVsZVN0YXRzW2ldLmVtcHR5fTwvdGQ+YDtcbiAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj4ke3J1bGVTdGF0c1tpXS5tYXRjaH08L3RkPmA7XG4gICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4ke3J1bGVTdGF0c1tpXS5ub21hdGNofTwvdGQ+YDtcbiAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHtydWxlU3RhdHNbaV0udG90YWx9PC90ZD5gO1xuICAgICAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGh0bWwgKz0gJzx0cj48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48L3RyPlxcbic7XG4gICAgICBodG1sICs9ICc8dHI+PHRoPnVkdHM8L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjwvdHI+XFxuJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWR0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodWR0U3RhdHNbaV0udG90YWwgPiAwKSB7XG4gICAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHt1ZHRTdGF0c1tpXS5uYW1lfTwvdGQ+YDtcbiAgICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiR7dWR0U3RhdHNbaV0uZW1wdHl9PC90ZD5gO1xuICAgICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+JHt1ZHRTdGF0c1tpXS5tYXRjaH08L3RkPmA7XG4gICAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPiR7dWR0U3RhdHNbaV0ubm9tYXRjaH08L3RkPmA7XG4gICAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHt1ZHRTdGF0c1tpXS50b3RhbH08L3RkPmA7XG4gICAgICAgICAgaHRtbCArPSAnPC90cj5cXG4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBjYWxsZWQgb25seSBieSB0aGUgcGFyc2VyIHRvIHZhbGlkYXRlIGEgc3RhdHMgb2JqZWN0ICovXG4gIHRoaXMudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShuYW1lKSB7XG4gICAgbGV0IHJldCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgbmFtZUlkID09PSBuYW1lKSB7XG4gICAgICByZXQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICAvKiBubyB2ZXJpZmljYXRpb24gb2YgaW5wdXQgLSBvbmx5IGNhbGxlZCBieSBwYXJzZXIoKSAqL1xuICB0aGlzLmluaXQgPSBmdW5jdGlvbiBpbml0KGlucHV0UnVsZXMsIGlucHV0VWR0cykge1xuICAgIHJ1bGVzID0gaW5wdXRSdWxlcztcbiAgICB1ZHRzID0gaW5wdXRVZHRzO1xuICAgIGNsZWFyKCk7XG4gIH07XG4gIC8qIFRoaXMgZnVuY3Rpb24gaXMgdGhlIG1haW4gaW50ZXJhY3Rpb24gd2l0aCB0aGUgcGFyc2VyLiAqL1xuICAvKiBUaGUgcGFyc2VyIGNhbGxzIGl0IGFmdGVyIGVhY2ggbm9kZSBoYXMgYmVlbiB0cmF2ZXJzZWQuICovXG4gIHRoaXMuY29sbGVjdCA9IGZ1bmN0aW9uIGNvbGxlY3Qob3AsIHJlc3VsdCkge1xuICAgIGluY1N0YXQodG90YWxzLCByZXN1bHQuc3RhdGUsIHJlc3VsdC5waHJhc2VMZW5ndGgpO1xuICAgIGluY1N0YXQoc3RhdHNbb3AudHlwZV0sIHJlc3VsdC5zdGF0ZSwgcmVzdWx0LnBocmFzZUxlbmd0aCk7XG4gICAgaWYgKG9wLnR5cGUgPT09IGlkLlJOTSkge1xuICAgICAgaW5jU3RhdChydWxlU3RhdHNbb3AuaW5kZXhdLCByZXN1bHQuc3RhdGUsIHJlc3VsdC5waHJhc2VMZW5ndGgpO1xuICAgIH1cbiAgICBpZiAob3AudHlwZSA9PT0gaWQuVURUKSB7XG4gICAgICBpbmNTdGF0KHVkdFN0YXRzW29wLmluZGV4XSwgcmVzdWx0LnN0YXRlLCByZXN1bHQucGhyYXNlTGVuZ3RoKTtcbiAgICB9XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHN0YXRpc3RpY3MgYXMgYW4gSFRNTCB0YWJsZS5cbiAgLy8gLSAqdHlwZSpcbiAgLy8gICAtIFwib3BzXCIgLSAoZGVmYXVsdCkgZGlzcGxheSBvbmx5IHRoZSB0b3RhbCBoaXQgY291bnRzIGZvciBhbGwgb3BlcmF0b3IgdHlwZXMuXG4gIC8vICAgLSBcImluZGV4XCIgLSBhZGRpdGlvbmFsbHksIGRpc3BsYXkgdGhlIGhpdCBjb3VudHMgZm9yIHRoZSBpbmRpdmlkdWFsIGBSTk1gIGFuZCBgVURUYCBvcGVyYXRvcnMgb3JkZXJlZCBieSBpbmRleC5cbiAgLy8gICAtIFwiaGl0c1wiIC0gYWRkaXRpb25hbGx5LCBkaXNwbGF5IHRoZSBoaXQgY291bnRzIGZvciB0aGUgaW5kaXZpZHVhbCBgUk5NYCBhbmQgYFVEVGAgb3BlcmF0b3JzIGJ5IGhpdCBjb3VudC5cbiAgLy8gICAtIFwiYWxwaGFcIiAtIGFkZGl0aW9uYWxseSwgZGlzcGxheSB0aGUgaGl0IGNvdW50cyBmb3IgdGhlIGluZGl2aWR1YWwgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBieSBuYW1lIGFscGhhYmV0aWNhbGx5LlxuICAvLyAtICpjYXB0aW9uKiAtIG9wdGlvbmFsIGNhcHRpb24gZm9yIHRoZSB0YWJsZVxuICB0aGlzLnRvSHRtbCA9IGZ1bmN0aW9uIHRvSHRtbCh0eXBlLCBjYXB0aW9uKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9IGA8dGFibGUgY2xhc3M9XCIke3N0eWxlLkNMQVNTX1NUQVRTfVwiPlxcbmA7XG4gICAgaWYgKHR5cGVvZiBjYXB0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgaHRtbCArPSBgPGNhcHRpb24+JHtjYXB0aW9ufTwvY2FwdGlvbj5cXG5gO1xuICAgIH1cbiAgICBodG1sICs9IGA8dHI+PHRoIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+b3BzPC90aD5cXG5gO1xuICAgIGh0bWwgKz0gYDx0aCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+RU1QVFk8L3RoPlxcbmA7XG4gICAgaHRtbCArPSBgPHRoIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj5NQVRDSDwvdGg+XFxuYDtcbiAgICBodG1sICs9IGA8dGggY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+Tk9NQVRDSDwvdGg+XFxuYDtcbiAgICBodG1sICs9IGA8dGggY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj50b3RhbHM8L3RoPjwvdHI+XFxuYDtcbiAgICBjb25zdCB0ZXN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAodGVzdCkge1xuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnb3BzJykge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdpbmRleCcpIHtcbiAgICAgICAgcnVsZVN0YXRzLnNvcnQoc29ydEluZGV4KTtcbiAgICAgICAgaWYgKHVkdFN0YXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1ZHRTdGF0cy5zb3J0KHNvcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBodG1sICs9IGRpc3BsYXlSdWxlcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnaGl0cycpIHtcbiAgICAgICAgcnVsZVN0YXRzLnNvcnQoc29ydEhpdHMpO1xuICAgICAgICBpZiAodWR0U3RhdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVkdFN0YXRzLnNvcnQoc29ydEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheVJ1bGVzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdhbHBoYScpIHtcbiAgICAgICAgcnVsZVN0YXRzLnNvcnQoc29ydEFscGhhKTtcbiAgICAgICAgaWYgKHVkdFN0YXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1ZHRTdGF0cy5zb3J0KHNvcnRBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBodG1sICs9IGRpc3BsYXlSdWxlcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBodG1sICs9ICc8L3RhYmxlPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHN0YXRzIHRhYmxlIGluIGEgY29tcGxldGUgSFRNTDUgcGFnZS5cbiAgdGhpcy50b0h0bWxQYWdlID0gZnVuY3Rpb24gdG9IdG1sUGFnZSh0eXBlLCBjYXB0aW9uLCB0aXRsZSkge1xuICAgIHJldHVybiB1dGlscy5odG1sVG9QYWdlKHRoaXMudG9IdG1sKHR5cGUsIGNhcHRpb24pLCB0aXRsZSk7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/stats.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js ***!
  \**************************************************************************************/
/***/ ((module) => {

eval("module.exports = {\n\n  // Generated by apglib/style.js \n  CLASS_MONOSPACE: 'apg-mono',\n  CLASS_ACTIVE: 'apg-active',\n  CLASS_EMPTY: 'apg-empty',\n  CLASS_MATCH: 'apg-match',\n  CLASS_NOMATCH: 'apg-nomatch',\n  CLASS_LOOKAHEAD: 'apg-lh-match',\n  CLASS_LOOKBEHIND: 'apg-lb-match',\n  CLASS_REMAINDER: 'apg-remainder',\n  CLASS_CTRLCHAR: 'apg-ctrl-char',\n  CLASS_LINEEND: 'apg-line-end',\n  CLASS_ERROR: 'apg-error',\n  CLASS_PHRASE: 'apg-phrase',\n  CLASS_EMPTYPHRASE: 'apg-empty-phrase',\n  CLASS_STATE: 'apg-state',\n  CLASS_STATS: 'apg-stats',\n  CLASS_TRACE: 'apg-trace',\n  CLASS_GRAMMAR: 'apg-grammar',\n  CLASS_RULES: 'apg-rules',\n  CLASS_RULESLINK: 'apg-rules-link',\n  CLASS_ATTRIBUTES: 'apg-attrs',\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0eWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvc3R5bGUuanM/NTMwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvLyBHZW5lcmF0ZWQgYnkgYXBnbGliL3N0eWxlLmpzIFxuICBDTEFTU19NT05PU1BBQ0U6ICdhcGctbW9ubycsXG4gIENMQVNTX0FDVElWRTogJ2FwZy1hY3RpdmUnLFxuICBDTEFTU19FTVBUWTogJ2FwZy1lbXB0eScsXG4gIENMQVNTX01BVENIOiAnYXBnLW1hdGNoJyxcbiAgQ0xBU1NfTk9NQVRDSDogJ2FwZy1ub21hdGNoJyxcbiAgQ0xBU1NfTE9PS0FIRUFEOiAnYXBnLWxoLW1hdGNoJyxcbiAgQ0xBU1NfTE9PS0JFSElORDogJ2FwZy1sYi1tYXRjaCcsXG4gIENMQVNTX1JFTUFJTkRFUjogJ2FwZy1yZW1haW5kZXInLFxuICBDTEFTU19DVFJMQ0hBUjogJ2FwZy1jdHJsLWNoYXInLFxuICBDTEFTU19MSU5FRU5EOiAnYXBnLWxpbmUtZW5kJyxcbiAgQ0xBU1NfRVJST1I6ICdhcGctZXJyb3InLFxuICBDTEFTU19QSFJBU0U6ICdhcGctcGhyYXNlJyxcbiAgQ0xBU1NfRU1QVFlQSFJBU0U6ICdhcGctZW1wdHktcGhyYXNlJyxcbiAgQ0xBU1NfU1RBVEU6ICdhcGctc3RhdGUnLFxuICBDTEFTU19TVEFUUzogJ2FwZy1zdGF0cycsXG4gIENMQVNTX1RSQUNFOiAnYXBnLXRyYWNlJyxcbiAgQ0xBU1NfR1JBTU1BUjogJ2FwZy1ncmFtbWFyJyxcbiAgQ0xBU1NfUlVMRVM6ICdhcGctcnVsZXMnLFxuICBDTEFTU19SVUxFU0xJTks6ICdhcGctcnVsZXMtbGluaycsXG4gIENMQVNTX0FUVFJJQlVURVM6ICdhcGctYXR0cnMnLFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/trace.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/trace.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module provides a means of tracing the parser through the parse tree as it goes.\n// It is the primary debugging facility for debugging both the SABNF grammar syntax\n// and the input strings that are supposed to be valid grammar sentences.\n// It is also a very informative and educational tool for understanding\n// how a parser actually operates for a given language.\n//\n// Tracing is the process of generating and saving a record of information for each passage\n// of the parser through a parse tree node. And since it traverses each node twice, once down the tree\n// and once coming back up, there are two records for each node.\n// This, obviously, has the potential of generating lots of records.\n// And since these records are normally displayed on a web page\n// it is important to have a means to limit the actual number of records generated to\n// probably no more that a few thousand. This is almost always enough to find any errors.\n// The problem is to get the *right* few thousand records.\n// Therefore, this module has a number of ways of limiting and/or filtering, the number and type of records.\n// Considerable effort has been made to make this filtering of the trace output as simple\n// and intuitive as possible.\n//\n// However, the ability to filter the trace records, or for that matter even understand what they are\n// and the information they contain, does require a minimum amount of understanding of the APG parsing\n// method. The parse tree nodes are all represented by APG operators. They break down into two natural groups.\n// - The `RNM` operators and `UDT` operators are named phrases.\n// These are names chosen by the writer of the SABNF grammar to represent special phrases of interest.\n// - All others collect, concatenate and otherwise manipulate various intermediate phrases along the way.\n//\n// There are separate means of filtering which of these operators in each of these two groups get traced.\n// Let `trace` be an instantiated `trace.js` object.\n// Prior to parsing the string, filtering the rules and UDTs can be defined as follows:\n// ```\n// trace.filter.rules[\"rulename\"] = true;\n//     /* trace rule name \"rulename\" */\n// trace.filter.rules[\"udtname\"]  = true;\n//     /* trace UDT name \"udtname\" */\n// trace.filter.rules[\"<ALL>\"]    = true;\n//     /* trace all rules and UDTs (the default) */\n// trace.filter.rules[\"<NONE>\"]   = true;\n//     /* trace no rules or UDTS */\n// ```\n// If any rule or UDT name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of rule names, a filter statement is required for each rule/UDT name desired.\n//\n// Filtering of the other operators follows a similar procedure.\n// ```\n// trace.filter.operators[\"TRG\"] = true;\n//     /* trace the terminal range, TRG, operators */\n// trace.filter.operators[\"CAT\"]  = true;\n//     /* trace the concatenations, CAT, operators */\n// trace.filter.operators[\"<ALL>\"]    = true;\n//     /* trace all operators */\n// trace.filter.operators[\"<NONE>\"]   = true;\n//     /* trace no operators (the default) */\n// ```\n// If any operator name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of operator names, a filter statement is required for each name desired.\n//\n// There is, additionally, a means for limiting the total number of filtered or saved trace records.\n// See the function, `setMaxRecords(max)` below. This will result in only the last `max` records being saved.\n//\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js-examples) for examples of using `trace.js`.)\nmodule.exports = function exportTrace() {\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\");\n  const style = __webpack_require__(/*! ./style */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js\");\n  const circular = new (__webpack_require__(/*! ./circular-buffer */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/circular-buffer.js\"))();\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n\n  const thisFileName = 'trace.js: ';\n  const that = this;\n  const MODE_HEX = 16;\n  const MODE_DEC = 10;\n  const MODE_ASCII = 8;\n  const MODE_UNICODE = 32;\n  const MAX_PHRASE = 80;\n  const MAX_TLS = 5;\n  const records = [];\n  let maxRecords = 5000;\n  let lastRecord = -1;\n  let filteredRecords = 0;\n  let treeDepth = 0;\n  const recordStack = [];\n  let chars = null;\n  let rules = null;\n  let udts = null;\n  const operatorFilter = [];\n  const ruleFilter = [];\n  /* special trace table phrases */\n  const PHRASE_END = `<span class=\"${style.CLASS_LINEEND}\">&bull;</span>`;\n  const PHRASE_CONTINUE = `<span class=\"${style.CLASS_LINEEND}\">&hellip;</span>`;\n  const PHRASE_EMPTY = `<span class=\"${style.CLASS_EMPTY}\">&#120634;</span>`;\n  /* filter the non-RNM & non-UDT operators */\n  const initOperatorFilter = function () {\n    const setOperators = function (set) {\n      operatorFilter[id.ALT] = set;\n      operatorFilter[id.CAT] = set;\n      operatorFilter[id.REP] = set;\n      operatorFilter[id.TLS] = set;\n      operatorFilter[id.TBS] = set;\n      operatorFilter[id.TRG] = set;\n      operatorFilter[id.AND] = set;\n      operatorFilter[id.NOT] = set;\n      operatorFilter[id.BKR] = set;\n      operatorFilter[id.BKA] = set;\n      operatorFilter[id.BKN] = set;\n      operatorFilter[id.ABG] = set;\n      operatorFilter[id.AEN] = set;\n    };\n    let items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.operators) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: no operators specified: default: do not trace any operators */\n      setOperators(false);\n      return;\n    }\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      if (upper === '<ALL>') {\n        /* case 2: <all> operators specified: trace all operators ignore all other operator commands */\n        setOperators(true);\n        return;\n      }\n      if (upper === '<NONE>') {\n        /* case 3: <none> operators specified: trace NO operators ignore all other operator commands */\n        setOperators(false);\n        return;\n      }\n    }\n    setOperators(false);\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      /* case 4: one or more individual operators specified: trace 'true' operators only */\n      if (upper === 'ALT') {\n        operatorFilter[id.ALT] = that.filter.operators[name] === true;\n      } else if (upper === 'CAT') {\n        operatorFilter[id.CAT] = that.filter.operators[name] === true;\n      } else if (upper === 'REP') {\n        operatorFilter[id.REP] = that.filter.operators[name] === true;\n      } else if (upper === 'AND') {\n        operatorFilter[id.AND] = that.filter.operators[name] === true;\n      } else if (upper === 'NOT') {\n        operatorFilter[id.NOT] = that.filter.operators[name] === true;\n      } else if (upper === 'TLS') {\n        operatorFilter[id.TLS] = that.filter.operators[name] === true;\n      } else if (upper === 'TBS') {\n        operatorFilter[id.TBS] = that.filter.operators[name] === true;\n      } else if (upper === 'TRG') {\n        operatorFilter[id.TRG] = that.filter.operators[name] === true;\n      } else if (upper === 'BKR') {\n        operatorFilter[id.BKR] = that.filter.operators[name] === true;\n      } else if (upper === 'BKA') {\n        operatorFilter[id.BKA] = that.filter.operators[name] === true;\n      } else if (upper === 'BKN') {\n        operatorFilter[id.BKN] = that.filter.operators[name] === true;\n      } else if (upper === 'ABG') {\n        operatorFilter[id.ABG] = that.filter.operators[name] === true;\n      } else if (upper === 'AEN') {\n        operatorFilter[id.AEN] = that.filter.operators[name] === true;\n      } else {\n        throw new Error(\n          `${thisFileName}initOpratorFilter: '${name}' not a valid operator name.` +\n            ` Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`\n        );\n      }\n    }\n  };\n  /* filter the rule and `UDT` named operators */\n  const initRuleFilter = function () {\n    const setRules = function (set) {\n      operatorFilter[id.RNM] = set;\n      operatorFilter[id.UDT] = set;\n      const count = rules.length + udts.length;\n      ruleFilter.length = 0;\n      for (let i = 0; i < count; i += 1) {\n        ruleFilter.push(set);\n      }\n    };\n    let items;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    ruleFilter.length = 0;\n    items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.rules) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: default to all rules & udts */\n      setRules(true);\n      return;\n    }\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      if (lower === '<all>') {\n        /* case 2: trace all rules ignore all other rule commands */\n        setRules(true);\n        return;\n      }\n      if (lower === '<none>') {\n        /* case 3: trace no rules */\n        setRules(false);\n        return;\n      }\n    }\n    /* case 4: trace only individually specified rules */\n    setRules(false);\n    operatorFilter[id.RNM] = true;\n    operatorFilter[id.UDT] = true;\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}initRuleFilter: '${name}' not a valid rule or udt name`);\n      }\n      ruleFilter[i] = that.filter.rules[name] === true;\n    }\n  };\n  /* used by other APG components to verify that they have a valid trace object */\n  this.traceObject = 'traceObject';\n  this.filter = {\n    operators: [],\n    rules: [],\n  };\n  // Set the maximum number of records to keep (default = 5000).\n  // Each record number larger than `maxRecords`\n  // will result in deleting the previously oldest record.\n  // - `max`: maximum number of records to retain (default = 5000)\n  // - `last`: last record number to retain, (default = -1 for (unknown) actual last record)\n  this.setMaxRecords = function (max, last) {\n    lastRecord = -1;\n    if (typeof max === 'number' && max > 0) {\n      maxRecords = Math.ceil(max);\n    } else {\n      maxRecords = 0;\n      return;\n    }\n    if (typeof last === 'number') {\n      lastRecord = Math.floor(last);\n      if (lastRecord < 0) {\n        lastRecord = -1;\n      }\n    }\n  };\n  // Returns `maxRecords` to the caller.\n  this.getMaxRecords = function () {\n    return maxRecords;\n  };\n  // Returns `lastRecord` to the caller.\n  this.getLastRecord = function () {\n    return lastRecord;\n  };\n  /* Called only by the `parser.js` object. No verification of input. */\n  this.init = function (rulesIn, udtsIn, charsIn) {\n    records.length = 0;\n    recordStack.length = 0;\n    filteredRecords = 0;\n    treeDepth = 0;\n    chars = charsIn;\n    rules = rulesIn;\n    udts = udtsIn;\n    initOperatorFilter();\n    initRuleFilter();\n    circular.init(maxRecords);\n  };\n  /* returns true if this records passes through the designated filter, false if the record is to be skipped */\n  const filterOps = function (op) {\n    let ret = false;\n    if (op.type === id.RNM) {\n      if (operatorFilter[op.type] && ruleFilter[op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else if (op.type === id.UDT) {\n      if (operatorFilter[op.type] && ruleFilter[rules.length + op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else {\n      ret = operatorFilter[op.type];\n    }\n    return ret;\n  };\n  const filterRecords = function (record) {\n    if (lastRecord === -1) {\n      return true;\n    }\n    if (record <= lastRecord) {\n      return true;\n    }\n    return false;\n  };\n  /* Collect the \"down\" record. */\n  this.down = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      recordStack.push(filteredRecords);\n      records[circular.increment()] = {\n        dirUp: false,\n        depth: treeDepth,\n        thisLine: filteredRecords,\n        thatLine: undefined,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n      treeDepth += 1;\n    }\n  };\n  /* Collect the \"up\" record. */\n  this.up = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      const thisLine = filteredRecords;\n      const thatLine = recordStack.pop();\n      const thatRecord = circular.getListIndex(thatLine);\n      if (thatRecord !== -1) {\n        records[thatRecord].thatLine = thisLine;\n      }\n      treeDepth -= 1;\n      records[circular.increment()] = {\n        dirUp: true,\n        depth: treeDepth,\n        thisLine,\n        thatLine,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n    }\n  };\n  /* convert the trace records to a tree of nodes */\n  const toTreeObj = function () {\n    /* private helper functions */\n    function nodeOpcode(node, opcode) {\n      let name;\n      let casetype;\n      let modetype;\n      if (opcode) {\n        node.op = { id: opcode.type, name: utils.opcodeToString(opcode.type) };\n        node.opData = undefined;\n        switch (opcode.type) {\n          case id.RNM:\n            node.opData = rules[opcode.index].name;\n            break;\n          case id.UDT:\n            node.opData = udts[opcode.index].name;\n            break;\n          case id.BKR:\n            if (opcode.index < rules.length) {\n              name = rules[opcode.index].name;\n            } else {\n              name = udts[opcode.index - rules.length].name;\n            }\n            casetype = opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n            modetype = opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n            node.opData = `\\\\\\\\${casetype}${modetype}${name}`;\n            break;\n          case id.TLS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TBS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TRG:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          case id.REP:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          default:\n            throw new Error('unrecognized opcode');\n        }\n      } else {\n        node.op = { id: undefined, name: undefined };\n        node.opData = undefined;\n      }\n    }\n    function nodePhrase(state, index, length) {\n      if (state === id.MATCH) {\n        return {\n          index,\n          length,\n        };\n      }\n      if (state === id.NOMATCH) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      if (state === id.EMPTY) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      return null;\n    }\n    let nodeId = -1;\n    function nodeDown(parent, record, depth) {\n      const node = {\n        // eslint-disable-next-line no-plusplus\n        id: nodeId++,\n        branch: -1,\n        parent,\n        up: false,\n        down: false,\n        depth,\n        children: [],\n      };\n      if (record) {\n        node.down = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = null;\n        nodeOpcode(node, record.opcode);\n      } else {\n        node.state = { id: undefined, name: undefined };\n        node.phrase = nodePhrase();\n        nodeOpcode(node, undefined);\n      }\n      return node;\n    }\n    function nodeUp(node, record) {\n      if (record) {\n        node.up = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = nodePhrase(record.state, record.phraseIndex, record.phraseLength);\n        if (!node.down) {\n          nodeOpcode(node, record.opcode);\n        }\n      }\n    }\n    /* walk the final tree: label branches and count leaf nodes */\n    let leafNodes = 0;\n    let depth = -1;\n    let branchCount = 1;\n    function walk(node) {\n      depth += 1;\n      node.branch = branchCount;\n      if (depth > treeDepth) {\n        treeDepth = depth;\n      }\n      if (node.children.length === 0) {\n        leafNodes += 1;\n      } else {\n        for (let i = 0; i < node.children.length; i += 1) {\n          if (i > 0) {\n            branchCount += 1;\n          }\n          node.children[i].leftMost = false;\n          node.children[i].rightMost = false;\n          if (node.leftMost) {\n            node.children[i].leftMost = i === 0;\n          }\n          if (node.rightMost) {\n            node.children[i].rightMost = i === node.children.length - 1;\n          }\n          walk(node.children[i]);\n        }\n      }\n      depth -= 1;\n    }\n    function display(node, offset) {\n      let name;\n      const obj = {};\n      obj.id = node.id;\n      obj.branch = node.branch;\n      obj.leftMost = node.leftMost;\n      obj.rightMost = node.rightMost;\n      name = node.state.name ? node.state.name : 'ACTIVE';\n      obj.state = { id: node.state.id, name };\n      name = node.op.name ? node.op.name : '?';\n      obj.op = { id: node.op.id, name };\n      if (typeof node.opData === 'string') {\n        obj.opData = node.opData;\n      } else if (Array.isArray(node.opData)) {\n        obj.opData = [];\n        for (let i = 0; i < node.opData.length; i += 1) {\n          obj.opData[i] = node.opData[i];\n        }\n      } else {\n        obj.opData = undefined;\n      }\n      if (node.phrase) {\n        obj.phrase = { index: node.phrase.index, length: node.phrase.length };\n      } else {\n        obj.phrase = null;\n      }\n      obj.depth = node.depth;\n      obj.children = [];\n      for (let i = 0; i < node.children.length; i += 1) {\n        const c = i !== node.children.length - 1;\n        obj.children[i] = display(node.children[i], offset, c);\n      }\n      return obj;\n    }\n\n    /* construct the tree beginning here */\n    const branch = [];\n    let root;\n    let node;\n    let parent;\n    let record;\n    let firstRecord = true;\n    /* push a dummy node so the root node will have a non-null parent */\n    const dummy = nodeDown(null, null, -1);\n    branch.push(dummy);\n    node = dummy;\n    circular.forEach((lineIndex) => {\n      record = records[lineIndex];\n      if (firstRecord) {\n        firstRecord = false;\n        if (record.depth > 0) {\n          /* push some dummy nodes to fill in for missing records */\n          const num = record.dirUp ? record.depth + 1 : record.depth;\n          for (let i = 0; i < num; i += 1) {\n            parent = node;\n            node = nodeDown(node, null, i);\n            branch.push(node);\n            parent.children.push(node);\n          }\n        }\n      }\n      if (record.dirUp) {\n        /* handle the next record up */\n        node = branch.pop();\n        nodeUp(node, record);\n        node = branch[branch.length - 1];\n      } else {\n        /* handle the next record down */\n        parent = node;\n        node = nodeDown(node, record, record.depth);\n        branch.push(node);\n        parent.children.push(node);\n      }\n    });\n\n    /* if not at root, walk it up to root */\n    while (branch.length > 1) {\n      node = branch.pop();\n      nodeUp(node, null);\n    }\n    /* maybe redundant or paranoid tests: these should never happen */\n    if (dummy.children.length === 0) {\n      throw new Error('trace.toTree(): parse tree has no nodes');\n    }\n    if (branch.length === 0) {\n      throw new Error('trace.toTree(): integrity check: dummy root node disappeared?');\n    }\n\n    /* if no record for start rule: find the pseudo root node (first dummy node above a real node) */\n    root = dummy.children[0];\n    let prev = root;\n    while (root && !root.down && !root.up) {\n      prev = root;\n      root = root.children[0];\n    }\n    root = prev;\n\n    /* walk the tree of nodes: label brances and count leaves */\n    root.leftMost = true;\n    root.rightMost = true;\n    walk(root);\n    root.branch = 0;\n\n    /* generate the exported object */\n    const obj = {};\n    obj.string = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      obj.string[i] = chars[i];\n    }\n    /* generate the exported rule names */\n    obj.rules = [];\n    for (let i = 0; i < rules.length; i += 1) {\n      obj.rules[i] = rules[i].name;\n    }\n    /* generate the exported UDT names */\n    obj.udts = [];\n    for (let i = 0; i < udts.length; i += 1) {\n      obj.udts[i] = udts[i].name;\n    }\n    /* generate the ids */\n    obj.id = {};\n    obj.id.ALT = { id: id.ALT, name: 'ALT' };\n    obj.id.CAT = { id: id.CAT, name: 'CAT' };\n    obj.id.REP = { id: id.REP, name: 'REP' };\n    obj.id.RNM = { id: id.RNM, name: 'RNM' };\n    obj.id.TLS = { id: id.TLS, name: 'TLS' };\n    obj.id.TBS = { id: id.TBS, name: 'TBS' };\n    obj.id.TRG = { id: id.TRG, name: 'TRG' };\n    obj.id.UDT = { id: id.UDT, name: 'UDT' };\n    obj.id.AND = { id: id.AND, name: 'AND' };\n    obj.id.NOT = { id: id.NOT, name: 'NOT' };\n    obj.id.BKR = { id: id.BKR, name: 'BKR' };\n    obj.id.BKA = { id: id.BKA, name: 'BKA' };\n    obj.id.BKN = { id: id.BKN, name: 'BKN' };\n    obj.id.ABG = { id: id.ABG, name: 'ABG' };\n    obj.id.AEN = { id: id.AEN, name: 'AEN' };\n    obj.id.ACTIVE = { id: id.ACTIVE, name: 'ACTIVE' };\n    obj.id.MATCH = { id: id.MATCH, name: 'MATCH' };\n    obj.id.EMPTY = { id: id.EMPTY, name: 'EMPTY' };\n    obj.id.NOMATCH = { id: id.NOMATCH, name: 'NOMATCH' };\n    /* generate the max tree depth */\n    obj.treeDepth = treeDepth;\n    /* generate the number of leaf nodes (branches) */\n    obj.leafNodes = leafNodes;\n    /* generate the types of the left- and right-most branches */\n    let branchesIncomplete;\n    if (root.down) {\n      if (root.up) {\n        branchesIncomplete = 'none';\n      } else {\n        branchesIncomplete = 'right';\n      }\n    } else if (root.up) {\n      branchesIncomplete = 'left';\n    } else {\n      branchesIncomplete = 'both';\n    }\n    obj.branchesIncomplete = branchesIncomplete;\n    obj.tree = display(root, root.depth, false);\n    return obj;\n  };\n  // Returns the trace records as JSON parse tree object.\n  // - stringify: if `true`, the object is 'stringified' before returning, otherwise, the object itself is returned.\n  this.toTree = function (stringify) {\n    const obj = toTreeObj();\n    if (stringify) {\n      return JSON.stringify(obj);\n    }\n    return obj;\n  };\n  // Translate the trace records to HTML format and create a complete HTML page for browser display.\n  this.toHtmlPage = function (mode, caption, title) {\n    return utils.htmlToPage(this.toHtml(mode, caption), title);\n  };\n\n  /* From here on down, these are just helper functions for `toHtml()`. */\n  const htmlHeader = function (mode, caption) {\n    /* open the page */\n    /* write the HTML5 header with table style */\n    /* open the <table> tag */\n    let modeName;\n    switch (mode) {\n      case MODE_HEX:\n        modeName = 'hexadecimal';\n        break;\n      case MODE_DEC:\n        modeName = 'decimal';\n        break;\n      case MODE_ASCII:\n        modeName = 'ASCII';\n        break;\n      case MODE_UNICODE:\n        modeName = 'UNICODE';\n        break;\n      default:\n        throw new Error(`${thisFileName}htmlHeader: unrecognized mode: ${mode}`);\n    }\n    let header = '';\n    header += `<p>display mode: ${modeName}</p>\\n`;\n    header += `<table class=\"${style.CLASS_TRACE}\">\\n`;\n    if (typeof caption === 'string') {\n      header += `<caption>${caption}</caption>`;\n    }\n    return header;\n  };\n  const htmlFooter = function () {\n    let footer = '';\n    /* close the </table> tag */\n    footer += '</table>\\n';\n    /* display a table legend */\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">legend:<br>\\n`;\n    footer += '(a)&nbsp;-&nbsp;line number<br>\\n';\n    footer += '(b)&nbsp;-&nbsp;matching line number<br>\\n';\n    footer += '(c)&nbsp;-&nbsp;phrase offset<br>\\n';\n    footer += '(d)&nbsp;-&nbsp;phrase length<br>\\n';\n    footer += '(e)&nbsp;-&nbsp;tree depth<br>\\n';\n    footer += '(f)&nbsp;-&nbsp;operator state<br>\\n';\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_ACTIVE}\">&darr;</span>&nbsp;&nbsp;phrase opened<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">&uarr;M</span> phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span> empty phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span> phrase not matched<br>\\n`;\n    footer +=\n      'operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>\\n';\n    footer += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${MAX_PHRASE} characters of the phrase being matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">matched characters</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKAHEAD}\">matched characters in look ahead mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKBEHIND}\">matched characters in look behind mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_REMAINDER}\">remainder characters(not yet examined by parser)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_CTRLCHAR}\">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_EMPTY} empty string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_END} end of input string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_CONTINUE} input string display truncated<br>\\n`;\n    footer += '</p>\\n';\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">\\n`;\n    footer += '<sup>&dagger;</sup>original ABNF operators:<br>\\n';\n    footer += 'ALT - alternation<br>\\n';\n    footer += 'CAT - concatenation<br>\\n';\n    footer += 'REP - repetition<br>\\n';\n    footer += 'RNM - rule name<br>\\n';\n    footer += 'TRG - terminal range<br>\\n';\n    footer += 'TLS - terminal literal string (case insensitive)<br>\\n';\n    footer += 'TBS - terminal binary string (case sensitive)<br>\\n';\n    footer += '<br>\\n';\n    footer += '<sup>&Dagger;</sup>super set SABNF operators:<br>\\n';\n    footer += 'UDT - user-defined terminal<br>\\n';\n    footer += 'AND - positive look ahead<br>\\n';\n    footer += 'NOT - negative look ahead<br>\\n';\n    footer += 'BKA - positive look behind<br>\\n';\n    footer += 'BKN - negative look behind<br>\\n';\n    footer += 'BKR - back reference<br>\\n';\n    footer += 'ABG - anchor - begin of input string<br>\\n';\n    footer += 'AEN - anchor - end of input string<br>\\n';\n    footer += '</p>\\n';\n    return footer;\n  };\n  this.indent = function (depth) {\n    let html = '';\n    for (let i = 0; i < depth; i += 1) {\n      html += '.';\n    }\n    return html;\n  };\n  /* format the TRG operator */\n  const displayTrg = function (mode, op) {\n    let html = '';\n    if (op.type === id.TRG) {\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        html += hex;\n        hex = op.max.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += `&ndash;${hex}`;\n      } else {\n        html = `%d${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      }\n    }\n    return html;\n  };\n  /* format the REP operator */\n  const displayRep = function (mode, op) {\n    let html = '';\n    if (op.type === id.REP) {\n      if (mode === MODE_HEX) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html = `x${hex}`;\n        if (op.max < Infinity) {\n          hex = op.max.toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n        } else {\n          hex = 'inf';\n        }\n        html += `&ndash;${hex}`;\n      } else if (op.max < Infinity) {\n        html = `${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      } else {\n        html = `${op.min.toString(10)}&ndash;inf`;\n      }\n    }\n    return html;\n  };\n  /* format the TBS operator */\n  const displayTbs = function (mode, op) {\n    let html = '';\n    if (op.type === id.TBS) {\n      const len = Math.min(op.string.length, MAX_TLS * 2);\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        for (let i = 0; i < len; i += 1) {\n          let hex;\n          if (i > 0) {\n            html += '.';\n          }\n          hex = op.string[i].toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n          html += hex;\n        }\n      } else {\n        html = '%d';\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          html += op.string[i].toString(10);\n        }\n      }\n      if (len < op.string.length) {\n        html += PHRASE_CONTINUE;\n      }\n    }\n    return html;\n  };\n  /* format the TLS operator */\n  const displayTls = function (mode, op) {\n    let html = '';\n    if (op.type === id.TLS) {\n      const len = Math.min(op.string.length, MAX_TLS);\n      if (mode === MODE_HEX || mode === MODE_DEC) {\n        let charu;\n        let charl;\n        let base;\n        if (mode === MODE_HEX) {\n          html = '%x';\n          base = 16;\n        } else {\n          html = '%d';\n          base = 10;\n        }\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          charl = op.string[i];\n          if (charl >= 97 && charl <= 122) {\n            charu = charl - 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else if (charl >= 65 && charl <= 90) {\n            charu = charl;\n            charl += 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else {\n            html += charl.toString(base).toUpperCase();\n          }\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n      } else {\n        html = '\"';\n        for (let i = 0; i < len; i += 1) {\n          html += utils.asciiChars[op.string[i]];\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n        html += '\"';\n      }\n    }\n    return html;\n  };\n  const subPhrase = function (mode, charsArg, index, length, prev) {\n    if (length === 0) {\n      return '';\n    }\n    let phrase = '';\n    const comma = prev ? ',' : '';\n    switch (mode) {\n      case MODE_HEX:\n        phrase = comma + utils.charsToHex(charsArg, index, length);\n        break;\n      case MODE_DEC:\n        if (prev) {\n          return `,${utils.charsToDec(charsArg, index, length)}`;\n        }\n        phrase = comma + utils.charsToDec(charsArg, index, length);\n        break;\n      case MODE_UNICODE:\n        phrase = utils.charsToUnicode(charsArg, index, length);\n        break;\n      case MODE_ASCII:\n      default:\n        phrase = utils.charsToAsciiHtml(charsArg, index, length);\n        break;\n    }\n    return phrase;\n  };\n  /* display phrases matched in look-behind mode */\n  const displayBehind = function (mode, charsArg, state, index, length, anchor) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanBehind = `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.MATCH:\n      case id.ACTIVE:\n        beg1 = index - length;\n        len1 = anchor - beg1;\n        beg2 = anchor;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanBehind;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  const displayForward = function (mode, charsArg, state, index, length, spanAhead) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.ACTIVE:\n        beg1 = index;\n        len1 = 0;\n        beg2 = index;\n        len2 = charsArg.length - beg2;\n        break;\n      case id.MATCH:\n        beg1 = index;\n        len1 = length;\n        beg2 = index + len1;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanAhead;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  /* display phrases matched in look-ahead mode */\n  const displayAhead = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* display phrases matched in normal parsing mode */\n  const displayNone = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_MATCH}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* Returns the filtered records, formatted as an HTML table. */\n  const htmlTable = function (mode) {\n    if (rules === null) {\n      return '';\n    }\n    let html = '';\n    let thisLine;\n    let thatLine;\n    let lookAhead;\n    let lookBehind;\n    let lookAround;\n    let anchor;\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    circular.forEach((lineIndex) => {\n      const line = records[lineIndex];\n      thisLine = line.thisLine;\n      thatLine = line.thatLine !== undefined ? line.thatLine : '--';\n      lookAhead = false;\n      lookBehind = false;\n      lookAround = false;\n      if (line.lookAround === id.LOOKAROUND_AHEAD) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.AND || line.opcode.type === id.NOT) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      if (line.lookAround === id.LOOKAROUND_BEHIND) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.BKA || line.opcode.type === id.BKN) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      html += '<tr>';\n      html += `<td>${thisLine}</td><td>${thatLine}</td>`;\n      html += `<td>${line.phraseIndex}</td>`;\n      html += `<td>${line.phraseLength}</td>`;\n      html += `<td>${line.depth}</td>`;\n      html += '<td>';\n      switch (line.state) {\n        case id.ACTIVE:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">&darr;&nbsp;</span>`;\n          break;\n        case id.MATCH:\n          html += `<span class=\"${style.CLASS_MATCH}\">&uarr;M</span>`;\n          break;\n        case id.NOMATCH:\n          html += `<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span>`;\n          break;\n        case id.EMPTY:\n          html += `<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span>`;\n          break;\n        default:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">--</span>`;\n          break;\n      }\n      html += '</td>';\n      html += '<td>';\n      html += that.indent(line.depth);\n      if (lookAhead) {\n        html += `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n      } else if (lookBehind) {\n        html += `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n      }\n      html += utils.opcodeToString(line.opcode.type);\n      if (line.opcode.type === id.RNM) {\n        html += `(${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.BKR) {\n        const casetype = line.opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n        const modetype = line.opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n        html += `(\\\\${casetype}${modetype}${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.UDT) {\n        html += `(${udts[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.TRG) {\n        html += `(${displayTrg(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TBS) {\n        html += `(${displayTbs(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TLS) {\n        html += `(${displayTls(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.REP) {\n        html += `(${displayRep(mode, line.opcode)}) `;\n      }\n      if (lookAround) {\n        html += '</span>';\n      }\n      html += '</td>';\n      html += '<td>';\n      if (lookBehind) {\n        html += displayBehind(mode, chars, line.state, line.phraseIndex, line.phraseLength, anchor);\n      } else if (lookAhead) {\n        html += displayAhead(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      } else {\n        html += displayNone(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      }\n      html += '</td></tr>\\n';\n    });\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    html += '</table>\\n';\n    return html;\n  };\n  // Translate the trace records to HTML format.\n  // - *modearg* - can be `\"ascii\"`, `\"decimal\"`, `\"hexadecimal\"` or `\"unicode\"`.\n  // Determines the format of the string character code display.\n  // - *caption* - optional caption for the HTML table.\n  this.toHtml = function (modearg, caption) {\n    /* writes the trace records as a table in a complete html page */\n    let mode = MODE_ASCII;\n    if (typeof modearg === 'string' && modearg.length >= 3) {\n      const modein = modearg.toLowerCase().slice(0, 3);\n      if (modein === 'hex') {\n        mode = MODE_HEX;\n      } else if (modein === 'dec') {\n        mode = MODE_DEC;\n      } else if (modein === 'uni') {\n        mode = MODE_UNICODE;\n      }\n    }\n    let html = '';\n    html += htmlHeader(mode, caption);\n    html += htmlTable(mode);\n    html += htmlFooter();\n    return html;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3RyYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDZHQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLHFHQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLHlIQUFtQjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsaUhBQWU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CLFFBQVE7QUFDakUsMENBQTBDLG9CQUFvQixVQUFVO0FBQ3hFLHVDQUF1QyxrQkFBa0IsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvdHJhY2UuanM/ZmUxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cbi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBtZWFucyBvZiB0cmFjaW5nIHRoZSBwYXJzZXIgdGhyb3VnaCB0aGUgcGFyc2UgdHJlZSBhcyBpdCBnb2VzLlxuLy8gSXQgaXMgdGhlIHByaW1hcnkgZGVidWdnaW5nIGZhY2lsaXR5IGZvciBkZWJ1Z2dpbmcgYm90aCB0aGUgU0FCTkYgZ3JhbW1hciBzeW50YXhcbi8vIGFuZCB0aGUgaW5wdXQgc3RyaW5ncyB0aGF0IGFyZSBzdXBwb3NlZCB0byBiZSB2YWxpZCBncmFtbWFyIHNlbnRlbmNlcy5cbi8vIEl0IGlzIGFsc28gYSB2ZXJ5IGluZm9ybWF0aXZlIGFuZCBlZHVjYXRpb25hbCB0b29sIGZvciB1bmRlcnN0YW5kaW5nXG4vLyBob3cgYSBwYXJzZXIgYWN0dWFsbHkgb3BlcmF0ZXMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UuXG4vL1xuLy8gVHJhY2luZyBpcyB0aGUgcHJvY2VzcyBvZiBnZW5lcmF0aW5nIGFuZCBzYXZpbmcgYSByZWNvcmQgb2YgaW5mb3JtYXRpb24gZm9yIGVhY2ggcGFzc2FnZVxuLy8gb2YgdGhlIHBhcnNlciB0aHJvdWdoIGEgcGFyc2UgdHJlZSBub2RlLiBBbmQgc2luY2UgaXQgdHJhdmVyc2VzIGVhY2ggbm9kZSB0d2ljZSwgb25jZSBkb3duIHRoZSB0cmVlXG4vLyBhbmQgb25jZSBjb21pbmcgYmFjayB1cCwgdGhlcmUgYXJlIHR3byByZWNvcmRzIGZvciBlYWNoIG5vZGUuXG4vLyBUaGlzLCBvYnZpb3VzbHksIGhhcyB0aGUgcG90ZW50aWFsIG9mIGdlbmVyYXRpbmcgbG90cyBvZiByZWNvcmRzLlxuLy8gQW5kIHNpbmNlIHRoZXNlIHJlY29yZHMgYXJlIG5vcm1hbGx5IGRpc3BsYXllZCBvbiBhIHdlYiBwYWdlXG4vLyBpdCBpcyBpbXBvcnRhbnQgdG8gaGF2ZSBhIG1lYW5zIHRvIGxpbWl0IHRoZSBhY3R1YWwgbnVtYmVyIG9mIHJlY29yZHMgZ2VuZXJhdGVkIHRvXG4vLyBwcm9iYWJseSBubyBtb3JlIHRoYXQgYSBmZXcgdGhvdXNhbmQuIFRoaXMgaXMgYWxtb3N0IGFsd2F5cyBlbm91Z2ggdG8gZmluZCBhbnkgZXJyb3JzLlxuLy8gVGhlIHByb2JsZW0gaXMgdG8gZ2V0IHRoZSAqcmlnaHQqIGZldyB0aG91c2FuZCByZWNvcmRzLlxuLy8gVGhlcmVmb3JlLCB0aGlzIG1vZHVsZSBoYXMgYSBudW1iZXIgb2Ygd2F5cyBvZiBsaW1pdGluZyBhbmQvb3IgZmlsdGVyaW5nLCB0aGUgbnVtYmVyIGFuZCB0eXBlIG9mIHJlY29yZHMuXG4vLyBDb25zaWRlcmFibGUgZWZmb3J0IGhhcyBiZWVuIG1hZGUgdG8gbWFrZSB0aGlzIGZpbHRlcmluZyBvZiB0aGUgdHJhY2Ugb3V0cHV0IGFzIHNpbXBsZVxuLy8gYW5kIGludHVpdGl2ZSBhcyBwb3NzaWJsZS5cbi8vXG4vLyBIb3dldmVyLCB0aGUgYWJpbGl0eSB0byBmaWx0ZXIgdGhlIHRyYWNlIHJlY29yZHMsIG9yIGZvciB0aGF0IG1hdHRlciBldmVuIHVuZGVyc3RhbmQgd2hhdCB0aGV5IGFyZVxuLy8gYW5kIHRoZSBpbmZvcm1hdGlvbiB0aGV5IGNvbnRhaW4sIGRvZXMgcmVxdWlyZSBhIG1pbmltdW0gYW1vdW50IG9mIHVuZGVyc3RhbmRpbmcgb2YgdGhlIEFQRyBwYXJzaW5nXG4vLyBtZXRob2QuIFRoZSBwYXJzZSB0cmVlIG5vZGVzIGFyZSBhbGwgcmVwcmVzZW50ZWQgYnkgQVBHIG9wZXJhdG9ycy4gVGhleSBicmVhayBkb3duIGludG8gdHdvIG5hdHVyYWwgZ3JvdXBzLlxuLy8gLSBUaGUgYFJOTWAgb3BlcmF0b3JzIGFuZCBgVURUYCBvcGVyYXRvcnMgYXJlIG5hbWVkIHBocmFzZXMuXG4vLyBUaGVzZSBhcmUgbmFtZXMgY2hvc2VuIGJ5IHRoZSB3cml0ZXIgb2YgdGhlIFNBQk5GIGdyYW1tYXIgdG8gcmVwcmVzZW50IHNwZWNpYWwgcGhyYXNlcyBvZiBpbnRlcmVzdC5cbi8vIC0gQWxsIG90aGVycyBjb2xsZWN0LCBjb25jYXRlbmF0ZSBhbmQgb3RoZXJ3aXNlIG1hbmlwdWxhdGUgdmFyaW91cyBpbnRlcm1lZGlhdGUgcGhyYXNlcyBhbG9uZyB0aGUgd2F5LlxuLy9cbi8vIFRoZXJlIGFyZSBzZXBhcmF0ZSBtZWFucyBvZiBmaWx0ZXJpbmcgd2hpY2ggb2YgdGhlc2Ugb3BlcmF0b3JzIGluIGVhY2ggb2YgdGhlc2UgdHdvIGdyb3VwcyBnZXQgdHJhY2VkLlxuLy8gTGV0IGB0cmFjZWAgYmUgYW4gaW5zdGFudGlhdGVkIGB0cmFjZS5qc2Agb2JqZWN0LlxuLy8gUHJpb3IgdG8gcGFyc2luZyB0aGUgc3RyaW5nLCBmaWx0ZXJpbmcgdGhlIHJ1bGVzIGFuZCBVRFRzIGNhbiBiZSBkZWZpbmVkIGFzIGZvbGxvd3M6XG4vLyBgYGBcbi8vIHRyYWNlLmZpbHRlci5ydWxlc1tcInJ1bGVuYW1lXCJdID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBydWxlIG5hbWUgXCJydWxlbmFtZVwiICovXG4vLyB0cmFjZS5maWx0ZXIucnVsZXNbXCJ1ZHRuYW1lXCJdICA9IHRydWU7XG4vLyAgICAgLyogdHJhY2UgVURUIG5hbWUgXCJ1ZHRuYW1lXCIgKi9cbi8vIHRyYWNlLmZpbHRlci5ydWxlc1tcIjxBTEw+XCJdICAgID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBhbGwgcnVsZXMgYW5kIFVEVHMgKHRoZSBkZWZhdWx0KSAqL1xuLy8gdHJhY2UuZmlsdGVyLnJ1bGVzW1wiPE5PTkU+XCJdICAgPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIG5vIHJ1bGVzIG9yIFVEVFMgKi9cbi8vIGBgYFxuLy8gSWYgYW55IHJ1bGUgb3IgVURUIG5hbWUgb3RoZXIgdGhhbiBcIiZsdDtBTEw+XCIgb3IgXCImbHQ7Tk9ORT5cIiBpcyBzcGVjaWZpZWQsIGFsbCBvdGhlciBuYW1lcyBhcmUgdHVybmVkIG9mZi5cbi8vIFRoZXJlZm9yZSwgdG8gYmUgc2VsZWN0aXZlIG9mIHJ1bGUgbmFtZXMsIGEgZmlsdGVyIHN0YXRlbWVudCBpcyByZXF1aXJlZCBmb3IgZWFjaCBydWxlL1VEVCBuYW1lIGRlc2lyZWQuXG4vL1xuLy8gRmlsdGVyaW5nIG9mIHRoZSBvdGhlciBvcGVyYXRvcnMgZm9sbG93cyBhIHNpbWlsYXIgcHJvY2VkdXJlLlxuLy8gYGBgXG4vLyB0cmFjZS5maWx0ZXIub3BlcmF0b3JzW1wiVFJHXCJdID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSB0aGUgdGVybWluYWwgcmFuZ2UsIFRSRywgb3BlcmF0b3JzICovXG4vLyB0cmFjZS5maWx0ZXIub3BlcmF0b3JzW1wiQ0FUXCJdICA9IHRydWU7XG4vLyAgICAgLyogdHJhY2UgdGhlIGNvbmNhdGVuYXRpb25zLCBDQVQsIG9wZXJhdG9ycyAqL1xuLy8gdHJhY2UuZmlsdGVyLm9wZXJhdG9yc1tcIjxBTEw+XCJdICAgID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBhbGwgb3BlcmF0b3JzICovXG4vLyB0cmFjZS5maWx0ZXIub3BlcmF0b3JzW1wiPE5PTkU+XCJdICAgPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIG5vIG9wZXJhdG9ycyAodGhlIGRlZmF1bHQpICovXG4vLyBgYGBcbi8vIElmIGFueSBvcGVyYXRvciBuYW1lIG90aGVyIHRoYW4gXCImbHQ7QUxMPlwiIG9yIFwiJmx0O05PTkU+XCIgaXMgc3BlY2lmaWVkLCBhbGwgb3RoZXIgbmFtZXMgYXJlIHR1cm5lZCBvZmYuXG4vLyBUaGVyZWZvcmUsIHRvIGJlIHNlbGVjdGl2ZSBvZiBvcGVyYXRvciBuYW1lcywgYSBmaWx0ZXIgc3RhdGVtZW50IGlzIHJlcXVpcmVkIGZvciBlYWNoIG5hbWUgZGVzaXJlZC5cbi8vXG4vLyBUaGVyZSBpcywgYWRkaXRpb25hbGx5LCBhIG1lYW5zIGZvciBsaW1pdGluZyB0aGUgdG90YWwgbnVtYmVyIG9mIGZpbHRlcmVkIG9yIHNhdmVkIHRyYWNlIHJlY29yZHMuXG4vLyBTZWUgdGhlIGZ1bmN0aW9uLCBgc2V0TWF4UmVjb3JkcyhtYXgpYCBiZWxvdy4gVGhpcyB3aWxsIHJlc3VsdCBpbiBvbmx5IHRoZSBsYXN0IGBtYXhgIHJlY29yZHMgYmVpbmcgc2F2ZWQuXG4vL1xuLy8gKFNlZSBbYGFwZy1leGFtcGxlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMtZXhhbXBsZXMpIGZvciBleGFtcGxlcyBvZiB1c2luZyBgdHJhY2UuanNgLilcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwb3J0VHJhY2UoKSB7XG4gIGNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcbiAgY29uc3Qgc3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlJyk7XG4gIGNvbnN0IGNpcmN1bGFyID0gbmV3IChyZXF1aXJlKCcuL2NpcmN1bGFyLWJ1ZmZlcicpKSgpO1xuICBjb25zdCBpZCA9IHJlcXVpcmUoJy4vaWRlbnRpZmllcnMnKTtcblxuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAndHJhY2UuanM6ICc7XG4gIGNvbnN0IHRoYXQgPSB0aGlzO1xuICBjb25zdCBNT0RFX0hFWCA9IDE2O1xuICBjb25zdCBNT0RFX0RFQyA9IDEwO1xuICBjb25zdCBNT0RFX0FTQ0lJID0gODtcbiAgY29uc3QgTU9ERV9VTklDT0RFID0gMzI7XG4gIGNvbnN0IE1BWF9QSFJBU0UgPSA4MDtcbiAgY29uc3QgTUFYX1RMUyA9IDU7XG4gIGNvbnN0IHJlY29yZHMgPSBbXTtcbiAgbGV0IG1heFJlY29yZHMgPSA1MDAwO1xuICBsZXQgbGFzdFJlY29yZCA9IC0xO1xuICBsZXQgZmlsdGVyZWRSZWNvcmRzID0gMDtcbiAgbGV0IHRyZWVEZXB0aCA9IDA7XG4gIGNvbnN0IHJlY29yZFN0YWNrID0gW107XG4gIGxldCBjaGFycyA9IG51bGw7XG4gIGxldCBydWxlcyA9IG51bGw7XG4gIGxldCB1ZHRzID0gbnVsbDtcbiAgY29uc3Qgb3BlcmF0b3JGaWx0ZXIgPSBbXTtcbiAgY29uc3QgcnVsZUZpbHRlciA9IFtdO1xuICAvKiBzcGVjaWFsIHRyYWNlIHRhYmxlIHBocmFzZXMgKi9cbiAgY29uc3QgUEhSQVNFX0VORCA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTElORUVORH1cIj4mYnVsbDs8L3NwYW4+YDtcbiAgY29uc3QgUEhSQVNFX0NPTlRJTlVFID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MSU5FRU5EfVwiPiZoZWxsaXA7PC9zcGFuPmA7XG4gIGNvbnN0IFBIUkFTRV9FTVBUWSA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+JiMxMjA2MzQ7PC9zcGFuPmA7XG4gIC8qIGZpbHRlciB0aGUgbm9uLVJOTSAmIG5vbi1VRFQgb3BlcmF0b3JzICovXG4gIGNvbnN0IGluaXRPcGVyYXRvckZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzZXRPcGVyYXRvcnMgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5BTFRdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQ0FUXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlJFUF0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5UTFNdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVEJTXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlRSR10gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5BTkRdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuTk9UXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkJLUl0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5CS0FdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQktOXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFCR10gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5BRU5dID0gc2V0O1xuICAgIH07XG4gICAgbGV0IGl0ZW1zID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIub3BlcmF0b3JzKSB7XG4gICAgICBpdGVtcyArPSAxO1xuICAgIH1cbiAgICBpZiAoaXRlbXMgPT09IDApIHtcbiAgICAgIC8qIGNhc2UgMTogbm8gb3BlcmF0b3JzIHNwZWNpZmllZDogZGVmYXVsdDogZG8gbm90IHRyYWNlIGFueSBvcGVyYXRvcnMgKi9cbiAgICAgIHNldE9wZXJhdG9ycyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGF0LmZpbHRlci5vcGVyYXRvcnMpIHtcbiAgICAgIGNvbnN0IHVwcGVyID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKHVwcGVyID09PSAnPEFMTD4nKSB7XG4gICAgICAgIC8qIGNhc2UgMjogPGFsbD4gb3BlcmF0b3JzIHNwZWNpZmllZDogdHJhY2UgYWxsIG9wZXJhdG9ycyBpZ25vcmUgYWxsIG90aGVyIG9wZXJhdG9yIGNvbW1hbmRzICovXG4gICAgICAgIHNldE9wZXJhdG9ycyh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHVwcGVyID09PSAnPE5PTkU+Jykge1xuICAgICAgICAvKiBjYXNlIDM6IDxub25lPiBvcGVyYXRvcnMgc3BlY2lmaWVkOiB0cmFjZSBOTyBvcGVyYXRvcnMgaWdub3JlIGFsbCBvdGhlciBvcGVyYXRvciBjb21tYW5kcyAqL1xuICAgICAgICBzZXRPcGVyYXRvcnMoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHNldE9wZXJhdG9ycyhmYWxzZSk7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoYXQuZmlsdGVyLm9wZXJhdG9ycykge1xuICAgICAgY29uc3QgdXBwZXIgPSBuYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAvKiBjYXNlIDQ6IG9uZSBvciBtb3JlIGluZGl2aWR1YWwgb3BlcmF0b3JzIHNwZWNpZmllZDogdHJhY2UgJ3RydWUnIG9wZXJhdG9ycyBvbmx5ICovXG4gICAgICBpZiAodXBwZXIgPT09ICdBTFQnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFMVF0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnQ0FUJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5DQVRdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ1JFUCcpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuUkVQXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdBTkQnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFORF0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnTk9UJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5OT1RdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ1RMUycpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVExTXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdUQlMnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlRCU10gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnVFJHJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5UUkddID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ0JLUicpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQktSXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdCS0EnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkJLQV0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnQktOJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5CS05dID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ0FCRycpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQUJHXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdBRU4nKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFFTl0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7dGhpc0ZpbGVOYW1lfWluaXRPcHJhdG9yRmlsdGVyOiAnJHtuYW1lfScgbm90IGEgdmFsaWQgb3BlcmF0b3IgbmFtZS5gICtcbiAgICAgICAgICAgIGAgTXVzdCBiZSA8YWxsPiwgPG5vbmU+LCBhbHQsIGNhdCwgcmVwLCB0bHMsIHRicywgdHJnLCBhbmQsIG5vdCwgYmtyLCBia2Egb3IgYmtuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogZmlsdGVyIHRoZSBydWxlIGFuZCBgVURUYCBuYW1lZCBvcGVyYXRvcnMgKi9cbiAgY29uc3QgaW5pdFJ1bGVGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc2V0UnVsZXMgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5STk1dID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVURUXSA9IHNldDtcbiAgICAgIGNvbnN0IGNvdW50ID0gcnVsZXMubGVuZ3RoICsgdWR0cy5sZW5ndGg7XG4gICAgICBydWxlRmlsdGVyLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgcnVsZUZpbHRlci5wdXNoKHNldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgaXRlbXM7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGlzdC5wdXNoKHJ1bGVzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaCh1ZHRzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgcnVsZUZpbHRlci5sZW5ndGggPSAwO1xuICAgIGl0ZW1zID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIucnVsZXMpIHtcbiAgICAgIGl0ZW1zICs9IDE7XG4gICAgfVxuICAgIGlmIChpdGVtcyA9PT0gMCkge1xuICAgICAgLyogY2FzZSAxOiBkZWZhdWx0IHRvIGFsbCBydWxlcyAmIHVkdHMgKi9cbiAgICAgIHNldFJ1bGVzKHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIucnVsZXMpIHtcbiAgICAgIGNvbnN0IGxvd2VyID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyID09PSAnPGFsbD4nKSB7XG4gICAgICAgIC8qIGNhc2UgMjogdHJhY2UgYWxsIHJ1bGVzIGlnbm9yZSBhbGwgb3RoZXIgcnVsZSBjb21tYW5kcyAqL1xuICAgICAgICBzZXRSdWxlcyh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSAnPG5vbmU+Jykge1xuICAgICAgICAvKiBjYXNlIDM6IHRyYWNlIG5vIHJ1bGVzICovXG4gICAgICAgIHNldFJ1bGVzKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBjYXNlIDQ6IHRyYWNlIG9ubHkgaW5kaXZpZHVhbGx5IHNwZWNpZmllZCBydWxlcyAqL1xuICAgIHNldFJ1bGVzKGZhbHNlKTtcbiAgICBvcGVyYXRvckZpbHRlcltpZC5STk1dID0gdHJ1ZTtcbiAgICBvcGVyYXRvckZpbHRlcltpZC5VRFRdID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIucnVsZXMpIHtcbiAgICAgIGNvbnN0IGxvd2VyID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaSA9IGxpc3QuaW5kZXhPZihsb3dlcik7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1pbml0UnVsZUZpbHRlcjogJyR7bmFtZX0nIG5vdCBhIHZhbGlkIHJ1bGUgb3IgdWR0IG5hbWVgKTtcbiAgICAgIH1cbiAgICAgIHJ1bGVGaWx0ZXJbaV0gPSB0aGF0LmZpbHRlci5ydWxlc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8qIHVzZWQgYnkgb3RoZXIgQVBHIGNvbXBvbmVudHMgdG8gdmVyaWZ5IHRoYXQgdGhleSBoYXZlIGEgdmFsaWQgdHJhY2Ugb2JqZWN0ICovXG4gIHRoaXMudHJhY2VPYmplY3QgPSAndHJhY2VPYmplY3QnO1xuICB0aGlzLmZpbHRlciA9IHtcbiAgICBvcGVyYXRvcnM6IFtdLFxuICAgIHJ1bGVzOiBbXSxcbiAgfTtcbiAgLy8gU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvcmRzIHRvIGtlZXAgKGRlZmF1bHQgPSA1MDAwKS5cbiAgLy8gRWFjaCByZWNvcmQgbnVtYmVyIGxhcmdlciB0aGFuIGBtYXhSZWNvcmRzYFxuICAvLyB3aWxsIHJlc3VsdCBpbiBkZWxldGluZyB0aGUgcHJldmlvdXNseSBvbGRlc3QgcmVjb3JkLlxuICAvLyAtIGBtYXhgOiBtYXhpbXVtIG51bWJlciBvZiByZWNvcmRzIHRvIHJldGFpbiAoZGVmYXVsdCA9IDUwMDApXG4gIC8vIC0gYGxhc3RgOiBsYXN0IHJlY29yZCBudW1iZXIgdG8gcmV0YWluLCAoZGVmYXVsdCA9IC0xIGZvciAodW5rbm93bikgYWN0dWFsIGxhc3QgcmVjb3JkKVxuICB0aGlzLnNldE1heFJlY29yZHMgPSBmdW5jdGlvbiAobWF4LCBsYXN0KSB7XG4gICAgbGFzdFJlY29yZCA9IC0xO1xuICAgIGlmICh0eXBlb2YgbWF4ID09PSAnbnVtYmVyJyAmJiBtYXggPiAwKSB7XG4gICAgICBtYXhSZWNvcmRzID0gTWF0aC5jZWlsKG1heCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFJlY29yZHMgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICBsYXN0UmVjb3JkID0gTWF0aC5mbG9vcihsYXN0KTtcbiAgICAgIGlmIChsYXN0UmVjb3JkIDwgMCkge1xuICAgICAgICBsYXN0UmVjb3JkID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBSZXR1cm5zIGBtYXhSZWNvcmRzYCB0byB0aGUgY2FsbGVyLlxuICB0aGlzLmdldE1heFJlY29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1heFJlY29yZHM7XG4gIH07XG4gIC8vIFJldHVybnMgYGxhc3RSZWNvcmRgIHRvIHRoZSBjYWxsZXIuXG4gIHRoaXMuZ2V0TGFzdFJlY29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbGFzdFJlY29yZDtcbiAgfTtcbiAgLyogQ2FsbGVkIG9ubHkgYnkgdGhlIGBwYXJzZXIuanNgIG9iamVjdC4gTm8gdmVyaWZpY2F0aW9uIG9mIGlucHV0LiAqL1xuICB0aGlzLmluaXQgPSBmdW5jdGlvbiAocnVsZXNJbiwgdWR0c0luLCBjaGFyc0luKSB7XG4gICAgcmVjb3Jkcy5sZW5ndGggPSAwO1xuICAgIHJlY29yZFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgZmlsdGVyZWRSZWNvcmRzID0gMDtcbiAgICB0cmVlRGVwdGggPSAwO1xuICAgIGNoYXJzID0gY2hhcnNJbjtcbiAgICBydWxlcyA9IHJ1bGVzSW47XG4gICAgdWR0cyA9IHVkdHNJbjtcbiAgICBpbml0T3BlcmF0b3JGaWx0ZXIoKTtcbiAgICBpbml0UnVsZUZpbHRlcigpO1xuICAgIGNpcmN1bGFyLmluaXQobWF4UmVjb3Jkcyk7XG4gIH07XG4gIC8qIHJldHVybnMgdHJ1ZSBpZiB0aGlzIHJlY29yZHMgcGFzc2VzIHRocm91Z2ggdGhlIGRlc2lnbmF0ZWQgZmlsdGVyLCBmYWxzZSBpZiB0aGUgcmVjb3JkIGlzIHRvIGJlIHNraXBwZWQgKi9cbiAgY29uc3QgZmlsdGVyT3BzID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgbGV0IHJldCA9IGZhbHNlO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5STk0pIHtcbiAgICAgIGlmIChvcGVyYXRvckZpbHRlcltvcC50eXBlXSAmJiBydWxlRmlsdGVyW29wLmluZGV4XSkge1xuICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcC50eXBlID09PSBpZC5VRFQpIHtcbiAgICAgIGlmIChvcGVyYXRvckZpbHRlcltvcC50eXBlXSAmJiBydWxlRmlsdGVyW3J1bGVzLmxlbmd0aCArIG9wLmluZGV4XSkge1xuICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCA9IG9wZXJhdG9yRmlsdGVyW29wLnR5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICBjb25zdCBmaWx0ZXJSZWNvcmRzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgIGlmIChsYXN0UmVjb3JkID09PSAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZWNvcmQgPD0gbGFzdFJlY29yZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyogQ29sbGVjdCB0aGUgXCJkb3duXCIgcmVjb3JkLiAqL1xuICB0aGlzLmRvd24gPSBmdW5jdGlvbiAob3AsIHN0YXRlLCBvZmZzZXQsIGxlbmd0aCwgYW5jaG9yLCBsb29rQXJvdW5kKSB7XG4gICAgaWYgKGZpbHRlclJlY29yZHMoZmlsdGVyZWRSZWNvcmRzKSAmJiBmaWx0ZXJPcHMob3ApKSB7XG4gICAgICByZWNvcmRTdGFjay5wdXNoKGZpbHRlcmVkUmVjb3Jkcyk7XG4gICAgICByZWNvcmRzW2NpcmN1bGFyLmluY3JlbWVudCgpXSA9IHtcbiAgICAgICAgZGlyVXA6IGZhbHNlLFxuICAgICAgICBkZXB0aDogdHJlZURlcHRoLFxuICAgICAgICB0aGlzTGluZTogZmlsdGVyZWRSZWNvcmRzLFxuICAgICAgICB0aGF0TGluZTogdW5kZWZpbmVkLFxuICAgICAgICBvcGNvZGU6IG9wLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcGhyYXNlSW5kZXg6IG9mZnNldCxcbiAgICAgICAgcGhyYXNlTGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIGxvb2tBbmNob3I6IGFuY2hvcixcbiAgICAgICAgbG9va0Fyb3VuZCxcbiAgICAgIH07XG4gICAgICBmaWx0ZXJlZFJlY29yZHMgKz0gMTtcbiAgICAgIHRyZWVEZXB0aCArPSAxO1xuICAgIH1cbiAgfTtcbiAgLyogQ29sbGVjdCB0aGUgXCJ1cFwiIHJlY29yZC4gKi9cbiAgdGhpcy51cCA9IGZ1bmN0aW9uIChvcCwgc3RhdGUsIG9mZnNldCwgbGVuZ3RoLCBhbmNob3IsIGxvb2tBcm91bmQpIHtcbiAgICBpZiAoZmlsdGVyUmVjb3JkcyhmaWx0ZXJlZFJlY29yZHMpICYmIGZpbHRlck9wcyhvcCkpIHtcbiAgICAgIGNvbnN0IHRoaXNMaW5lID0gZmlsdGVyZWRSZWNvcmRzO1xuICAgICAgY29uc3QgdGhhdExpbmUgPSByZWNvcmRTdGFjay5wb3AoKTtcbiAgICAgIGNvbnN0IHRoYXRSZWNvcmQgPSBjaXJjdWxhci5nZXRMaXN0SW5kZXgodGhhdExpbmUpO1xuICAgICAgaWYgKHRoYXRSZWNvcmQgIT09IC0xKSB7XG4gICAgICAgIHJlY29yZHNbdGhhdFJlY29yZF0udGhhdExpbmUgPSB0aGlzTGluZTtcbiAgICAgIH1cbiAgICAgIHRyZWVEZXB0aCAtPSAxO1xuICAgICAgcmVjb3Jkc1tjaXJjdWxhci5pbmNyZW1lbnQoKV0gPSB7XG4gICAgICAgIGRpclVwOiB0cnVlLFxuICAgICAgICBkZXB0aDogdHJlZURlcHRoLFxuICAgICAgICB0aGlzTGluZSxcbiAgICAgICAgdGhhdExpbmUsXG4gICAgICAgIG9wY29kZTogb3AsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwaHJhc2VJbmRleDogb2Zmc2V0LFxuICAgICAgICBwaHJhc2VMZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgbG9va0FuY2hvcjogYW5jaG9yLFxuICAgICAgICBsb29rQXJvdW5kLFxuICAgICAgfTtcbiAgICAgIGZpbHRlcmVkUmVjb3JkcyArPSAxO1xuICAgIH1cbiAgfTtcbiAgLyogY29udmVydCB0aGUgdHJhY2UgcmVjb3JkcyB0byBhIHRyZWUgb2Ygbm9kZXMgKi9cbiAgY29uc3QgdG9UcmVlT2JqID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIHByaXZhdGUgaGVscGVyIGZ1bmN0aW9ucyAqL1xuICAgIGZ1bmN0aW9uIG5vZGVPcGNvZGUobm9kZSwgb3Bjb2RlKSB7XG4gICAgICBsZXQgbmFtZTtcbiAgICAgIGxldCBjYXNldHlwZTtcbiAgICAgIGxldCBtb2RldHlwZTtcbiAgICAgIGlmIChvcGNvZGUpIHtcbiAgICAgICAgbm9kZS5vcCA9IHsgaWQ6IG9wY29kZS50eXBlLCBuYW1lOiB1dGlscy5vcGNvZGVUb1N0cmluZyhvcGNvZGUudHlwZSkgfTtcbiAgICAgICAgbm9kZS5vcERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN3aXRjaCAob3Bjb2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIGlkLlJOTTpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gcnVsZXNbb3Bjb2RlLmluZGV4XS5uYW1lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5VRFQ6XG4gICAgICAgICAgICBub2RlLm9wRGF0YSA9IHVkdHNbb3Bjb2RlLmluZGV4XS5uYW1lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgICAgICBpZiAob3Bjb2RlLmluZGV4IDwgcnVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBydWxlc1tvcGNvZGUuaW5kZXhdLm5hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lID0gdWR0c1tvcGNvZGUuaW5kZXggLSBydWxlcy5sZW5ndGhdLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNldHlwZSA9IG9wY29kZS5ia3JDYXNlID09PSBpZC5CS1JfTU9ERV9DSSA/ICclaScgOiAnJXMnO1xuICAgICAgICAgICAgbW9kZXR5cGUgPSBvcGNvZGUuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfVU0gPyAnJXUnIDogJyVwJztcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gYFxcXFxcXFxcJHtjYXNldHlwZX0ke21vZGV0eXBlfSR7bmFtZX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgICAgICBub2RlLm9wRGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcGNvZGUuc3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIG5vZGUub3BEYXRhLnB1c2gob3Bjb2RlLnN0cmluZ1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRCUzpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wY29kZS5zdHJpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgbm9kZS5vcERhdGEucHVzaChvcGNvZGUuc3RyaW5nW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVFJHOlxuICAgICAgICAgICAgbm9kZS5vcERhdGEgPSBbb3Bjb2RlLm1pbiwgb3Bjb2RlLm1heF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gW29wY29kZS5taW4sIG9wY29kZS5tYXhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIG9wY29kZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLm9wID0geyBpZDogdW5kZWZpbmVkLCBuYW1lOiB1bmRlZmluZWQgfTtcbiAgICAgICAgbm9kZS5vcERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVQaHJhc2Uoc3RhdGUsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gaWQuTUFUQ0gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsZW5ndGgsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IGlkLkVNUFRZKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBub2RlSWQgPSAtMTtcbiAgICBmdW5jdGlvbiBub2RlRG93bihwYXJlbnQsIHJlY29yZCwgZGVwdGgpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wbHVzcGx1c1xuICAgICAgICBpZDogbm9kZUlkKyssXG4gICAgICAgIGJyYW5jaDogLTEsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgdXA6IGZhbHNlLFxuICAgICAgICBkb3duOiBmYWxzZSxcbiAgICAgICAgZGVwdGgsXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIH07XG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIG5vZGUuZG93biA9IHRydWU7XG4gICAgICAgIG5vZGUuc3RhdGUgPSB7IGlkOiByZWNvcmQuc3RhdGUsIG5hbWU6IHV0aWxzLnN0YXRlVG9TdHJpbmcocmVjb3JkLnN0YXRlKSB9O1xuICAgICAgICBub2RlLnBocmFzZSA9IG51bGw7XG4gICAgICAgIG5vZGVPcGNvZGUobm9kZSwgcmVjb3JkLm9wY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnN0YXRlID0geyBpZDogdW5kZWZpbmVkLCBuYW1lOiB1bmRlZmluZWQgfTtcbiAgICAgICAgbm9kZS5waHJhc2UgPSBub2RlUGhyYXNlKCk7XG4gICAgICAgIG5vZGVPcGNvZGUobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlVXAobm9kZSwgcmVjb3JkKSB7XG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIG5vZGUudXAgPSB0cnVlO1xuICAgICAgICBub2RlLnN0YXRlID0geyBpZDogcmVjb3JkLnN0YXRlLCBuYW1lOiB1dGlscy5zdGF0ZVRvU3RyaW5nKHJlY29yZC5zdGF0ZSkgfTtcbiAgICAgICAgbm9kZS5waHJhc2UgPSBub2RlUGhyYXNlKHJlY29yZC5zdGF0ZSwgcmVjb3JkLnBocmFzZUluZGV4LCByZWNvcmQucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgaWYgKCFub2RlLmRvd24pIHtcbiAgICAgICAgICBub2RlT3Bjb2RlKG5vZGUsIHJlY29yZC5vcGNvZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIHdhbGsgdGhlIGZpbmFsIHRyZWU6IGxhYmVsIGJyYW5jaGVzIGFuZCBjb3VudCBsZWFmIG5vZGVzICovXG4gICAgbGV0IGxlYWZOb2RlcyA9IDA7XG4gICAgbGV0IGRlcHRoID0gLTE7XG4gICAgbGV0IGJyYW5jaENvdW50ID0gMTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGRlcHRoICs9IDE7XG4gICAgICBub2RlLmJyYW5jaCA9IGJyYW5jaENvdW50O1xuICAgICAgaWYgKGRlcHRoID4gdHJlZURlcHRoKSB7XG4gICAgICAgIHRyZWVEZXB0aCA9IGRlcHRoO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGxlYWZOb2RlcyArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBicmFuY2hDb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmxlZnRNb3N0ID0gZmFsc2U7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5yaWdodE1vc3QgPSBmYWxzZTtcbiAgICAgICAgICBpZiAobm9kZS5sZWZ0TW9zdCkge1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5sZWZ0TW9zdCA9IGkgPT09IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlLnJpZ2h0TW9zdCkge1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5yaWdodE1vc3QgPSBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhbGsobm9kZS5jaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlcHRoIC09IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BsYXkobm9kZSwgb2Zmc2V0KSB7XG4gICAgICBsZXQgbmFtZTtcbiAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgb2JqLmlkID0gbm9kZS5pZDtcbiAgICAgIG9iai5icmFuY2ggPSBub2RlLmJyYW5jaDtcbiAgICAgIG9iai5sZWZ0TW9zdCA9IG5vZGUubGVmdE1vc3Q7XG4gICAgICBvYmoucmlnaHRNb3N0ID0gbm9kZS5yaWdodE1vc3Q7XG4gICAgICBuYW1lID0gbm9kZS5zdGF0ZS5uYW1lID8gbm9kZS5zdGF0ZS5uYW1lIDogJ0FDVElWRSc7XG4gICAgICBvYmouc3RhdGUgPSB7IGlkOiBub2RlLnN0YXRlLmlkLCBuYW1lIH07XG4gICAgICBuYW1lID0gbm9kZS5vcC5uYW1lID8gbm9kZS5vcC5uYW1lIDogJz8nO1xuICAgICAgb2JqLm9wID0geyBpZDogbm9kZS5vcC5pZCwgbmFtZSB9O1xuICAgICAgaWYgKHR5cGVvZiBub2RlLm9wRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqLm9wRGF0YSA9IG5vZGUub3BEYXRhO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGUub3BEYXRhKSkge1xuICAgICAgICBvYmoub3BEYXRhID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5vcERhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBvYmoub3BEYXRhW2ldID0gbm9kZS5vcERhdGFbaV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai5vcERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5waHJhc2UpIHtcbiAgICAgICAgb2JqLnBocmFzZSA9IHsgaW5kZXg6IG5vZGUucGhyYXNlLmluZGV4LCBsZW5ndGg6IG5vZGUucGhyYXNlLmxlbmd0aCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqLnBocmFzZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBvYmouZGVwdGggPSBub2RlLmRlcHRoO1xuICAgICAgb2JqLmNoaWxkcmVuID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgYyA9IGkgIT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgb2JqLmNoaWxkcmVuW2ldID0gZGlzcGxheShub2RlLmNoaWxkcmVuW2ldLCBvZmZzZXQsIGMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAvKiBjb25zdHJ1Y3QgdGhlIHRyZWUgYmVnaW5uaW5nIGhlcmUgKi9cbiAgICBjb25zdCBicmFuY2ggPSBbXTtcbiAgICBsZXQgcm9vdDtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgcGFyZW50O1xuICAgIGxldCByZWNvcmQ7XG4gICAgbGV0IGZpcnN0UmVjb3JkID0gdHJ1ZTtcbiAgICAvKiBwdXNoIGEgZHVtbXkgbm9kZSBzbyB0aGUgcm9vdCBub2RlIHdpbGwgaGF2ZSBhIG5vbi1udWxsIHBhcmVudCAqL1xuICAgIGNvbnN0IGR1bW15ID0gbm9kZURvd24obnVsbCwgbnVsbCwgLTEpO1xuICAgIGJyYW5jaC5wdXNoKGR1bW15KTtcbiAgICBub2RlID0gZHVtbXk7XG4gICAgY2lyY3VsYXIuZm9yRWFjaCgobGluZUluZGV4KSA9PiB7XG4gICAgICByZWNvcmQgPSByZWNvcmRzW2xpbmVJbmRleF07XG4gICAgICBpZiAoZmlyc3RSZWNvcmQpIHtcbiAgICAgICAgZmlyc3RSZWNvcmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJlY29yZC5kZXB0aCA+IDApIHtcbiAgICAgICAgICAvKiBwdXNoIHNvbWUgZHVtbXkgbm9kZXMgdG8gZmlsbCBpbiBmb3IgbWlzc2luZyByZWNvcmRzICovXG4gICAgICAgICAgY29uc3QgbnVtID0gcmVjb3JkLmRpclVwID8gcmVjb3JkLmRlcHRoICsgMSA6IHJlY29yZC5kZXB0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bTsgaSArPSAxKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVEb3duKG5vZGUsIG51bGwsIGkpO1xuICAgICAgICAgICAgYnJhbmNoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWNvcmQuZGlyVXApIHtcbiAgICAgICAgLyogaGFuZGxlIHRoZSBuZXh0IHJlY29yZCB1cCAqL1xuICAgICAgICBub2RlID0gYnJhbmNoLnBvcCgpO1xuICAgICAgICBub2RlVXAobm9kZSwgcmVjb3JkKTtcbiAgICAgICAgbm9kZSA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBoYW5kbGUgdGhlIG5leHQgcmVjb3JkIGRvd24gKi9cbiAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGVEb3duKG5vZGUsIHJlY29yZCwgcmVjb3JkLmRlcHRoKTtcbiAgICAgICAgYnJhbmNoLnB1c2gobm9kZSk7XG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogaWYgbm90IGF0IHJvb3QsIHdhbGsgaXQgdXAgdG8gcm9vdCAqL1xuICAgIHdoaWxlIChicmFuY2gubGVuZ3RoID4gMSkge1xuICAgICAgbm9kZSA9IGJyYW5jaC5wb3AoKTtcbiAgICAgIG5vZGVVcChub2RlLCBudWxsKTtcbiAgICB9XG4gICAgLyogbWF5YmUgcmVkdW5kYW50IG9yIHBhcmFub2lkIHRlc3RzOiB0aGVzZSBzaG91bGQgbmV2ZXIgaGFwcGVuICovXG4gICAgaWYgKGR1bW15LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFjZS50b1RyZWUoKTogcGFyc2UgdHJlZSBoYXMgbm8gbm9kZXMnKTtcbiAgICB9XG4gICAgaWYgKGJyYW5jaC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhY2UudG9UcmVlKCk6IGludGVncml0eSBjaGVjazogZHVtbXkgcm9vdCBub2RlIGRpc2FwcGVhcmVkPycpO1xuICAgIH1cblxuICAgIC8qIGlmIG5vIHJlY29yZCBmb3Igc3RhcnQgcnVsZTogZmluZCB0aGUgcHNldWRvIHJvb3Qgbm9kZSAoZmlyc3QgZHVtbXkgbm9kZSBhYm92ZSBhIHJlYWwgbm9kZSkgKi9cbiAgICByb290ID0gZHVtbXkuY2hpbGRyZW5bMF07XG4gICAgbGV0IHByZXYgPSByb290O1xuICAgIHdoaWxlIChyb290ICYmICFyb290LmRvd24gJiYgIXJvb3QudXApIHtcbiAgICAgIHByZXYgPSByb290O1xuICAgICAgcm9vdCA9IHJvb3QuY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIHJvb3QgPSBwcmV2O1xuXG4gICAgLyogd2FsayB0aGUgdHJlZSBvZiBub2RlczogbGFiZWwgYnJhbmNlcyBhbmQgY291bnQgbGVhdmVzICovXG4gICAgcm9vdC5sZWZ0TW9zdCA9IHRydWU7XG4gICAgcm9vdC5yaWdodE1vc3QgPSB0cnVlO1xuICAgIHdhbGsocm9vdCk7XG4gICAgcm9vdC5icmFuY2ggPSAwO1xuXG4gICAgLyogZ2VuZXJhdGUgdGhlIGV4cG9ydGVkIG9iamVjdCAqL1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIG9iai5zdHJpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvYmouc3RyaW5nW2ldID0gY2hhcnNbaV07XG4gICAgfVxuICAgIC8qIGdlbmVyYXRlIHRoZSBleHBvcnRlZCBydWxlIG5hbWVzICovXG4gICAgb2JqLnJ1bGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgb2JqLnJ1bGVzW2ldID0gcnVsZXNbaV0ubmFtZTtcbiAgICB9XG4gICAgLyogZ2VuZXJhdGUgdGhlIGV4cG9ydGVkIFVEVCBuYW1lcyAqL1xuICAgIG9iai51ZHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvYmoudWR0c1tpXSA9IHVkdHNbaV0ubmFtZTtcbiAgICB9XG4gICAgLyogZ2VuZXJhdGUgdGhlIGlkcyAqL1xuICAgIG9iai5pZCA9IHt9O1xuICAgIG9iai5pZC5BTFQgPSB7IGlkOiBpZC5BTFQsIG5hbWU6ICdBTFQnIH07XG4gICAgb2JqLmlkLkNBVCA9IHsgaWQ6IGlkLkNBVCwgbmFtZTogJ0NBVCcgfTtcbiAgICBvYmouaWQuUkVQID0geyBpZDogaWQuUkVQLCBuYW1lOiAnUkVQJyB9O1xuICAgIG9iai5pZC5STk0gPSB7IGlkOiBpZC5STk0sIG5hbWU6ICdSTk0nIH07XG4gICAgb2JqLmlkLlRMUyA9IHsgaWQ6IGlkLlRMUywgbmFtZTogJ1RMUycgfTtcbiAgICBvYmouaWQuVEJTID0geyBpZDogaWQuVEJTLCBuYW1lOiAnVEJTJyB9O1xuICAgIG9iai5pZC5UUkcgPSB7IGlkOiBpZC5UUkcsIG5hbWU6ICdUUkcnIH07XG4gICAgb2JqLmlkLlVEVCA9IHsgaWQ6IGlkLlVEVCwgbmFtZTogJ1VEVCcgfTtcbiAgICBvYmouaWQuQU5EID0geyBpZDogaWQuQU5ELCBuYW1lOiAnQU5EJyB9O1xuICAgIG9iai5pZC5OT1QgPSB7IGlkOiBpZC5OT1QsIG5hbWU6ICdOT1QnIH07XG4gICAgb2JqLmlkLkJLUiA9IHsgaWQ6IGlkLkJLUiwgbmFtZTogJ0JLUicgfTtcbiAgICBvYmouaWQuQktBID0geyBpZDogaWQuQktBLCBuYW1lOiAnQktBJyB9O1xuICAgIG9iai5pZC5CS04gPSB7IGlkOiBpZC5CS04sIG5hbWU6ICdCS04nIH07XG4gICAgb2JqLmlkLkFCRyA9IHsgaWQ6IGlkLkFCRywgbmFtZTogJ0FCRycgfTtcbiAgICBvYmouaWQuQUVOID0geyBpZDogaWQuQUVOLCBuYW1lOiAnQUVOJyB9O1xuICAgIG9iai5pZC5BQ1RJVkUgPSB7IGlkOiBpZC5BQ1RJVkUsIG5hbWU6ICdBQ1RJVkUnIH07XG4gICAgb2JqLmlkLk1BVENIID0geyBpZDogaWQuTUFUQ0gsIG5hbWU6ICdNQVRDSCcgfTtcbiAgICBvYmouaWQuRU1QVFkgPSB7IGlkOiBpZC5FTVBUWSwgbmFtZTogJ0VNUFRZJyB9O1xuICAgIG9iai5pZC5OT01BVENIID0geyBpZDogaWQuTk9NQVRDSCwgbmFtZTogJ05PTUFUQ0gnIH07XG4gICAgLyogZ2VuZXJhdGUgdGhlIG1heCB0cmVlIGRlcHRoICovXG4gICAgb2JqLnRyZWVEZXB0aCA9IHRyZWVEZXB0aDtcbiAgICAvKiBnZW5lcmF0ZSB0aGUgbnVtYmVyIG9mIGxlYWYgbm9kZXMgKGJyYW5jaGVzKSAqL1xuICAgIG9iai5sZWFmTm9kZXMgPSBsZWFmTm9kZXM7XG4gICAgLyogZ2VuZXJhdGUgdGhlIHR5cGVzIG9mIHRoZSBsZWZ0LSBhbmQgcmlnaHQtbW9zdCBicmFuY2hlcyAqL1xuICAgIGxldCBicmFuY2hlc0luY29tcGxldGU7XG4gICAgaWYgKHJvb3QuZG93bikge1xuICAgICAgaWYgKHJvb3QudXApIHtcbiAgICAgICAgYnJhbmNoZXNJbmNvbXBsZXRlID0gJ25vbmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJhbmNoZXNJbmNvbXBsZXRlID0gJ3JpZ2h0JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJvb3QudXApIHtcbiAgICAgIGJyYW5jaGVzSW5jb21wbGV0ZSA9ICdsZWZ0JztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJhbmNoZXNJbmNvbXBsZXRlID0gJ2JvdGgnO1xuICAgIH1cbiAgICBvYmouYnJhbmNoZXNJbmNvbXBsZXRlID0gYnJhbmNoZXNJbmNvbXBsZXRlO1xuICAgIG9iai50cmVlID0gZGlzcGxheShyb290LCByb290LmRlcHRoLCBmYWxzZSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbiAgLy8gUmV0dXJucyB0aGUgdHJhY2UgcmVjb3JkcyBhcyBKU09OIHBhcnNlIHRyZWUgb2JqZWN0LlxuICAvLyAtIHN0cmluZ2lmeTogaWYgYHRydWVgLCB0aGUgb2JqZWN0IGlzICdzdHJpbmdpZmllZCcgYmVmb3JlIHJldHVybmluZywgb3RoZXJ3aXNlLCB0aGUgb2JqZWN0IGl0c2VsZiBpcyByZXR1cm5lZC5cbiAgdGhpcy50b1RyZWUgPSBmdW5jdGlvbiAoc3RyaW5naWZ5KSB7XG4gICAgY29uc3Qgb2JqID0gdG9UcmVlT2JqKCk7XG4gICAgaWYgKHN0cmluZ2lmeSkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG4gIC8vIFRyYW5zbGF0ZSB0aGUgdHJhY2UgcmVjb3JkcyB0byBIVE1MIGZvcm1hdCBhbmQgY3JlYXRlIGEgY29tcGxldGUgSFRNTCBwYWdlIGZvciBicm93c2VyIGRpc3BsYXkuXG4gIHRoaXMudG9IdG1sUGFnZSA9IGZ1bmN0aW9uIChtb2RlLCBjYXB0aW9uLCB0aXRsZSkge1xuICAgIHJldHVybiB1dGlscy5odG1sVG9QYWdlKHRoaXMudG9IdG1sKG1vZGUsIGNhcHRpb24pLCB0aXRsZSk7XG4gIH07XG5cbiAgLyogRnJvbSBoZXJlIG9uIGRvd24sIHRoZXNlIGFyZSBqdXN0IGhlbHBlciBmdW5jdGlvbnMgZm9yIGB0b0h0bWwoKWAuICovXG4gIGNvbnN0IGh0bWxIZWFkZXIgPSBmdW5jdGlvbiAobW9kZSwgY2FwdGlvbikge1xuICAgIC8qIG9wZW4gdGhlIHBhZ2UgKi9cbiAgICAvKiB3cml0ZSB0aGUgSFRNTDUgaGVhZGVyIHdpdGggdGFibGUgc3R5bGUgKi9cbiAgICAvKiBvcGVuIHRoZSA8dGFibGU+IHRhZyAqL1xuICAgIGxldCBtb2RlTmFtZTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgTU9ERV9IRVg6XG4gICAgICAgIG1vZGVOYW1lID0gJ2hleGFkZWNpbWFsJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfREVDOlxuICAgICAgICBtb2RlTmFtZSA9ICdkZWNpbWFsJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfQVNDSUk6XG4gICAgICAgIG1vZGVOYW1lID0gJ0FTQ0lJJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfVU5JQ09ERTpcbiAgICAgICAgbW9kZU5hbWUgPSAnVU5JQ09ERSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1odG1sSGVhZGVyOiB1bnJlY29nbml6ZWQgbW9kZTogJHttb2RlfWApO1xuICAgIH1cbiAgICBsZXQgaGVhZGVyID0gJyc7XG4gICAgaGVhZGVyICs9IGA8cD5kaXNwbGF5IG1vZGU6ICR7bW9kZU5hbWV9PC9wPlxcbmA7XG4gICAgaGVhZGVyICs9IGA8dGFibGUgY2xhc3M9XCIke3N0eWxlLkNMQVNTX1RSQUNFfVwiPlxcbmA7XG4gICAgaWYgKHR5cGVvZiBjYXB0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgaGVhZGVyICs9IGA8Y2FwdGlvbj4ke2NhcHRpb259PC9jYXB0aW9uPmA7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXI7XG4gIH07XG4gIGNvbnN0IGh0bWxGb290ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGZvb3RlciA9ICcnO1xuICAgIC8qIGNsb3NlIHRoZSA8L3RhYmxlPiB0YWcgKi9cbiAgICBmb290ZXIgKz0gJzwvdGFibGU+XFxuJztcbiAgICAvKiBkaXNwbGF5IGEgdGFibGUgbGVnZW5kICovXG4gICAgZm9vdGVyICs9IGA8cCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTU9OT1NQQUNFfVwiPmxlZ2VuZDo8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gJyhhKSZuYnNwOy0mbmJzcDtsaW5lIG51bWJlcjxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnKGIpJm5ic3A7LSZuYnNwO21hdGNoaW5nIGxpbmUgbnVtYmVyPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICcoYykmbmJzcDstJm5ic3A7cGhyYXNlIG9mZnNldDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnKGQpJm5ic3A7LSZuYnNwO3BocmFzZSBsZW5ndGg8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJyhlKSZuYnNwOy0mbmJzcDt0cmVlIGRlcHRoPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICcoZikmbmJzcDstJm5ic3A7b3BlcmF0b3Igc3RhdGU8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDs8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiZkYXJyOzwvc3Bhbj4mbmJzcDsmbmJzcDtwaHJhc2Ugb3BlbmVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPiZ1YXJyO008L3NwYW4+IHBocmFzZSBtYXRjaGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiZ1YXJyO0U8L3NwYW4+IGVtcHR5IHBocmFzZSBtYXRjaGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+JnVhcnI7Tjwvc3Bhbj4gcGhyYXNlIG5vdCBtYXRjaGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9XG4gICAgICAnb3BlcmF0b3ImbmJzcDstJm5ic3A7QUxULCBDQVQsIFJFUCwgUk5NLCBUUkcsIFRMUywgVEJTPHN1cD4mZGFnZ2VyOzwvc3VwPiwgVURULCBBTkQsIE5PVCwgQktBLCBCS04sIEJLUiwgQUJHLCBBRU48c3VwPiZEYWdnZXI7PC9zdXA+PGJyPlxcbic7XG4gICAgZm9vdGVyICs9IGBwaHJhc2UmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7dXAgdG8gJHtNQVhfUEhSQVNFfSBjaGFyYWN0ZXJzIG9mIHRoZSBwaHJhc2UgYmVpbmcgbWF0Y2hlZDxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj5tYXRjaGVkIGNoYXJhY3RlcnM8L3NwYW4+PGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0xPT0tBSEVBRH1cIj5tYXRjaGVkIGNoYXJhY3RlcnMgaW4gbG9vayBhaGVhZCBtb2RlPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQkVISU5EfVwiPm1hdGNoZWQgY2hhcmFjdGVycyBpbiBsb29rIGJlaGluZCBtb2RlPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19SRU1BSU5ERVJ9XCI+cmVtYWluZGVyIGNoYXJhY3RlcnMobm90IHlldCBleGFtaW5lZCBieSBwYXJzZXIpPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19DVFJMQ0hBUn1cIj5jb250cm9sIGNoYXJhY3RlcnMsIFRBQiwgTEYsIENSLCBldGMuIChBU0NJSSBtb2RlIG9ubHkpPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOyR7UEhSQVNFX0VNUFRZfSBlbXB0eSBzdHJpbmc8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDske1BIUkFTRV9FTkR9IGVuZCBvZiBpbnB1dCBzdHJpbmc8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDske1BIUkFTRV9DT05USU5VRX0gaW5wdXQgc3RyaW5nIGRpc3BsYXkgdHJ1bmNhdGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9ICc8L3A+XFxuJztcbiAgICBmb290ZXIgKz0gYDxwIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NT05PU1BBQ0V9XCI+XFxuYDtcbiAgICBmb290ZXIgKz0gJzxzdXA+JmRhZ2dlcjs8L3N1cD5vcmlnaW5hbCBBQk5GIG9wZXJhdG9yczo8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0FMVCAtIGFsdGVybmF0aW9uPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdDQVQgLSBjb25jYXRlbmF0aW9uPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdSRVAgLSByZXBldGl0aW9uPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdSTk0gLSBydWxlIG5hbWU8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1RSRyAtIHRlcm1pbmFsIHJhbmdlPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdUTFMgLSB0ZXJtaW5hbCBsaXRlcmFsIHN0cmluZyAoY2FzZSBpbnNlbnNpdGl2ZSk8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1RCUyAtIHRlcm1pbmFsIGJpbmFyeSBzdHJpbmcgKGNhc2Ugc2Vuc2l0aXZlKTxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICc8c3VwPiZEYWdnZXI7PC9zdXA+c3VwZXIgc2V0IFNBQk5GIG9wZXJhdG9yczo8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1VEVCAtIHVzZXItZGVmaW5lZCB0ZXJtaW5hbDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQU5EIC0gcG9zaXRpdmUgbG9vayBhaGVhZDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnTk9UIC0gbmVnYXRpdmUgbG9vayBhaGVhZDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQktBIC0gcG9zaXRpdmUgbG9vayBiZWhpbmQ8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0JLTiAtIG5lZ2F0aXZlIGxvb2sgYmVoaW5kPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdCS1IgLSBiYWNrIHJlZmVyZW5jZTxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQUJHIC0gYW5jaG9yIC0gYmVnaW4gb2YgaW5wdXQgc3RyaW5nPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdBRU4gLSBhbmNob3IgLSBlbmQgb2YgaW5wdXQgc3RyaW5nPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICc8L3A+XFxuJztcbiAgICByZXR1cm4gZm9vdGVyO1xuICB9O1xuICB0aGlzLmluZGVudCA9IGZ1bmN0aW9uIChkZXB0aCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXB0aDsgaSArPSAxKSB7XG4gICAgICBodG1sICs9ICcuJztcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGZvcm1hdCB0aGUgVFJHIG9wZXJhdG9yICovXG4gIGNvbnN0IGRpc3BsYXlUcmcgPSBmdW5jdGlvbiAobW9kZSwgb3ApIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5UUkcpIHtcbiAgICAgIGlmIChtb2RlID09PSBNT0RFX0hFWCB8fCBtb2RlID09PSBNT0RFX1VOSUNPREUpIHtcbiAgICAgICAgbGV0IGhleCA9IG9wLm1pbi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gbW9kZSA9PT0gTU9ERV9IRVggPyAnJXgnIDogJ1UrJztcbiAgICAgICAgaHRtbCArPSBoZXg7XG4gICAgICAgIGhleCA9IG9wLm1heC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gYCZuZGFzaDske2hleH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9IGAlZCR7b3AubWluLnRvU3RyaW5nKDEwKX0mbmRhc2g7JHtvcC5tYXgudG9TdHJpbmcoMTApfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBmb3JtYXQgdGhlIFJFUCBvcGVyYXRvciAqL1xuICBjb25zdCBkaXNwbGF5UmVwID0gZnVuY3Rpb24gKG1vZGUsIG9wKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBpZiAob3AudHlwZSA9PT0gaWQuUkVQKSB7XG4gICAgICBpZiAobW9kZSA9PT0gTU9ERV9IRVgpIHtcbiAgICAgICAgbGV0IGhleCA9IG9wLm1pbi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgPSBgeCR7aGV4fWA7XG4gICAgICAgIGlmIChvcC5tYXggPCBJbmZpbml0eSkge1xuICAgICAgICAgIGhleCA9IG9wLm1heC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGV4ID0gJ2luZic7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBgJm5kYXNoOyR7aGV4fWA7XG4gICAgICB9IGVsc2UgaWYgKG9wLm1heCA8IEluZmluaXR5KSB7XG4gICAgICAgIGh0bWwgPSBgJHtvcC5taW4udG9TdHJpbmcoMTApfSZuZGFzaDske29wLm1heC50b1N0cmluZygxMCl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSBgJHtvcC5taW4udG9TdHJpbmcoMTApfSZuZGFzaDtpbmZgO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogZm9ybWF0IHRoZSBUQlMgb3BlcmF0b3IgKi9cbiAgY29uc3QgZGlzcGxheVRicyA9IGZ1bmN0aW9uIChtb2RlLCBvcCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaWYgKG9wLnR5cGUgPT09IGlkLlRCUykge1xuICAgICAgY29uc3QgbGVuID0gTWF0aC5taW4ob3Auc3RyaW5nLmxlbmd0aCwgTUFYX1RMUyAqIDIpO1xuICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEVYIHx8IG1vZGUgPT09IE1PREVfVU5JQ09ERSkge1xuICAgICAgICBodG1sICs9IG1vZGUgPT09IE1PREVfSEVYID8gJyV4JyA6ICdVKyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBsZXQgaGV4O1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaHRtbCArPSAnLic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhleCA9IG9wLnN0cmluZ1tpXS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbCArPSBoZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSAnJWQnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBodG1sICs9ICcuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbCArPSBvcC5zdHJpbmdbaV0udG9TdHJpbmcoMTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGVuIDwgb3Auc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICBodG1sICs9IFBIUkFTRV9DT05USU5VRTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGZvcm1hdCB0aGUgVExTIG9wZXJhdG9yICovXG4gIGNvbnN0IGRpc3BsYXlUbHMgPSBmdW5jdGlvbiAobW9kZSwgb3ApIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5UTFMpIHtcbiAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKG9wLnN0cmluZy5sZW5ndGgsIE1BWF9UTFMpO1xuICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEVYIHx8IG1vZGUgPT09IE1PREVfREVDKSB7XG4gICAgICAgIGxldCBjaGFydTtcbiAgICAgICAgbGV0IGNoYXJsO1xuICAgICAgICBsZXQgYmFzZTtcbiAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEVYKSB7XG4gICAgICAgICAgaHRtbCA9ICcleCc7XG4gICAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGh0bWwgPSAnJWQnO1xuICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBodG1sICs9ICcuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhcmwgPSBvcC5zdHJpbmdbaV07XG4gICAgICAgICAgaWYgKGNoYXJsID49IDk3ICYmIGNoYXJsIDw9IDEyMikge1xuICAgICAgICAgICAgY2hhcnUgPSBjaGFybCAtIDMyO1xuICAgICAgICAgICAgaHRtbCArPSBgJHtjaGFydS50b1N0cmluZyhiYXNlKX0vJHtjaGFybC50b1N0cmluZyhiYXNlKX1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFybCA+PSA2NSAmJiBjaGFybCA8PSA5MCkge1xuICAgICAgICAgICAgY2hhcnUgPSBjaGFybDtcbiAgICAgICAgICAgIGNoYXJsICs9IDMyO1xuICAgICAgICAgICAgaHRtbCArPSBgJHtjaGFydS50b1N0cmluZyhiYXNlKX0vJHtjaGFybC50b1N0cmluZyhiYXNlKX1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWwgKz0gY2hhcmwudG9TdHJpbmcoYmFzZSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA8IG9wLnN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICBodG1sICs9IFBIUkFTRV9DT05USU5VRTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9ICdcIic7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBodG1sICs9IHV0aWxzLmFzY2lpQ2hhcnNbb3Auc3RyaW5nW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuIDwgb3Auc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIGh0bWwgKz0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gJ1wiJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIGNvbnN0IHN1YlBocmFzZSA9IGZ1bmN0aW9uIChtb2RlLCBjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCwgcHJldikge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IHBocmFzZSA9ICcnO1xuICAgIGNvbnN0IGNvbW1hID0gcHJldiA/ICcsJyA6ICcnO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBNT0RFX0hFWDpcbiAgICAgICAgcGhyYXNlID0gY29tbWEgKyB1dGlscy5jaGFyc1RvSGV4KGNoYXJzQXJnLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfREVDOlxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIHJldHVybiBgLCR7dXRpbHMuY2hhcnNUb0RlYyhjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCl9YDtcbiAgICAgICAgfVxuICAgICAgICBwaHJhc2UgPSBjb21tYSArIHV0aWxzLmNoYXJzVG9EZWMoY2hhcnNBcmcsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTU9ERV9VTklDT0RFOlxuICAgICAgICBwaHJhc2UgPSB1dGlscy5jaGFyc1RvVW5pY29kZShjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNT0RFX0FTQ0lJOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcGhyYXNlID0gdXRpbHMuY2hhcnNUb0FzY2lpSHRtbChjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcGhyYXNlO1xuICB9O1xuICAvKiBkaXNwbGF5IHBocmFzZXMgbWF0Y2hlZCBpbiBsb29rLWJlaGluZCBtb2RlICovXG4gIGNvbnN0IGRpc3BsYXlCZWhpbmQgPSBmdW5jdGlvbiAobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBhbmNob3IpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGxldCBiZWcxO1xuICAgIGxldCBsZW4xO1xuICAgIGxldCBiZWcyO1xuICAgIGxldCBsZW4yO1xuICAgIGxldCBsYXN0Y2hhciA9IFBIUkFTRV9FTkQ7XG4gICAgY29uc3Qgc3BhbkJlaGluZCA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTE9PS0JFSElORH1cIj5gO1xuICAgIGNvbnN0IHNwYW5SZW1haW5kZXIgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX1JFTUFJTkRFUn1cIj5gO1xuICAgIGNvbnN0IHNwYW5lbmQgPSAnPC9zcGFuPic7XG4gICAgbGV0IHByZXYgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBodG1sICs9IFBIUkFTRV9FTVBUWTtcbiAgICAgIC8qIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBiZWcxID0gaW5kZXggLSBsZW5ndGg7XG4gICAgICAgIGxlbjEgPSBhbmNob3IgLSBiZWcxO1xuICAgICAgICBiZWcyID0gYW5jaG9yO1xuICAgICAgICBsZW4yID0gY2hhcnNBcmcubGVuZ3RoIC0gYmVnMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBzdGF0ZScpO1xuICAgIH1cbiAgICBsYXN0Y2hhciA9IFBIUkFTRV9FTkQ7XG4gICAgaWYgKGxlbjEgPiBNQVhfUEhSQVNFKSB7XG4gICAgICBsZW4xID0gTUFYX1BIUkFTRTtcbiAgICAgIGxhc3RjaGFyID0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgbGVuMiA9IDA7XG4gICAgfSBlbHNlIGlmIChsZW4xICsgbGVuMiA+IE1BWF9QSFJBU0UpIHtcbiAgICAgIGxhc3RjaGFyID0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgbGVuMiA9IE1BWF9QSFJBU0UgLSBsZW4xO1xuICAgIH1cbiAgICBpZiAobGVuMSA+IDApIHtcbiAgICAgIGh0bWwgKz0gc3BhbkJlaGluZDtcbiAgICAgIGh0bWwgKz0gc3ViUGhyYXNlKG1vZGUsIGNoYXJzQXJnLCBiZWcxLCBsZW4xLCBwcmV2KTtcbiAgICAgIGh0bWwgKz0gc3BhbmVuZDtcbiAgICAgIHByZXYgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobGVuMiA+IDApIHtcbiAgICAgIGh0bWwgKz0gc3BhblJlbWFpbmRlcjtcbiAgICAgIGh0bWwgKz0gc3ViUGhyYXNlKG1vZGUsIGNoYXJzQXJnLCBiZWcyLCBsZW4yLCBwcmV2KTtcbiAgICAgIGh0bWwgKz0gc3BhbmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWwgKyBsYXN0Y2hhcjtcbiAgfTtcbiAgY29uc3QgZGlzcGxheUZvcndhcmQgPSBmdW5jdGlvbiAobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBzcGFuQWhlYWQpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGxldCBiZWcxO1xuICAgIGxldCBsZW4xO1xuICAgIGxldCBiZWcyO1xuICAgIGxldCBsZW4yO1xuICAgIGxldCBsYXN0Y2hhciA9IFBIUkFTRV9FTkQ7XG4gICAgY29uc3Qgc3BhblJlbWFpbmRlciA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfUkVNQUlOREVSfVwiPmA7XG4gICAgY29uc3Qgc3BhbmVuZCA9ICc8L3NwYW4+JztcbiAgICBsZXQgcHJldiA9IGZhbHNlO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGh0bWwgKz0gUEhSQVNFX0VNUFRZO1xuICAgICAgLyogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYmVnMSA9IGluZGV4O1xuICAgICAgICBsZW4xID0gMDtcbiAgICAgICAgYmVnMiA9IGluZGV4O1xuICAgICAgICBsZW4yID0gY2hhcnNBcmcubGVuZ3RoIC0gYmVnMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBiZWcxID0gaW5kZXg7XG4gICAgICAgIGxlbjEgPSBsZW5ndGg7XG4gICAgICAgIGJlZzIgPSBpbmRleCArIGxlbjE7XG4gICAgICAgIGxlbjIgPSBjaGFyc0FyZy5sZW5ndGggLSBiZWcyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHN0YXRlJyk7XG4gICAgfVxuICAgIGxhc3RjaGFyID0gUEhSQVNFX0VORDtcbiAgICBpZiAobGVuMSA+IE1BWF9QSFJBU0UpIHtcbiAgICAgIGxlbjEgPSBNQVhfUEhSQVNFO1xuICAgICAgbGFzdGNoYXIgPSBQSFJBU0VfQ09OVElOVUU7XG4gICAgICBsZW4yID0gMDtcbiAgICB9IGVsc2UgaWYgKGxlbjEgKyBsZW4yID4gTUFYX1BIUkFTRSkge1xuICAgICAgbGFzdGNoYXIgPSBQSFJBU0VfQ09OVElOVUU7XG4gICAgICBsZW4yID0gTUFYX1BIUkFTRSAtIGxlbjE7XG4gICAgfVxuICAgIGlmIChsZW4xID4gMCkge1xuICAgICAgaHRtbCArPSBzcGFuQWhlYWQ7XG4gICAgICBodG1sICs9IHN1YlBocmFzZShtb2RlLCBjaGFyc0FyZywgYmVnMSwgbGVuMSwgcHJldik7XG4gICAgICBodG1sICs9IHNwYW5lbmQ7XG4gICAgICBwcmV2ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxlbjIgPiAwKSB7XG4gICAgICBodG1sICs9IHNwYW5SZW1haW5kZXI7XG4gICAgICBodG1sICs9IHN1YlBocmFzZShtb2RlLCBjaGFyc0FyZywgYmVnMiwgbGVuMiwgcHJldik7XG4gICAgICBodG1sICs9IHNwYW5lbmQ7XG4gICAgfVxuICAgIHJldHVybiBodG1sICsgbGFzdGNoYXI7XG4gIH07XG4gIC8qIGRpc3BsYXkgcGhyYXNlcyBtYXRjaGVkIGluIGxvb2stYWhlYWQgbW9kZSAqL1xuICBjb25zdCBkaXNwbGF5QWhlYWQgPSBmdW5jdGlvbiAobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgY29uc3Qgc3BhbkFoZWFkID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQUhFQUR9XCI+YDtcbiAgICByZXR1cm4gZGlzcGxheUZvcndhcmQobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBzcGFuQWhlYWQpO1xuICB9O1xuICAvKiBkaXNwbGF5IHBocmFzZXMgbWF0Y2hlZCBpbiBub3JtYWwgcGFyc2luZyBtb2RlICovXG4gIGNvbnN0IGRpc3BsYXlOb25lID0gZnVuY3Rpb24gKG1vZGUsIGNoYXJzQXJnLCBzdGF0ZSwgaW5kZXgsIGxlbmd0aCkge1xuICAgIGNvbnN0IHNwYW5BaGVhZCA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+YDtcbiAgICByZXR1cm4gZGlzcGxheUZvcndhcmQobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBzcGFuQWhlYWQpO1xuICB9O1xuICAvKiBSZXR1cm5zIHRoZSBmaWx0ZXJlZCByZWNvcmRzLCBmb3JtYXR0ZWQgYXMgYW4gSFRNTCB0YWJsZS4gKi9cbiAgY29uc3QgaHRtbFRhYmxlID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICBpZiAocnVsZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBsZXQgdGhpc0xpbmU7XG4gICAgbGV0IHRoYXRMaW5lO1xuICAgIGxldCBsb29rQWhlYWQ7XG4gICAgbGV0IGxvb2tCZWhpbmQ7XG4gICAgbGV0IGxvb2tBcm91bmQ7XG4gICAgbGV0IGFuY2hvcjtcbiAgICBodG1sICs9ICc8dHI+PHRoPihhKTwvdGg+PHRoPihiKTwvdGg+PHRoPihjKTwvdGg+PHRoPihkKTwvdGg+PHRoPihlKTwvdGg+PHRoPihmKTwvdGg+JztcbiAgICBodG1sICs9ICc8dGg+b3BlcmF0b3I8L3RoPjx0aD5waHJhc2U8L3RoPjwvdHI+XFxuJztcbiAgICBjaXJjdWxhci5mb3JFYWNoKChsaW5lSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGxpbmUgPSByZWNvcmRzW2xpbmVJbmRleF07XG4gICAgICB0aGlzTGluZSA9IGxpbmUudGhpc0xpbmU7XG4gICAgICB0aGF0TGluZSA9IGxpbmUudGhhdExpbmUgIT09IHVuZGVmaW5lZCA/IGxpbmUudGhhdExpbmUgOiAnLS0nO1xuICAgICAgbG9va0FoZWFkID0gZmFsc2U7XG4gICAgICBsb29rQmVoaW5kID0gZmFsc2U7XG4gICAgICBsb29rQXJvdW5kID0gZmFsc2U7XG4gICAgICBpZiAobGluZS5sb29rQXJvdW5kID09PSBpZC5MT09LQVJPVU5EX0FIRUFEKSB7XG4gICAgICAgIGxvb2tBaGVhZCA9IHRydWU7XG4gICAgICAgIGxvb2tBcm91bmQgPSB0cnVlO1xuICAgICAgICBhbmNob3IgPSBsaW5lLmxvb2tBbmNob3I7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuQU5EIHx8IGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLk5PVCkge1xuICAgICAgICBsb29rQWhlYWQgPSB0cnVlO1xuICAgICAgICBsb29rQXJvdW5kID0gdHJ1ZTtcbiAgICAgICAgYW5jaG9yID0gbGluZS5waHJhc2VJbmRleDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLmxvb2tBcm91bmQgPT09IGlkLkxPT0tBUk9VTkRfQkVISU5EKSB7XG4gICAgICAgIGxvb2tCZWhpbmQgPSB0cnVlO1xuICAgICAgICBsb29rQXJvdW5kID0gdHJ1ZTtcbiAgICAgICAgYW5jaG9yID0gbGluZS5sb29rQW5jaG9yO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLkJLQSB8fCBsaW5lLm9wY29kZS50eXBlID09PSBpZC5CS04pIHtcbiAgICAgICAgbG9va0JlaGluZCA9IHRydWU7XG4gICAgICAgIGxvb2tBcm91bmQgPSB0cnVlO1xuICAgICAgICBhbmNob3IgPSBsaW5lLnBocmFzZUluZGV4O1xuICAgICAgfVxuICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICBodG1sICs9IGA8dGQ+JHt0aGlzTGluZX08L3RkPjx0ZD4ke3RoYXRMaW5lfTwvdGQ+YDtcbiAgICAgIGh0bWwgKz0gYDx0ZD4ke2xpbmUucGhyYXNlSW5kZXh9PC90ZD5gO1xuICAgICAgaHRtbCArPSBgPHRkPiR7bGluZS5waHJhc2VMZW5ndGh9PC90ZD5gO1xuICAgICAgaHRtbCArPSBgPHRkPiR7bGluZS5kZXB0aH08L3RkPmA7XG4gICAgICBodG1sICs9ICc8dGQ+JztcbiAgICAgIHN3aXRjaCAobGluZS5zdGF0ZSkge1xuICAgICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiZkYXJyOyZuYnNwOzwvc3Bhbj5gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj4mdWFycjtNPC9zcGFuPmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4mdWFycjtOPC9zcGFuPmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiZ1YXJyO0U8L3NwYW4+YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPi0tPC9zcGFuPmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBodG1sICs9ICc8L3RkPic7XG4gICAgICBodG1sICs9ICc8dGQ+JztcbiAgICAgIGh0bWwgKz0gdGhhdC5pbmRlbnQobGluZS5kZXB0aCk7XG4gICAgICBpZiAobG9va0FoZWFkKSB7XG4gICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQUhFQUR9XCI+YDtcbiAgICAgIH0gZWxzZSBpZiAobG9va0JlaGluZCkge1xuICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTE9PS0JFSElORH1cIj5gO1xuICAgICAgfVxuICAgICAgaHRtbCArPSB1dGlscy5vcGNvZGVUb1N0cmluZyhsaW5lLm9wY29kZS50eXBlKTtcbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5STk0pIHtcbiAgICAgICAgaHRtbCArPSBgKCR7cnVsZXNbbGluZS5vcGNvZGUuaW5kZXhdLm5hbWV9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLkJLUikge1xuICAgICAgICBjb25zdCBjYXNldHlwZSA9IGxpbmUub3Bjb2RlLmJrckNhc2UgPT09IGlkLkJLUl9NT0RFX0NJID8gJyVpJyA6ICclcyc7XG4gICAgICAgIGNvbnN0IG1vZGV0eXBlID0gbGluZS5vcGNvZGUuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfVU0gPyAnJXUnIDogJyVwJztcbiAgICAgICAgaHRtbCArPSBgKFxcXFwke2Nhc2V0eXBlfSR7bW9kZXR5cGV9JHtydWxlc1tsaW5lLm9wY29kZS5pbmRleF0ubmFtZX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuVURUKSB7XG4gICAgICAgIGh0bWwgKz0gYCgke3VkdHNbbGluZS5vcGNvZGUuaW5kZXhdLm5hbWV9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLlRSRykge1xuICAgICAgICBodG1sICs9IGAoJHtkaXNwbGF5VHJnKG1vZGUsIGxpbmUub3Bjb2RlKX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuVEJTKSB7XG4gICAgICAgIGh0bWwgKz0gYCgke2Rpc3BsYXlUYnMobW9kZSwgbGluZS5vcGNvZGUpfSkgYDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5UTFMpIHtcbiAgICAgICAgaHRtbCArPSBgKCR7ZGlzcGxheVRscyhtb2RlLCBsaW5lLm9wY29kZSl9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLlJFUCkge1xuICAgICAgICBodG1sICs9IGAoJHtkaXNwbGF5UmVwKG1vZGUsIGxpbmUub3Bjb2RlKX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobG9va0Fyb3VuZCkge1xuICAgICAgICBodG1sICs9ICc8L3NwYW4+JztcbiAgICAgIH1cbiAgICAgIGh0bWwgKz0gJzwvdGQ+JztcbiAgICAgIGh0bWwgKz0gJzx0ZD4nO1xuICAgICAgaWYgKGxvb2tCZWhpbmQpIHtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5QmVoaW5kKG1vZGUsIGNoYXJzLCBsaW5lLnN0YXRlLCBsaW5lLnBocmFzZUluZGV4LCBsaW5lLnBocmFzZUxlbmd0aCwgYW5jaG9yKTtcbiAgICAgIH0gZWxzZSBpZiAobG9va0FoZWFkKSB7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheUFoZWFkKG1vZGUsIGNoYXJzLCBsaW5lLnN0YXRlLCBsaW5lLnBocmFzZUluZGV4LCBsaW5lLnBocmFzZUxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlOb25lKG1vZGUsIGNoYXJzLCBsaW5lLnN0YXRlLCBsaW5lLnBocmFzZUluZGV4LCBsaW5lLnBocmFzZUxlbmd0aCk7XG4gICAgICB9XG4gICAgICBodG1sICs9ICc8L3RkPjwvdHI+XFxuJztcbiAgICB9KTtcbiAgICBodG1sICs9ICc8dHI+PHRoPihhKTwvdGg+PHRoPihiKTwvdGg+PHRoPihjKTwvdGg+PHRoPihkKTwvdGg+PHRoPihlKTwvdGg+PHRoPihmKTwvdGg+JztcbiAgICBodG1sICs9ICc8dGg+b3BlcmF0b3I8L3RoPjx0aD5waHJhc2U8L3RoPjwvdHI+XFxuJztcbiAgICBodG1sICs9ICc8L3RhYmxlPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8vIFRyYW5zbGF0ZSB0aGUgdHJhY2UgcmVjb3JkcyB0byBIVE1MIGZvcm1hdC5cbiAgLy8gLSAqbW9kZWFyZyogLSBjYW4gYmUgYFwiYXNjaWlcImAsIGBcImRlY2ltYWxcImAsIGBcImhleGFkZWNpbWFsXCJgIG9yIGBcInVuaWNvZGVcImAuXG4gIC8vIERldGVybWluZXMgdGhlIGZvcm1hdCBvZiB0aGUgc3RyaW5nIGNoYXJhY3RlciBjb2RlIGRpc3BsYXkuXG4gIC8vIC0gKmNhcHRpb24qIC0gb3B0aW9uYWwgY2FwdGlvbiBmb3IgdGhlIEhUTUwgdGFibGUuXG4gIHRoaXMudG9IdG1sID0gZnVuY3Rpb24gKG1vZGVhcmcsIGNhcHRpb24pIHtcbiAgICAvKiB3cml0ZXMgdGhlIHRyYWNlIHJlY29yZHMgYXMgYSB0YWJsZSBpbiBhIGNvbXBsZXRlIGh0bWwgcGFnZSAqL1xuICAgIGxldCBtb2RlID0gTU9ERV9BU0NJSTtcbiAgICBpZiAodHlwZW9mIG1vZGVhcmcgPT09ICdzdHJpbmcnICYmIG1vZGVhcmcubGVuZ3RoID49IDMpIHtcbiAgICAgIGNvbnN0IG1vZGVpbiA9IG1vZGVhcmcudG9Mb3dlckNhc2UoKS5zbGljZSgwLCAzKTtcbiAgICAgIGlmIChtb2RlaW4gPT09ICdoZXgnKSB7XG4gICAgICAgIG1vZGUgPSBNT0RFX0hFWDtcbiAgICAgIH0gZWxzZSBpZiAobW9kZWluID09PSAnZGVjJykge1xuICAgICAgICBtb2RlID0gTU9ERV9ERUM7XG4gICAgICB9IGVsc2UgaWYgKG1vZGVpbiA9PT0gJ3VuaScpIHtcbiAgICAgICAgbW9kZSA9IE1PREVfVU5JQ09ERTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9IGh0bWxIZWFkZXIobW9kZSwgY2FwdGlvbik7XG4gICAgaHRtbCArPSBodG1sVGFibGUobW9kZSk7XG4gICAgaHRtbCArPSBodG1sRm9vdGVyKCk7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/trace.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exports a variety of utility functions that support\n// [`apg`](https://github.com/ldthomas/apg-js2), [`apg-lib`](https://github.com/ldthomas/apg-js2-lib)\n// and the generated parser applications.\n\nconst style = __webpack_require__(/*! ./style */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js\");\nconst converter = __webpack_require__(/*! ../apg-conv-api/converter */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/converter.js\");\nconst emitCss = __webpack_require__(/*! ./emitcss */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/emitcss.js\");\nconst id = __webpack_require__(/*! ./identifiers */ \"(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n\nconst thisFileName = 'utilities.js: ';\n\n/* translate (implied) phrase beginning character and length to actual first and last character indexes */\n/* used by multiple phrase handling functions */\nconst getBounds = function (length, begArg, len) {\n  let end;\n  let beg = begArg;\n  const TRUE = true;\n  while (TRUE) {\n    if (length <= 0) {\n      beg = 0;\n      end = 0;\n      break;\n    }\n    if (typeof beg !== 'number') {\n      beg = 0;\n      end = length;\n      break;\n    }\n    if (beg >= length) {\n      beg = length;\n      end = length;\n      break;\n    }\n    if (typeof len !== 'number') {\n      end = length;\n      break;\n    }\n    end = beg + len;\n    if (end > length) {\n      end = length;\n      break;\n    }\n    break;\n  }\n  return {\n    beg,\n    end,\n  };\n};\n// Generates a complete, minimal HTML5 page, inserting the user's HTML text on the page.\n// - *html* - the page text in HTML format\n// - *title* - the HTML page `<title>` - defaults to `htmlToPage`.\nexports.htmlToPage = function (html, titleArg) {\n  let title;\n  if (typeof html !== 'string') {\n    throw new Error(`${thisFileName}htmlToPage: input HTML is not a string`);\n  }\n  if (typeof titleArg !== 'string') {\n    title = 'htmlToPage';\n  } else {\n    title = titleArg;\n  }\n  let page = '';\n  page += '<!DOCTYPE html>\\n';\n  page += '<html lang=\"en\">\\n';\n  page += '<head>\\n';\n  page += '<meta charset=\"utf-8\">\\n';\n  page += `<title>${title}</title>\\n`;\n  page += '<style>\\n';\n  page += emitCss();\n  page += '</style>\\n';\n  page += '</head>\\n<body>\\n';\n  page += `<p>${new Date()}</p>\\n`;\n  page += html;\n  page += '</body>\\n</html>\\n';\n  return page;\n};\n// Formats the returned object from `parser.parse()`\n// into an HTML table.\n// ```\n// return {\n//   success : sysData.success,\n//   state : sysData.state,\n//   length : charsLength,\n//   matched : sysData.phraseLength,\n//   maxMatched : maxMatched,\n//   maxTreeDepth : maxTreeDepth,\n//   nodeHits : nodeHits,\n//   inputLength : chars.length,\n//   subBegin : charsBegin,\n//   subEnd : charsEnd,\n//   subLength : charsLength\n// };\n// ```\nexports.parserResultToHtml = function (result, caption) {\n  let cap = null;\n  if (typeof caption === 'string' && caption !== '') {\n    cap = caption;\n  }\n  let success;\n  let state;\n  if (result.success === true) {\n    success = `<span class=\"${style.CLASS_MATCH}\">true</span>`;\n  } else {\n    success = `<span class=\"${style.CLASS_NOMATCH}\">false</span>`;\n  }\n  if (result.state === id.EMPTY) {\n    state = `<span class=\"${style.CLASS_EMPTY}\">EMPTY</span>`;\n  } else if (result.state === id.MATCH) {\n    state = `<span class=\"${style.CLASS_MATCH}\">MATCH</span>`;\n  } else if (result.state === id.NOMATCH) {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span>`;\n  } else {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">unrecognized</span>`;\n  }\n  let html = '';\n  html += `<table class=\"${style.CLASS_STATE}\">\\n`;\n  if (cap) {\n    html += `<caption>${cap}</caption>\\n`;\n  }\n  html += '<tr><th>state item</th><th>value</th><th>description</th></tr>\\n';\n  html += `<tr><td>parser success</td><td>${success}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_MATCH}\">true</span> if the parse succeeded,\\n`;\n  html += ` <span class=\"${style.CLASS_NOMATCH}\">false</span> otherwise`;\n  html += '<br><i>NOTE: for success, entire string must be matched</i></td></tr>\\n';\n  html += `<tr><td>parser state</td><td>${state}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_EMPTY}\">EMPTY</span>, `;\n  html += `<span class=\"${style.CLASS_MATCH}\">MATCH</span> or \\n`;\n  html += `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span></td></tr>\\n`;\n  html += `<tr><td>string length</td><td>${result.length}</td><td>length of the input (sub)string</td></tr>\\n`;\n  html += `<tr><td>matched length</td><td>${result.matched}</td><td>number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max matched</td><td>${result.maxMatched}</td><td>maximum number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max tree depth</td><td>${result.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>\\n`;\n  html += `<tr><td>node hits</td><td>${result.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>\\n`;\n  html += `<tr><td>input length</td><td>${result.inputLength}</td><td>length of full input string</td></tr>\\n`;\n  html += `<tr><td>sub-string begin</td><td>${result.subBegin}</td><td>sub-string first character index</td></tr>\\n`;\n  html += `<tr><td>sub-string end</td><td>${result.subEnd}</td><td>sub-string end-of-string index</td></tr>\\n`;\n  html += `<tr><td>sub-string length</td><td>${result.subLength}</td><td>sub-string length</td></tr>\\n`;\n  html += '</table>\\n';\n  return html;\n};\n// Translates a sub-array of integer character codes into a string.\n// Very useful in callback functions to translate the matched phrases into strings.\nexports.charsToString = function (chars, phraseIndex, phraseLength) {\n  let beg;\n  let end;\n  if (typeof phraseIndex === 'number') {\n    if (phraseIndex >= chars.length) {\n      return '';\n    }\n    beg = phraseIndex < 0 ? 0 : phraseIndex;\n  } else {\n    beg = 0;\n  }\n  if (typeof phraseLength === 'number') {\n    if (phraseLength <= 0) {\n      return '';\n    }\n    end = phraseLength > chars.length - beg ? chars.length : beg + phraseLength;\n  } else {\n    end = chars.length;\n  }\n  if (beg < end) {\n    return converter.encode('UTF16LE', chars.slice(beg, end)).toString('utf16le');\n  }\n  return '';\n};\n// Translates a string into an array of integer character codes.\nexports.stringToChars = function (string) {\n  return converter.decode('STRING', string);\n};\n// Translates an opcode identifier into a human-readable string.\nexports.opcodeToString = function (type) {\n  let ret = 'unknown';\n  switch (type) {\n    case id.ALT:\n      ret = 'ALT';\n      break;\n    case id.CAT:\n      ret = 'CAT';\n      break;\n    case id.RNM:\n      ret = 'RNM';\n      break;\n    case id.UDT:\n      ret = 'UDT';\n      break;\n    case id.AND:\n      ret = 'AND';\n      break;\n    case id.NOT:\n      ret = 'NOT';\n      break;\n    case id.REP:\n      ret = 'REP';\n      break;\n    case id.TRG:\n      ret = 'TRG';\n      break;\n    case id.TBS:\n      ret = 'TBS';\n      break;\n    case id.TLS:\n      ret = 'TLS';\n      break;\n    case id.BKR:\n      ret = 'BKR';\n      break;\n    case id.BKA:\n      ret = 'BKA';\n      break;\n    case id.BKN:\n      ret = 'BKN';\n      break;\n    case id.ABG:\n      ret = 'ABG';\n      break;\n    case id.AEN:\n      ret = 'AEN';\n      break;\n    default:\n      throw new Error('unrecognized opcode');\n  }\n  return ret;\n};\n// Translates an state identifier into a human-readable string.\nexports.stateToString = function (state) {\n  let ret = 'unknown';\n  switch (state) {\n    case id.ACTIVE:\n      ret = 'ACTIVE';\n      break;\n    case id.MATCH:\n      ret = 'MATCH';\n      break;\n    case id.EMPTY:\n      ret = 'EMPTY';\n      break;\n    case id.NOMATCH:\n      ret = 'NOMATCH';\n      break;\n    default:\n      throw new Error('unrecognized state');\n  }\n  return ret;\n};\n// Array which translates all 128, 7-bit ASCII character codes to their respective HTML format.\nexports.asciiChars = [\n  'NUL',\n  'SOH',\n  'STX',\n  'ETX',\n  'EOT',\n  'ENQ',\n  'ACK',\n  'BEL',\n  'BS',\n  'TAB',\n  'LF',\n  'VT',\n  'FF',\n  'CR',\n  'SO',\n  'SI',\n  'DLE',\n  'DC1',\n  'DC2',\n  'DC3',\n  'DC4',\n  'NAK',\n  'SYN',\n  'ETB',\n  'CAN',\n  'EM',\n  'SUB',\n  'ESC',\n  'FS',\n  'GS',\n  'RS',\n  'US',\n  '&nbsp;',\n  '!',\n  '&#34;',\n  '#',\n  '$',\n  '%',\n  '&#38;',\n  '&#39;',\n  '(',\n  ')',\n  '*',\n  '+',\n  ',',\n  '-',\n  '.',\n  '/',\n  '0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n  ':',\n  ';',\n  '&#60;',\n  '=',\n  '&#62;',\n  '?',\n  '@',\n  'A',\n  'B',\n  'C',\n  'D',\n  'E',\n  'F',\n  'G',\n  'H',\n  'I',\n  'J',\n  'K',\n  'L',\n  'M',\n  'N',\n  'O',\n  'P',\n  'Q',\n  'R',\n  'S',\n  'T',\n  'U',\n  'V',\n  'W',\n  'X',\n  'Y',\n  'Z',\n  '[',\n  '&#92;',\n  ']',\n  '^',\n  '_',\n  '`',\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n  '{',\n  '|',\n  '}',\n  '~',\n  'DEL',\n];\n// Translates a single character to hexadecimal with leading zeros for 2, 4, or 8 digit display.\nexports.charToHex = function (char) {\n  let ch = char.toString(16).toUpperCase();\n  switch (ch.length) {\n    case 1:\n    case 3:\n    case 7:\n      ch = `0${ch}`;\n      break;\n    case 2:\n    case 6:\n      ch = `00${ch}`;\n      break;\n    case 4:\n      break;\n    case 5:\n      ch = `000${ch}`;\n      break;\n    default:\n      throw new Error('unrecognized option');\n  }\n  return ch;\n};\n// Translates a sub-array of character codes to decimal display format.\nexports.charsToDec = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToDec: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += chars[bounds.beg];\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,${chars[i]}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to hexadecimal display format.\nexports.charsToHex = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\x${exports.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\x${exports.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\nexports.charsToHtmlEntities = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      ret += `&#x${chars[i].toString(16)};`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to Unicode display format.\nfunction isUnicode(char) {\n  if (char >= 0xd800 && char <= 0xdfff) {\n    return false;\n  }\n  if (char > 0x10ffff) {\n    return false;\n  }\n  return true;\n}\nexports.charsToUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      if (isUnicode(chars[i])) {\n        ret += `&#${chars[i]};`;\n      } else {\n        ret += ` U+${exports.charToHex(chars[i])}`;\n      }\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to JavaScript Unicode display format (`\\uXXXX`).\nexports.charsToJsUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToJsUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\u${exports.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\u${exports.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to printing ASCII character display format.\nexports.charsToAscii = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAscii: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      ret += String.fromCharCode(char);\n    } else {\n      ret += `\\\\x${exports.charToHex(char)}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to HTML display format.\nexports.charsToAsciiHtml = function (chars, beg, len) {\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAsciiHtml: input must be an array of integers`);\n  }\n  let html = '';\n  let char;\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    char = chars[i];\n    if (char < 32 || char === 127) {\n      /* control characters */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">${exports.asciiChars[char]}</span>`;\n    } else if (char > 127) {\n      /* non-ASCII */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">U+${exports.charToHex(char)}</span>`;\n    } else {\n      /* printing ASCII, 32 <= char <= 126 */\n      html += exports.asciiChars[char];\n    }\n  }\n  return html;\n};\n// Translates a JavaScript string to HTML display format.\nexports.stringToAsciiHtml = function (str) {\n  const chars = converter.decode('STRING', str);\n  return this.charsToAsciiHtml(chars);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3V0aWxpdGllcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxxR0FBUztBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyxnSUFBMkI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMseUdBQVc7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLGlIQUFlOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQsSUFBSTtBQUNKLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUMsSUFBSTtBQUNKLDRCQUE0QixrQkFBa0I7QUFDOUMsSUFBSTtBQUNKLDRCQUE0QixvQkFBb0I7QUFDaEQsSUFBSTtBQUNKLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSx3QkFBd0IsSUFBSTtBQUM1QjtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQsOEJBQThCLGtCQUFrQjtBQUNoRCwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQsOEJBQThCLGtCQUFrQjtBQUNoRCwwQkFBMEIsa0JBQWtCO0FBQzVDLDBCQUEwQixvQkFBb0I7QUFDOUMsMkNBQTJDLGNBQWM7QUFDekQsNENBQTRDLGVBQWU7QUFDM0QseUNBQXlDLGtCQUFrQjtBQUMzRCw0Q0FBNEMsb0JBQW9CO0FBQ2hFLHVDQUF1QyxnQkFBZ0I7QUFDdkQsMENBQTBDLG1CQUFtQjtBQUM3RCw4Q0FBOEMsZ0JBQWdCO0FBQzlELDRDQUE0QyxjQUFjO0FBQzFELCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRCxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUNBQXFDO0FBQ3RELGlDQUFpQyxnQkFBZ0I7QUFDakQsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QyxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QixRQUFRO0FBQ1IscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQ0FBcUM7QUFDdEQsaUNBQWlDLGdCQUFnQjtBQUNqRCxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQixJQUFJLHlCQUF5QjtBQUNoRixNQUFNO0FBQ047QUFDQSw4QkFBOEIscUJBQXFCLE1BQU0sd0JBQXdCO0FBQ2pGLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi91dGlsaXRpZXMuanM/NGFmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzICovXG4vKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBleHBvcnRzIGEgdmFyaWV0eSBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IHN1cHBvcnRcbi8vIFtgYXBnYF0oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qczIpLCBbYGFwZy1saWJgXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzMi1saWIpXG4vLyBhbmQgdGhlIGdlbmVyYXRlZCBwYXJzZXIgYXBwbGljYXRpb25zLlxuXG5jb25zdCBzdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGUnKTtcbmNvbnN0IGNvbnZlcnRlciA9IHJlcXVpcmUoJy4uL2FwZy1jb252LWFwaS9jb252ZXJ0ZXInKTtcbmNvbnN0IGVtaXRDc3MgPSByZXF1aXJlKCcuL2VtaXRjc3MnKTtcbmNvbnN0IGlkID0gcmVxdWlyZSgnLi9pZGVudGlmaWVycycpO1xuXG5jb25zdCB0aGlzRmlsZU5hbWUgPSAndXRpbGl0aWVzLmpzOiAnO1xuXG4vKiB0cmFuc2xhdGUgKGltcGxpZWQpIHBocmFzZSBiZWdpbm5pbmcgY2hhcmFjdGVyIGFuZCBsZW5ndGggdG8gYWN0dWFsIGZpcnN0IGFuZCBsYXN0IGNoYXJhY3RlciBpbmRleGVzICovXG4vKiB1c2VkIGJ5IG11bHRpcGxlIHBocmFzZSBoYW5kbGluZyBmdW5jdGlvbnMgKi9cbmNvbnN0IGdldEJvdW5kcyA9IGZ1bmN0aW9uIChsZW5ndGgsIGJlZ0FyZywgbGVuKSB7XG4gIGxldCBlbmQ7XG4gIGxldCBiZWcgPSBiZWdBcmc7XG4gIGNvbnN0IFRSVUUgPSB0cnVlO1xuICB3aGlsZSAoVFJVRSkge1xuICAgIGlmIChsZW5ndGggPD0gMCkge1xuICAgICAgYmVnID0gMDtcbiAgICAgIGVuZCA9IDA7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiZWcgIT09ICdudW1iZXInKSB7XG4gICAgICBiZWcgPSAwO1xuICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChiZWcgPj0gbGVuZ3RoKSB7XG4gICAgICBiZWcgPSBsZW5ndGg7XG4gICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsZW4gIT09ICdudW1iZXInKSB7XG4gICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZW5kID0gYmVnICsgbGVuO1xuICAgIGlmIChlbmQgPiBsZW5ndGgpIHtcbiAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4ge1xuICAgIGJlZyxcbiAgICBlbmQsXG4gIH07XG59O1xuLy8gR2VuZXJhdGVzIGEgY29tcGxldGUsIG1pbmltYWwgSFRNTDUgcGFnZSwgaW5zZXJ0aW5nIHRoZSB1c2VyJ3MgSFRNTCB0ZXh0IG9uIHRoZSBwYWdlLlxuLy8gLSAqaHRtbCogLSB0aGUgcGFnZSB0ZXh0IGluIEhUTUwgZm9ybWF0XG4vLyAtICp0aXRsZSogLSB0aGUgSFRNTCBwYWdlIGA8dGl0bGU+YCAtIGRlZmF1bHRzIHRvIGBodG1sVG9QYWdlYC5cbmV4cG9ydHMuaHRtbFRvUGFnZSA9IGZ1bmN0aW9uIChodG1sLCB0aXRsZUFyZykge1xuICBsZXQgdGl0bGU7XG4gIGlmICh0eXBlb2YgaHRtbCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWh0bWxUb1BhZ2U6IGlucHV0IEhUTUwgaXMgbm90IGEgc3RyaW5nYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0aXRsZUFyZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aXRsZSA9ICdodG1sVG9QYWdlJztcbiAgfSBlbHNlIHtcbiAgICB0aXRsZSA9IHRpdGxlQXJnO1xuICB9XG4gIGxldCBwYWdlID0gJyc7XG4gIHBhZ2UgKz0gJzwhRE9DVFlQRSBodG1sPlxcbic7XG4gIHBhZ2UgKz0gJzxodG1sIGxhbmc9XCJlblwiPlxcbic7XG4gIHBhZ2UgKz0gJzxoZWFkPlxcbic7XG4gIHBhZ2UgKz0gJzxtZXRhIGNoYXJzZXQ9XCJ1dGYtOFwiPlxcbic7XG4gIHBhZ2UgKz0gYDx0aXRsZT4ke3RpdGxlfTwvdGl0bGU+XFxuYDtcbiAgcGFnZSArPSAnPHN0eWxlPlxcbic7XG4gIHBhZ2UgKz0gZW1pdENzcygpO1xuICBwYWdlICs9ICc8L3N0eWxlPlxcbic7XG4gIHBhZ2UgKz0gJzwvaGVhZD5cXG48Ym9keT5cXG4nO1xuICBwYWdlICs9IGA8cD4ke25ldyBEYXRlKCl9PC9wPlxcbmA7XG4gIHBhZ2UgKz0gaHRtbDtcbiAgcGFnZSArPSAnPC9ib2R5PlxcbjwvaHRtbD5cXG4nO1xuICByZXR1cm4gcGFnZTtcbn07XG4vLyBGb3JtYXRzIHRoZSByZXR1cm5lZCBvYmplY3QgZnJvbSBgcGFyc2VyLnBhcnNlKClgXG4vLyBpbnRvIGFuIEhUTUwgdGFibGUuXG4vLyBgYGBcbi8vIHJldHVybiB7XG4vLyAgIHN1Y2Nlc3MgOiBzeXNEYXRhLnN1Y2Nlc3MsXG4vLyAgIHN0YXRlIDogc3lzRGF0YS5zdGF0ZSxcbi8vICAgbGVuZ3RoIDogY2hhcnNMZW5ndGgsXG4vLyAgIG1hdGNoZWQgOiBzeXNEYXRhLnBocmFzZUxlbmd0aCxcbi8vICAgbWF4TWF0Y2hlZCA6IG1heE1hdGNoZWQsXG4vLyAgIG1heFRyZWVEZXB0aCA6IG1heFRyZWVEZXB0aCxcbi8vICAgbm9kZUhpdHMgOiBub2RlSGl0cyxcbi8vICAgaW5wdXRMZW5ndGggOiBjaGFycy5sZW5ndGgsXG4vLyAgIHN1YkJlZ2luIDogY2hhcnNCZWdpbixcbi8vICAgc3ViRW5kIDogY2hhcnNFbmQsXG4vLyAgIHN1Ykxlbmd0aCA6IGNoYXJzTGVuZ3RoXG4vLyB9O1xuLy8gYGBgXG5leHBvcnRzLnBhcnNlclJlc3VsdFRvSHRtbCA9IGZ1bmN0aW9uIChyZXN1bHQsIGNhcHRpb24pIHtcbiAgbGV0IGNhcCA9IG51bGw7XG4gIGlmICh0eXBlb2YgY2FwdGlvbiA9PT0gJ3N0cmluZycgJiYgY2FwdGlvbiAhPT0gJycpIHtcbiAgICBjYXAgPSBjYXB0aW9uO1xuICB9XG4gIGxldCBzdWNjZXNzO1xuICBsZXQgc3RhdGU7XG4gIGlmIChyZXN1bHQuc3VjY2VzcyA9PT0gdHJ1ZSkge1xuICAgIHN1Y2Nlc3MgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPnRydWU8L3NwYW4+YDtcbiAgfSBlbHNlIHtcbiAgICBzdWNjZXNzID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPmZhbHNlPC9zcGFuPmA7XG4gIH1cbiAgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gaWQuRU1QVFkpIHtcbiAgICBzdGF0ZSA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+RU1QVFk8L3NwYW4+YDtcbiAgfSBlbHNlIGlmIChyZXN1bHQuc3RhdGUgPT09IGlkLk1BVENIKSB7XG4gICAgc3RhdGUgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPk1BVENIPC9zcGFuPmA7XG4gIH0gZWxzZSBpZiAocmVzdWx0LnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgc3RhdGUgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+Tk9NQVRDSDwvc3Bhbj5gO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPnVucmVjb2duaXplZDwvc3Bhbj5gO1xuICB9XG4gIGxldCBodG1sID0gJyc7XG4gIGh0bWwgKz0gYDx0YWJsZSBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfU1RBVEV9XCI+XFxuYDtcbiAgaWYgKGNhcCkge1xuICAgIGh0bWwgKz0gYDxjYXB0aW9uPiR7Y2FwfTwvY2FwdGlvbj5cXG5gO1xuICB9XG4gIGh0bWwgKz0gJzx0cj48dGg+c3RhdGUgaXRlbTwvdGg+PHRoPnZhbHVlPC90aD48dGg+ZGVzY3JpcHRpb248L3RoPjwvdHI+XFxuJztcbiAgaHRtbCArPSBgPHRyPjx0ZD5wYXJzZXIgc3VjY2VzczwvdGQ+PHRkPiR7c3VjY2Vzc308L3RkPlxcbmA7XG4gIGh0bWwgKz0gYDx0ZD48c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+dHJ1ZTwvc3Bhbj4gaWYgdGhlIHBhcnNlIHN1Y2NlZWRlZCxcXG5gO1xuICBodG1sICs9IGAgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+ZmFsc2U8L3NwYW4+IG90aGVyd2lzZWA7XG4gIGh0bWwgKz0gJzxicj48aT5OT1RFOiBmb3Igc3VjY2VzcywgZW50aXJlIHN0cmluZyBtdXN0IGJlIG1hdGNoZWQ8L2k+PC90ZD48L3RyPlxcbic7XG4gIGh0bWwgKz0gYDx0cj48dGQ+cGFyc2VyIHN0YXRlPC90ZD48dGQ+JHtzdGF0ZX08L3RkPlxcbmA7XG4gIGh0bWwgKz0gYDx0ZD48c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+RU1QVFk8L3NwYW4+LCBgO1xuICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+TUFUQ0g8L3NwYW4+IG9yIFxcbmA7XG4gIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPk5PTUFUQ0g8L3NwYW4+PC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+c3RyaW5nIGxlbmd0aDwvdGQ+PHRkPiR7cmVzdWx0Lmxlbmd0aH08L3RkPjx0ZD5sZW5ndGggb2YgdGhlIGlucHV0IChzdWIpc3RyaW5nPC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+bWF0Y2hlZCBsZW5ndGg8L3RkPjx0ZD4ke3Jlc3VsdC5tYXRjaGVkfTwvdGQ+PHRkPm51bWJlciBvZiBpbnB1dCBzdHJpbmcgY2hhcmFjdGVycyBtYXRjaGVkPC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+bWF4IG1hdGNoZWQ8L3RkPjx0ZD4ke3Jlc3VsdC5tYXhNYXRjaGVkfTwvdGQ+PHRkPm1heGltdW0gbnVtYmVyIG9mIGlucHV0IHN0cmluZyBjaGFyYWN0ZXJzIG1hdGNoZWQ8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5tYXggdHJlZSBkZXB0aDwvdGQ+PHRkPiR7cmVzdWx0Lm1heFRyZWVEZXB0aH08L3RkPjx0ZD5tYXhpbXVtIGRlcHRoIG9mIHRoZSBwYXJzZSB0cmVlIHJlYWNoZWQ8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5ub2RlIGhpdHM8L3RkPjx0ZD4ke3Jlc3VsdC5ub2RlSGl0c308L3RkPjx0ZD5udW1iZXIgb2YgcGFyc2UgdHJlZSBub2RlIGhpdHMgKG9wY29kZSBmdW5jdGlvbiBjYWxscyk8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5pbnB1dCBsZW5ndGg8L3RkPjx0ZD4ke3Jlc3VsdC5pbnB1dExlbmd0aH08L3RkPjx0ZD5sZW5ndGggb2YgZnVsbCBpbnB1dCBzdHJpbmc8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5zdWItc3RyaW5nIGJlZ2luPC90ZD48dGQ+JHtyZXN1bHQuc3ViQmVnaW59PC90ZD48dGQ+c3ViLXN0cmluZyBmaXJzdCBjaGFyYWN0ZXIgaW5kZXg8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5zdWItc3RyaW5nIGVuZDwvdGQ+PHRkPiR7cmVzdWx0LnN1YkVuZH08L3RkPjx0ZD5zdWItc3RyaW5nIGVuZC1vZi1zdHJpbmcgaW5kZXg8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5zdWItc3RyaW5nIGxlbmd0aDwvdGQ+PHRkPiR7cmVzdWx0LnN1Ykxlbmd0aH08L3RkPjx0ZD5zdWItc3RyaW5nIGxlbmd0aDwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9ICc8L3RhYmxlPlxcbic7XG4gIHJldHVybiBodG1sO1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdWItYXJyYXkgb2YgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMgaW50byBhIHN0cmluZy5cbi8vIFZlcnkgdXNlZnVsIGluIGNhbGxiYWNrIGZ1bmN0aW9ucyB0byB0cmFuc2xhdGUgdGhlIG1hdGNoZWQgcGhyYXNlcyBpbnRvIHN0cmluZ3MuXG5leHBvcnRzLmNoYXJzVG9TdHJpbmcgPSBmdW5jdGlvbiAoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgpIHtcbiAgbGV0IGJlZztcbiAgbGV0IGVuZDtcbiAgaWYgKHR5cGVvZiBwaHJhc2VJbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAocGhyYXNlSW5kZXggPj0gY2hhcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGJlZyA9IHBocmFzZUluZGV4IDwgMCA/IDAgOiBwaHJhc2VJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBiZWcgPSAwO1xuICB9XG4gIGlmICh0eXBlb2YgcGhyYXNlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIGlmIChwaHJhc2VMZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBlbmQgPSBwaHJhc2VMZW5ndGggPiBjaGFycy5sZW5ndGggLSBiZWcgPyBjaGFycy5sZW5ndGggOiBiZWcgKyBwaHJhc2VMZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgZW5kID0gY2hhcnMubGVuZ3RoO1xuICB9XG4gIGlmIChiZWcgPCBlbmQpIHtcbiAgICByZXR1cm4gY29udmVydGVyLmVuY29kZSgnVVRGMTZMRScsIGNoYXJzLnNsaWNlKGJlZywgZW5kKSkudG9TdHJpbmcoJ3V0ZjE2bGUnKTtcbiAgfVxuICByZXR1cm4gJyc7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGludGVnZXIgY2hhcmFjdGVyIGNvZGVzLlxuZXhwb3J0cy5zdHJpbmdUb0NoYXJzID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gY29udmVydGVyLmRlY29kZSgnU1RSSU5HJywgc3RyaW5nKTtcbn07XG4vLyBUcmFuc2xhdGVzIGFuIG9wY29kZSBpZGVudGlmaWVyIGludG8gYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcuXG5leHBvcnRzLm9wY29kZVRvU3RyaW5nID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgbGV0IHJldCA9ICd1bmtub3duJztcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBpZC5BTFQ6XG4gICAgICByZXQgPSAnQUxUJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQ0FUOlxuICAgICAgcmV0ID0gJ0NBVCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLlJOTTpcbiAgICAgIHJldCA9ICdSTk0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5VRFQ6XG4gICAgICByZXQgPSAnVURUJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQU5EOlxuICAgICAgcmV0ID0gJ0FORCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLk5PVDpcbiAgICAgIHJldCA9ICdOT1QnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5SRVA6XG4gICAgICByZXQgPSAnUkVQJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuVFJHOlxuICAgICAgcmV0ID0gJ1RSRyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLlRCUzpcbiAgICAgIHJldCA9ICdUQlMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5UTFM6XG4gICAgICByZXQgPSAnVExTJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQktSOlxuICAgICAgcmV0ID0gJ0JLUic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLkJLQTpcbiAgICAgIHJldCA9ICdCS0EnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5CS046XG4gICAgICByZXQgPSAnQktOJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQUJHOlxuICAgICAgcmV0ID0gJ0FCRyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLkFFTjpcbiAgICAgIHJldCA9ICdBRU4nO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIG9wY29kZScpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gVHJhbnNsYXRlcyBhbiBzdGF0ZSBpZGVudGlmaWVyIGludG8gYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcuXG5leHBvcnRzLnN0YXRlVG9TdHJpbmcgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgbGV0IHJldCA9ICd1bmtub3duJztcbiAgc3dpdGNoIChzdGF0ZSkge1xuICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgcmV0ID0gJ0FDVElWRSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgcmV0ID0gJ01BVENIJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICByZXQgPSAnRU1QVFknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgcmV0ID0gJ05PTUFUQ0gnO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHN0YXRlJyk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBBcnJheSB3aGljaCB0cmFuc2xhdGVzIGFsbCAxMjgsIDctYml0IEFTQ0lJIGNoYXJhY3RlciBjb2RlcyB0byB0aGVpciByZXNwZWN0aXZlIEhUTUwgZm9ybWF0LlxuZXhwb3J0cy5hc2NpaUNoYXJzID0gW1xuICAnTlVMJyxcbiAgJ1NPSCcsXG4gICdTVFgnLFxuICAnRVRYJyxcbiAgJ0VPVCcsXG4gICdFTlEnLFxuICAnQUNLJyxcbiAgJ0JFTCcsXG4gICdCUycsXG4gICdUQUInLFxuICAnTEYnLFxuICAnVlQnLFxuICAnRkYnLFxuICAnQ1InLFxuICAnU08nLFxuICAnU0knLFxuICAnRExFJyxcbiAgJ0RDMScsXG4gICdEQzInLFxuICAnREMzJyxcbiAgJ0RDNCcsXG4gICdOQUsnLFxuICAnU1lOJyxcbiAgJ0VUQicsXG4gICdDQU4nLFxuICAnRU0nLFxuICAnU1VCJyxcbiAgJ0VTQycsXG4gICdGUycsXG4gICdHUycsXG4gICdSUycsXG4gICdVUycsXG4gICcmbmJzcDsnLFxuICAnIScsXG4gICcmIzM0OycsXG4gICcjJyxcbiAgJyQnLFxuICAnJScsXG4gICcmIzM4OycsXG4gICcmIzM5OycsXG4gICcoJyxcbiAgJyknLFxuICAnKicsXG4gICcrJyxcbiAgJywnLFxuICAnLScsXG4gICcuJyxcbiAgJy8nLFxuICAnMCcsXG4gICcxJyxcbiAgJzInLFxuICAnMycsXG4gICc0JyxcbiAgJzUnLFxuICAnNicsXG4gICc3JyxcbiAgJzgnLFxuICAnOScsXG4gICc6JyxcbiAgJzsnLFxuICAnJiM2MDsnLFxuICAnPScsXG4gICcmIzYyOycsXG4gICc/JyxcbiAgJ0AnLFxuICAnQScsXG4gICdCJyxcbiAgJ0MnLFxuICAnRCcsXG4gICdFJyxcbiAgJ0YnLFxuICAnRycsXG4gICdIJyxcbiAgJ0knLFxuICAnSicsXG4gICdLJyxcbiAgJ0wnLFxuICAnTScsXG4gICdOJyxcbiAgJ08nLFxuICAnUCcsXG4gICdRJyxcbiAgJ1InLFxuICAnUycsXG4gICdUJyxcbiAgJ1UnLFxuICAnVicsXG4gICdXJyxcbiAgJ1gnLFxuICAnWScsXG4gICdaJyxcbiAgJ1snLFxuICAnJiM5MjsnLFxuICAnXScsXG4gICdeJyxcbiAgJ18nLFxuICAnYCcsXG4gICdhJyxcbiAgJ2InLFxuICAnYycsXG4gICdkJyxcbiAgJ2UnLFxuICAnZicsXG4gICdnJyxcbiAgJ2gnLFxuICAnaScsXG4gICdqJyxcbiAgJ2snLFxuICAnbCcsXG4gICdtJyxcbiAgJ24nLFxuICAnbycsXG4gICdwJyxcbiAgJ3EnLFxuICAncicsXG4gICdzJyxcbiAgJ3QnLFxuICAndScsXG4gICd2JyxcbiAgJ3cnLFxuICAneCcsXG4gICd5JyxcbiAgJ3onLFxuICAneycsXG4gICd8JyxcbiAgJ30nLFxuICAnficsXG4gICdERUwnLFxuXTtcbi8vIFRyYW5zbGF0ZXMgYSBzaW5nbGUgY2hhcmFjdGVyIHRvIGhleGFkZWNpbWFsIHdpdGggbGVhZGluZyB6ZXJvcyBmb3IgMiwgNCwgb3IgOCBkaWdpdCBkaXNwbGF5LlxuZXhwb3J0cy5jaGFyVG9IZXggPSBmdW5jdGlvbiAoY2hhcikge1xuICBsZXQgY2ggPSBjaGFyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICBzd2l0Y2ggKGNoLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICBjYXNlIDM6XG4gICAgY2FzZSA3OlxuICAgICAgY2ggPSBgMCR7Y2h9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICBjYXNlIDY6XG4gICAgICBjaCA9IGAwMCR7Y2h9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIGNoID0gYDAwMCR7Y2h9YDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBvcHRpb24nKTtcbiAgfVxuICByZXR1cm4gY2g7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgdG8gZGVjaW1hbCBkaXNwbGF5IGZvcm1hdC5cbmV4cG9ydHMuY2hhcnNUb0RlYyA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgbGV0IHJldCA9ICcnO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvRGVjOiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBpZiAoYm91bmRzLmVuZCA+IGJvdW5kcy5iZWcpIHtcbiAgICByZXQgKz0gY2hhcnNbYm91bmRzLmJlZ107XG4gICAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWcgKyAxOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICByZXQgKz0gYCwke2NoYXJzW2ldfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgdG8gaGV4YWRlY2ltYWwgZGlzcGxheSBmb3JtYXQuXG5leHBvcnRzLmNoYXJzVG9IZXggPSBmdW5jdGlvbiAoY2hhcnMsIGJlZywgbGVuKSB7XG4gIGxldCByZXQgPSAnJztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb0hleDogaW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhjaGFycy5sZW5ndGgsIGJlZywgbGVuKTtcbiAgaWYgKGJvdW5kcy5lbmQgPiBib3VuZHMuYmVnKSB7XG4gICAgcmV0ICs9IGBcXFxceCR7ZXhwb3J0cy5jaGFyVG9IZXgoY2hhcnNbYm91bmRzLmJlZ10pfWA7XG4gICAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWcgKyAxOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICByZXQgKz0gYCxcXFxceCR7ZXhwb3J0cy5jaGFyVG9IZXgoY2hhcnNbaV0pfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy5jaGFyc1RvSHRtbEVudGl0aWVzID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBsZXQgcmV0ID0gJyc7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNoYXJzVG9IZXg6IGlucHV0IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgfVxuICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMoY2hhcnMubGVuZ3RoLCBiZWcsIGxlbik7XG4gIGlmIChib3VuZHMuZW5kID4gYm91bmRzLmJlZykge1xuICAgIGZvciAobGV0IGkgPSBib3VuZHMuYmVnOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICByZXQgKz0gYCYjeCR7Y2hhcnNbaV0udG9TdHJpbmcoMTYpfTtgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdWItYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzIHRvIFVuaWNvZGUgZGlzcGxheSBmb3JtYXQuXG5mdW5jdGlvbiBpc1VuaWNvZGUoY2hhcikge1xuICBpZiAoY2hhciA+PSAweGQ4MDAgJiYgY2hhciA8PSAweGRmZmYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNoYXIgPiAweDEwZmZmZikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY2hhcnNUb1VuaWNvZGUgPSBmdW5jdGlvbiAoY2hhcnMsIGJlZywgbGVuKSB7XG4gIGxldCByZXQgPSAnJztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb1VuaWNvZGU6IGlucHV0IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgfVxuICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMoY2hhcnMubGVuZ3RoLCBiZWcsIGxlbik7XG4gIGlmIChib3VuZHMuZW5kID4gYm91bmRzLmJlZykge1xuICAgIGZvciAobGV0IGkgPSBib3VuZHMuYmVnOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICBpZiAoaXNVbmljb2RlKGNoYXJzW2ldKSkge1xuICAgICAgICByZXQgKz0gYCYjJHtjaGFyc1tpXX07YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCArPSBgIFUrJHtleHBvcnRzLmNoYXJUb0hleChjaGFyc1tpXSl9YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyB0byBKYXZhU2NyaXB0IFVuaWNvZGUgZGlzcGxheSBmb3JtYXQgKGBcXHVYWFhYYCkuXG5leHBvcnRzLmNoYXJzVG9Kc1VuaWNvZGUgPSBmdW5jdGlvbiAoY2hhcnMsIGJlZywgbGVuKSB7XG4gIGxldCByZXQgPSAnJztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb0pzVW5pY29kZTogaW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhjaGFycy5sZW5ndGgsIGJlZywgbGVuKTtcbiAgaWYgKGJvdW5kcy5lbmQgPiBib3VuZHMuYmVnKSB7XG4gICAgcmV0ICs9IGBcXFxcdSR7ZXhwb3J0cy5jaGFyVG9IZXgoY2hhcnNbYm91bmRzLmJlZ10pfWA7XG4gICAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWcgKyAxOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICByZXQgKz0gYCxcXFxcdSR7ZXhwb3J0cy5jaGFyVG9IZXgoY2hhcnNbaV0pfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgdG8gcHJpbnRpbmcgQVNDSUkgY2hhcmFjdGVyIGRpc3BsYXkgZm9ybWF0LlxuZXhwb3J0cy5jaGFyc1RvQXNjaWkgPSBmdW5jdGlvbiAoY2hhcnMsIGJlZywgbGVuKSB7XG4gIGxldCByZXQgPSAnJztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb0FzY2lpOiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBmb3IgKGxldCBpID0gYm91bmRzLmJlZzsgaSA8IGJvdW5kcy5lbmQ7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXIgPSBjaGFyc1tpXTtcbiAgICBpZiAoY2hhciA+PSAzMiAmJiBjaGFyIDw9IDEyNikge1xuICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCArPSBgXFxcXHgke2V4cG9ydHMuY2hhclRvSGV4KGNoYXIpfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgdG8gSFRNTCBkaXNwbGF5IGZvcm1hdC5cbmV4cG9ydHMuY2hhcnNUb0FzY2lpSHRtbCA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb0FzY2lpSHRtbDogaW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICB9XG4gIGxldCBodG1sID0gJyc7XG4gIGxldCBjaGFyO1xuICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMoY2hhcnMubGVuZ3RoLCBiZWcsIGxlbik7XG4gIGZvciAobGV0IGkgPSBib3VuZHMuYmVnOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgY2hhciA9IGNoYXJzW2ldO1xuICAgIGlmIChjaGFyIDwgMzIgfHwgY2hhciA9PT0gMTI3KSB7XG4gICAgICAvKiBjb250cm9sIGNoYXJhY3RlcnMgKi9cbiAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19DVFJMQ0hBUn1cIj4ke2V4cG9ydHMuYXNjaWlDaGFyc1tjaGFyXX08L3NwYW4+YDtcbiAgICB9IGVsc2UgaWYgKGNoYXIgPiAxMjcpIHtcbiAgICAgIC8qIG5vbi1BU0NJSSAqL1xuICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0NUUkxDSEFSfVwiPlUrJHtleHBvcnRzLmNoYXJUb0hleChjaGFyKX08L3NwYW4+YDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogcHJpbnRpbmcgQVNDSUksIDMyIDw9IGNoYXIgPD0gMTI2ICovXG4gICAgICBodG1sICs9IGV4cG9ydHMuYXNjaWlDaGFyc1tjaGFyXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGh0bWw7XG59O1xuLy8gVHJhbnNsYXRlcyBhIEphdmFTY3JpcHQgc3RyaW5nIHRvIEhUTUwgZGlzcGxheSBmb3JtYXQuXG5leHBvcnRzLnN0cmluZ1RvQXNjaWlIdG1sID0gZnVuY3Rpb24gKHN0cikge1xuICBjb25zdCBjaGFycyA9IGNvbnZlcnRlci5kZWNvZGUoJ1NUUklORycsIHN0cik7XG4gIHJldHVybiB0aGlzLmNoYXJzVG9Bc2NpaUh0bWwoY2hhcnMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/api.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/api.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module is Application Programming Interface (API) for **APG** - the ABNF Parser Generator.\n//\n// *Note on teminology.*\n// APG is a parser generator.\n// However, it really only generates a \"grammar object\" (see below) from the defining SABNF grammar.\n// The generated parser is incomplete at this stage.\n// Remaining, it is the job of the user to develop the generated parser from the grammar object and the **APG** Library (**apg-lib**).\n//\n// The following terminology my help clear up any confusion between the idea of a \"generated parser\" versus a \"generated grammar object\".\n// - The generating parser: **APG** is an **APG** parser (yes, there is a circular dependence between **apg-api** and **apg-lib**). We'll call it the generating parser.\n// - The target parser: **APG**'s goal is to generate a parser. We'll call it the target parser.\n// - The target grammar: this is the (ASCII) SABNF grammar defining the target parser.\n// - The target grammar object: **APG** parses the SABNF grammar and generates the JavaScript source for a target grammar object constructor function\n// and/or an actual grammar object.\n// - The final target parser: The user then develops the final target parser using the generated target grammar\n// object and the **APG** parsing library, **apg-lib**.\n// Throws execeptions on fatal errors.\n//\n// src: the input SABNF grammar<br>\n// may be one of:\n// - Buffer of bytes\n// - JavaScript string\n// - Array of integer character codes\n\nmodule.exports = function api(src) {\n    const { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n    const thisFileName = \"api.js: \";\n    const thisObject = this;\n    /* PRIVATE PROPERTIES */ const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\");\n    const converter = __webpack_require__(/*! ../apg-conv-api/converter */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/converter.js\");\n    const scanner = __webpack_require__(/*! ./scanner */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner.js\");\n    const parser = new (__webpack_require__(/*! ./parser */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/parser.js\"))();\n    const { attributes, showAttributes, showAttributeErrors, showRuleDependencies } = __webpack_require__(/*! ./attributes */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/attributes.js\");\n    const showRules = __webpack_require__(/*! ./show-rules */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/show-rules.js\");\n    /* PRIVATE MEMBERS (FUNCTIONS) */ /* Convert a phrase (array of character codes) to HTML. */ const abnfToHtml = function abnfToHtml(chars, beg, len) {\n        const NORMAL = 0;\n        const CONTROL = 1;\n        const INVALID = 2;\n        const CONTROL_BEG = `<span class=\"${apglib.style.CLASS_CTRLCHAR}\">`;\n        const CONTROL_END = \"</span>\";\n        const INVALID_BEG = `<span class=\"${apglib.style.CLASS_NOMATCH}\">`;\n        const INVALID_END = \"</span>\";\n        let end;\n        let html = \"\";\n        const TRUE = true;\n        while(TRUE){\n            if (!Array.isArray(chars) || chars.length === 0) {\n                break;\n            }\n            if (typeof beg !== \"number\") {\n                throw new Error(\"abnfToHtml: beg must be type number\");\n            }\n            if (beg >= chars.length) {\n                break;\n            }\n            if (typeof len !== \"number\" || beg + len >= chars.length) {\n                end = chars.length;\n            } else {\n                end = beg + len;\n            }\n            let state = NORMAL;\n            for(let i = beg; i < end; i += 1){\n                const ch = chars[i];\n                if (ch >= 32 && ch <= 126) {\n                    /* normal - printable ASCII characters */ if (state === CONTROL) {\n                        html += CONTROL_END;\n                        state = NORMAL;\n                    } else if (state === INVALID) {\n                        html += INVALID_END;\n                        state = NORMAL;\n                    }\n                    /* handle reserved HTML entity characters */ switch(ch){\n                        case 32:\n                            html += \"&nbsp;\";\n                            break;\n                        case 60:\n                            html += \"&lt;\";\n                            break;\n                        case 62:\n                            html += \"&gt;\";\n                            break;\n                        case 38:\n                            html += \"&amp;\";\n                            break;\n                        case 34:\n                            html += \"&quot;\";\n                            break;\n                        case 39:\n                            html += \"&#039;\";\n                            break;\n                        case 92:\n                            html += \"&#092;\";\n                            break;\n                        default:\n                            html += String.fromCharCode(ch);\n                            break;\n                    }\n                } else if (ch === 9 || ch === 10 || ch === 13) {\n                    /* control characters */ if (state === NORMAL) {\n                        html += CONTROL_BEG;\n                        state = CONTROL;\n                    } else if (state === INVALID) {\n                        html += INVALID_END + CONTROL_BEG;\n                        state = CONTROL;\n                    }\n                    if (ch === 9) {\n                        html += \"TAB\";\n                    }\n                    if (ch === 10) {\n                        html += \"LF\";\n                    }\n                    if (ch === 13) {\n                        html += \"CR\";\n                    }\n                } else {\n                    /* invalid characters */ if (state === NORMAL) {\n                        html += INVALID_BEG;\n                        state = INVALID;\n                    } else if (state === CONTROL) {\n                        html += CONTROL_END + INVALID_BEG;\n                        state = INVALID;\n                    }\n                    /* display character as hexadecimal value */ html += `\\\\x${apglib.utils.charToHex(ch)}`;\n                }\n            }\n            if (state === INVALID) {\n                html += INVALID_END;\n            }\n            if (state === CONTROL) {\n                html += CONTROL_END;\n            }\n            break;\n        }\n        return html;\n    };\n    /* Convert a phrase (array of character codes) to ASCII text. */ const abnfToAscii = function abnfToAscii(chars, beg, len) {\n        let str = \"\";\n        for(let i = beg; i < beg + len; i += 1){\n            const ch = chars[i];\n            if (ch >= 32 && ch <= 126) {\n                str += String.fromCharCode(ch);\n            } else {\n                switch(ch){\n                    case 9:\n                        str += \"\\\\t\";\n                        break;\n                    case 10:\n                        str += \"\\\\n\";\n                        break;\n                    case 13:\n                        str += \"\\\\r\";\n                        break;\n                    default:\n                        str += \"\\\\unknown\";\n                        break;\n                }\n            }\n        }\n        return str;\n    };\n    /* translate lines (SABNF grammar) to ASCII text */ const linesToAscii = function linesToAscii(lines) {\n        let str = \"Annotated Input Grammar\";\n        lines.forEach((val)=>{\n            str += \"\\n\";\n            str += `line no: ${val.lineNo}`;\n            str += ` : char index: ${val.beginChar}`;\n            str += ` : length: ${val.length}`;\n            str += ` : abnf: ${abnfToAscii(thisObject.chars, val.beginChar, val.length)}`;\n        });\n        str += \"\\n\";\n        return str;\n    };\n    /* translate lines (SABNF grammar) to HTML */ const linesToHtml = function linesToHtml(lines) {\n        let html = \"\";\n        html += `<table class=\"${apglib.style.CLASS_GRAMMAR}\">\\n`;\n        const title = \"Annotated Input Grammar\";\n        html += `<caption>${title}</caption>\\n`;\n        html += \"<tr>\";\n        html += \"<th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th>\";\n        html += \"</tr>\\n\";\n        lines.forEach((val)=>{\n            html += \"<tr>\";\n            html += `<td>${val.lineNo}`;\n            html += `</td><td>${val.beginChar}`;\n            html += `</td><td>${val.length}`;\n            html += `</td><td>${abnfToHtml(thisObject.chars, val.beginChar, val.length)}`;\n            html += \"</td>\";\n            html += \"</tr>\\n\";\n        });\n        html += \"</table>\\n\";\n        return html;\n    };\n    /* Format the error messages to HTML, for page display. */ const errorsToHtml = function errorsToHtml(errors, lines, chars, title) {\n        const [style] = apglib;\n        let html = \"\";\n        const errorArrow = `<span class=\"${style.CLASS_NOMATCH}\">&raquo;</span>`;\n        html += `<p><table class=\"${style.CLASS_GRAMMAR}\">\\n`;\n        if (title && typeof title === \"string\") {\n            html += `<caption>${title}</caption>\\n`;\n        }\n        html += \"<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\\n\";\n        errors.forEach((val)=>{\n            let line;\n            let relchar;\n            let beg;\n            let end;\n            let text;\n            let prefix = \"\";\n            let suffix = \"\";\n            if (lines.length === 0) {\n                text = errorArrow;\n                relchar = 0;\n            } else {\n                line = lines[val.line];\n                beg = line.beginChar;\n                if (val.char > beg) {\n                    prefix = abnfToHtml(chars, beg, val.char - beg);\n                }\n                beg = val.char;\n                end = line.beginChar + line.length;\n                if (beg < end) {\n                    suffix = abnfToHtml(chars, beg, end - beg);\n                }\n                text = prefix + errorArrow + suffix;\n                relchar = val.char - line.beginChar;\n                html += \"<tr>\";\n                html += `<td>${val.line}</td><td>${line.beginChar}</td><td>${relchar}</td><td>${text}</td>`;\n                html += \"</tr>\\n\";\n                html += \"<tr>\";\n                html += `<td colspan=\"3\"></td><td>&uarr;:&nbsp;${apglib.utils.stringToAsciiHtml(val.msg)}</td>`;\n                html += \"</tr>\\n\";\n            }\n        });\n        html += \"</table></p>\\n\";\n        return html;\n    };\n    /* Display an array of errors in ASCII text */ const errorsToAscii = function errorsToAscii(errors, lines, chars) {\n        let str;\n        let line;\n        let beg;\n        let len;\n        str = \"\";\n        errors.forEach((error)=>{\n            line = lines[error.line];\n            str += `${line.lineNo}: `;\n            str += `${line.beginChar}: `;\n            str += `${error.char - line.beginChar}: `;\n            beg = line.beginChar;\n            len = error.char - line.beginChar;\n            str += abnfToAscii(chars, beg, len);\n            str += \" >> \";\n            beg = error.char;\n            len = line.beginChar + line.length - error.char;\n            str += abnfToAscii(chars, beg, len);\n            str += \"\\n\";\n            str += `${line.lineNo}: `;\n            str += `${line.beginChar}: `;\n            str += `${error.char - line.beginChar}: `;\n            str += \"error: \";\n            str += error.msg;\n            str += \"\\n\";\n        });\n        return str;\n    };\n    let isScanned = false;\n    let isParsed = false;\n    let isTranslated = false;\n    let haveAttributes = false;\n    let attributeErrors = 0;\n    let lineMap;\n    /* PUBLIC PROPERTIES */ // The input SABNF grammar as a JavaScript string.\n    // this.sabnf;\n    // The input SABNF grammar as an array of character codes.\n    // this.chars;\n    // An array of line objects, defining each line of the input SABNF grammar\n    // - lineNo : the zero-based line number\n    // - beginChar : offset (into `this.chars`) of the first character in the line\n    // - length : the number of characters in the line\n    // - textLength : the number of characters of text in the line, excluding the line ending characters\n    // - endType : \"CRLF\", \"LF\", \"CR\" or \"none\" if the last line has no line ending characters\n    // - invalidChars : `true` if the line contains invalid characters, `false` otherwise\n    // this.lines;\n    // An array of rule names and data.\n    // - name : the rule name\n    // - lower : the rule name in lower case\n    // - index : the index of the rule (ordered by appearance in SABNF grammar)\n    // - isBkr : `true` if this rule has been back referenced, `false` otherwise\n    // - opcodes : array of opcodes for this rule\n    // - attrs : the rule attributes\n    // - ctrl : system data\n    // this.rules;\n    // An array of UDT names and data.\n    // this.udts;\n    // An array of errors, if any.\n    // - line : the line number containing the error\n    // - char : the character offset of the error\n    // - msg : the error message\n    this.errors = [];\n    /* CONSTRUCTOR */ if (Buffer.isBuffer(src)) {\n        this.chars = converter.decode(\"BINARY\", src);\n    } else if (Array.isArray(src)) {\n        this.chars = src.slice();\n    } else if (typeof src === \"string\") {\n        this.chars = converter.decode(\"STRING\", src);\n    } else {\n        throw new Error(`${thisFileName}input source is not a string, byte Buffer or character array`);\n    }\n    this.sabnf = converter.encode(\"STRING\", this.chars);\n    /* PUBLIC MEMBERS (FUNCTIONS) */ // Scan the input SABNF grammar for invalid characters and catalog the lines via `this.lines`.\n    // - strict : (optional) if `true`, all lines, including the last must end with CRLF (\\r\\n),\n    // if `false` (in any JavaScript sense) then line endings may be any mix of CRLF, LF, CR, or end-of-file.\n    // - trace (*) : (optional) a parser trace object, which will trace the parser that does the scan\n    this.scan = function scan(strict, trace) {\n        this.lines = scanner(this.chars, this.errors, strict, trace);\n        isScanned = true;\n    };\n    // Parse the input SABNF grammar for correct syntax.\n    // - strict : (optional) if `true`, the input grammar must be strict ABNF, conforming to [RFC 5234](https://tools.ietf.org/html/rfc5234)\n    // and [RFC 7405](https://tools.ietf.org/html/rfc7405). No superset features allowed.\n    // - trace (\\*) : (optional) a parser trace object, which will trace the syntax parser\n    //\n    // <i>(*)NOTE: the trace option was used primarily during development.\n    // Error detection and reporting is now fairly robust and tracing should be unnecessary. Use at your own peril.</i>\n    this.parse = function parse(strict, trace) {\n        if (!isScanned) {\n            throw new Error(`${thisFileName}grammar not scanned`);\n        }\n        parser.syntax(this.chars, this.lines, this.errors, strict, trace);\n        isParsed = true;\n    };\n    // Translate the SABNF grammar syntax into the opcodes that will guide the parser for this grammar.\n    this.translate = function translate() {\n        if (!isParsed) {\n            throw new Error(`${thisFileName}grammar not scanned and parsed`);\n        }\n        const ret = parser.semantic(this.chars, this.lines, this.errors);\n        if (this.errors.length === 0) {\n            this.rules = ret.rules;\n            this.udts = ret.udts;\n            lineMap = ret.lineMap;\n            isTranslated = true;\n        }\n    };\n    // Compute the attributes of each rule.\n    this.attributes = function attrs() {\n        if (!isTranslated) {\n            throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n        }\n        attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n        haveAttributes = true;\n        return attributeErrors;\n    };\n    // This function will perform the full suite of steps required to generate a parser grammar object\n    // from the input SABNF grammar.\n    this.generate = function generate(strict) {\n        this.lines = scanner(this.chars, this.errors, strict);\n        if (this.errors.length) {\n            return;\n        }\n        parser.syntax(this.chars, this.lines, this.errors, strict);\n        if (this.errors.length) {\n            return;\n        }\n        const ret = parser.semantic(this.chars, this.lines, this.errors);\n        if (this.errors.length) {\n            return;\n        }\n        this.rules = ret.rules;\n        this.udts = ret.udts;\n        lineMap = ret.lineMap;\n        attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n        haveAttributes = true;\n    };\n    // Display the rules.\n    // Must scan, parse and translate before calling this function, otherwise there are no rules to display.\n    // - order\n    //      - \"index\" or \"i\", index order (default)\n    //      - \"alpha\" or \"a\", alphabetical order\n    //      - none of above, index order (default)\n    this.displayRules = function displayRules(order = \"index\") {\n        if (!isTranslated) {\n            throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n        }\n        return showRules(this.rules, this.udts, order);\n    };\n    // Display the rule dependencies.\n    // Must scan, parse, translate and compute attributes before calling this function.\n    // Otherwise the rule dependencies are not known.\n    // - order\n    //      - \"index\" or \"i\", index order (default)\n    //      - \"alpha\" or \"a\", alphabetical order\n    //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n    //      - none of above, index order (default)\n    this.displayRuleDependencies = function displayRuleDependencies(order = \"index\") {\n        if (!haveAttributes) {\n            throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n        }\n        return showRuleDependencies(order);\n    };\n    // Display the attributes.\n    // Must scan, parse, translate and compute attributes before calling this function.\n    // - order\n    //      - \"index\" or \"i\", index order (default)\n    //      - \"alpha\" or \"a\", alphabetical order\n    //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n    //      - none of above, type order (default)\n    this.displayAttributes = function displayAttributes(order = \"index\") {\n        if (!haveAttributes) {\n            throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n        }\n        if (attributeErrors) {\n            showAttributeErrors(order);\n        }\n        return showAttributes(order);\n    };\n    this.displayAttributeErrors = function displayAttributeErrors() {\n        if (!haveAttributes) {\n            throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n        }\n        return showAttributeErrors();\n    };\n    // Returns a parser grammar object constructor function as a JavaScript string.\n    // This object can then be used to construct a parser.\n    this.toSource = function toSource(name) {\n        if (!haveAttributes) {\n            throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n        }\n        if (attributeErrors) {\n            throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n        }\n        return parser.generateSource(this.chars, this.lines, this.rules, this.udts, name);\n    };\n    // Returns a parser grammar object.\n    // This grammar object may be used by the application to construct a parser.\n    this.toObject = function toObject() {\n        if (!haveAttributes) {\n            throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n        }\n        if (attributeErrors) {\n            throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n        }\n        return parser.generateObject(this.sabnf, this.rules, this.udts);\n    };\n    // Display errors in text format, suitable for `console.log()`.\n    this.errorsToAscii = function errorsToAsciiFunc() {\n        return errorsToAscii(this.errors, this.lines, this.chars);\n    };\n    // Display errors in HTML format, suitable for web page display.\n    // (`apg-lib.css` required for proper styling)\n    this.errorsToHtml = function errorsToHtmlFunc(title) {\n        return errorsToHtml(this.errors, this.lines, this.chars, title);\n    };\n    // Generate an annotated the SABNF grammar display in text format.\n    this.linesToAscii = function linesToAsciiFunc() {\n        return linesToAscii(this.lines);\n    };\n    // Generate an annotated the SABNF grammar display in HTML format.\n    // (`apg-lib.css` required for proper styling)\n    this.linesToHtml = function linesToHtmlFunc() {\n        return linesToHtml(this.lines);\n    };\n// This function was only used by apg.html which has been abandoned.\n/*\n    this.getAttributesObject = function () {\n        return null;\n    };\n    */ };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O3VGQUd1RixHQUN2RixrR0FBa0c7QUFDbEcsRUFBRTtBQUNGLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0Isb0dBQW9HO0FBQ3BHLG9EQUFvRDtBQUNwRCxzSUFBc0k7QUFDdEksRUFBRTtBQUNGLHlJQUF5STtBQUV6SSx3S0FBd0s7QUFDeEssZ0dBQWdHO0FBQ2hHLHNGQUFzRjtBQUN0RixxSkFBcUo7QUFDckosbUNBQW1DO0FBQ25DLCtHQUErRztBQUMvRyx1REFBdUQ7QUFDdkQsc0NBQXNDO0FBQ3RDLEVBQUU7QUFDRixtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIscUNBQXFDOztBQUNyQ0EsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLElBQUlDLEdBQUc7SUFDL0IsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7SUFDM0IsTUFBTUMsZUFBZTtJQUNyQixNQUFNQyxhQUFhLElBQUk7SUFFdkIsc0JBQXNCLEdBQ3RCLE1BQU1DLFNBQVNILG1CQUFPQSxDQUFDO0lBQ3ZCLE1BQU1JLFlBQVlKLG1CQUFPQSxDQUFDO0lBQzFCLE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDO0lBQ3hCLE1BQU1NLFNBQVMsSUFBS04sQ0FBQUEsbUJBQU9BLENBQUMsd0dBQVU7SUFDdEMsTUFBTSxFQUFFTyxVQUFVLEVBQUVDLGNBQWMsRUFBRUMsbUJBQW1CLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0lBQzFGLE1BQU1XLFlBQVlYLG1CQUFPQSxDQUFDO0lBRTFCLCtCQUErQixHQUMvQix3REFBd0QsR0FDeEQsTUFBTVksYUFBYSxTQUFTQSxXQUFXQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztRQUNwRCxNQUFN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SyxFQUFFcUM7SUFDM0Q7SUFDQSxrRUFBa0U7SUFDbEUsSUFBSSxDQUFDUixZQUFZLEdBQUcsU0FBU3lEO1FBQzNCLE9BQU96RCxhQUFhLElBQUksQ0FBQ0MsS0FBSztJQUNoQztJQUNBLGtFQUFrRTtJQUNsRSw4Q0FBOEM7SUFDOUMsSUFBSSxDQUFDSyxXQUFXLEdBQUcsU0FBU29EO1FBQzFCLE9BQU9wRCxZQUFZLElBQUksQ0FBQ0wsS0FBSztJQUMvQjtBQUNBLG9FQUFvRTtBQUNwRTs7OztJQUlFLEdBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9hcGkuanM/ZWY0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBpcyBBcHBsaWNhdGlvbiBQcm9ncmFtbWluZyBJbnRlcmZhY2UgKEFQSSkgZm9yICoqQVBHKiogLSB0aGUgQUJORiBQYXJzZXIgR2VuZXJhdG9yLlxuLy9cbi8vICpOb3RlIG9uIHRlbWlub2xvZ3kuKlxuLy8gQVBHIGlzIGEgcGFyc2VyIGdlbmVyYXRvci5cbi8vIEhvd2V2ZXIsIGl0IHJlYWxseSBvbmx5IGdlbmVyYXRlcyBhIFwiZ3JhbW1hciBvYmplY3RcIiAoc2VlIGJlbG93KSBmcm9tIHRoZSBkZWZpbmluZyBTQUJORiBncmFtbWFyLlxuLy8gVGhlIGdlbmVyYXRlZCBwYXJzZXIgaXMgaW5jb21wbGV0ZSBhdCB0aGlzIHN0YWdlLlxuLy8gUmVtYWluaW5nLCBpdCBpcyB0aGUgam9iIG9mIHRoZSB1c2VyIHRvIGRldmVsb3AgdGhlIGdlbmVyYXRlZCBwYXJzZXIgZnJvbSB0aGUgZ3JhbW1hciBvYmplY3QgYW5kIHRoZSAqKkFQRyoqIExpYnJhcnkgKCoqYXBnLWxpYioqKS5cbi8vXG4vLyBUaGUgZm9sbG93aW5nIHRlcm1pbm9sb2d5IG15IGhlbHAgY2xlYXIgdXAgYW55IGNvbmZ1c2lvbiBiZXR3ZWVuIHRoZSBpZGVhIG9mIGEgXCJnZW5lcmF0ZWQgcGFyc2VyXCIgdmVyc3VzIGEgXCJnZW5lcmF0ZWQgZ3JhbW1hciBvYmplY3RcIi5cblxuLy8gLSBUaGUgZ2VuZXJhdGluZyBwYXJzZXI6ICoqQVBHKiogaXMgYW4gKipBUEcqKiBwYXJzZXIgKHllcywgdGhlcmUgaXMgYSBjaXJjdWxhciBkZXBlbmRlbmNlIGJldHdlZW4gKiphcGctYXBpKiogYW5kICoqYXBnLWxpYioqKS4gV2UnbGwgY2FsbCBpdCB0aGUgZ2VuZXJhdGluZyBwYXJzZXIuXG4vLyAtIFRoZSB0YXJnZXQgcGFyc2VyOiAqKkFQRyoqJ3MgZ29hbCBpcyB0byBnZW5lcmF0ZSBhIHBhcnNlci4gV2UnbGwgY2FsbCBpdCB0aGUgdGFyZ2V0IHBhcnNlci5cbi8vIC0gVGhlIHRhcmdldCBncmFtbWFyOiB0aGlzIGlzIHRoZSAoQVNDSUkpIFNBQk5GIGdyYW1tYXIgZGVmaW5pbmcgdGhlIHRhcmdldCBwYXJzZXIuXG4vLyAtIFRoZSB0YXJnZXQgZ3JhbW1hciBvYmplY3Q6ICoqQVBHKiogcGFyc2VzIHRoZSBTQUJORiBncmFtbWFyIGFuZCBnZW5lcmF0ZXMgdGhlIEphdmFTY3JpcHQgc291cmNlIGZvciBhIHRhcmdldCBncmFtbWFyIG9iamVjdCBjb25zdHJ1Y3RvciBmdW5jdGlvblxuLy8gYW5kL29yIGFuIGFjdHVhbCBncmFtbWFyIG9iamVjdC5cbi8vIC0gVGhlIGZpbmFsIHRhcmdldCBwYXJzZXI6IFRoZSB1c2VyIHRoZW4gZGV2ZWxvcHMgdGhlIGZpbmFsIHRhcmdldCBwYXJzZXIgdXNpbmcgdGhlIGdlbmVyYXRlZCB0YXJnZXQgZ3JhbW1hclxuLy8gb2JqZWN0IGFuZCB0aGUgKipBUEcqKiBwYXJzaW5nIGxpYnJhcnksICoqYXBnLWxpYioqLlxuLy8gVGhyb3dzIGV4ZWNlcHRpb25zIG9uIGZhdGFsIGVycm9ycy5cbi8vXG4vLyBzcmM6IHRoZSBpbnB1dCBTQUJORiBncmFtbWFyPGJyPlxuLy8gbWF5IGJlIG9uZSBvZjpcbi8vIC0gQnVmZmVyIG9mIGJ5dGVzXG4vLyAtIEphdmFTY3JpcHQgc3RyaW5nXG4vLyAtIEFycmF5IG9mIGludGVnZXIgY2hhcmFjdGVyIGNvZGVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwaShzcmMpIHtcbiAgY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnYXBpLmpzOiAnO1xuICBjb25zdCB0aGlzT2JqZWN0ID0gdGhpcztcblxuICAvKiBQUklWQVRFIFBST1BFUlRJRVMgKi9cbiAgY29uc3QgYXBnbGliID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHMnKTtcbiAgY29uc3QgY29udmVydGVyID0gcmVxdWlyZSgnLi4vYXBnLWNvbnYtYXBpL2NvbnZlcnRlcicpO1xuICBjb25zdCBzY2FubmVyID0gcmVxdWlyZSgnLi9zY2FubmVyJyk7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyAocmVxdWlyZSgnLi9wYXJzZXInKSkoKTtcbiAgY29uc3QgeyBhdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZUVycm9ycywgc2hvd1J1bGVEZXBlbmRlbmNpZXMgfSA9IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpO1xuICBjb25zdCBzaG93UnVsZXMgPSByZXF1aXJlKCcuL3Nob3ctcnVsZXMnKTtcblxuICAvKiBQUklWQVRFIE1FTUJFUlMgKEZVTkNUSU9OUykgKi9cbiAgLyogQ29udmVydCBhIHBocmFzZSAoYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzKSB0byBIVE1MLiAqL1xuICBjb25zdCBhYm5mVG9IdG1sID0gZnVuY3Rpb24gYWJuZlRvSHRtbChjaGFycywgYmVnLCBsZW4pIHtcbiAgICBjb25zdCBOT1JNQUwgPSAwO1xuICAgIGNvbnN0IENPTlRST0wgPSAxO1xuICAgIGNvbnN0IElOVkFMSUQgPSAyO1xuICAgIGNvbnN0IENPTlRST0xfQkVHID0gYDxzcGFuIGNsYXNzPVwiJHthcGdsaWIuc3R5bGUuQ0xBU1NfQ1RSTENIQVJ9XCI+YDtcbiAgICBjb25zdCBDT05UUk9MX0VORCA9ICc8L3NwYW4+JztcbiAgICBjb25zdCBJTlZBTElEX0JFRyA9IGA8c3BhbiBjbGFzcz1cIiR7YXBnbGliLnN0eWxlLkNMQVNTX05PTUFUQ0h9XCI+YDtcbiAgICBjb25zdCBJTlZBTElEX0VORCA9ICc8L3NwYW4+JztcbiAgICBsZXQgZW5kO1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjaGFycykgfHwgY2hhcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiZWcgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWJuZlRvSHRtbDogYmVnIG11c3QgYmUgdHlwZSBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmIChiZWcgPj0gY2hhcnMubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsZW4gIT09ICdudW1iZXInIHx8IGJlZyArIGxlbiA+PSBjaGFycy5sZW5ndGgpIHtcbiAgICAgICAgZW5kID0gY2hhcnMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gYmVnICsgbGVuO1xuICAgICAgfVxuICAgICAgbGV0IHN0YXRlID0gTk9STUFMO1xuICAgICAgZm9yIChsZXQgaSA9IGJlZzsgaSA8IGVuZDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNoID0gY2hhcnNbaV07XG4gICAgICAgIGlmIChjaCA+PSAzMiAmJiBjaCA8PSAxMjYpIHtcbiAgICAgICAgICAvKiBub3JtYWwgLSBwcmludGFibGUgQVNDSUkgY2hhcmFjdGVycyAqL1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gQ09OVFJPTCkge1xuICAgICAgICAgICAgaHRtbCArPSBDT05UUk9MX0VORDtcbiAgICAgICAgICAgIHN0YXRlID0gTk9STUFMO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IElOVkFMSUQpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gSU5WQUxJRF9FTkQ7XG4gICAgICAgICAgICBzdGF0ZSA9IE5PUk1BTDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogaGFuZGxlIHJlc2VydmVkIEhUTUwgZW50aXR5IGNoYXJhY3RlcnMgKi9cbiAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICBodG1sICs9ICcmbmJzcDsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyZsdDsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyZndDsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyZhbXA7JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICBodG1sICs9ICcmcXVvdDsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyYjMDM5Oyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA5MjpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJiMwOTI7JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBodG1sICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkgfHwgY2ggPT09IDEwIHx8IGNoID09PSAxMykge1xuICAgICAgICAgIC8qIGNvbnRyb2wgY2hhcmFjdGVycyAqL1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gTk9STUFMKSB7XG4gICAgICAgICAgICBodG1sICs9IENPTlRST0xfQkVHO1xuICAgICAgICAgICAgc3RhdGUgPSBDT05UUk9MO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IElOVkFMSUQpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gSU5WQUxJRF9FTkQgKyBDT05UUk9MX0JFRztcbiAgICAgICAgICAgIHN0YXRlID0gQ09OVFJPTDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoID09PSA5KSB7XG4gICAgICAgICAgICBodG1sICs9ICdUQUInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2ggPT09IDEwKSB7XG4gICAgICAgICAgICBodG1sICs9ICdMRic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaCA9PT0gMTMpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJ0NSJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogaW52YWxpZCBjaGFyYWN0ZXJzICovXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBOT1JNQUwpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gSU5WQUxJRF9CRUc7XG4gICAgICAgICAgICBzdGF0ZSA9IElOVkFMSUQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQ09OVFJPTCkge1xuICAgICAgICAgICAgaHRtbCArPSBDT05UUk9MX0VORCArIElOVkFMSURfQkVHO1xuICAgICAgICAgICAgc3RhdGUgPSBJTlZBTElEO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBkaXNwbGF5IGNoYXJhY3RlciBhcyBoZXhhZGVjaW1hbCB2YWx1ZSAqL1xuICAgICAgICAgIGh0bWwgKz0gYFxcXFx4JHthcGdsaWIudXRpbHMuY2hhclRvSGV4KGNoKX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IElOVkFMSUQpIHtcbiAgICAgICAgaHRtbCArPSBJTlZBTElEX0VORDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PT0gQ09OVFJPTCkge1xuICAgICAgICBodG1sICs9IENPTlRST0xfRU5EO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBDb252ZXJ0IGEgcGhyYXNlIChhcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMpIHRvIEFTQ0lJIHRleHQuICovXG4gIGNvbnN0IGFibmZUb0FzY2lpID0gZnVuY3Rpb24gYWJuZlRvQXNjaWkoY2hhcnMsIGJlZywgbGVuKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSBiZWc7IGkgPCBiZWcgKyBsZW47IGkgKz0gMSkge1xuICAgICAgY29uc3QgY2ggPSBjaGFyc1tpXTtcbiAgICAgIGlmIChjaCA+PSAzMiAmJiBjaCA8PSAxMjYpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHN0ciArPSAnXFxcXHQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHN0ciArPSAnXFxcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxcXHInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN0ciArPSAnXFxcXHVua25vd24nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgLyogdHJhbnNsYXRlIGxpbmVzIChTQUJORiBncmFtbWFyKSB0byBBU0NJSSB0ZXh0ICovXG4gIGNvbnN0IGxpbmVzVG9Bc2NpaSA9IGZ1bmN0aW9uIGxpbmVzVG9Bc2NpaShsaW5lcykge1xuICAgIGxldCBzdHIgPSAnQW5ub3RhdGVkIElucHV0IEdyYW1tYXInO1xuICAgIGxpbmVzLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgc3RyICs9IGBsaW5lIG5vOiAke3ZhbC5saW5lTm99YDtcbiAgICAgIHN0ciArPSBgIDogY2hhciBpbmRleDogJHt2YWwuYmVnaW5DaGFyfWA7XG4gICAgICBzdHIgKz0gYCA6IGxlbmd0aDogJHt2YWwubGVuZ3RofWA7XG4gICAgICBzdHIgKz0gYCA6IGFibmY6ICR7YWJuZlRvQXNjaWkodGhpc09iamVjdC5jaGFycywgdmFsLmJlZ2luQ2hhciwgdmFsLmxlbmd0aCl9YDtcbiAgICB9KTtcbiAgICBzdHIgKz0gJ1xcbic7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgLyogdHJhbnNsYXRlIGxpbmVzIChTQUJORiBncmFtbWFyKSB0byBIVE1MICovXG4gIGNvbnN0IGxpbmVzVG9IdG1sID0gZnVuY3Rpb24gbGluZXNUb0h0bWwobGluZXMpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGh0bWwgKz0gYDx0YWJsZSBjbGFzcz1cIiR7YXBnbGliLnN0eWxlLkNMQVNTX0dSQU1NQVJ9XCI+XFxuYDtcbiAgICBjb25zdCB0aXRsZSA9ICdBbm5vdGF0ZWQgSW5wdXQgR3JhbW1hcic7XG4gICAgaHRtbCArPSBgPGNhcHRpb24+JHt0aXRsZX08L2NhcHRpb24+XFxuYDtcbiAgICBodG1sICs9ICc8dHI+JztcbiAgICBodG1sICs9ICc8dGg+bGluZTxicj5uby48L3RoPjx0aD5maXJzdDxicj5jaGFyPC90aD48dGg+PGJyPmxlbmd0aDwvdGg+PHRoPjxicj50ZXh0PC90aD4nO1xuICAgIGh0bWwgKz0gJzwvdHI+XFxuJztcbiAgICBsaW5lcy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgaHRtbCArPSBgPHRkPiR7dmFsLmxpbmVOb31gO1xuICAgICAgaHRtbCArPSBgPC90ZD48dGQ+JHt2YWwuYmVnaW5DaGFyfWA7XG4gICAgICBodG1sICs9IGA8L3RkPjx0ZD4ke3ZhbC5sZW5ndGh9YDtcbiAgICAgIGh0bWwgKz0gYDwvdGQ+PHRkPiR7YWJuZlRvSHRtbCh0aGlzT2JqZWN0LmNoYXJzLCB2YWwuYmVnaW5DaGFyLCB2YWwubGVuZ3RoKX1gO1xuICAgICAgaHRtbCArPSAnPC90ZD4nO1xuICAgICAgaHRtbCArPSAnPC90cj5cXG4nO1xuICAgIH0pO1xuXG4gICAgaHRtbCArPSAnPC90YWJsZT5cXG4nO1xuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBGb3JtYXQgdGhlIGVycm9yIG1lc3NhZ2VzIHRvIEhUTUwsIGZvciBwYWdlIGRpc3BsYXkuICovXG4gIGNvbnN0IGVycm9yc1RvSHRtbCA9IGZ1bmN0aW9uIGVycm9yc1RvSHRtbChlcnJvcnMsIGxpbmVzLCBjaGFycywgdGl0bGUpIHtcbiAgICBjb25zdCBbc3R5bGVdID0gYXBnbGliO1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgY29uc3QgZXJyb3JBcnJvdyA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4mcmFxdW87PC9zcGFuPmA7XG4gICAgaHRtbCArPSBgPHA+PHRhYmxlIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19HUkFNTUFSfVwiPlxcbmA7XG4gICAgaWYgKHRpdGxlICYmIHR5cGVvZiB0aXRsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGh0bWwgKz0gYDxjYXB0aW9uPiR7dGl0bGV9PC9jYXB0aW9uPlxcbmA7XG4gICAgfVxuICAgIGh0bWwgKz0gJzx0cj48dGg+bGluZTxicj5uby48L3RoPjx0aD5saW5lPGJyPm9mZnNldDwvdGg+PHRoPmVycm9yPGJyPm9mZnNldDwvdGg+PHRoPjxicj50ZXh0PC90aD48L3RyPlxcbic7XG4gICAgZXJyb3JzLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgbGV0IGxpbmU7XG4gICAgICBsZXQgcmVsY2hhcjtcbiAgICAgIGxldCBiZWc7XG4gICAgICBsZXQgZW5kO1xuICAgICAgbGV0IHRleHQ7XG4gICAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgICBsZXQgc3VmZml4ID0gJyc7XG4gICAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRleHQgPSBlcnJvckFycm93O1xuICAgICAgICByZWxjaGFyID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmUgPSBsaW5lc1t2YWwubGluZV07XG4gICAgICAgIGJlZyA9IGxpbmUuYmVnaW5DaGFyO1xuICAgICAgICBpZiAodmFsLmNoYXIgPiBiZWcpIHtcbiAgICAgICAgICBwcmVmaXggPSBhYm5mVG9IdG1sKGNoYXJzLCBiZWcsIHZhbC5jaGFyIC0gYmVnKTtcbiAgICAgICAgfVxuICAgICAgICBiZWcgPSB2YWwuY2hhcjtcbiAgICAgICAgZW5kID0gbGluZS5iZWdpbkNoYXIgKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgaWYgKGJlZyA8IGVuZCkge1xuICAgICAgICAgIHN1ZmZpeCA9IGFibmZUb0h0bWwoY2hhcnMsIGJlZywgZW5kIC0gYmVnKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gcHJlZml4ICsgZXJyb3JBcnJvdyArIHN1ZmZpeDtcbiAgICAgICAgcmVsY2hhciA9IHZhbC5jaGFyIC0gbGluZS5iZWdpbkNoYXI7XG4gICAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgICBodG1sICs9IGA8dGQ+JHt2YWwubGluZX08L3RkPjx0ZD4ke2xpbmUuYmVnaW5DaGFyfTwvdGQ+PHRkPiR7cmVsY2hhcn08L3RkPjx0ZD4ke3RleHR9PC90ZD5gO1xuICAgICAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgICBodG1sICs9IGA8dGQgY29sc3Bhbj1cIjNcIj48L3RkPjx0ZD4mdWFycjs6Jm5ic3A7JHthcGdsaWIudXRpbHMuc3RyaW5nVG9Bc2NpaUh0bWwodmFsLm1zZyl9PC90ZD5gO1xuICAgICAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaHRtbCArPSAnPC90YWJsZT48L3A+XFxuJztcbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogRGlzcGxheSBhbiBhcnJheSBvZiBlcnJvcnMgaW4gQVNDSUkgdGV4dCAqL1xuICBjb25zdCBlcnJvcnNUb0FzY2lpID0gZnVuY3Rpb24gZXJyb3JzVG9Bc2NpaShlcnJvcnMsIGxpbmVzLCBjaGFycykge1xuICAgIGxldCBzdHI7XG4gICAgbGV0IGxpbmU7XG4gICAgbGV0IGJlZztcbiAgICBsZXQgbGVuO1xuICAgIHN0ciA9ICcnO1xuICAgIGVycm9ycy5mb3JFYWNoKChlcnJvcikgPT4ge1xuICAgICAgbGluZSA9IGxpbmVzW2Vycm9yLmxpbmVdO1xuICAgICAgc3RyICs9IGAke2xpbmUubGluZU5vfTogYDtcbiAgICAgIHN0ciArPSBgJHtsaW5lLmJlZ2luQ2hhcn06IGA7XG4gICAgICBzdHIgKz0gYCR7ZXJyb3IuY2hhciAtIGxpbmUuYmVnaW5DaGFyfTogYDtcbiAgICAgIGJlZyA9IGxpbmUuYmVnaW5DaGFyO1xuICAgICAgbGVuID0gZXJyb3IuY2hhciAtIGxpbmUuYmVnaW5DaGFyO1xuICAgICAgc3RyICs9IGFibmZUb0FzY2lpKGNoYXJzLCBiZWcsIGxlbik7XG4gICAgICBzdHIgKz0gJyA+PiAnO1xuICAgICAgYmVnID0gZXJyb3IuY2hhcjtcbiAgICAgIGxlbiA9IGxpbmUuYmVnaW5DaGFyICsgbGluZS5sZW5ndGggLSBlcnJvci5jaGFyO1xuICAgICAgc3RyICs9IGFibmZUb0FzY2lpKGNoYXJzLCBiZWcsIGxlbik7XG4gICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICBzdHIgKz0gYCR7bGluZS5saW5lTm99OiBgO1xuICAgICAgc3RyICs9IGAke2xpbmUuYmVnaW5DaGFyfTogYDtcbiAgICAgIHN0ciArPSBgJHtlcnJvci5jaGFyIC0gbGluZS5iZWdpbkNoYXJ9OiBgO1xuICAgICAgc3RyICs9ICdlcnJvcjogJztcbiAgICAgIHN0ciArPSBlcnJvci5tc2c7XG4gICAgICBzdHIgKz0gJ1xcbic7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgbGV0IGlzU2Nhbm5lZCA9IGZhbHNlO1xuICBsZXQgaXNQYXJzZWQgPSBmYWxzZTtcbiAgbGV0IGlzVHJhbnNsYXRlZCA9IGZhbHNlO1xuICBsZXQgaGF2ZUF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgbGV0IGF0dHJpYnV0ZUVycm9ycyA9IDA7XG4gIGxldCBsaW5lTWFwO1xuXG4gIC8qIFBVQkxJQyBQUk9QRVJUSUVTICovXG4gIC8vIFRoZSBpbnB1dCBTQUJORiBncmFtbWFyIGFzIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4gIC8vIHRoaXMuc2FibmY7XG4gIC8vIFRoZSBpbnB1dCBTQUJORiBncmFtbWFyIGFzIGFuIGFycmF5IG9mIGNoYXJhY3RlciBjb2Rlcy5cbiAgLy8gdGhpcy5jaGFycztcbiAgLy8gQW4gYXJyYXkgb2YgbGluZSBvYmplY3RzLCBkZWZpbmluZyBlYWNoIGxpbmUgb2YgdGhlIGlucHV0IFNBQk5GIGdyYW1tYXJcbiAgLy8gLSBsaW5lTm8gOiB0aGUgemVyby1iYXNlZCBsaW5lIG51bWJlclxuICAvLyAtIGJlZ2luQ2hhciA6IG9mZnNldCAoaW50byBgdGhpcy5jaGFyc2ApIG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIGxpbmVcbiAgLy8gLSBsZW5ndGggOiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gdGhlIGxpbmVcbiAgLy8gLSB0ZXh0TGVuZ3RoIDogdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHRleHQgaW4gdGhlIGxpbmUsIGV4Y2x1ZGluZyB0aGUgbGluZSBlbmRpbmcgY2hhcmFjdGVyc1xuICAvLyAtIGVuZFR5cGUgOiBcIkNSTEZcIiwgXCJMRlwiLCBcIkNSXCIgb3IgXCJub25lXCIgaWYgdGhlIGxhc3QgbGluZSBoYXMgbm8gbGluZSBlbmRpbmcgY2hhcmFjdGVyc1xuICAvLyAtIGludmFsaWRDaGFycyA6IGB0cnVlYCBpZiB0aGUgbGluZSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gIC8vIHRoaXMubGluZXM7XG4gIC8vIEFuIGFycmF5IG9mIHJ1bGUgbmFtZXMgYW5kIGRhdGEuXG4gIC8vIC0gbmFtZSA6IHRoZSBydWxlIG5hbWVcbiAgLy8gLSBsb3dlciA6IHRoZSBydWxlIG5hbWUgaW4gbG93ZXIgY2FzZVxuICAvLyAtIGluZGV4IDogdGhlIGluZGV4IG9mIHRoZSBydWxlIChvcmRlcmVkIGJ5IGFwcGVhcmFuY2UgaW4gU0FCTkYgZ3JhbW1hcilcbiAgLy8gLSBpc0JrciA6IGB0cnVlYCBpZiB0aGlzIHJ1bGUgaGFzIGJlZW4gYmFjayByZWZlcmVuY2VkLCBgZmFsc2VgIG90aGVyd2lzZVxuICAvLyAtIG9wY29kZXMgOiBhcnJheSBvZiBvcGNvZGVzIGZvciB0aGlzIHJ1bGVcbiAgLy8gLSBhdHRycyA6IHRoZSBydWxlIGF0dHJpYnV0ZXNcbiAgLy8gLSBjdHJsIDogc3lzdGVtIGRhdGFcbiAgLy8gdGhpcy5ydWxlcztcbiAgLy8gQW4gYXJyYXkgb2YgVURUIG5hbWVzIGFuZCBkYXRhLlxuICAvLyB0aGlzLnVkdHM7XG4gIC8vIEFuIGFycmF5IG9mIGVycm9ycywgaWYgYW55LlxuICAvLyAtIGxpbmUgOiB0aGUgbGluZSBudW1iZXIgY29udGFpbmluZyB0aGUgZXJyb3JcbiAgLy8gLSBjaGFyIDogdGhlIGNoYXJhY3RlciBvZmZzZXQgb2YgdGhlIGVycm9yXG4gIC8vIC0gbXNnIDogdGhlIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lcnJvcnMgPSBbXTtcblxuICAvKiBDT05TVFJVQ1RPUiAqL1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNyYykpIHtcbiAgICB0aGlzLmNoYXJzID0gY29udmVydGVyLmRlY29kZSgnQklOQVJZJywgc3JjKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICB0aGlzLmNoYXJzID0gc3JjLnNsaWNlKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoYXJzID0gY29udmVydGVyLmRlY29kZSgnU1RSSU5HJywgc3JjKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWlucHV0IHNvdXJjZSBpcyBub3QgYSBzdHJpbmcsIGJ5dGUgQnVmZmVyIG9yIGNoYXJhY3RlciBhcnJheWApO1xuICB9XG4gIHRoaXMuc2FibmYgPSBjb252ZXJ0ZXIuZW5jb2RlKCdTVFJJTkcnLCB0aGlzLmNoYXJzKTtcblxuICAvKiBQVUJMSUMgTUVNQkVSUyAoRlVOQ1RJT05TKSAqL1xuICAvLyBTY2FuIHRoZSBpbnB1dCBTQUJORiBncmFtbWFyIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMgYW5kIGNhdGFsb2cgdGhlIGxpbmVzIHZpYSBgdGhpcy5saW5lc2AuXG4gIC8vIC0gc3RyaWN0IDogKG9wdGlvbmFsKSBpZiBgdHJ1ZWAsIGFsbCBsaW5lcywgaW5jbHVkaW5nIHRoZSBsYXN0IG11c3QgZW5kIHdpdGggQ1JMRiAoXFxyXFxuKSxcbiAgLy8gaWYgYGZhbHNlYCAoaW4gYW55IEphdmFTY3JpcHQgc2Vuc2UpIHRoZW4gbGluZSBlbmRpbmdzIG1heSBiZSBhbnkgbWl4IG9mIENSTEYsIExGLCBDUiwgb3IgZW5kLW9mLWZpbGUuXG4gIC8vIC0gdHJhY2UgKCopIDogKG9wdGlvbmFsKSBhIHBhcnNlciB0cmFjZSBvYmplY3QsIHdoaWNoIHdpbGwgdHJhY2UgdGhlIHBhcnNlciB0aGF0IGRvZXMgdGhlIHNjYW5cbiAgdGhpcy5zY2FuID0gZnVuY3Rpb24gc2NhbihzdHJpY3QsIHRyYWNlKSB7XG4gICAgdGhpcy5saW5lcyA9IHNjYW5uZXIodGhpcy5jaGFycywgdGhpcy5lcnJvcnMsIHN0cmljdCwgdHJhY2UpO1xuICAgIGlzU2Nhbm5lZCA9IHRydWU7XG4gIH07XG4gIC8vIFBhcnNlIHRoZSBpbnB1dCBTQUJORiBncmFtbWFyIGZvciBjb3JyZWN0IHN5bnRheC5cbiAgLy8gLSBzdHJpY3QgOiAob3B0aW9uYWwpIGlmIGB0cnVlYCwgdGhlIGlucHV0IGdyYW1tYXIgbXVzdCBiZSBzdHJpY3QgQUJORiwgY29uZm9ybWluZyB0byBbUkZDIDUyMzRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MjM0KVxuICAvLyBhbmQgW1JGQyA3NDA1XShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzQwNSkuIE5vIHN1cGVyc2V0IGZlYXR1cmVzIGFsbG93ZWQuXG4gIC8vIC0gdHJhY2UgKFxcKikgOiAob3B0aW9uYWwpIGEgcGFyc2VyIHRyYWNlIG9iamVjdCwgd2hpY2ggd2lsbCB0cmFjZSB0aGUgc3ludGF4IHBhcnNlclxuICAvL1xuICAvLyA8aT4oKilOT1RFOiB0aGUgdHJhY2Ugb3B0aW9uIHdhcyB1c2VkIHByaW1hcmlseSBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gIC8vIEVycm9yIGRldGVjdGlvbiBhbmQgcmVwb3J0aW5nIGlzIG5vdyBmYWlybHkgcm9idXN0IGFuZCB0cmFjaW5nIHNob3VsZCBiZSB1bm5lY2Vzc2FyeS4gVXNlIGF0IHlvdXIgb3duIHBlcmlsLjwvaT5cbiAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHN0cmljdCwgdHJhY2UpIHtcbiAgICBpZiAoIWlzU2Nhbm5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ncmFtbWFyIG5vdCBzY2FubmVkYCk7XG4gICAgfVxuICAgIHBhcnNlci5zeW50YXgodGhpcy5jaGFycywgdGhpcy5saW5lcywgdGhpcy5lcnJvcnMsIHN0cmljdCwgdHJhY2UpO1xuICAgIGlzUGFyc2VkID0gdHJ1ZTtcbiAgfTtcbiAgLy8gVHJhbnNsYXRlIHRoZSBTQUJORiBncmFtbWFyIHN5bnRheCBpbnRvIHRoZSBvcGNvZGVzIHRoYXQgd2lsbCBndWlkZSB0aGUgcGFyc2VyIGZvciB0aGlzIGdyYW1tYXIuXG4gIHRoaXMudHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlKCkge1xuICAgIGlmICghaXNQYXJzZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Z3JhbW1hciBub3Qgc2Nhbm5lZCBhbmQgcGFyc2VkYCk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHBhcnNlci5zZW1hbnRpYyh0aGlzLmNoYXJzLCB0aGlzLmxpbmVzLCB0aGlzLmVycm9ycyk7XG4gICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5ydWxlcyA9IHJldC5ydWxlcztcbiAgICAgIHRoaXMudWR0cyA9IHJldC51ZHRzO1xuICAgICAgbGluZU1hcCA9IHJldC5saW5lTWFwO1xuICAgICAgaXNUcmFuc2xhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8vIENvbXB1dGUgdGhlIGF0dHJpYnV0ZXMgb2YgZWFjaCBydWxlLlxuICB0aGlzLmF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBhdHRycygpIHtcbiAgICBpZiAoIWlzVHJhbnNsYXRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ncmFtbWFyIG5vdCBzY2FubmVkLCBwYXJzZWQgYW5kIHRyYW5zbGF0ZWRgKTtcbiAgICB9XG4gICAgYXR0cmlidXRlRXJyb3JzID0gYXR0cmlidXRlcyh0aGlzLnJ1bGVzLCB0aGlzLnVkdHMsIGxpbmVNYXAsIHRoaXMuZXJyb3JzKTtcbiAgICBoYXZlQXR0cmlidXRlcyA9IHRydWU7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZUVycm9ycztcbiAgfTtcbiAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHBlcmZvcm0gdGhlIGZ1bGwgc3VpdGUgb2Ygc3RlcHMgcmVxdWlyZWQgdG8gZ2VuZXJhdGUgYSBwYXJzZXIgZ3JhbW1hciBvYmplY3RcbiAgLy8gZnJvbSB0aGUgaW5wdXQgU0FCTkYgZ3JhbW1hci5cbiAgdGhpcy5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKHN0cmljdCkge1xuICAgIHRoaXMubGluZXMgPSBzY2FubmVyKHRoaXMuY2hhcnMsIHRoaXMuZXJyb3JzLCBzdHJpY3QpO1xuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFyc2VyLnN5bnRheCh0aGlzLmNoYXJzLCB0aGlzLmxpbmVzLCB0aGlzLmVycm9ycywgc3RyaWN0KTtcbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHBhcnNlci5zZW1hbnRpYyh0aGlzLmNoYXJzLCB0aGlzLmxpbmVzLCB0aGlzLmVycm9ycyk7XG4gICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJ1bGVzID0gcmV0LnJ1bGVzO1xuICAgIHRoaXMudWR0cyA9IHJldC51ZHRzO1xuICAgIGxpbmVNYXAgPSByZXQubGluZU1hcDtcblxuICAgIGF0dHJpYnV0ZUVycm9ycyA9IGF0dHJpYnV0ZXModGhpcy5ydWxlcywgdGhpcy51ZHRzLCBsaW5lTWFwLCB0aGlzLmVycm9ycyk7XG4gICAgaGF2ZUF0dHJpYnV0ZXMgPSB0cnVlO1xuICB9O1xuICAvLyBEaXNwbGF5IHRoZSBydWxlcy5cbiAgLy8gTXVzdCBzY2FuLCBwYXJzZSBhbmQgdHJhbnNsYXRlIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIG90aGVyd2lzZSB0aGVyZSBhcmUgbm8gcnVsZXMgdG8gZGlzcGxheS5cbiAgLy8gLSBvcmRlclxuICAvLyAgICAgIC0gXCJpbmRleFwiIG9yIFwiaVwiLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgLy8gICAgICAtIFwiYWxwaGFcIiBvciBcImFcIiwgYWxwaGFiZXRpY2FsIG9yZGVyXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgdGhpcy5kaXNwbGF5UnVsZXMgPSBmdW5jdGlvbiBkaXNwbGF5UnVsZXMob3JkZXIgPSAnaW5kZXgnKSB7XG4gICAgaWYgKCFpc1RyYW5zbGF0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Z3JhbW1hciBub3Qgc2Nhbm5lZCwgcGFyc2VkIGFuZCB0cmFuc2xhdGVkYCk7XG4gICAgfVxuICAgIHJldHVybiBzaG93UnVsZXModGhpcy5ydWxlcywgdGhpcy51ZHRzLCBvcmRlcik7XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHJ1bGUgZGVwZW5kZW5jaWVzLlxuICAvLyBNdXN0IHNjYW4sIHBhcnNlLCB0cmFuc2xhdGUgYW5kIGNvbXB1dGUgYXR0cmlidXRlcyBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAvLyBPdGhlcndpc2UgdGhlIHJ1bGUgZGVwZW5kZW5jaWVzIGFyZSBub3Qga25vd24uXG4gIC8vIC0gb3JkZXJcbiAgLy8gICAgICAtIFwiaW5kZXhcIiBvciBcImlcIiwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIC8vICAgICAgLSBcImFscGhhXCIgb3IgXCJhXCIsIGFscGhhYmV0aWNhbCBvcmRlclxuICAvLyAgICAgIC0gXCJ0eXBlXCIgb3IgXCJ0XCIsIG9yZGVyZWQgYnkgdHlwZSAoYWxwaGFiZXRpY2FsIHdpdGhpbiBlYWNoIHR5cGUvZ3JvdXApXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgdGhpcy5kaXNwbGF5UnVsZURlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIGRpc3BsYXlSdWxlRGVwZW5kZW5jaWVzKG9yZGVyID0gJ2luZGV4Jykge1xuICAgIGlmICghaGF2ZUF0dHJpYnV0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9bm8gYXR0cmlidXRlcyAtIG11c3QgYmUgcHJlY2VlZGVkIGJ5IGNhbGwgdG8gYXR0cmlidXRlcygpYCk7XG4gICAgfVxuICAgIHJldHVybiBzaG93UnVsZURlcGVuZGVuY2llcyhvcmRlcik7XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIGF0dHJpYnV0ZXMuXG4gIC8vIE11c3Qgc2NhbiwgcGFyc2UsIHRyYW5zbGF0ZSBhbmQgY29tcHV0ZSBhdHRyaWJ1dGVzIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gIC8vIC0gb3JkZXJcbiAgLy8gICAgICAtIFwiaW5kZXhcIiBvciBcImlcIiwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIC8vICAgICAgLSBcImFscGhhXCIgb3IgXCJhXCIsIGFscGhhYmV0aWNhbCBvcmRlclxuICAvLyAgICAgIC0gXCJ0eXBlXCIgb3IgXCJ0XCIsIG9yZGVyZWQgYnkgdHlwZSAoYWxwaGFiZXRpY2FsIHdpdGhpbiBlYWNoIHR5cGUvZ3JvdXApXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCB0eXBlIG9yZGVyIChkZWZhdWx0KVxuICB0aGlzLmRpc3BsYXlBdHRyaWJ1dGVzID0gZnVuY3Rpb24gZGlzcGxheUF0dHJpYnV0ZXMob3JkZXIgPSAnaW5kZXgnKSB7XG4gICAgaWYgKCFoYXZlQXR0cmlidXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ubyBhdHRyaWJ1dGVzIC0gbXVzdCBiZSBwcmVjZWVkZWQgYnkgY2FsbCB0byBhdHRyaWJ1dGVzKClgKTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZUVycm9ycykge1xuICAgICAgc2hvd0F0dHJpYnV0ZUVycm9ycyhvcmRlcik7XG4gICAgfVxuICAgIHJldHVybiBzaG93QXR0cmlidXRlcyhvcmRlcik7XG4gIH07XG4gIHRoaXMuZGlzcGxheUF0dHJpYnV0ZUVycm9ycyA9IGZ1bmN0aW9uIGRpc3BsYXlBdHRyaWJ1dGVFcnJvcnMoKSB7XG4gICAgaWYgKCFoYXZlQXR0cmlidXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ubyBhdHRyaWJ1dGVzIC0gbXVzdCBiZSBwcmVjZWVkZWQgYnkgY2FsbCB0byBhdHRyaWJ1dGVzKClgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3dBdHRyaWJ1dGVFcnJvcnMoKTtcbiAgfTtcbiAgLy8gUmV0dXJucyBhIHBhcnNlciBncmFtbWFyIG9iamVjdCBjb25zdHJ1Y3RvciBmdW5jdGlvbiBhcyBhIEphdmFTY3JpcHQgc3RyaW5nLlxuICAvLyBUaGlzIG9iamVjdCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIHBhcnNlci5cbiAgdGhpcy50b1NvdXJjZSA9IGZ1bmN0aW9uIHRvU291cmNlKG5hbWUpIHtcbiAgICBpZiAoIWhhdmVBdHRyaWJ1dGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNhbid0IGdlbmVyYXRlIHBhcnNlciBzb3VyY2UgLSBtdXN0IGJlIHByZWNlZWRlZCBieSBjYWxsIHRvIGF0dHJpYnV0ZXMoKWApO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlRXJyb3JzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNhbid0IGdlbmVyYXRlIHBhcnNlciBzb3VyY2UgLSBhdHRyaWJ1dGVzIGhhdmUgJHthdHRyaWJ1dGVFcnJvcnN9IGVycm9yc2ApO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmdlbmVyYXRlU291cmNlKHRoaXMuY2hhcnMsIHRoaXMubGluZXMsIHRoaXMucnVsZXMsIHRoaXMudWR0cywgbmFtZSk7XG4gIH07XG4gIC8vIFJldHVybnMgYSBwYXJzZXIgZ3JhbW1hciBvYmplY3QuXG4gIC8vIFRoaXMgZ3JhbW1hciBvYmplY3QgbWF5IGJlIHVzZWQgYnkgdGhlIGFwcGxpY2F0aW9uIHRvIGNvbnN0cnVjdCBhIHBhcnNlci5cbiAgdGhpcy50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgIGlmICghaGF2ZUF0dHJpYnV0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2FuJ3QgZ2VuZXJhdGUgcGFyc2VyIHNvdXJjZSAtIG11c3QgYmUgcHJlY2VlZGVkIGJ5IGNhbGwgdG8gYXR0cmlidXRlcygpYCk7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVFcnJvcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2FuJ3QgZ2VuZXJhdGUgcGFyc2VyIHNvdXJjZSAtIGF0dHJpYnV0ZXMgaGF2ZSAke2F0dHJpYnV0ZUVycm9yc30gZXJyb3JzYCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIuZ2VuZXJhdGVPYmplY3QodGhpcy5zYWJuZiwgdGhpcy5ydWxlcywgdGhpcy51ZHRzKTtcbiAgfTtcbiAgLy8gRGlzcGxheSBlcnJvcnMgaW4gdGV4dCBmb3JtYXQsIHN1aXRhYmxlIGZvciBgY29uc29sZS5sb2coKWAuXG4gIHRoaXMuZXJyb3JzVG9Bc2NpaSA9IGZ1bmN0aW9uIGVycm9yc1RvQXNjaWlGdW5jKCkge1xuICAgIHJldHVybiBlcnJvcnNUb0FzY2lpKHRoaXMuZXJyb3JzLCB0aGlzLmxpbmVzLCB0aGlzLmNoYXJzKTtcbiAgfTtcbiAgLy8gRGlzcGxheSBlcnJvcnMgaW4gSFRNTCBmb3JtYXQsIHN1aXRhYmxlIGZvciB3ZWIgcGFnZSBkaXNwbGF5LlxuICAvLyAoYGFwZy1saWIuY3NzYCByZXF1aXJlZCBmb3IgcHJvcGVyIHN0eWxpbmcpXG4gIHRoaXMuZXJyb3JzVG9IdG1sID0gZnVuY3Rpb24gZXJyb3JzVG9IdG1sRnVuYyh0aXRsZSkge1xuICAgIHJldHVybiBlcnJvcnNUb0h0bWwodGhpcy5lcnJvcnMsIHRoaXMubGluZXMsIHRoaXMuY2hhcnMsIHRpdGxlKTtcbiAgfTtcbiAgLy8gR2VuZXJhdGUgYW4gYW5ub3RhdGVkIHRoZSBTQUJORiBncmFtbWFyIGRpc3BsYXkgaW4gdGV4dCBmb3JtYXQuXG4gIHRoaXMubGluZXNUb0FzY2lpID0gZnVuY3Rpb24gbGluZXNUb0FzY2lpRnVuYygpIHtcbiAgICByZXR1cm4gbGluZXNUb0FzY2lpKHRoaXMubGluZXMpO1xuICB9O1xuICAvLyBHZW5lcmF0ZSBhbiBhbm5vdGF0ZWQgdGhlIFNBQk5GIGdyYW1tYXIgZGlzcGxheSBpbiBIVE1MIGZvcm1hdC5cbiAgLy8gKGBhcGctbGliLmNzc2AgcmVxdWlyZWQgZm9yIHByb3BlciBzdHlsaW5nKVxuICB0aGlzLmxpbmVzVG9IdG1sID0gZnVuY3Rpb24gbGluZXNUb0h0bWxGdW5jKCkge1xuICAgIHJldHVybiBsaW5lc1RvSHRtbCh0aGlzLmxpbmVzKTtcbiAgfTtcbiAgLy8gVGhpcyBmdW5jdGlvbiB3YXMgb25seSB1c2VkIGJ5IGFwZy5odG1sIHdoaWNoIGhhcyBiZWVuIGFiYW5kb25lZC5cbiAgLypcbiAgICB0aGlzLmdldEF0dHJpYnV0ZXNPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgKi9cbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImFwaSIsInNyYyIsIkJ1ZmZlciIsInJlcXVpcmUiLCJ0aGlzRmlsZU5hbWUiLCJ0aGlzT2JqZWN0IiwiYXBnbGliIiwiY29udmVydGVyIiwic2Nhbm5lciIsInBhcnNlciIsImF0dHJpYnV0ZXMiLCJzaG93QXR0cmlidXRlcyIsInNob3dBdHRyaWJ1dGVFcnJvcnMiLCJzaG93UnVsZURlcGVuZGVuY2llcyIsInNob3dSdWxlcyIsImFibmZUb0h0bWwiLCJjaGFycyIsImJlZyIsImxlbiIsIk5PUk1BTCIsIkNPTlRST0wiLCJJTlZBTElEIiwiQ09OVFJPTF9CRUciLCJzdHlsZSIsIkNMQVNTX0NUUkxDSEFSIiwiQ09OVFJPTF9FTkQiLCJJTlZBTElEX0JFRyIsIkNMQVNTX05PTUFUQ0giLCJJTlZBTElEX0VORCIsImVuZCIsImh0bWwiLCJUUlVFIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiRXJyb3IiLCJzdGF0ZSIsImkiLCJjaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInV0aWxzIiwiY2hhclRvSGV4IiwiYWJuZlRvQXNjaWkiLCJzdHIiLCJsaW5lc1RvQXNjaWkiLCJsaW5lcyIsImZvckVhY2giLCJ2YWwiLCJsaW5lTm8iLCJiZWdpbkNoYXIiLCJsaW5lc1RvSHRtbCIsIkNMQVNTX0dSQU1NQVIiLCJ0aXRsZSIsImVycm9yc1RvSHRtbCIsImVycm9ycyIsImVycm9yQXJyb3ciLCJsaW5lIiwicmVsY2hhciIsInRleHQiLCJwcmVmaXgiLCJzdWZmaXgiLCJjaGFyIiwic3RyaW5nVG9Bc2NpaUh0bWwiLCJtc2ciLCJlcnJvcnNUb0FzY2lpIiwiZXJyb3IiLCJpc1NjYW5uZWQiLCJpc1BhcnNlZCIsImlzVHJhbnNsYXRlZCIsImhhdmVBdHRyaWJ1dGVzIiwiYXR0cmlidXRlRXJyb3JzIiwibGluZU1hcCIsImlzQnVmZmVyIiwiZGVjb2RlIiwic2xpY2UiLCJzYWJuZiIsImVuY29kZSIsInNjYW4iLCJzdHJpY3QiLCJ0cmFjZSIsInBhcnNlIiwic3ludGF4IiwidHJhbnNsYXRlIiwicmV0Iiwic2VtYW50aWMiLCJydWxlcyIsInVkdHMiLCJhdHRycyIsImdlbmVyYXRlIiwiZGlzcGxheVJ1bGVzIiwib3JkZXIiLCJkaXNwbGF5UnVsZURlcGVuZGVuY2llcyIsImRpc3BsYXlBdHRyaWJ1dGVzIiwiZGlzcGxheUF0dHJpYnV0ZUVycm9ycyIsInRvU291cmNlIiwibmFtZSIsImdlbmVyYXRlU291cmNlIiwidG9PYmplY3QiLCJnZW5lcmF0ZU9iamVjdCIsImVycm9yc1RvQXNjaWlGdW5jIiwiZXJyb3JzVG9IdG1sRnVuYyIsImxpbmVzVG9Bc2NpaUZ1bmMiLCJsaW5lc1RvSHRtbEZ1bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/api.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/attributes.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/attributes.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint-disable class-methods-use-this */ /*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // Attributes Validation\n//\n// It is well known that recursive-descent parsers will fail if a rule is left recursive.\n// Besides left recursion, there are a couple of other fatal attributes that need to be disclosed as well.\n// There are several non-fatal attributes that are of interest also.\n// This module will determine six different attributes listed here with simple examples.\n//\n// **fatal attributes**<br>\n// left recursion<br>\n// S = S \"x\" / \"y\"\n//\n// cyclic<br>\n// S = S\n//\n// infinite<br>\n// S = \"y\" S\n//\n// **non-fatal attributes** (but nice to know)<br>\n// nested recursion<br>\n// S = \"a\" S \"b\" / \"y\"\n//\n// right recursion<br>\n// S = \"x\" S / \"y\"\n//\n// empty string<br>\n// S = \"x\" S / \"\"\n//\n// Note that these are “aggregate” attributes, in that if the attribute is true it only means that it can be true,\n// not that it will always be true for every input string.\n// In the simple examples above the attributes may be obvious and definite – always true or false.\n// However, for a large grammar with possibly hundreds of rules and parse tree branches,\n// it can be obscure which branches lead to which attributes.\n// Furthermore, different input strings will lead the parser down different branches.\n// One input string may parse perfectly while another will hit a left-recursive branch and bottom out the call stack.\n//\n// It is for this reason that the APG parser generator computes these attributes.\n// When using the API the attributes call is optional but generating a parser without checking the attributes - proceed at your own peril.\n//\n// Additionally, the attribute phase will identify rule dependencies and mutually-recursive groups. For example,\n//\n// S = \"a\" A \"b\" / \"y\"<br>\n// A = \"x\"\n//\n// S is dependent on A but A is not dependent on S.\n//\n// S = \"a\" A \"b\" / \"c\"<br>\n// A = \"x\" S \"y\" / \"z\"\n//\n// S and A are dependent on one another and are mutually recursive.\n\nmodule.exports = function exportAttributes() {\n    const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n    const { ruleAttributes, showAttributes, showAttributeErrors } = __webpack_require__(/*! ./rule-attributes */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-attributes.js\");\n    const { ruleDependencies, showRuleDependencies } = __webpack_require__(/*! ./rule-dependencies */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-dependencies.js\");\n    class State {\n        constructor(rules, udts){\n            this.rules = rules;\n            this.udts = udts;\n            this.ruleCount = rules.length;\n            this.udtCount = udts.length;\n            this.startRule = 0;\n            this.dependenciesComplete = false;\n            this.attributesComplete = false;\n            this.isMutuallyRecursive = false;\n            this.ruleIndexes = this.indexArray(this.ruleCount);\n            this.ruleAlphaIndexes = this.indexArray(this.ruleCount);\n            this.ruleTypeIndexes = this.indexArray(this.ruleCount);\n            this.udtIndexes = this.indexArray(this.udtCount);\n            this.udtAlphaIndexes = this.indexArray(this.udtCount);\n            this.attrsErrorCount = 0;\n            this.attrs = [];\n            this.attrsErrors = [];\n            this.attrsWorking = [];\n            this.ruleDeps = [];\n            for(let i = 0; i < this.ruleCount; i += 1){\n                this.attrs.push(this.attrGen(this.rules[i]));\n                this.attrsWorking.push(this.attrGen(this.rules[i]));\n                this.ruleDeps.push(this.rdGen(rules[i], this.ruleCount, this.udtCount));\n            }\n            this.compRulesAlpha = this.compRulesAlpha.bind(this);\n            this.compUdtsAlpha = this.compUdtsAlpha.bind(this);\n            this.compRulesType = this.compRulesType.bind(this);\n            this.compRulesGroup = this.compRulesGroup.bind(this);\n        }\n        // eslint-disable-next-line class-methods-use-this\n        attrGen(rule) {\n            return {\n                left: false,\n                nested: false,\n                right: false,\n                empty: false,\n                finite: false,\n                cyclic: false,\n                leaf: false,\n                isOpen: false,\n                isComplete: false,\n                rule\n            };\n        }\n        // eslint-disable-next-line class-methods-use-this\n        attrInit(attr) {\n            attr.left = false;\n            attr.nested = false;\n            attr.right = false;\n            attr.empty = false;\n            attr.finite = false;\n            attr.cyclic = false;\n            attr.leaf = false;\n            attr.isOpen = false;\n            attr.isComplete = false;\n        }\n        attrCopy(dst, src) {\n            dst.left = src.left;\n            dst.nested = src.nested;\n            dst.right = src.right;\n            dst.empty = src.empty;\n            dst.finite = src.finite;\n            dst.cyclic = src.cyclic;\n            dst.leaf = src.leaf;\n            dst.isOpen = src.isOpen;\n            dst.isComplete = src.isComplete;\n            dst.rule = src.rule;\n        }\n        rdGen(rule, ruleCount, udtCount) {\n            const ret = {\n                rule,\n                recursiveType: id.ATTR_N,\n                groupNumber: -1,\n                refersTo: this.falseArray(ruleCount),\n                refersToUdt: this.falseArray(udtCount),\n                referencedBy: this.falseArray(ruleCount)\n            };\n            return ret;\n        }\n        typeToString(recursiveType) {\n            switch(recursiveType){\n                case id.ATTR_N:\n                    return \" N\";\n                case id.ATTR_R:\n                    return \" R\";\n                case id.ATTR_MR:\n                    return \"MR\";\n                default:\n                    return \"UNKNOWN\";\n            }\n        }\n        falseArray(length) {\n            const ret = [];\n            if (length > 0) {\n                for(let i = 0; i < length; i += 1){\n                    ret.push(false);\n                }\n            }\n            return ret;\n        }\n        falsifyArray(a) {\n            for(let i = 0; i < a.length; i += 1){\n                a[i] = false;\n            }\n        }\n        indexArray(length) {\n            const ret = [];\n            if (length > 0) {\n                for(let i = 0; i < length; i += 1){\n                    ret.push(i);\n                }\n            }\n            return ret;\n        }\n        compRulesAlpha(left, right) {\n            if (this.rules[left].lower < this.rules[right].lower) {\n                return -1;\n            }\n            if (this.rules[left].lower > this.rules[right].lower) {\n                return 1;\n            }\n            return 0;\n        }\n        compUdtsAlpha(left, right) {\n            if (this.udts[left].lower < this.udts[right].lower) {\n                return -1;\n            }\n            if (this.udts[left].lower > this.udts[right].lower) {\n                return 1;\n            }\n            return 0;\n        }\n        compRulesType(left, right) {\n            if (this.ruleDeps[left].recursiveType < this.ruleDeps[right].recursiveType) {\n                return -1;\n            }\n            if (this.ruleDeps[left].recursiveType > this.ruleDeps[right].recursiveType) {\n                return 1;\n            }\n            return 0;\n        }\n        compRulesGroup(left, right) {\n            if (this.ruleDeps[left].recursiveType === id.ATTR_MR && this.ruleDeps[right].recursiveType === id.ATTR_MR) {\n                if (this.ruleDeps[left].groupNumber < this.ruleDeps[right].groupNumber) {\n                    return -1;\n                }\n                if (this.ruleDeps[left].groupNumber > this.ruleDeps[right].groupNumber) {\n                    return 1;\n                }\n            }\n            return 0;\n        }\n    }\n    // eslint-disable-next-line no-unused-vars\n    const attributes = function attributes(rules = [], udts = [], lineMap = [], errors = []) {\n        // let i = 0;\n        // Initialize the state. The state of the computation get passed around to multiple functions in multiple files.\n        const state = new State(rules, udts);\n        // Determine all rule dependencies\n        //  - which rules each rule refers to\n        //  - which rules reference each rule\n        ruleDependencies(state);\n        // Determine the attributes for each rule.\n        ruleAttributes(state);\n        if (state.attrsErrorCount) {\n            errors.push({\n                line: 0,\n                char: 0,\n                msg: `${state.attrsErrorCount} attribute errors`\n            });\n        }\n        // Return the number of attribute errors to the caller.\n        return state.attrsErrorCount;\n    };\n    /* Destructuring assignment - see MDN Web Docs */ return {\n        attributes,\n        showAttributes,\n        showAttributeErrors,\n        showRuleDependencies\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2F0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQUEseUNBQXlDLEdBQ3pDOzs7dUZBR3VGLEdBQ3ZGLHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YseUZBQXlGO0FBQ3pGLDBHQUEwRztBQUMxRyxvRUFBb0U7QUFDcEUsd0ZBQXdGO0FBQ3hGLEVBQUU7QUFDRiwyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQixFQUFFO0FBQ0YsYUFBYTtBQUNiLFFBQVE7QUFDUixFQUFFO0FBQ0YsZUFBZTtBQUNmLFlBQVk7QUFDWixFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsRUFBRTtBQUNGLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsRUFBRTtBQUNGLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsRUFBRTtBQUNGLGtIQUFrSDtBQUNsSCwwREFBMEQ7QUFDMUQsa0dBQWtHO0FBQ2xHLHdGQUF3RjtBQUN4Riw2REFBNkQ7QUFDN0QscUZBQXFGO0FBQ3JGLHFIQUFxSDtBQUNySCxFQUFFO0FBQ0YsaUZBQWlGO0FBQ2pGLDBJQUEwSTtBQUMxSSxFQUFFO0FBQ0YsZ0hBQWdIO0FBQ2hILEVBQUU7QUFDRiwwQkFBMEI7QUFDMUIsVUFBVTtBQUNWLEVBQUU7QUFDRixtREFBbUQ7QUFDbkQsRUFBRTtBQUNGLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsRUFBRTtBQUNGLG1FQUFtRTs7QUFDbkVBLE9BQU9DLE9BQU8sR0FBRyxTQUFVQztJQUN6QixNQUFNQyxLQUFLQyxtQkFBT0EsQ0FBQztJQUNuQixNQUFNLEVBQUVDLGNBQWMsRUFBRUMsY0FBYyxFQUFFQyxtQkFBbUIsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztJQUN4RSxNQUFNLEVBQUVJLGdCQUFnQixFQUFFQyxvQkFBb0IsRUFB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RUFBRSxFQUFFQyxTQUFTLEVBQUU7UUFDckYsYUFBYTtRQUNiLGdIQUFnSDtRQUNoSCxNQUFNQyxRQUFRLElBQUkvRCxNQUFNRSxPQUFPQztRQUUvQixrQ0FBa0M7UUFDbEMscUNBQXFDO1FBQ3JDLHFDQUFxQztRQUNyQ0wsaUJBQWlCaUU7UUFFakIsMENBQTBDO1FBQzFDcEUsZUFBZW9FO1FBQ2YsSUFBSUEsTUFBTTlDLGVBQWUsRUFBRTtZQUN6QjZDLE9BQU92QyxJQUFJLENBQUM7Z0JBQUV5QyxNQUFNO2dCQUFHQyxNQUFNO2dCQUFHQyxLQUFLLENBQUMsRUFBRUgsTUFBTTlDLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQztZQUFDO1FBQ25GO1FBRUEsdURBQXVEO1FBQ3ZELE9BQU84QyxNQUFNOUMsZUFBZTtJQUM5QjtJQUVBLCtDQUErQyxHQUMvQyxPQUFPO1FBQUUyQztRQUFZaEU7UUFBZ0JDO1FBQXFCRTtJQUFxQjtBQUNqRiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2F0dHJpYnV0ZXMuanM/MDkxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG4vKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBBdHRyaWJ1dGVzIFZhbGlkYXRpb25cbi8vXG4vLyBJdCBpcyB3ZWxsIGtub3duIHRoYXQgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VycyB3aWxsIGZhaWwgaWYgYSBydWxlIGlzIGxlZnQgcmVjdXJzaXZlLlxuLy8gQmVzaWRlcyBsZWZ0IHJlY3Vyc2lvbiwgdGhlcmUgYXJlIGEgY291cGxlIG9mIG90aGVyIGZhdGFsIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHRvIGJlIGRpc2Nsb3NlZCBhcyB3ZWxsLlxuLy8gVGhlcmUgYXJlIHNldmVyYWwgbm9uLWZhdGFsIGF0dHJpYnV0ZXMgdGhhdCBhcmUgb2YgaW50ZXJlc3QgYWxzby5cbi8vIFRoaXMgbW9kdWxlIHdpbGwgZGV0ZXJtaW5lIHNpeCBkaWZmZXJlbnQgYXR0cmlidXRlcyBsaXN0ZWQgaGVyZSB3aXRoIHNpbXBsZSBleGFtcGxlcy5cbi8vXG4vLyAqKmZhdGFsIGF0dHJpYnV0ZXMqKjxicj5cbi8vIGxlZnQgcmVjdXJzaW9uPGJyPlxuLy8gUyA9IFMgXCJ4XCIgLyBcInlcIlxuLy9cbi8vIGN5Y2xpYzxicj5cbi8vIFMgPSBTXG4vL1xuLy8gaW5maW5pdGU8YnI+XG4vLyBTID0gXCJ5XCIgU1xuLy9cbi8vICoqbm9uLWZhdGFsIGF0dHJpYnV0ZXMqKiAoYnV0IG5pY2UgdG8ga25vdyk8YnI+XG4vLyBuZXN0ZWQgcmVjdXJzaW9uPGJyPlxuLy8gUyA9IFwiYVwiIFMgXCJiXCIgLyBcInlcIlxuLy9cbi8vIHJpZ2h0IHJlY3Vyc2lvbjxicj5cbi8vIFMgPSBcInhcIiBTIC8gXCJ5XCJcbi8vXG4vLyBlbXB0eSBzdHJpbmc8YnI+XG4vLyBTID0gXCJ4XCIgUyAvIFwiXCJcbi8vXG4vLyBOb3RlIHRoYXQgdGhlc2UgYXJlIOKAnGFnZ3JlZ2F0ZeKAnSBhdHRyaWJ1dGVzLCBpbiB0aGF0IGlmIHRoZSBhdHRyaWJ1dGUgaXMgdHJ1ZSBpdCBvbmx5IG1lYW5zIHRoYXQgaXQgY2FuIGJlIHRydWUsXG4vLyBub3QgdGhhdCBpdCB3aWxsIGFsd2F5cyBiZSB0cnVlIGZvciBldmVyeSBpbnB1dCBzdHJpbmcuXG4vLyBJbiB0aGUgc2ltcGxlIGV4YW1wbGVzIGFib3ZlIHRoZSBhdHRyaWJ1dGVzIG1heSBiZSBvYnZpb3VzIGFuZCBkZWZpbml0ZSDigJMgYWx3YXlzIHRydWUgb3IgZmFsc2UuXG4vLyBIb3dldmVyLCBmb3IgYSBsYXJnZSBncmFtbWFyIHdpdGggcG9zc2libHkgaHVuZHJlZHMgb2YgcnVsZXMgYW5kIHBhcnNlIHRyZWUgYnJhbmNoZXMsXG4vLyBpdCBjYW4gYmUgb2JzY3VyZSB3aGljaCBicmFuY2hlcyBsZWFkIHRvIHdoaWNoIGF0dHJpYnV0ZXMuXG4vLyBGdXJ0aGVybW9yZSwgZGlmZmVyZW50IGlucHV0IHN0cmluZ3Mgd2lsbCBsZWFkIHRoZSBwYXJzZXIgZG93biBkaWZmZXJlbnQgYnJhbmNoZXMuXG4vLyBPbmUgaW5wdXQgc3RyaW5nIG1heSBwYXJzZSBwZXJmZWN0bHkgd2hpbGUgYW5vdGhlciB3aWxsIGhpdCBhIGxlZnQtcmVjdXJzaXZlIGJyYW5jaCBhbmQgYm90dG9tIG91dCB0aGUgY2FsbCBzdGFjay5cbi8vXG4vLyBJdCBpcyBmb3IgdGhpcyByZWFzb24gdGhhdCB0aGUgQVBHIHBhcnNlciBnZW5lcmF0b3IgY29tcHV0ZXMgdGhlc2UgYXR0cmlidXRlcy5cbi8vIFdoZW4gdXNpbmcgdGhlIEFQSSB0aGUgYXR0cmlidXRlcyBjYWxsIGlzIG9wdGlvbmFsIGJ1dCBnZW5lcmF0aW5nIGEgcGFyc2VyIHdpdGhvdXQgY2hlY2tpbmcgdGhlIGF0dHJpYnV0ZXMgLSBwcm9jZWVkIGF0IHlvdXIgb3duIHBlcmlsLlxuLy9cbi8vIEFkZGl0aW9uYWxseSwgdGhlIGF0dHJpYnV0ZSBwaGFzZSB3aWxsIGlkZW50aWZ5IHJ1bGUgZGVwZW5kZW5jaWVzIGFuZCBtdXR1YWxseS1yZWN1cnNpdmUgZ3JvdXBzLiBGb3IgZXhhbXBsZSxcbi8vXG4vLyBTID0gXCJhXCIgQSBcImJcIiAvIFwieVwiPGJyPlxuLy8gQSA9IFwieFwiXG4vL1xuLy8gUyBpcyBkZXBlbmRlbnQgb24gQSBidXQgQSBpcyBub3QgZGVwZW5kZW50IG9uIFMuXG4vL1xuLy8gUyA9IFwiYVwiIEEgXCJiXCIgLyBcImNcIjxicj5cbi8vIEEgPSBcInhcIiBTIFwieVwiIC8gXCJ6XCJcbi8vXG4vLyBTIGFuZCBBIGFyZSBkZXBlbmRlbnQgb24gb25lIGFub3RoZXIgYW5kIGFyZSBtdXR1YWxseSByZWN1cnNpdmUuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBleHBvcnRBdHRyaWJ1dGVzKCkge1xuICBjb25zdCBpZCA9IHJlcXVpcmUoJy4uL2FwZy1saWIvaWRlbnRpZmllcnMnKTtcbiAgY29uc3QgeyBydWxlQXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVFcnJvcnMgfSA9IHJlcXVpcmUoJy4vcnVsZS1hdHRyaWJ1dGVzJyk7XG4gIGNvbnN0IHsgcnVsZURlcGVuZGVuY2llcywgc2hvd1J1bGVEZXBlbmRlbmNpZXMgfSA9IHJlcXVpcmUoJy4vcnVsZS1kZXBlbmRlbmNpZXMnKTtcbiAgY2xhc3MgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHJ1bGVzLCB1ZHRzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgICB0aGlzLnVkdHMgPSB1ZHRzO1xuICAgICAgdGhpcy5ydWxlQ291bnQgPSBydWxlcy5sZW5ndGg7XG4gICAgICB0aGlzLnVkdENvdW50ID0gdWR0cy5sZW5ndGg7XG4gICAgICB0aGlzLnN0YXJ0UnVsZSA9IDA7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5pc011dHVhbGx5UmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnJ1bGVJbmRleGVzID0gdGhpcy5pbmRleEFycmF5KHRoaXMucnVsZUNvdW50KTtcbiAgICAgIHRoaXMucnVsZUFscGhhSW5kZXhlcyA9IHRoaXMuaW5kZXhBcnJheSh0aGlzLnJ1bGVDb3VudCk7XG4gICAgICB0aGlzLnJ1bGVUeXBlSW5kZXhlcyA9IHRoaXMuaW5kZXhBcnJheSh0aGlzLnJ1bGVDb3VudCk7XG4gICAgICB0aGlzLnVkdEluZGV4ZXMgPSB0aGlzLmluZGV4QXJyYXkodGhpcy51ZHRDb3VudCk7XG4gICAgICB0aGlzLnVkdEFscGhhSW5kZXhlcyA9IHRoaXMuaW5kZXhBcnJheSh0aGlzLnVkdENvdW50KTtcbiAgICAgIHRoaXMuYXR0cnNFcnJvckNvdW50ID0gMDtcbiAgICAgIHRoaXMuYXR0cnMgPSBbXTtcbiAgICAgIHRoaXMuYXR0cnNFcnJvcnMgPSBbXTtcbiAgICAgIHRoaXMuYXR0cnNXb3JraW5nID0gW107XG4gICAgICB0aGlzLnJ1bGVEZXBzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5hdHRycy5wdXNoKHRoaXMuYXR0ckdlbih0aGlzLnJ1bGVzW2ldKSk7XG4gICAgICAgIHRoaXMuYXR0cnNXb3JraW5nLnB1c2godGhpcy5hdHRyR2VuKHRoaXMucnVsZXNbaV0pKTtcbiAgICAgICAgdGhpcy5ydWxlRGVwcy5wdXNoKHRoaXMucmRHZW4ocnVsZXNbaV0sIHRoaXMucnVsZUNvdW50LCB0aGlzLnVkdENvdW50KSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbXBSdWxlc0FscGhhID0gdGhpcy5jb21wUnVsZXNBbHBoYS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5jb21wVWR0c0FscGhhID0gdGhpcy5jb21wVWR0c0FscGhhLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNvbXBSdWxlc1R5cGUgPSB0aGlzLmNvbXBSdWxlc1R5cGUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY29tcFJ1bGVzR3JvdXAgPSB0aGlzLmNvbXBSdWxlc0dyb3VwLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBhdHRyR2VuKHJ1bGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICBuZXN0ZWQ6IGZhbHNlLFxuICAgICAgICByaWdodDogZmFsc2UsXG4gICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgZmluaXRlOiBmYWxzZSxcbiAgICAgICAgY3ljbGljOiBmYWxzZSxcbiAgICAgICAgbGVhZjogZmFsc2UsXG4gICAgICAgIGlzT3BlbjogZmFsc2UsXG4gICAgICAgIGlzQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICBydWxlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGF0dHJJbml0KGF0dHIpIHtcbiAgICAgIGF0dHIubGVmdCA9IGZhbHNlO1xuICAgICAgYXR0ci5uZXN0ZWQgPSBmYWxzZTtcbiAgICAgIGF0dHIucmlnaHQgPSBmYWxzZTtcbiAgICAgIGF0dHIuZW1wdHkgPSBmYWxzZTtcbiAgICAgIGF0dHIuZmluaXRlID0gZmFsc2U7XG4gICAgICBhdHRyLmN5Y2xpYyA9IGZhbHNlO1xuICAgICAgYXR0ci5sZWFmID0gZmFsc2U7XG4gICAgICBhdHRyLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgYXR0ci5pc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYXR0ckNvcHkoZHN0LCBzcmMpIHtcbiAgICAgIGRzdC5sZWZ0ID0gc3JjLmxlZnQ7XG4gICAgICBkc3QubmVzdGVkID0gc3JjLm5lc3RlZDtcbiAgICAgIGRzdC5yaWdodCA9IHNyYy5yaWdodDtcbiAgICAgIGRzdC5lbXB0eSA9IHNyYy5lbXB0eTtcbiAgICAgIGRzdC5maW5pdGUgPSBzcmMuZmluaXRlO1xuICAgICAgZHN0LmN5Y2xpYyA9IHNyYy5jeWNsaWM7XG4gICAgICBkc3QubGVhZiA9IHNyYy5sZWFmO1xuICAgICAgZHN0LmlzT3BlbiA9IHNyYy5pc09wZW47XG4gICAgICBkc3QuaXNDb21wbGV0ZSA9IHNyYy5pc0NvbXBsZXRlO1xuICAgICAgZHN0LnJ1bGUgPSBzcmMucnVsZTtcbiAgICB9XG5cbiAgICByZEdlbihydWxlLCBydWxlQ291bnQsIHVkdENvdW50KSB7XG4gICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgIHJ1bGUsXG4gICAgICAgIHJlY3Vyc2l2ZVR5cGU6IGlkLkFUVFJfTixcbiAgICAgICAgZ3JvdXBOdW1iZXI6IC0xLFxuICAgICAgICByZWZlcnNUbzogdGhpcy5mYWxzZUFycmF5KHJ1bGVDb3VudCksXG4gICAgICAgIHJlZmVyc1RvVWR0OiB0aGlzLmZhbHNlQXJyYXkodWR0Q291bnQpLFxuICAgICAgICByZWZlcmVuY2VkQnk6IHRoaXMuZmFsc2VBcnJheShydWxlQ291bnQpLFxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdHlwZVRvU3RyaW5nKHJlY3Vyc2l2ZVR5cGUpIHtcbiAgICAgIHN3aXRjaCAocmVjdXJzaXZlVHlwZSkge1xuICAgICAgICBjYXNlIGlkLkFUVFJfTjpcbiAgICAgICAgICByZXR1cm4gJyBOJztcbiAgICAgICAgY2FzZSBpZC5BVFRSX1I6XG4gICAgICAgICAgcmV0dXJuICcgUic7XG4gICAgICAgIGNhc2UgaWQuQVRUUl9NUjpcbiAgICAgICAgICByZXR1cm4gJ01SJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ1VOS05PV04nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZhbHNlQXJyYXkobGVuZ3RoKSB7XG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICByZXQucHVzaChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZmFsc2lmeUFycmF5KGEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhW2ldID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXhBcnJheShsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHJldC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNvbXBSdWxlc0FscGhhKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAodGhpcy5ydWxlc1tsZWZ0XS5sb3dlciA8IHRoaXMucnVsZXNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJ1bGVzW2xlZnRdLmxvd2VyID4gdGhpcy5ydWxlc1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBjb21wVWR0c0FscGhhKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAodGhpcy51ZHRzW2xlZnRdLmxvd2VyIDwgdGhpcy51ZHRzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy51ZHRzW2xlZnRdLmxvd2VyID4gdGhpcy51ZHRzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbXBSdWxlc1R5cGUobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmICh0aGlzLnJ1bGVEZXBzW2xlZnRdLnJlY3Vyc2l2ZVR5cGUgPCB0aGlzLnJ1bGVEZXBzW3JpZ2h0XS5yZWN1cnNpdmVUeXBlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJ1bGVEZXBzW2xlZnRdLnJlY3Vyc2l2ZVR5cGUgPiB0aGlzLnJ1bGVEZXBzW3JpZ2h0XS5yZWN1cnNpdmVUeXBlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29tcFJ1bGVzR3JvdXAobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmICh0aGlzLnJ1bGVEZXBzW2xlZnRdLnJlY3Vyc2l2ZVR5cGUgPT09IGlkLkFUVFJfTVIgJiYgdGhpcy5ydWxlRGVwc1tyaWdodF0ucmVjdXJzaXZlVHlwZSA9PT0gaWQuQVRUUl9NUikge1xuICAgICAgICBpZiAodGhpcy5ydWxlRGVwc1tsZWZ0XS5ncm91cE51bWJlciA8IHRoaXMucnVsZURlcHNbcmlnaHRdLmdyb3VwTnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bGVEZXBzW2xlZnRdLmdyb3VwTnVtYmVyID4gdGhpcy5ydWxlRGVwc1tyaWdodF0uZ3JvdXBOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBjb25zdCBhdHRyaWJ1dGVzID0gZnVuY3Rpb24gYXR0cmlidXRlcyhydWxlcyA9IFtdLCB1ZHRzID0gW10sIGxpbmVNYXAgPSBbXSwgZXJyb3JzID0gW10pIHtcbiAgICAvLyBsZXQgaSA9IDA7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuIFRoZSBzdGF0ZSBvZiB0aGUgY29tcHV0YXRpb24gZ2V0IHBhc3NlZCBhcm91bmQgdG8gbXVsdGlwbGUgZnVuY3Rpb25zIGluIG11bHRpcGxlIGZpbGVzLlxuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKHJ1bGVzLCB1ZHRzKTtcblxuICAgIC8vIERldGVybWluZSBhbGwgcnVsZSBkZXBlbmRlbmNpZXNcbiAgICAvLyAgLSB3aGljaCBydWxlcyBlYWNoIHJ1bGUgcmVmZXJzIHRvXG4gICAgLy8gIC0gd2hpY2ggcnVsZXMgcmVmZXJlbmNlIGVhY2ggcnVsZVxuICAgIHJ1bGVEZXBlbmRlbmNpZXMoc3RhdGUpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBhdHRyaWJ1dGVzIGZvciBlYWNoIHJ1bGUuXG4gICAgcnVsZUF0dHJpYnV0ZXMoc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5hdHRyc0Vycm9yQ291bnQpIHtcbiAgICAgIGVycm9ycy5wdXNoKHsgbGluZTogMCwgY2hhcjogMCwgbXNnOiBgJHtzdGF0ZS5hdHRyc0Vycm9yQ291bnR9IGF0dHJpYnV0ZSBlcnJvcnNgIH0pO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGF0dHJpYnV0ZSBlcnJvcnMgdG8gdGhlIGNhbGxlci5cbiAgICByZXR1cm4gc3RhdGUuYXR0cnNFcnJvckNvdW50O1xuICB9O1xuXG4gIC8qIERlc3RydWN0dXJpbmcgYXNzaWdubWVudCAtIHNlZSBNRE4gV2ViIERvY3MgKi9cbiAgcmV0dXJuIHsgYXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVFcnJvcnMsIHNob3dSdWxlRGVwZW5kZW5jaWVzIH07XG59KSgpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJleHBvcnRBdHRyaWJ1dGVzIiwiaWQiLCJyZXF1aXJlIiwicnVsZUF0dHJpYnV0ZXMiLCJzaG93QXR0cmlidXRlcyIsInNob3dBdHRyaWJ1dGVFcnJvcnMiLCJydWxlRGVwZW5kZW5jaWVzIiwic2hvd1J1bGVEZXBlbmRlbmNpZXMiLCJTdGF0ZSIsImNvbnN0cnVjdG9yIiwicnVsZXMiLCJ1ZHRzIiwicnVsZUNvdW50IiwibGVuZ3RoIiwidWR0Q291bnQiLCJzdGFydFJ1bGUiLCJkZXBlbmRlbmNpZXNDb21wbGV0ZSIsImF0dHJpYnV0ZXNDb21wbGV0ZSIsImlzTXV0dWFsbHlSZWN1cnNpdmUiLCJydWxlSW5kZXhlcyIsImluZGV4QXJyYXkiLCJydWxlQWxwaGFJbmRleGVzIiwicnVsZVR5cGVJbmRleGVzIiwidWR0SW5kZXhlcyIsInVkdEFscGhhSW5kZXhlcyIsImF0dHJzRXJyb3JDb3VudCIsImF0dHJzIiwiYXR0cnNFcnJvcnMiLCJhdHRyc1dvcmtpbmciLCJydWxlRGVwcyIsImkiLCJwdXNoIiwiYXR0ckdlbiIsInJkR2VuIiwiY29tcFJ1bGVzQWxwaGEiLCJiaW5kIiwiY29tcFVkdHNBbHBoYSIsImNvbXBSdWxlc1R5cGUiLCJjb21wUnVsZXNHcm91cCIsInJ1bGUiLCJsZWZ0IiwibmVzdGVkIiwicmlnaHQiLCJlbXB0eSIsImZpbml0ZSIsImN5Y2xpYyIsImxlYWYiLCJpc09wZW4iLCJpc0NvbXBsZXRlIiwiYXR0ckluaXQiLCJhdHRyIiwiYXR0ckNvcHkiLCJkc3QiLCJzcmMiLCJyZXQiLCJyZWN1cnNpdmVUeXBlIiwiQVRUUl9OIiwiZ3JvdXBOdW1iZXIiLCJyZWZlcnNUbyIsImZhbHNlQXJyYXkiLCJyZWZlcnNUb1VkdCIsInJlZmVyZW5jZWRCeSIsInR5cGVUb1N0cmluZyIsIkFUVFJfUiIsIkFUVFJfTVIiLCJmYWxzaWZ5QXJyYXkiLCJhIiwibG93ZXIiLCJhdHRyaWJ1dGVzIiwibGluZU1hcCIsImVycm9ycyIsInN0YXRlIiwibGluZSIsImNoYXIiLCJtc2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/attributes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/parser.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/parser.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module converts an input SABNF grammar text file into a\n// grammar object that can be used with `apg-lib` in an application parser.\n// **apg** is, in fact itself, an ABNF parser that generates an SABNF parser.\n// It is based on the grammar<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`.<br>\n// In its syntax phase, **apg** analyzes the user's input SABNF grammar for correct syntax, generating an AST as it goes.\n// In its semantic phase, **apg** translates the AST to generate the parser for the input grammar.\n\nmodule.exports = function exportParser() {\n    const thisFileName = \"parser: \";\n    const ApgLib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\");\n    const id = ApgLib.ids;\n    const syn = new (__webpack_require__(/*! ./syntax-callbacks */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/syntax-callbacks.js\"))();\n    const sem = new (__webpack_require__(/*! ./semantic-callbacks */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/semantic-callbacks.js\"))();\n    const sabnfGrammar = new (__webpack_require__(/*! ./sabnf-grammar */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/sabnf-grammar.js\"))();\n    // eslint-disable-next-line new-cap\n    const parser = new ApgLib.parser();\n    // eslint-disable-next-line new-cap\n    parser.ast = new ApgLib.ast();\n    parser.callbacks = syn.callbacks;\n    parser.ast.callbacks = sem.callbacks;\n    /* find the line containing the given character index */ const findLine = function findLine(lines, charIndex, charLength) {\n        if (charIndex < 0 || charIndex >= charLength) {\n            /* return error if out of range */ return -1;\n        }\n        for(let i = 0; i < lines.length; i += 1){\n            if (charIndex >= lines[i].beginChar && charIndex < lines[i].beginChar + lines[i].length) {\n                return i;\n            }\n        }\n        /* should never reach here */ return -1;\n    };\n    const translateIndex = function translateIndex(map, index) {\n        let ret = -1;\n        if (index < map.length) {\n            for(let i = index; i < map.length; i += 1){\n                if (map[i] !== null) {\n                    ret = map[i];\n                    break;\n                }\n            }\n        }\n        return ret;\n    };\n    /* helper function when removing redundant opcodes */ const reduceOpcodes = function reduceOpcodes(rules) {\n        rules.forEach((rule)=>{\n            const opcodes = [];\n            const map = [];\n            let reducedIndex = 0;\n            rule.opcodes.forEach((op)=>{\n                if (op.type === id.ALT && op.children.length === 1) {\n                    map.push(null);\n                } else if (op.type === id.CAT && op.children.length === 1) {\n                    map.push(null);\n                } else if (op.type === id.REP && op.min === 1 && op.max === 1) {\n                    map.push(null);\n                } else {\n                    map.push(reducedIndex);\n                    opcodes.push(op);\n                    reducedIndex += 1;\n                }\n            });\n            map.push(reducedIndex);\n            /* translate original opcode indexes to the reduced set. */ opcodes.forEach((op)=>{\n                if (op.type === id.ALT || op.type === id.CAT) {\n                    for(let i = 0; i < op.children.length; i += 1){\n                        op.children[i] = translateIndex(map, op.children[i]);\n                    }\n                }\n            });\n            rule.opcodes = opcodes;\n        });\n    };\n    /* Parse the grammar - the syntax phase. */ /* SABNF grammar syntax errors are caught and reported here. */ this.syntax = function syntax(chars, lines, errors, strict, trace) {\n        if (trace) {\n            if (trace.traceObject !== \"traceObject\") {\n                throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n            }\n            parser.trace = trace;\n        }\n        const data = {};\n        data.errors = errors;\n        data.strict = !!strict;\n        data.lines = lines;\n        data.findLine = findLine;\n        data.charsLength = chars.length;\n        data.ruleCount = 0;\n        const result = parser.parse(sabnfGrammar, \"file\", chars, data);\n        if (!result.success) {\n            errors.push({\n                line: 0,\n                char: 0,\n                msg: \"syntax analysis of input grammar failed\"\n            });\n        }\n    };\n    /* Parse the grammar - the semantic phase, translates the AST. */ /* SABNF grammar syntax errors are caught and reported here. */ this.semantic = function semantic(chars, lines, errors) {\n        const data = {};\n        data.errors = errors;\n        data.lines = lines;\n        data.findLine = findLine;\n        data.charsLength = chars.length;\n        parser.ast.translate(data);\n        if (errors.length) {\n            return null;\n        }\n        /* Remove unneeded operators. */ /* ALT operators with a single alternate */ /* CAT operators with a single phrase to concatenate */ /* REP(1,1) operators (`1*1RuleName` or `1RuleName` is the same as just `RuleName`.) */ reduceOpcodes(data.rules);\n        return {\n            rules: data.rules,\n            udts: data.udts,\n            lineMap: data.rulesLineMap\n        };\n    };\n    // Generate a grammar constructor function.\n    // An object instantiated from this constructor is used with the `apg-lib` `parser()` function.\n    this.generateSource = function generateSource(chars, lines, rules, udts, name) {\n        let source = \"\";\n        let i;\n        let bkrname;\n        let bkrlower;\n        let opcodeCount = 0;\n        let charCodeMin = Infinity;\n        let charCodeMax = 0;\n        const ruleNames = [];\n        const udtNames = [];\n        let alt = 0;\n        let cat = 0;\n        let rnm = 0;\n        let udt = 0;\n        let rep = 0;\n        let and = 0;\n        let not = 0;\n        let tls = 0;\n        let tbs = 0;\n        let trg = 0;\n        let bkr = 0;\n        let bka = 0;\n        let bkn = 0;\n        let abg = 0;\n        let aen = 0;\n        rules.forEach((rule)=>{\n            ruleNames.push(rule.lower);\n            opcodeCount += rule.opcodes.length;\n            rule.opcodes.forEach((op)=>{\n                switch(op.type){\n                    case id.ALT:\n                        alt += 1;\n                        break;\n                    case id.CAT:\n                        cat += 1;\n                        break;\n                    case id.RNM:\n                        rnm += 1;\n                        break;\n                    case id.UDT:\n                        udt += 1;\n                        break;\n                    case id.REP:\n                        rep += 1;\n                        break;\n                    case id.AND:\n                        and += 1;\n                        break;\n                    case id.NOT:\n                        not += 1;\n                        break;\n                    case id.BKA:\n                        bka += 1;\n                        break;\n                    case id.BKN:\n                        bkn += 1;\n                        break;\n                    case id.BKR:\n                        bkr += 1;\n                        break;\n                    case id.ABG:\n                        abg += 1;\n                        break;\n                    case id.AEN:\n                        aen += 1;\n                        break;\n                    case id.TLS:\n                        tls += 1;\n                        for(i = 0; i < op.string.length; i += 1){\n                            if (op.string[i] < charCodeMin) {\n                                charCodeMin = op.string[i];\n                            }\n                            if (op.string[i] > charCodeMax) {\n                                charCodeMax = op.string[i];\n                            }\n                        }\n                        break;\n                    case id.TBS:\n                        tbs += 1;\n                        for(i = 0; i < op.string.length; i += 1){\n                            if (op.string[i] < charCodeMin) {\n                                charCodeMin = op.string[i];\n                            }\n                            if (op.string[i] > charCodeMax) {\n                                charCodeMax = op.string[i];\n                            }\n                        }\n                        break;\n                    case id.TRG:\n                        trg += 1;\n                        if (op.min < charCodeMin) {\n                            charCodeMin = op.min;\n                        }\n                        if (op.max > charCodeMax) {\n                            charCodeMax = op.max;\n                        }\n                        break;\n                    default:\n                        throw new Error(\"generateSource: unrecognized opcode\");\n                }\n            });\n        });\n        ruleNames.sort();\n        if (udts.length > 0) {\n            udts.forEach((udtFunc)=>{\n                udtNames.push(udtFunc.lower);\n            });\n            udtNames.sort();\n        }\n        let funcname = \"module.exports\";\n        if (name && typeof name === \"string\") {\n            funcname = `let ${name}`;\n        }\n        source += \"// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\\n\";\n        source += \"//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\\n\";\n        source += \"//\\n\";\n        source += \"// Generated by apg-js, Version 4.2.1 [apg-js](https://github.com/ldthomas/apg-js)\\n\";\n        source += `${funcname} = function grammar(){\\n`;\n        source += \"  // ```\\n\";\n        source += \"  // SUMMARY\\n\";\n        source += `  //      rules = ${rules.length}\\n`;\n        source += `  //       udts = ${udts.length}\\n`;\n        source += `  //    opcodes = ${opcodeCount}\\n`;\n        source += \"  //        ---   ABNF original opcodes\\n\";\n        source += `  //        ALT = ${alt}\\n`;\n        source += `  //        CAT = ${cat}\\n`;\n        source += `  //        REP = ${rep}\\n`;\n        source += `  //        RNM = ${rnm}\\n`;\n        source += `  //        TLS = ${tls}\\n`;\n        source += `  //        TBS = ${tbs}\\n`;\n        source += `  //        TRG = ${trg}\\n`;\n        source += \"  //        ---   SABNF superset opcodes\\n\";\n        source += `  //        UDT = ${udt}\\n`;\n        source += `  //        AND = ${and}\\n`;\n        source += `  //        NOT = ${not}\\n`;\n        source += `  //        BKA = ${bka}\\n`;\n        source += `  //        BKN = ${bkn}\\n`;\n        source += `  //        BKR = ${bkr}\\n`;\n        source += `  //        ABG = ${abg}\\n`;\n        source += `  //        AEN = ${aen}\\n`;\n        source += \"  // characters = [\";\n        if (tls + tbs + trg === 0) {\n            source += \" none defined ]\";\n        } else {\n            source += `${charCodeMin} - ${charCodeMax}]`;\n        }\n        if (udt > 0) {\n            source += \" + user defined\";\n        }\n        source += \"\\n\";\n        source += \"  // ```\\n\";\n        source += \"  /* OBJECT IDENTIFIER (for internal parser use) */\\n\";\n        source += \"  this.grammarObject = 'grammarObject';\\n\";\n        source += \"\\n\";\n        source += \"  /* RULES */\\n\";\n        source += \"  this.rules = [];\\n\";\n        rules.forEach((rule, ii)=>{\n            let thisRule = \"  this.rules[\";\n            thisRule += ii;\n            thisRule += \"] = {name: '\";\n            thisRule += rule.name;\n            thisRule += \"', lower: '\";\n            thisRule += rule.lower;\n            thisRule += \"', index: \";\n            thisRule += rule.index;\n            thisRule += \", isBkr: \";\n            thisRule += rule.isBkr;\n            thisRule += \"};\\n\";\n            source += thisRule;\n        });\n        source += \"\\n\";\n        source += \"  /* UDTS */\\n\";\n        source += \"  this.udts = [];\\n\";\n        if (udts.length > 0) {\n            udts.forEach((udtFunc, ii)=>{\n                let thisUdt = \"  this.udts[\";\n                thisUdt += ii;\n                thisUdt += \"] = {name: '\";\n                thisUdt += udtFunc.name;\n                thisUdt += \"', lower: '\";\n                thisUdt += udtFunc.lower;\n                thisUdt += \"', index: \";\n                thisUdt += udtFunc.index;\n                thisUdt += \", empty: \";\n                thisUdt += udtFunc.empty;\n                thisUdt += \", isBkr: \";\n                thisUdt += udtFunc.isBkr;\n                thisUdt += \"};\\n\";\n                source += thisUdt;\n            });\n        }\n        source += \"\\n\";\n        source += \"  /* OPCODES */\\n\";\n        rules.forEach((rule, ruleIndex)=>{\n            if (ruleIndex > 0) {\n                source += \"\\n\";\n            }\n            source += `  /* ${rule.name} */\\n`;\n            source += `  this.rules[${ruleIndex}].opcodes = [];\\n`;\n            rule.opcodes.forEach((op, opIndex)=>{\n                let prefix;\n                switch(op.type){\n                    case id.ALT:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, children: [${op.children.toString()}]};// ALT\\n`;\n                        break;\n                    case id.CAT:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, children: [${op.children.toString()}]};// CAT\\n`;\n                        break;\n                    case id.RNM:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}};// RNM(${rules[op.index].name})\\n`;\n                        break;\n                    case id.BKR:\n                        if (op.index >= rules.length) {\n                            bkrname = udts[op.index - rules.length].name;\n                            bkrlower = udts[op.index - rules.length].lower;\n                        } else {\n                            bkrname = rules[op.index].name;\n                            bkrlower = rules[op.index].lower;\n                        }\n                        prefix = \"%i\";\n                        if (op.bkrCase === id.BKR_MODE_CS) {\n                            prefix = \"%s\";\n                        }\n                        if (op.bkrMode === id.BKR_MODE_UM) {\n                            prefix += \"%u\";\n                        } else {\n                            prefix += \"%p\";\n                        }\n                        bkrname = prefix + bkrname;\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, index: ${op.index}, lower: '${bkrlower}'` + `, bkrCase: ${op.bkrCase}, bkrMode: ${op.bkrMode}};// BKR(\\\\${bkrname})\\n`;\n                        break;\n                    case id.UDT:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, empty: ${op.empty}, index: ${op.index}};// UDT(${udts[op.index].name})\\n`;\n                        break;\n                    case id.REP:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// REP\\n`;\n                        break;\n                    case id.AND:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AND\\n`;\n                        break;\n                    case id.NOT:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// NOT\\n`;\n                        break;\n                    case id.ABG:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// ABG(%^)\\n`;\n                        break;\n                    case id.AEN:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// AEN(%$)\\n`;\n                        break;\n                    case id.BKA:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKA\\n`;\n                        break;\n                    case id.BKN:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}};// BKN\\n`;\n                        break;\n                    case id.TLS:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, string: [${op.string.toString()}]};// TLS\\n`;\n                        break;\n                    case id.TBS:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, string: [${op.string.toString()}]};// TBS\\n`;\n                        break;\n                    case id.TRG:\n                        source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = {type: ${op.type}, min: ${op.min}, max: ${op.max}};// TRG\\n`;\n                        break;\n                    default:\n                        throw new Error(\"parser.js: ~143: unrecognized opcode\");\n                }\n            });\n        });\n        source += \"\\n\";\n        source += \"  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\\n\";\n        source += \"  this.toString = function toString(){\\n\";\n        source += '    let str = \"\";\\n';\n        let str;\n        lines.forEach((line)=>{\n            const end = line.beginChar + line.length;\n            str = \"\";\n            source += '    str += \"';\n            for(let ii = line.beginChar; ii < end; ii += 1){\n                switch(chars[ii]){\n                    case 9:\n                        str = \" \";\n                        break;\n                    case 10:\n                        str = \"\\\\n\";\n                        break;\n                    case 13:\n                        str = \"\\\\r\";\n                        break;\n                    case 34:\n                        str = '\\\\\"';\n                        break;\n                    case 92:\n                        str = \"\\\\\\\\\";\n                        break;\n                    default:\n                        str = String.fromCharCode(chars[ii]);\n                        break;\n                }\n                source += str;\n            }\n            source += '\";\\n';\n        });\n        source += \"    return str;\\n\";\n        source += \"  }\\n\";\n        source += \"}\\n\";\n        return source;\n    };\n    // Generate a grammar file object.\n    // Returns the same object as instantiating the constructor function returned by<br>\n    // `this.generateSource()`.<br>\n    this.generateObject = function generateObject(stringArg, rules, udts) {\n        const obj = {};\n        const ruleNames = [];\n        const udtNames = [];\n        const string = stringArg.slice(0);\n        obj.grammarObject = \"grammarObject\";\n        rules.forEach((rule)=>{\n            ruleNames.push(rule.lower);\n        });\n        ruleNames.sort();\n        if (udts.length > 0) {\n            udts.forEach((udtFunc)=>{\n                udtNames.push(udtFunc.lower);\n            });\n            udtNames.sort();\n        }\n        obj.callbacks = [];\n        ruleNames.forEach((name)=>{\n            obj.callbacks[name] = false;\n        });\n        if (udts.length > 0) {\n            udtNames.forEach((name)=>{\n                obj.callbacks[name] = false;\n            });\n        }\n        obj.rules = rules;\n        obj.udts = udts;\n        obj.toString = function toStringFunc() {\n            return string;\n        };\n        return obj;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O3VGQUd1RixHQUN2RiwrREFBK0Q7QUFDL0QsMkVBQTJFO0FBQzNFLDZFQUE2RTtBQUM3RSxpQ0FBaUM7QUFDakMsMkNBQTJDO0FBQzNDLHlIQUF5SDtBQUN6SCxrR0FBa0c7O0FBQ2xHQSxPQUFPQyxPQUFPLEdBQUcsU0FBU0M7SUFDeEIsTUFBTUMsZUFBZTtJQUNyQixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQztJQUN2QixNQUFNQyxLQUFLRixPQUFPRyxHQUFHO0lBQ3JCLE1BQU1DLE1BQU0sSUFBS0gsQ0FBQUEsbUJBQU9BLENBQUMsNEhBQW9CO0lBQzdDLE1BQU1JLE1BQU0sSUFBS0osQ0FBQUEsbUJBQU9BLENBQUMsZ0lBQXNCO0lBQy9DLE1BQU1LLGVBQWUsSUFBS0wsQ0FBQUEsbUJBQU9BLENBQUMsc0hBQWlCO0lBQ25ELG1DQUFtQztJQUNuQyxNQUFNTSxTQUFTLElBQUlQLE9BQU9PLE1BQU07SUFDaEMsbUNBQW1DO0lBQ25DQSxPQUFPQyxHQUFHLEdBQUcsSUFBSVIsT0FBT1EsR0FBRztJQUMzQkQsT0FBT0UsU0FBUyxHQUFHTCxJQUFJSyxTQUFTO0lBQ2hDRixPQUFPQyxHQUFHLENBQUNDLFNBQVMsR0FBR0osSUFBSUksU0FBUztJQUVwQyxzREFBc0QsR0FDdEQsTUFBTUMsV0FBVyxTQUFTQSxTQUFTQyxLQUFLLEVBQUVDLFNBQVMsRUFBRUMsVUFBVTtRQUM3RCxJQUFJRCxZQUFZLEtBQUtBLGFBQWFDLFlBQVk7WUFDNUMsZ0NBQWdDLEdBQ2hDLE9BQU8sQ0FBQztRQUNWO1FBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE1BQU1JLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1lBQ3hDLElBQUlGLGFBQWFELEtBQUssQ0FBQ0csRUFBRSxDQUFDRSxTQUFTLElBQUlKLFlBQVlELEtBQUssQ0FBQ0csRUFBRSxDQUFDRSxTQUFTLEdBQUdMLEtBQUssQ0FBQ0csRUFBRSxDQUFDQyxNQUFNLEVBQUU7Z0JBQ3ZGLE9BQU9EO1lBQ1Q7UUFDRjtRQUNBLDJCQUEyQixHQUMzQixPQUFPLENBQUM7SUFDVjtJQUNBLE1BQU1HLGlCQUFpQixTQUFTQSxlQUFlQyxHQUFHLEVBQUVDLEtBQUs7UUFDdkQsSUFBSUMsTUFBTSxDQUFDO1FBQ1gsSUFBSUQsUUFBUUQsSUFBSUgsTUFBTSxFQUFFO1lBQ3RCLElBQUssSUFBSUQsSUFBSUssT0FBT0wsSUFBSUksSUFBSUgsTUFBTSxFQUFFRCxLQUFLLEVBQUc7Z0JBQzFDLElBQUlJLEdBQUcsQ0FBQ0osRUFBRSxLQUFLLE1BQU07b0JBQ25CTSxNQUFNRixHQUFHLENBQUNKLEVBQUU7b0JBQ1o7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsT0FBT007SUFDVDtJQUNBLG1EQUFtRCxHQUNuRCxNQUFNQyxnQkFBZ0IsU0FBU0EsY0FBY0MsS0FBSztRQUNoREEsTUFBTUMsT0FBTyxDQUFDLENBQUNDO1lBQ2IsTUFBTUMsVUFBVSxFQUFFO1lBQ2xCLE1BQU1QLE1BQU0sRUFBRTtZQUNkLElBQUlRLGVBQWU7WUFDbkJGLEtBQUtDLE9BQU8sQ0FBQ0YsT0FBTyxDQUFDLENBQUNJO2dCQUNwQixJQUFJQSxHQUFHQyxJQUFJLEtBQUsxQixHQUFHMkIsR0FBRyxJQUFJRixHQUFHRyxRQUFRLENBQUNmLE1BQU0sS0FBSyxHQUFHO29CQUNsREcsSUFBSWEsSUFBSSxDQUFDO2dCQUNYLE9BQU8sSUFBSUosR0FBR0MsSUFBSSxLQUFLMUIsR0FBRzhCLEdBQUcsSUFBSUwsR0FBR0csUUFBUSxDQUFDZixNQUFNLEtBQUssR0FBRztvQkFDekRHLElBQUlhLElBQUksQ0FBQztnQkFDWCxPQUFPLElBQUlKLEdBQUdDLElBQUksS0FBSzFCLEdBQUcrQixHQUFHLElBQUlOLEdBQUdPLEdBQUcsS0FBSyxLQUFLUCxHQUFHUSxHQUFHLEtBQUssR0FBRztvQkFDN0RqQixJQUFJYSxJQUFJLENBQUM7Z0JBQ1gsT0FBTztvQkFDTGIsSUFBSWEsSUFBSSxDQUFDTDtvQkFDVEQsUUFBUU0sSUFBSSxDQUFDSjtvQkFDYkQsZ0JBQWdCO2dCQUNsQjtZQUNGO1lBQ0FSLElBQUlhLElBQUksQ0FBQ0w7WUFDVCx5REFBeUQsR0FDekRELFFBQVFGLE9BQU8sQ0FBQyxDQUFDSTtnQkFDZixJQUFJQSxHQUFHQyxJQUFJLEtBQUsxQixHQUFHMkIsR0FBRyxJQUFJRixHQUFHQyxJQUFJLEtBQUsxQixHQUFHOEIsR0FBRyxFQUFFO29CQUM1QyxJQUFLLElBQUlsQixJQUFJLEdBQUdBLElBQUlhLEdBQUdHLFFBQVEsQ0FBQ2YsTUFBTSxFQUFFRCxLQUFLLEVBQUc7d0JBQzlDYSxHQUFHRyxRQUFRLENBQUNoQixFQUFFLEdBQUdHLGVBQWVDLEtBQUtTLEdBQUdHLFFBQVEsQ0FBQ2hCLEVBQUU7b0JBQ3JEO2dCQUNGO1lBQ0Y7WUFDQVUsS0FBS0MsT0FBTyxHQUFHQTtRQUNqQjtJQUNGO0lBQ0EseUNBQXlDLEdBQ3pDLDZEQUE2RCxHQUM3RCxJQUFJLENBQUNXLE1BQU0sR0FBRyxTQUFTQSxPQUFPQyxLQUFLLEVBQUUxQixLQUFLLEVBQUUyQixNQUFNLEVBQUVDLE1BQU0sRUFBRUMsS0FBSztRQUMvRCxJQUFJQSxPQUFPO1lBQ1QsSUFBSUEsTUFBTUMsV0FBVyxLQUFLLGVBQWU7Z0JBQ3ZDLE1BQU0sSUFBSUMsVUFBVSxDQUFDLEVBQUUzQyxhQUFhLG9DQUFvQyxDQUFDO1lBQzNFO1lBQ0FRLE9BQU9pQyxLQUFLLEdBQUdBO1FBQ2pCO1FBQ0EsTUFBTUcsT0FBTyxDQUFDO1FBQ2RBLEtBQUtMLE1BQU0sR0FBR0E7UUFDZEssS0FBS0osTUFBTSxHQUFHLENBQUMsQ0FBQ0E7UUFDaEJJLEtBQUtoQyxLQUFLLEdBQUdBO1FBQ2JnQyxLQUFLakMsUUFBUSxHQUFHQTtRQUNoQmlDLEtBQUtDLFdBQVcsR0FBR1AsTUFBTXRCLE1BQU07UUFDL0I0QixLQUFLRSxTQUFTLEdBQUc7UUFDakIsTUFBTUMsU0FBU3ZDLE9BQU93QyxLQUFLLENBQUN6QyxjQUFjLFFBQVErQixPQUFPTTtRQUN6RCxJQUFJLENBQUNHLE9BQU9FLE9BQU8sRUFBRTtZQUNuQlYsT0FBT1AsSUFBSSxDQUFDO2dCQUNWa0IsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkMsS0FBSztZQUNQO1FBQ0Y7SUFDRjtJQUNBLCtEQUErRCxHQUMvRCw2REFBNkQsR0FDN0QsSUFBSSxDQUFDQyxRQUFRLEdBQUcsU0FBU0EsU0FBU2YsS0FBSyxFQUFFMUIsS0FBSyxFQUFFMkIsTUFBTTtRQUNwRCxNQUFNSyxPQUFPLENBQUM7UUFDZEEsS0FBS0wsTUFBTSxHQUFHQTtRQUNkSyxLQUFLaEMsS0FBSyxHQUFHQTtRQUNiZ0MsS0FBS2pDLFFBQVEsR0FBR0E7UUFDaEJpQyxLQUFLQyxXQUFXLEdBQUdQLE1BQU10QixNQUFNO1FBQy9CUixPQUFPQyxHQUFHLENBQUM2QyxTQUFTLENBQUNWO1FBQ3JCLElBQUlMLE9BQU92QixNQUFNLEVBQUU7WUFDakIsT0FBTztRQUNUO1FBQ0EsOEJBQThCLEdBQzlCLHlDQUF5QyxHQUN6QyxxREFBcUQsR0FDckQscUZBQXFGLEdBQ3JGTSxjQUFjc0IsS0FBS3JCLEtBQUs7UUFDeEIsT0FBTztZQUNMQSxPQUFPcUIsS0FBS3JCLEtBQUs7WUFDakJnQyxNQUFNWCxLQUFLVyxJQUFJO1lBQ2ZDLFNBQVNaLEtBQUthLFlBQVk7UUFDNUI7SUFDRjtJQUNBLDJDQUEyQztJQUMzQywrRkFBK0Y7SUFDL0YsSUFBSSxDQUFDQyxjQUFjLEdBQUcsU0FBU0EsZUFBZXBCLEtBQUssRUFBRTFCLEtBQUssRUFBRVcsS0FBSyxFQUFFZ0MsSUFBSSxFQUFFSSxJQUFJO1FBQzNFLElBQUlDLFNBQVM7UUFDYixJQUFJN0M7UUFDSixJQUFJOEM7UUFDSixJQUFJQztRQUNKLElBQUlDLGNBQWM7UUFDbEIsSUFBSUMsY0FBY0M7UUFDbEIsSUFBSUMsY0FBYztRQUNsQixNQUFNQyxZQUFZLEVBQUU7UUFDcEIsTUFBTUMsV0FBVyxFQUFFO1FBQ25CLElBQUlDLE1BQU07UUFDVixJQUFJQyxNQUFNO1FBQ1YsSUFBSUMsTUFBTTtRQUNWLElBQUlDLE1BQU07UUFDVixJQUFJQyxNQUFNO1FBQ1YsSUFBSUMsTUFBTTtRQUNWLElBQUlDLE1BQU07UUFDVixJQUFJQyxNQUFNO1FBQ1YsSUFBSUMsTUFBTTtRQUNWLElBQUlDLE1BQU07UUFDVixJQUFJQyxNQUFNO1FBQ1YsSUFBSUMsTUFBTTtRQUNWLElBQUlDLE1BQU07UUFDVixJQUFJQyxNQUFNO1FBQ1YsSUFBSUMsTUFBTTtRQUNWNUQsTUFBTUMsT0FBTyxDQUFDLENBQUNDO1lBQ2IwQyxVQUFVbkMsSUFBSSxDQUFDUCxLQUFLMkQsS0FBSztZQUN6QnJCLGVBQWV0QyxLQUFLQyxPQUFPLENBQUNWLE1BQU07WUFDbENTLEtBQUtDLE9BQU8sQ0FBQ0YsT0FBTyxDQUFDLENBQUNJO2dCQUNwQixPQUFRQSxHQUFHQyxJQUFJO29CQUNiLEtBQUsxQixHQUFHMkIsR0FBRzt3QkFDVHVDLE9BQU87d0JBQ1A7b0JBQ0YsS0FBS2xFLEdBQUc4QixHQUFHO3dCQUNUcUMsT0FBTzt3QkFDUDtvQkFDRixLQUFLbkUsR0FBR2tGLEdBQUc7d0JBQ1RkLE9BQU87d0JBQ1A7b0JBQ0YsS0FBS3BFLEdBQUdtRixHQUFHO3dCQUNUZCxPQUFPO3dCQUNQO29CQUNGLEtBQUtyRSxHQUFHK0IsR0FBRzt3QkFDVHVDLE9BQU87d0JBQ1A7b0JBQ0YsS0FBS3RFLEdBQUdvRixHQUFHO3dCQUNUYixPQUFPO3dCQUNQO29CQUNGLEtBQUt2RSxHQUFHcUYsR0FBRzt3QkFDVGIsT0FBTzt3QkFDUDtvQkFDRixLQUFLeEUsR0FBR3NGLEdBQUc7d0JBQ1RULE9BQU87d0JBQ1A7b0JBQ0YsS0FBSzdFLEdBQUd1RixHQUFHO3dCQUNUVCxPQUFPO3dCQUNQO29CQUNGLEtBQUs5RSxHQUFHd0YsR0FBRzt3QkFDVFosT0FBTzt3QkFDUDtvQkFDRixLQUFLNUUsR0FBR3lGLEdBQUc7d0JBQ1RWLE9BQU87d0JBQ1A7b0JBQ0YsS0FBSy9FLEdBQUcwRixHQUFHO3dCQUNUVixPQUFPO3dCQUNQO29CQUNGLEtBQUtoRixHQUFHMkYsR0FBRzt3QkFDVGxCLE9BQU87d0JBQ1AsSUFBSzdELElBQUksR0FBR0EsSUFBSWEsR0FBR21FLE1BQU0sQ0FBQy9FLE1BQU0sRUFBRUQsS0FBSyxFQUFHOzRCQUN4QyxJQUFJYSxHQUFHbUUsTUFBTSxDQUFDaEYsRUFBRSxHQUFHaUQsYUFBYTtnQ0FDOUJBLGNBQWNwQyxHQUFHbUUsTUFBTSxDQUFDaEYsRUFBRTs0QkFDNUI7NEJBQ0EsSUFBSWEsR0FBR21FLE1BQU0sQ0FBQ2hGLEVBQUUsR0FBR21ELGFBQWE7Z0NBQzlCQSxjQUFjdEMsR0FBR21FLE1BQU0sQ0FBQ2hGLEVBQUU7NEJBQzVCO3dCQUNGO3dCQUNBO29CQUNGLEtBQUtaLEdBQUc2RixHQUFHO3dCQUNUbkIsT0FBTzt3QkFDUCxJQUFLOUQsSUFBSSxHQUFHQSxJQUFJYSxHQUFHbUUsTUFBTSxDQUFDL0UsTUFBTSxFQUFFRCxLQUFLLEVBQUc7NEJBQ3hDLElBQUlhLEdBQUdtRSxNQUFNLENBQUNoRixFQUFFLEdBQUdpRCxhQUFhO2dDQUM5QkEsY0FBY3BDLEdBQUdtRSxNQUFNLENBQUNoRixFQUFFOzRCQUM1Qjs0QkFDQSxJQUFJYSxHQUFHbUUsTUFBTSxDQUFDaEYsRUFBRSxHQUFHbUQsYUFBYTtnQ0FDOUJBLGNBQWN0QyxHQUFHbUUsTUFBTSxDQUFDaEYsRUFBRTs0QkFDNUI7d0JBQ0Y7d0JBQ0E7b0JBQ0YsS0FBS1osR0FBRzhGLEdBQUc7d0JBQ1RuQixPQUFPO3dCQUNQLElBQUlsRCxHQUFHTyxHQUFHLEdBQUc2QixhQUFhOzRCQUN4QkEsY0FBY3BDLEdBQUdPLEdBQUc7d0JBQ3RCO3dCQUNBLElBQUlQLEdBQUdRLEdBQUcsR0FBRzhCLGFBQWE7NEJBQ3hCQSxjQUFjdEMsR0FBR1EsR0FBRzt3QkFDdEI7d0JBQ0E7b0JBQ0Y7d0JBQ0UsTUFBTSxJQUFJOEQsTUFBTTtnQkFDcEI7WUFDRjtRQUNGO1FBQ0EvQixVQUFVZ0MsSUFBSTtRQUNkLElBQUk1QyxLQUFLdkMsTUFBTSxHQUFHLEdBQUc7WUFDbkJ1QyxLQUFLL0IsT0FBTyxDQUFDLENBQUM0RTtnQkFDWmhDLFNBQVNwQyxJQUFJLENBQUNvRSxRQUFRaEIsS0FBSztZQUM3QjtZQUNBaEIsU0FBUytCLElBQUk7UUFDZjtRQUNBLElBQUlFLFdBQVc7UUFDZixJQUFJMUMsUUFBUSxPQUFPQSxTQUFTLFVBQVU7WUFDcEMwQyxXQUFXLENBQUMsSUFBSSxFQUFFMUMsS0FBSyxDQUFDO1FBQzFCO1FBQ0FDLFVBQVU7UUFDVkEsVUFBVTtRQUNWQSxVQUFVO1FBQ1ZBLFVBQVU7UUFDVkEsVUFBVSxDQUFDLEVBQUV5QyxTQUFTLHdCQUF3QixDQUFDO1FBQy9DekMsVUFBVTtRQUNWQSxVQUFVO1FBQ1ZBLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRXJDLE1BQU1QLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDL0M0QyxVQUFVLENBQUMsa0JBQWtCLEVBQUVMLEtBQUt2QyxNQUFNLENBQUMsRUFBRSxDQUFDO1FBQzlDNEMsVUFBVSxDQUFDLGtCQUFrQixFQUFFRyxZQUFZLEVBQUUsQ0FBQztRQUM5Q0gsVUFBVTtRQUNWQSxVQUFVLENBQUMsa0JBQWtCLEVBQUVTLElBQUksRUFBRSxDQUFDO1FBQ3RDVCxVQUFVLENBQUMsa0JBQWtCLEVBQUVVLElBQUksRUFBRSxDQUFDO1FBQ3RDVixVQUFVLENBQUMsa0JBQWtCLEVBQUVhLElBQUksRUFBRSxDQUFDO1FBQ3RDYixVQUFVLENBQUMsa0JBQWtCLEVBQUVXLElBQUksRUFBRSxDQUFDO1FBQ3RDWCxVQUFVLENBQUMsa0JBQWtCLEVBQUVnQixJQUFJLEVBQUUsQ0FBQztRQUN0Q2hCLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRWlCLElBQUksRUFBRSxDQUFDO1FBQ3RDakIsVUFBVSxDQUFDLGtCQUFrQixFQUFFa0IsSUFBSSxFQUFFLENBQUM7UUFDdENsQixVQUFVO1FBQ1ZBLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRVksSUFBSSxFQUFFLENBQUM7UUFDdENaLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRWMsSUFBSSxFQUFFLENBQUM7UUFDdENkLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRWUsSUFBSSxFQUFFLENBQUM7UUFDdENmLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRW9CLElBQUksRUFBRSxDQUFDO1FBQ3RDcEIsVUFBVSxDQUFDLGtCQUFrQixFQUFFcUIsSUFBSSxFQUFFLENBQUM7UUFDdENyQixVQUFVLENBQUMsa0JBQWtCLEVBQUVtQixJQUFJLEVBQUUsQ0FBQztRQUN0Q25CLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRXNCLElBQUksRUFBRSxDQUFDO1FBQ3RDdEIsVUFBVSxDQUFDLGtCQUFrQixFQUFFdUIsSUFBSSxFQUFFLENBQUM7UUFDdEN2QixVQUFVO1FBQ1YsSUFBSWdCLE1BQU1DLE1BQU1DLFFBQVEsR0FBRztZQUN6QmxCLFVBQVU7UUFDWixPQUFPO1lBQ0xBLFVBQVUsQ0FBQyxFQUFFSSxZQUFZLEdBQUcsRUFBRUUsWUFBWSxDQUFDLENBQUM7UUFDOUM7UUFDQSxJQUFJTSxNQUFNLEdBQUc7WUFDWFosVUFBVTtRQUNaO1FBQ0FBLFVBQVU7UUFDVkEsVUFBVTtRQUNWQSxVQUFVO1FBQ1ZBLFVBQVU7UUFDVkEsVUFBVTtRQUNWQSxVQUFVO1FBQ1ZBLFVBQVU7UUFDVnJDLE1BQU1DLE9BQU8sQ0FBQyxDQUFDQyxNQUFNNkU7WUFDbkIsSUFBSUMsV0FBVztZQUNmQSxZQUFZRDtZQUNaQyxZQUFZO1lBQ1pBLFlBQVk5RSxLQUFLa0MsSUFBSTtZQUNyQjRDLFlBQVk7WUFDWkEsWUFBWTlFLEtBQUsyRCxLQUFLO1lBQ3RCbUIsWUFBWTtZQUNaQSxZQUFZOUUsS0FBS0wsS0FBSztZQUN0Qm1GLFlBQVk7WUFDWkEsWUFBWTlFLEtBQUsrRSxLQUFLO1lBQ3RCRCxZQUFZO1lBQ1ozQyxVQUFVMkM7UUFDWjtRQUNBM0MsVUFBVTtRQUNWQSxVQUFVO1FBQ1ZBLFVBQVU7UUFDVixJQUFJTCxLQUFLdkMsTUFBTSxHQUFHLEdBQUc7WUFDbkJ1QyxLQUFLL0IsT0FBTyxDQUFDLENBQUM0RSxTQUFTRTtnQkFDckIsSUFBSUcsVUFBVTtnQkFDZEEsV0FBV0g7Z0JBQ1hHLFdBQVc7Z0JBQ1hBLFdBQVdMLFFBQVF6QyxJQUFJO2dCQUN2QjhDLFdBQVc7Z0JBQ1hBLFdBQVdMLFFBQVFoQixLQUFLO2dCQUN4QnFCLFdBQVc7Z0JBQ1hBLFdBQVdMLFFBQVFoRixLQUFLO2dCQUN4QnFGLFdBQVc7Z0JBQ1hBLFdBQVdMLFFBQVFNLEtBQUs7Z0JBQ3hCRCxXQUFXO2dCQUNYQSxXQUFXTCxRQUFRSSxLQUFLO2dCQUN4QkMsV0FBVztnQkFDWDdDLFVBQVU2QztZQUNaO1FBQ0Y7UUFDQTdDLFVBQVU7UUFDVkEsVUFBVTtRQUNWckMsTUFBTUMsT0FBTyxDQUFDLENBQUNDLE1BQU1rRjtZQUNuQixJQUFJQSxZQUFZLEdBQUc7Z0JBQ2pCL0MsVUFBVTtZQUNaO1lBQ0FBLFVBQVUsQ0FBQyxLQUFLLEVBQUVuQyxLQUFLa0MsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUNsQ0MsVUFBVSxDQUFDLGFBQWEsRUFBRStDLFVBQVUsaUJBQWlCLENBQUM7WUFDdERsRixLQUFLQyxPQUFPLENBQUNGLE9BQU8sQ0FBQyxDQUFDSSxJQUFJZ0Y7Z0JBQ3hCLElBQUlDO2dCQUNKLE9BQVFqRixHQUFHQyxJQUFJO29CQUNiLEtBQUsxQixHQUFHMkIsR0FBRzt3QkFDVDhCLFVBQVUsQ0FBQyxhQUFhLEVBQUUrQyxVQUFVLFVBQVUsRUFBRUMsUUFBUSxXQUFXLEVBQ2pFaEYsR0FBR0MsSUFBSSxDQUNSLGFBQWEsRUFBRUQsR0FBR0csUUFBUSxDQUFDK0UsUUFBUSxHQUFHLFdBQVcsQ0FBQzt3QkFDbkQ7b0JBQ0YsS0FBSzNHLEdBQUc4QixHQUFHO3dCQUNUMkIsVUFBVSxDQUFDLGFBQWEsRUFBRStDLFVBQVUsVUFBVSxFQUFFQyxRQUFRLFdBQVcsRUFDakVoRixHQUFHQyxJQUFJLENBQ1IsYUFBYSxFQUFFRCxHQUFHRyxRQUFRLENBQUMrRSxRQUFRLEdBQUcsV0FBVyxDQUFDO3dCQUNuRDtvQkFDRixLQUFLM0csR0FBR2tGLEdBQUc7d0JBQ1R6QixVQUFVLENBQUMsYUFBYSxFQUFFK0MsVUFBVSxVQUFVLEVBQUVDLFFBQVEsV0FBVyxFQUFFaEYsR0FBR0MsSUFBSSxDQUFDLFNBQVMsRUFBRUQsR0FBR1IsS0FBSyxDQUFDLFNBQVMsRUFDeEdHLEtBQUssQ0FBQ0ssR0FBR1IsS0FBSyxDQUFDLENBQUN1QyxJQUFJLENBQ3JCLEdBQUcsQ0FBQzt3QkFDTDtvQkFDRixLQUFLeEQsR0FBR3dGLEdBQUc7d0JBQ1QsSUFBSS9ELEdBQUdSLEtBQUssSUFBSUcsTUFBTVAsTUFBTSxFQUFFOzRCQUM1QjZDLFVBQVVOLElBQUksQ0FBQzNCLEdBQUdSLEtBQUssR0FBR0csTUFBTVAsTUFBTSxDQUFDLENBQUMyQyxJQUFJOzRCQUM1Q0csV0FBV1AsSUFBSSxDQUFDM0IsR0FBR1IsS0FBSyxHQUFHRyxNQUFNUCxNQUFNLENBQUMsQ0FBQ29FLEtBQUs7d0JBQ2hELE9BQU87NEJBQ0x2QixVQUFVdEMsS0FBSyxDQUFDSyxHQUFHUixLQUFLLENBQUMsQ0FBQ3VDLElBQUk7NEJBQzlCRyxXQUFXdkMsS0FBSyxDQUFDSyxHQUFHUixLQUFLLENBQUMsQ0FBQ2dFLEtBQUs7d0JBQ2xDO3dCQUNBeUIsU0FBUzt3QkFDVCxJQUFJakYsR0FBR21GLE9BQU8sS0FBSzVHLEdBQUc2RyxXQUFXLEVBQUU7NEJBQ2pDSCxTQUFTO3dCQUNYO3dCQUNBLElBQUlqRixHQUFHcUYsT0FBTyxLQUFLOUcsR0FBRytHLFdBQVcsRUFBRTs0QkFDakNMLFVBQVU7d0JBQ1osT0FBTzs0QkFDTEEsVUFBVTt3QkFDWjt3QkFDQWhELFVBQVVnRCxTQUFTaEQ7d0JBQ25CRCxVQUNFLENBQUMsYUFBYSxFQUFFK0MsVUFBVSxVQUFVLEVBQUVDLFFBQVEsV0FBVyxFQUFFaEYsR0FBR0MsSUFBSSxDQUFDLFNBQVMsRUFBRUQsR0FBR1IsS0FBSyxDQUFDLFVBQVUsRUFBRTBDLFNBQVMsQ0FBQyxDQUFDLEdBQzlHLENBQUMsV0FBVyxFQUFFbEMsR0FBR21GLE9BQU8sQ0FBQyxXQUFXLEVBQUVuRixHQUFHcUYsT0FBTyxDQUFDLFdBQVcsRUFBRXBELFFBQVEsR0FBRyxDQUFDO3dCQUM1RTtvQkFDRixLQUFLMUQsR0FBR21GLEdBQUc7d0JBQ1QxQixVQUFVLENBQUMsYUFBYSxFQUFFK0MsVUFBVSxVQUFVLEVBQUVDLFFBQVEsV0FBVyxFQUFFaEYsR0FBR0MsSUFBSSxDQUFDLFNBQVMsRUFBRUQsR0FBRzhFLEtBQUssQ0FBQyxTQUFTLEVBQ3hHOUUsR0FBR1IsS0FBSyxDQUNULFNBQVMsRUFBRW1DLElBQUksQ0FBQzNCLEdBQUdSLEtBQUssQ0FBQyxDQUFDdUMsSUFBSSxDQUFDLEdBQUcsQ0FBQzt3QkFDcEM7b0JBQ0YsS0FBS3hELEdBQUcrQixHQUFHO3dCQUNUMEIsVUFBVSxDQUFDLGFBQWEsRUFBRStDLFVBQVUsVUFBVSxFQUFFQyxRQUFRLFdBQVcsRUFBRWhGLEdBQUdDLElBQUksQ0FBQyxPQUFPLEVBQUVELEdBQUdPLEdBQUcsQ0FBQyxPQUFPLEVBQUVQLEdBQUdRLEdBQUcsQ0FBQyxVQUFVLENBQUM7d0JBQ3hIO29CQUNGLEtBQUtqQyxHQUFHb0YsR0FBRzt3QkFDVDNCLFVBQVUsQ0FBQyxhQUFhLEVBQUUrQyxVQUFVLFVBQVUsRUFBRUMsUUFBUSxXQUFXLEVBQUVoRixHQUFHQyxJQUFJLENBQUMsVUFBVSxDQUFDO3dCQUN4RjtvQkFDRixLQUFLMUIsR0FBR3FGLEdBQUc7d0JBQ1Q1QixVQUFVLENBQUMsYUFBYSxFQUFFK0MsVUFBVSxVQUFVLEVBQUVDLFFBQVEsV0FBVyxFQUFFaEYsR0FBR0MsSUFBSSxDQUFDLFVBQVUsQ0FBQzt3QkFDeEY7b0JBQ0YsS0FBSzFCLEdBQUd5RixHQUFHO3dCQUNUaEMsVUFBVSxDQUFDLGFBQWEsRUFBRStDLFVBQVUsVUFBVSxFQUFFQyxRQUFRLFdBQVcsRUFBRWhGLEdBQUdDLElBQUksQ0FBQyxjQUFjLENBQUM7d0JBQzVGO29CQUNGLEtBQUsxQixHQUFHMEYsR0FBRzt3QkFDVGpDLFVBQVUsQ0FBQyxhQUFhLEVBQUUrQyxVQUFVLFVBQVUsRUFBRUMsUUFBUSxXQUFXLEVBQUVoRixHQUFHQyxJQUFJLENBQUMsY0FBYyxDQUFDO3dCQUM1RjtvQkFDRixLQUFLMUIsR0FBR3NGLEdBQUc7d0JBQ1Q3QixVQUFVLENBQUMsYUFBYSxFQUFFK0MsVUFBVSxVQUFVLEVBQUVDLFFBQVEsV0FBVyxFQUFFaEYsR0FBR0MsSUFBSSxDQUFDLFVBQVUsQ0FBQzt3QkFDeEY7b0JBQ0YsS0FBSzFCLEdBQUd1RixHQUFHO3dCQUNUOUIsVUFBVSxDQUFDLGFBQWEsRUFBRStDLFVBQVUsVUFBVSxFQUFFQyxRQUFRLFdBQVcsRUFBRWhGLEdBQUdDLElBQUksQ0FBQyxVQUFVLENBQUM7d0JBQ3hGO29CQUNGLEtBQUsxQixHQUFHMkYsR0FBRzt3QkFDVGxDLFVBQVUsQ0FBQyxhQUFhLEVBQUUrQyxVQUFVLFVBQVUsRUFBRUMsUUFBUSxXQUFXLEVBQ2pFaEYsR0FBR0MsSUFBSSxDQUNSLFdBQVcsRUFBRUQsR0FBR21FLE1BQU0sQ0FBQ2UsUUFBUSxHQUFHLFdBQVcsQ0FBQzt3QkFDL0M7b0JBQ0YsS0FBSzNHLEdBQUc2RixHQUFHO3dCQUNUcEMsVUFBVSxDQUFDLGFBQWEsRUFBRStDLFVBQVUsVUFBVSxFQUFFQyxRQUFRLFdBQVcsRUFDakVoRixHQUFHQyxJQUFJLENBQ1IsV0FBVyxFQUFFRCxHQUFHbUUsTUFBTSxDQUFDZSxRQUFRLEdBQUcsV0FBVyxDQUFDO3dCQUMvQztvQkFDRixLQUFLM0csR0FBRzhGLEdBQUc7d0JBQ1RyQyxVQUFVLENBQUMsYUFBYSxFQUFFK0MsVUFBVSxVQUFVLEVBQUVDLFFBQVEsV0FBVyxFQUFFaEYsR0FBR0MsSUFBSSxDQUFDLE9BQU8sRUFBRUQsR0FBR08sR0FBRyxDQUFDLE9BQU8sRUFBRVAsR0FBR1EsR0FBRyxDQUFDLFVBQVUsQ0FBQzt3QkFDeEg7b0JBQ0Y7d0JBQ0UsTUFBTSxJQUFJOEQsTUFBTTtnQkFDcEI7WUFDRjtRQUNGO1FBQ0F0QyxVQUFVO1FBQ1ZBLFVBQVU7UUFDVkEsVUFBVTtRQUNWQSxVQUFVO1FBQ1YsSUFBSXVEO1FBQ0p2RyxNQUFNWSxPQUFPLENBQUMsQ0FBQzBCO1lBQ2IsTUFBTWtFLE1BQU1sRSxLQUFLakMsU0FBUyxHQUFHaUMsS0FBS2xDLE1BQU07WUFDeENtRyxNQUFNO1lBQ052RCxVQUFVO1lBQ1YsSUFBSyxJQUFJMEMsS0FBS3BELEtBQUtqQyxTQUFTLEVBQUVxRixLQUFLYyxLQUFLZCxNQUFNLEVBQUc7Z0JBQy9DLE9BQVFoRSxLQUFLLENBQUNnRSxHQUFHO29CQUNmLEtBQUs7d0JBQ0hhLE1BQU07d0JBQ047b0JBQ0YsS0FBSzt3QkFDSEEsTUFBTTt3QkFDTjtvQkFDRixLQUFLO3dCQUNIQSxNQUFNO3dCQUNOO29CQUNGLEtBQUs7d0JBQ0hBLE1BQU07d0JBQ047b0JBQ0YsS0FBSzt3QkFDSEEsTUFBTTt3QkFDTjtvQkFDRjt3QkFDRUEsTUFBTUUsT0FBT0MsWUFBWSxDQUFDaEYsS0FBSyxDQUFDZ0UsR0FBRzt3QkFDbkM7Z0JBQ0o7Z0JBQ0ExQyxVQUFVdUQ7WUFDWjtZQUNBdkQsVUFBVTtRQUNaO1FBQ0FBLFVBQVU7UUFDVkEsVUFBVTtRQUNWQSxVQUFVO1FBQ1YsT0FBT0E7SUFDVDtJQUNBLGtDQUFrQztJQUNsQyxvRkFBb0Y7SUFDcEYsK0JBQStCO0lBQy9CLElBQUksQ0FBQzJELGNBQWMsR0FBRyxTQUFTQSxlQUFlQyxTQUFTLEVBQUVqRyxLQUFLLEVBQUVnQyxJQUFJO1FBQ2xFLE1BQU1rRSxNQUFNLENBQUM7UUFDYixNQUFNdEQsWUFBWSxFQUFFO1FBQ3BCLE1BQU1DLFdBQVcsRUFBRTtRQUNuQixNQUFNMkIsU0FBU3lCLFVBQVVFLEtBQUssQ0FBQztRQUMvQkQsSUFBSUUsYUFBYSxHQUFHO1FBQ3BCcEcsTUFBTUMsT0FBTyxDQUFDLENBQUNDO1lBQ2IwQyxVQUFVbkMsSUFBSSxDQUFDUCxLQUFLMkQsS0FBSztRQUMzQjtRQUNBakIsVUFBVWdDLElBQUk7UUFDZCxJQUFJNUMsS0FBS3ZDLE1BQU0sR0FBRyxHQUFHO1lBQ25CdUMsS0FBSy9CLE9BQU8sQ0FBQyxDQUFDNEU7Z0JBQ1poQyxTQUFTcEMsSUFBSSxDQUFDb0UsUUFBUWhCLEtBQUs7WUFDN0I7WUFDQWhCLFNBQVMrQixJQUFJO1FBQ2Y7UUFDQXNCLElBQUkvRyxTQUFTLEdBQUcsRUFBRTtRQUNsQnlELFVBQVUzQyxPQUFPLENBQUMsQ0FBQ21DO1lBQ2pCOEQsSUFBSS9HLFNBQVMsQ0FBQ2lELEtBQUssR0FBRztRQUN4QjtRQUNBLElBQUlKLEtBQUt2QyxNQUFNLEdBQUcsR0FBRztZQUNuQm9ELFNBQVM1QyxPQUFPLENBQUMsQ0FBQ21DO2dCQUNoQjhELElBQUkvRyxTQUFTLENBQUNpRCxLQUFLLEdBQUc7WUFDeEI7UUFDRjtRQUNBOEQsSUFBSWxHLEtBQUssR0FBR0E7UUFDWmtHLElBQUlsRSxJQUFJLEdBQUdBO1FBQ1hrRSxJQUFJWCxRQUFRLEdBQUcsU0FBU2M7WUFDdEIsT0FBTzdCO1FBQ1Q7UUFDQSxPQUFPMEI7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvcGFyc2VyLmpzPzg5ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgY29udmVydHMgYW4gaW5wdXQgU0FCTkYgZ3JhbW1hciB0ZXh0IGZpbGUgaW50byBhXG4vLyBncmFtbWFyIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggYGFwZy1saWJgIGluIGFuIGFwcGxpY2F0aW9uIHBhcnNlci5cbi8vICoqYXBnKiogaXMsIGluIGZhY3QgaXRzZWxmLCBhbiBBQk5GIHBhcnNlciB0aGF0IGdlbmVyYXRlcyBhbiBTQUJORiBwYXJzZXIuXG4vLyBJdCBpcyBiYXNlZCBvbiB0aGUgZ3JhbW1hcjxicj5cbi8vIGAuL2Rpc3QvYWJuZi1mb3Itc2FibmYtZ3JhbW1hci5ibmZgLjxicj5cbi8vIEluIGl0cyBzeW50YXggcGhhc2UsICoqYXBnKiogYW5hbHl6ZXMgdGhlIHVzZXIncyBpbnB1dCBTQUJORiBncmFtbWFyIGZvciBjb3JyZWN0IHN5bnRheCwgZ2VuZXJhdGluZyBhbiBBU1QgYXMgaXQgZ29lcy5cbi8vIEluIGl0cyBzZW1hbnRpYyBwaGFzZSwgKiphcGcqKiB0cmFuc2xhdGVzIHRoZSBBU1QgdG8gZ2VuZXJhdGUgdGhlIHBhcnNlciBmb3IgdGhlIGlucHV0IGdyYW1tYXIuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cG9ydFBhcnNlcigpIHtcbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ3BhcnNlcjogJztcbiAgY29uc3QgQXBnTGliID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHMnKTtcbiAgY29uc3QgaWQgPSBBcGdMaWIuaWRzO1xuICBjb25zdCBzeW4gPSBuZXcgKHJlcXVpcmUoJy4vc3ludGF4LWNhbGxiYWNrcycpKSgpO1xuICBjb25zdCBzZW0gPSBuZXcgKHJlcXVpcmUoJy4vc2VtYW50aWMtY2FsbGJhY2tzJykpKCk7XG4gIGNvbnN0IHNhYm5mR3JhbW1hciA9IG5ldyAocmVxdWlyZSgnLi9zYWJuZi1ncmFtbWFyJykpKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gIGNvbnN0IHBhcnNlciA9IG5ldyBBcGdMaWIucGFyc2VyKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gIHBhcnNlci5hc3QgPSBuZXcgQXBnTGliLmFzdCgpO1xuICBwYXJzZXIuY2FsbGJhY2tzID0gc3luLmNhbGxiYWNrcztcbiAgcGFyc2VyLmFzdC5jYWxsYmFja3MgPSBzZW0uY2FsbGJhY2tzO1xuXG4gIC8qIGZpbmQgdGhlIGxpbmUgY29udGFpbmluZyB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGluZGV4ICovXG4gIGNvbnN0IGZpbmRMaW5lID0gZnVuY3Rpb24gZmluZExpbmUobGluZXMsIGNoYXJJbmRleCwgY2hhckxlbmd0aCkge1xuICAgIGlmIChjaGFySW5kZXggPCAwIHx8IGNoYXJJbmRleCA+PSBjaGFyTGVuZ3RoKSB7XG4gICAgICAvKiByZXR1cm4gZXJyb3IgaWYgb3V0IG9mIHJhbmdlICovXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChjaGFySW5kZXggPj0gbGluZXNbaV0uYmVnaW5DaGFyICYmIGNoYXJJbmRleCA8IGxpbmVzW2ldLmJlZ2luQ2hhciArIGxpbmVzW2ldLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUgKi9cbiAgICByZXR1cm4gLTE7XG4gIH07XG4gIGNvbnN0IHRyYW5zbGF0ZUluZGV4ID0gZnVuY3Rpb24gdHJhbnNsYXRlSW5kZXgobWFwLCBpbmRleCkge1xuICAgIGxldCByZXQgPSAtMTtcbiAgICBpZiAoaW5kZXggPCBtYXAubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCBtYXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG1hcFtpXSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldCA9IG1hcFtpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICAvKiBoZWxwZXIgZnVuY3Rpb24gd2hlbiByZW1vdmluZyByZWR1bmRhbnQgb3Bjb2RlcyAqL1xuICBjb25zdCByZWR1Y2VPcGNvZGVzID0gZnVuY3Rpb24gcmVkdWNlT3Bjb2RlcyhydWxlcykge1xuICAgIHJ1bGVzLmZvckVhY2goKHJ1bGUpID0+IHtcbiAgICAgIGNvbnN0IG9wY29kZXMgPSBbXTtcbiAgICAgIGNvbnN0IG1hcCA9IFtdO1xuICAgICAgbGV0IHJlZHVjZWRJbmRleCA9IDA7XG4gICAgICBydWxlLm9wY29kZXMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgaWYgKG9wLnR5cGUgPT09IGlkLkFMVCAmJiBvcC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBtYXAucHVzaChudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcC50eXBlID09PSBpZC5DQVQgJiYgb3AuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbWFwLnB1c2gobnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3AudHlwZSA9PT0gaWQuUkVQICYmIG9wLm1pbiA9PT0gMSAmJiBvcC5tYXggPT09IDEpIHtcbiAgICAgICAgICBtYXAucHVzaChudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXAucHVzaChyZWR1Y2VkSW5kZXgpO1xuICAgICAgICAgIG9wY29kZXMucHVzaChvcCk7XG4gICAgICAgICAgcmVkdWNlZEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbWFwLnB1c2gocmVkdWNlZEluZGV4KTtcbiAgICAgIC8qIHRyYW5zbGF0ZSBvcmlnaW5hbCBvcGNvZGUgaW5kZXhlcyB0byB0aGUgcmVkdWNlZCBzZXQuICovXG4gICAgICBvcGNvZGVzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgIGlmIChvcC50eXBlID09PSBpZC5BTFQgfHwgb3AudHlwZSA9PT0gaWQuQ0FUKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgb3AuY2hpbGRyZW5baV0gPSB0cmFuc2xhdGVJbmRleChtYXAsIG9wLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcnVsZS5vcGNvZGVzID0gb3Bjb2RlcztcbiAgICB9KTtcbiAgfTtcbiAgLyogUGFyc2UgdGhlIGdyYW1tYXIgLSB0aGUgc3ludGF4IHBoYXNlLiAqL1xuICAvKiBTQUJORiBncmFtbWFyIHN5bnRheCBlcnJvcnMgYXJlIGNhdWdodCBhbmQgcmVwb3J0ZWQgaGVyZS4gKi9cbiAgdGhpcy5zeW50YXggPSBmdW5jdGlvbiBzeW50YXgoY2hhcnMsIGxpbmVzLCBlcnJvcnMsIHN0cmljdCwgdHJhY2UpIHtcbiAgICBpZiAodHJhY2UpIHtcbiAgICAgIGlmICh0cmFjZS50cmFjZU9iamVjdCAhPT0gJ3RyYWNlT2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3RoaXNGaWxlTmFtZX10cmFjZSBhcmd1bWVudCBpcyBub3QgYSB0cmFjZSBvYmplY3RgKTtcbiAgICAgIH1cbiAgICAgIHBhcnNlci50cmFjZSA9IHRyYWNlO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZGF0YS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgZGF0YS5zdHJpY3QgPSAhIXN0cmljdDtcbiAgICBkYXRhLmxpbmVzID0gbGluZXM7XG4gICAgZGF0YS5maW5kTGluZSA9IGZpbmRMaW5lO1xuICAgIGRhdGEuY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgZGF0YS5ydWxlQ291bnQgPSAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlci5wYXJzZShzYWJuZkdyYW1tYXIsICdmaWxlJywgY2hhcnMsIGRhdGEpO1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgbGluZTogMCxcbiAgICAgICAgY2hhcjogMCxcbiAgICAgICAgbXNnOiAnc3ludGF4IGFuYWx5c2lzIG9mIGlucHV0IGdyYW1tYXIgZmFpbGVkJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyogUGFyc2UgdGhlIGdyYW1tYXIgLSB0aGUgc2VtYW50aWMgcGhhc2UsIHRyYW5zbGF0ZXMgdGhlIEFTVC4gKi9cbiAgLyogU0FCTkYgZ3JhbW1hciBzeW50YXggZXJyb3JzIGFyZSBjYXVnaHQgYW5kIHJlcG9ydGVkIGhlcmUuICovXG4gIHRoaXMuc2VtYW50aWMgPSBmdW5jdGlvbiBzZW1hbnRpYyhjaGFycywgbGluZXMsIGVycm9ycykge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBkYXRhLmVycm9ycyA9IGVycm9ycztcbiAgICBkYXRhLmxpbmVzID0gbGluZXM7XG4gICAgZGF0YS5maW5kTGluZSA9IGZpbmRMaW5lO1xuICAgIGRhdGEuY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgcGFyc2VyLmFzdC50cmFuc2xhdGUoZGF0YSk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKiBSZW1vdmUgdW5uZWVkZWQgb3BlcmF0b3JzLiAqL1xuICAgIC8qIEFMVCBvcGVyYXRvcnMgd2l0aCBhIHNpbmdsZSBhbHRlcm5hdGUgKi9cbiAgICAvKiBDQVQgb3BlcmF0b3JzIHdpdGggYSBzaW5nbGUgcGhyYXNlIHRvIGNvbmNhdGVuYXRlICovXG4gICAgLyogUkVQKDEsMSkgb3BlcmF0b3JzIChgMSoxUnVsZU5hbWVgIG9yIGAxUnVsZU5hbWVgIGlzIHRoZSBzYW1lIGFzIGp1c3QgYFJ1bGVOYW1lYC4pICovXG4gICAgcmVkdWNlT3Bjb2RlcyhkYXRhLnJ1bGVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgcnVsZXM6IGRhdGEucnVsZXMsXG4gICAgICB1ZHRzOiBkYXRhLnVkdHMsXG4gICAgICBsaW5lTWFwOiBkYXRhLnJ1bGVzTGluZU1hcCxcbiAgICB9O1xuICB9O1xuICAvLyBHZW5lcmF0ZSBhIGdyYW1tYXIgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gIC8vIEFuIG9iamVjdCBpbnN0YW50aWF0ZWQgZnJvbSB0aGlzIGNvbnN0cnVjdG9yIGlzIHVzZWQgd2l0aCB0aGUgYGFwZy1saWJgIGBwYXJzZXIoKWAgZnVuY3Rpb24uXG4gIHRoaXMuZ2VuZXJhdGVTb3VyY2UgPSBmdW5jdGlvbiBnZW5lcmF0ZVNvdXJjZShjaGFycywgbGluZXMsIHJ1bGVzLCB1ZHRzLCBuYW1lKSB7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGxldCBpO1xuICAgIGxldCBia3JuYW1lO1xuICAgIGxldCBia3Jsb3dlcjtcbiAgICBsZXQgb3Bjb2RlQ291bnQgPSAwO1xuICAgIGxldCBjaGFyQ29kZU1pbiA9IEluZmluaXR5O1xuICAgIGxldCBjaGFyQ29kZU1heCA9IDA7XG4gICAgY29uc3QgcnVsZU5hbWVzID0gW107XG4gICAgY29uc3QgdWR0TmFtZXMgPSBbXTtcbiAgICBsZXQgYWx0ID0gMDtcbiAgICBsZXQgY2F0ID0gMDtcbiAgICBsZXQgcm5tID0gMDtcbiAgICBsZXQgdWR0ID0gMDtcbiAgICBsZXQgcmVwID0gMDtcbiAgICBsZXQgYW5kID0gMDtcbiAgICBsZXQgbm90ID0gMDtcbiAgICBsZXQgdGxzID0gMDtcbiAgICBsZXQgdGJzID0gMDtcbiAgICBsZXQgdHJnID0gMDtcbiAgICBsZXQgYmtyID0gMDtcbiAgICBsZXQgYmthID0gMDtcbiAgICBsZXQgYmtuID0gMDtcbiAgICBsZXQgYWJnID0gMDtcbiAgICBsZXQgYWVuID0gMDtcbiAgICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICBydWxlTmFtZXMucHVzaChydWxlLmxvd2VyKTtcbiAgICAgIG9wY29kZUNvdW50ICs9IHJ1bGUub3Bjb2Rlcy5sZW5ndGg7XG4gICAgICBydWxlLm9wY29kZXMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBpZC5BTFQ6XG4gICAgICAgICAgICBhbHQgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQ0FUOlxuICAgICAgICAgICAgY2F0ICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlJOTTpcbiAgICAgICAgICAgIHJubSArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5VRFQ6XG4gICAgICAgICAgICB1ZHQgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuUkVQOlxuICAgICAgICAgICAgcmVwICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFORDpcbiAgICAgICAgICAgIGFuZCArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5OT1Q6XG4gICAgICAgICAgICBub3QgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktBOlxuICAgICAgICAgICAgYmthICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkJLTjpcbiAgICAgICAgICAgIGJrbiArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgICAgICBia3IgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQUJHOlxuICAgICAgICAgICAgYWJnICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFFTjpcbiAgICAgICAgICAgIGFlbiArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgICAgICB0bHMgKz0gMTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcC5zdHJpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKG9wLnN0cmluZ1tpXSA8IGNoYXJDb2RlTWluKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGVNaW4gPSBvcC5zdHJpbmdbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9wLnN0cmluZ1tpXSA+IGNoYXJDb2RlTWF4KSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGVNYXggPSBvcC5zdHJpbmdbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVEJTOlxuICAgICAgICAgICAgdGJzICs9IDE7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3Auc3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5zdHJpbmdbaV0gPCBjaGFyQ29kZU1pbikge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlTWluID0gb3Auc3RyaW5nW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvcC5zdHJpbmdbaV0gPiBjaGFyQ29kZU1heCkge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlTWF4ID0gb3Auc3RyaW5nW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRSRzpcbiAgICAgICAgICAgIHRyZyArPSAxO1xuICAgICAgICAgICAgaWYgKG9wLm1pbiA8IGNoYXJDb2RlTWluKSB7XG4gICAgICAgICAgICAgIGNoYXJDb2RlTWluID0gb3AubWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wLm1heCA+IGNoYXJDb2RlTWF4KSB7XG4gICAgICAgICAgICAgIGNoYXJDb2RlTWF4ID0gb3AubWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VuZXJhdGVTb3VyY2U6IHVucmVjb2duaXplZCBvcGNvZGUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcnVsZU5hbWVzLnNvcnQoKTtcbiAgICBpZiAodWR0cy5sZW5ndGggPiAwKSB7XG4gICAgICB1ZHRzLmZvckVhY2goKHVkdEZ1bmMpID0+IHtcbiAgICAgICAgdWR0TmFtZXMucHVzaCh1ZHRGdW5jLmxvd2VyKTtcbiAgICAgIH0pO1xuICAgICAgdWR0TmFtZXMuc29ydCgpO1xuICAgIH1cbiAgICBsZXQgZnVuY25hbWUgPSAnbW9kdWxlLmV4cG9ydHMnO1xuICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZnVuY25hbWUgPSBgbGV0ICR7bmFtZX1gO1xuICAgIH1cbiAgICBzb3VyY2UgKz0gJy8vIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIzIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWQ8YnI+XFxuJztcbiAgICBzb3VyY2UgKz0gJy8vICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSk8YnI+XFxuJztcbiAgICBzb3VyY2UgKz0gJy8vXFxuJztcbiAgICBzb3VyY2UgKz0gJy8vIEdlbmVyYXRlZCBieSBhcGctanMsIFZlcnNpb24gNC4yLjEgW2FwZy1qc10oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qcylcXG4nO1xuICAgIHNvdXJjZSArPSBgJHtmdW5jbmFtZX0gPSBmdW5jdGlvbiBncmFtbWFyKCl7XFxuYDtcbiAgICBzb3VyY2UgKz0gJyAgLy8gYGBgXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLy8gU1VNTUFSWVxcbic7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgcnVsZXMgPSAke3J1bGVzLmxlbmd0aH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICB1ZHRzID0gJHt1ZHRzLmxlbmd0aH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICBvcGNvZGVzID0gJHtvcGNvZGVDb3VudH1cXG5gO1xuICAgIHNvdXJjZSArPSAnICAvLyAgICAgICAgLS0tICAgQUJORiBvcmlnaW5hbCBvcGNvZGVzXFxuJztcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIEFMVCA9ICR7YWx0fVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBDQVQgPSAke2NhdH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgUkVQID0gJHtyZXB9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIFJOTSA9ICR7cm5tfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBUTFMgPSAke3Rsc31cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgVEJTID0gJHt0YnN9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIFRSRyA9ICR7dHJnfVxcbmA7XG4gICAgc291cmNlICs9ICcgIC8vICAgICAgICAtLS0gICBTQUJORiBzdXBlcnNldCBvcGNvZGVzXFxuJztcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIFVEVCA9ICR7dWR0fVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBBTkQgPSAke2FuZH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgTk9UID0gJHtub3R9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIEJLQSA9ICR7YmthfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBCS04gPSAke2Jrbn1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQktSID0gJHtia3J9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIEFCRyA9ICR7YWJnfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBBRU4gPSAke2Flbn1cXG5gO1xuICAgIHNvdXJjZSArPSAnICAvLyBjaGFyYWN0ZXJzID0gWyc7XG4gICAgaWYgKHRscyArIHRicyArIHRyZyA9PT0gMCkge1xuICAgICAgc291cmNlICs9ICcgbm9uZSBkZWZpbmVkIF0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgKz0gYCR7Y2hhckNvZGVNaW59IC0gJHtjaGFyQ29kZU1heH1dYDtcbiAgICB9XG4gICAgaWYgKHVkdCA+IDApIHtcbiAgICAgIHNvdXJjZSArPSAnICsgdXNlciBkZWZpbmVkJztcbiAgICB9XG4gICAgc291cmNlICs9ICdcXG4nO1xuICAgIHNvdXJjZSArPSAnICAvLyBgYGBcXG4nO1xuICAgIHNvdXJjZSArPSAnICAvKiBPQkpFQ1QgSURFTlRJRklFUiAoZm9yIGludGVybmFsIHBhcnNlciB1c2UpICovXFxuJztcbiAgICBzb3VyY2UgKz0gXCIgIHRoaXMuZ3JhbW1hck9iamVjdCA9ICdncmFtbWFyT2JqZWN0JztcXG5cIjtcbiAgICBzb3VyY2UgKz0gJ1xcbic7XG4gICAgc291cmNlICs9ICcgIC8qIFJVTEVTICovXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgdGhpcy5ydWxlcyA9IFtdO1xcbic7XG4gICAgcnVsZXMuZm9yRWFjaCgocnVsZSwgaWkpID0+IHtcbiAgICAgIGxldCB0aGlzUnVsZSA9ICcgIHRoaXMucnVsZXNbJztcbiAgICAgIHRoaXNSdWxlICs9IGlpO1xuICAgICAgdGhpc1J1bGUgKz0gXCJdID0ge25hbWU6ICdcIjtcbiAgICAgIHRoaXNSdWxlICs9IHJ1bGUubmFtZTtcbiAgICAgIHRoaXNSdWxlICs9IFwiJywgbG93ZXI6ICdcIjtcbiAgICAgIHRoaXNSdWxlICs9IHJ1bGUubG93ZXI7XG4gICAgICB0aGlzUnVsZSArPSBcIicsIGluZGV4OiBcIjtcbiAgICAgIHRoaXNSdWxlICs9IHJ1bGUuaW5kZXg7XG4gICAgICB0aGlzUnVsZSArPSAnLCBpc0JrcjogJztcbiAgICAgIHRoaXNSdWxlICs9IHJ1bGUuaXNCa3I7XG4gICAgICB0aGlzUnVsZSArPSAnfTtcXG4nO1xuICAgICAgc291cmNlICs9IHRoaXNSdWxlO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSAnXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLyogVURUUyAqL1xcbic7XG4gICAgc291cmNlICs9ICcgIHRoaXMudWR0cyA9IFtdO1xcbic7XG4gICAgaWYgKHVkdHMubGVuZ3RoID4gMCkge1xuICAgICAgdWR0cy5mb3JFYWNoKCh1ZHRGdW5jLCBpaSkgPT4ge1xuICAgICAgICBsZXQgdGhpc1VkdCA9ICcgIHRoaXMudWR0c1snO1xuICAgICAgICB0aGlzVWR0ICs9IGlpO1xuICAgICAgICB0aGlzVWR0ICs9IFwiXSA9IHtuYW1lOiAnXCI7XG4gICAgICAgIHRoaXNVZHQgKz0gdWR0RnVuYy5uYW1lO1xuICAgICAgICB0aGlzVWR0ICs9IFwiJywgbG93ZXI6ICdcIjtcbiAgICAgICAgdGhpc1VkdCArPSB1ZHRGdW5jLmxvd2VyO1xuICAgICAgICB0aGlzVWR0ICs9IFwiJywgaW5kZXg6IFwiO1xuICAgICAgICB0aGlzVWR0ICs9IHVkdEZ1bmMuaW5kZXg7XG4gICAgICAgIHRoaXNVZHQgKz0gJywgZW1wdHk6ICc7XG4gICAgICAgIHRoaXNVZHQgKz0gdWR0RnVuYy5lbXB0eTtcbiAgICAgICAgdGhpc1VkdCArPSAnLCBpc0JrcjogJztcbiAgICAgICAgdGhpc1VkdCArPSB1ZHRGdW5jLmlzQmtyO1xuICAgICAgICB0aGlzVWR0ICs9ICd9O1xcbic7XG4gICAgICAgIHNvdXJjZSArPSB0aGlzVWR0O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNvdXJjZSArPSAnXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLyogT1BDT0RFUyAqL1xcbic7XG4gICAgcnVsZXMuZm9yRWFjaCgocnVsZSwgcnVsZUluZGV4KSA9PiB7XG4gICAgICBpZiAocnVsZUluZGV4ID4gMCkge1xuICAgICAgICBzb3VyY2UgKz0gJ1xcbic7XG4gICAgICB9XG4gICAgICBzb3VyY2UgKz0gYCAgLyogJHtydWxlLm5hbWV9ICovXFxuYDtcbiAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2RlcyA9IFtdO1xcbmA7XG4gICAgICBydWxlLm9wY29kZXMuZm9yRWFjaCgob3AsIG9wSW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHByZWZpeDtcbiAgICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBpZC5BTFQ6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtcbiAgICAgICAgICAgICAgb3AudHlwZVxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IFske29wLmNoaWxkcmVuLnRvU3RyaW5nKCl9XX07Ly8gQUxUXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQ0FUOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7XG4gICAgICAgICAgICAgIG9wLnR5cGVcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbJHtvcC5jaGlsZHJlbi50b1N0cmluZygpfV19Oy8vIENBVFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlJOTTpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9LCBpbmRleDogJHtvcC5pbmRleH19Oy8vIFJOTSgke1xuICAgICAgICAgICAgICBydWxlc1tvcC5pbmRleF0ubmFtZVxuICAgICAgICAgICAgfSlcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgICAgICBpZiAob3AuaW5kZXggPj0gcnVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJrcm5hbWUgPSB1ZHRzW29wLmluZGV4IC0gcnVsZXMubGVuZ3RoXS5uYW1lO1xuICAgICAgICAgICAgICBia3Jsb3dlciA9IHVkdHNbb3AuaW5kZXggLSBydWxlcy5sZW5ndGhdLmxvd2VyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmtybmFtZSA9IHJ1bGVzW29wLmluZGV4XS5uYW1lO1xuICAgICAgICAgICAgICBia3Jsb3dlciA9IHJ1bGVzW29wLmluZGV4XS5sb3dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWZpeCA9ICclaSc7XG4gICAgICAgICAgICBpZiAob3AuYmtyQ2FzZSA9PT0gaWQuQktSX01PREVfQ1MpIHtcbiAgICAgICAgICAgICAgcHJlZml4ID0gJyVzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcC5ia3JNb2RlID09PSBpZC5CS1JfTU9ERV9VTSkge1xuICAgICAgICAgICAgICBwcmVmaXggKz0gJyV1JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByZWZpeCArPSAnJXAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmtybmFtZSA9IHByZWZpeCArIGJrcm5hbWU7XG4gICAgICAgICAgICBzb3VyY2UgKz1cbiAgICAgICAgICAgICAgYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfSwgaW5kZXg6ICR7b3AuaW5kZXh9LCBsb3dlcjogJyR7YmtybG93ZXJ9J2AgK1xuICAgICAgICAgICAgICBgLCBia3JDYXNlOiAke29wLmJrckNhc2V9LCBia3JNb2RlOiAke29wLmJrck1vZGV9fTsvLyBCS1IoXFxcXCR7YmtybmFtZX0pXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVURUOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX0sIGVtcHR5OiAke29wLmVtcHR5fSwgaW5kZXg6ICR7XG4gICAgICAgICAgICAgIG9wLmluZGV4XG4gICAgICAgICAgICB9fTsvLyBVRFQoJHt1ZHRzW29wLmluZGV4XS5uYW1lfSlcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5SRVA6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfSwgbWluOiAke29wLm1pbn0sIG1heDogJHtvcC5tYXh9fTsvLyBSRVBcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5BTkQ6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfX07Ly8gQU5EXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuTk9UOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX19Oy8vIE5PVFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFCRzpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9fTsvLyBBQkcoJV4pXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQUVOOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX19Oy8vIEFFTiglJClcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5CS0E6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7dHlwZTogJHtvcC50eXBlfX07Ly8gQktBXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktOOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0ge3R5cGU6ICR7b3AudHlwZX19Oy8vIEJLTlxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRMUzpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke1xuICAgICAgICAgICAgICBvcC50eXBlXG4gICAgICAgICAgICB9LCBzdHJpbmc6IFske29wLnN0cmluZy50b1N0cmluZygpfV19Oy8vIFRMU1xcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRCUzpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke1xuICAgICAgICAgICAgICBvcC50eXBlXG4gICAgICAgICAgICB9LCBzdHJpbmc6IFske29wLnN0cmluZy50b1N0cmluZygpfV19Oy8vIFRCU1xcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRSRzpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHt0eXBlOiAke29wLnR5cGV9LCBtaW46ICR7b3AubWlufSwgbWF4OiAke29wLm1heH19Oy8vIFRSR1xcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJzZXIuanM6IH4xNDM6IHVucmVjb2duaXplZCBvcGNvZGUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc291cmNlICs9ICdcXG4nO1xuICAgIHNvdXJjZSArPSAnICAvLyBUaGUgYHRvU3RyaW5nKClgIGZ1bmN0aW9uIHdpbGwgZGlzcGxheSB0aGUgb3JpZ2luYWwgZ3JhbW1hciBmaWxlKHMpIHRoYXQgcHJvZHVjZWQgdGhlc2Ugb3Bjb2Rlcy5cXG4nO1xuICAgIHNvdXJjZSArPSAnICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKXtcXG4nO1xuICAgIHNvdXJjZSArPSAnICAgIGxldCBzdHIgPSBcIlwiO1xcbic7XG4gICAgbGV0IHN0cjtcbiAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICBjb25zdCBlbmQgPSBsaW5lLmJlZ2luQ2hhciArIGxpbmUubGVuZ3RoO1xuICAgICAgc3RyID0gJyc7XG4gICAgICBzb3VyY2UgKz0gJyAgICBzdHIgKz0gXCInO1xuICAgICAgZm9yIChsZXQgaWkgPSBsaW5lLmJlZ2luQ2hhcjsgaWkgPCBlbmQ7IGlpICs9IDEpIHtcbiAgICAgICAgc3dpdGNoIChjaGFyc1tpaV0pIHtcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBzdHIgPSAnICc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgc3RyID0gJ1xcXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBzdHIgPSAnXFxcXHInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIHN0ciA9ICdcXFxcXCInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5MjpcbiAgICAgICAgICAgIHN0ciA9ICdcXFxcXFxcXCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyc1tpaV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlICs9IHN0cjtcbiAgICAgIH1cbiAgICAgIHNvdXJjZSArPSAnXCI7XFxuJztcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gJyAgICByZXR1cm4gc3RyO1xcbic7XG4gICAgc291cmNlICs9ICcgIH1cXG4nO1xuICAgIHNvdXJjZSArPSAnfVxcbic7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfTtcbiAgLy8gR2VuZXJhdGUgYSBncmFtbWFyIGZpbGUgb2JqZWN0LlxuICAvLyBSZXR1cm5zIHRoZSBzYW1lIG9iamVjdCBhcyBpbnN0YW50aWF0aW5nIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiByZXR1cm5lZCBieTxicj5cbiAgLy8gYHRoaXMuZ2VuZXJhdGVTb3VyY2UoKWAuPGJyPlxuICB0aGlzLmdlbmVyYXRlT2JqZWN0ID0gZnVuY3Rpb24gZ2VuZXJhdGVPYmplY3Qoc3RyaW5nQXJnLCBydWxlcywgdWR0cykge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGNvbnN0IHJ1bGVOYW1lcyA9IFtdO1xuICAgIGNvbnN0IHVkdE5hbWVzID0gW107XG4gICAgY29uc3Qgc3RyaW5nID0gc3RyaW5nQXJnLnNsaWNlKDApO1xuICAgIG9iai5ncmFtbWFyT2JqZWN0ID0gJ2dyYW1tYXJPYmplY3QnO1xuICAgIHJ1bGVzLmZvckVhY2goKHJ1bGUpID0+IHtcbiAgICAgIHJ1bGVOYW1lcy5wdXNoKHJ1bGUubG93ZXIpO1xuICAgIH0pO1xuICAgIHJ1bGVOYW1lcy5zb3J0KCk7XG4gICAgaWYgKHVkdHMubGVuZ3RoID4gMCkge1xuICAgICAgdWR0cy5mb3JFYWNoKCh1ZHRGdW5jKSA9PiB7XG4gICAgICAgIHVkdE5hbWVzLnB1c2godWR0RnVuYy5sb3dlcik7XG4gICAgICB9KTtcbiAgICAgIHVkdE5hbWVzLnNvcnQoKTtcbiAgICB9XG4gICAgb2JqLmNhbGxiYWNrcyA9IFtdO1xuICAgIHJ1bGVOYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBvYmouY2FsbGJhY2tzW25hbWVdID0gZmFsc2U7XG4gICAgfSk7XG4gICAgaWYgKHVkdHMubGVuZ3RoID4gMCkge1xuICAgICAgdWR0TmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICBvYmouY2FsbGJhY2tzW25hbWVdID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgb2JqLnJ1bGVzID0gcnVsZXM7XG4gICAgb2JqLnVkdHMgPSB1ZHRzO1xuICAgIG9iai50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nRnVuYygpIHtcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZXhwb3J0UGFyc2VyIiwidGhpc0ZpbGVOYW1lIiwiQXBnTGliIiwicmVxdWlyZSIsImlkIiwiaWRzIiwic3luIiwic2VtIiwic2FibmZHcmFtbWFyIiwicGFyc2VyIiwiYXN0IiwiY2FsbGJhY2tzIiwiZmluZExpbmUiLCJsaW5lcyIsImNoYXJJbmRleCIsImNoYXJMZW5ndGgiLCJpIiwibGVuZ3RoIiwiYmVnaW5DaGFyIiwidHJhbnNsYXRlSW5kZXgiLCJtYXAiLCJpbmRleCIsInJldCIsInJlZHVjZU9wY29kZXMiLCJydWxlcyIsImZvckVhY2giLCJydWxlIiwib3Bjb2RlcyIsInJlZHVjZWRJbmRleCIsIm9wIiwidHlwZSIsIkFMVCIsImNoaWxkcmVuIiwicHVzaCIsIkNBVCIsIlJFUCIsIm1pbiIsIm1heCIsInN5bnRheCIsImNoYXJzIiwiZXJyb3JzIiwic3RyaWN0IiwidHJhY2UiLCJ0cmFjZU9iamVjdCIsIlR5cGVFcnJvciIsImRhdGEiLCJjaGFyc0xlbmd0aCIsInJ1bGVDb3VudCIsInJlc3VsdCIsInBhcnNlIiwic3VjY2VzcyIsImxpbmUiLCJjaGFyIiwibXNnIiwic2VtYW50aWMiLCJ0cmFuc2xhdGUiLCJ1ZHRzIiwibGluZU1hcCIsInJ1bGVzTGluZU1hcCIsImdlbmVyYXRlU291cmNlIiwibmFtZSIsInNvdXJjZSIsImJrcm5hbWUiLCJia3Jsb3dlciIsIm9wY29kZUNvdW50IiwiY2hhckNvZGVNaW4iLCJJbmZpbml0eSIsImNoYXJDb2RlTWF4IiwicnVsZU5hbWVzIiwidWR0TmFtZXMiLCJhbHQiLCJjYXQiLCJybm0iLCJ1ZHQiLCJyZXAiLCJhbmQiLCJub3QiLCJ0bHMiLCJ0YnMiLCJ0cmciLCJia3IiLCJia2EiLCJia24iLCJhYmciLCJhZW4iLCJsb3dlciIsIlJOTSIsIlVEVCIsIkFORCIsIk5PVCIsIkJLQSIsIkJLTiIsIkJLUiIsIkFCRyIsIkFFTiIsIlRMUyIsInN0cmluZyIsIlRCUyIsIlRSRyIsIkVycm9yIiwic29ydCIsInVkdEZ1bmMiLCJmdW5jbmFtZSIsImlpIiwidGhpc1J1bGUiLCJpc0JrciIsInRoaXNVZHQiLCJlbXB0eSIsInJ1bGVJbmRleCIsIm9wSW5kZXgiLCJwcmVmaXgiLCJ0b1N0cmluZyIsImJrckNhc2UiLCJCS1JfTU9ERV9DUyIsImJrck1vZGUiLCJCS1JfTU9ERV9VTSIsInN0ciIsImVuZCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImdlbmVyYXRlT2JqZWN0Iiwic3RyaW5nQXJnIiwib2JqIiwic2xpY2UiLCJncmFtbWFyT2JqZWN0IiwidG9TdHJpbmdGdW5jIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/parser.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-attributes.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-attributes.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module does the heavy lifting for attribute generation.\n\nmodule.exports = function exportRuleAttributes() {\n    const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n    const thisFile = \"rule-attributes.js\";\n    let state = null;\n    function isEmptyOnly(attr) {\n        if (attr.left || attr.nested || attr.right || attr.cyclic) {\n            return false;\n        }\n        return attr.empty;\n    }\n    function isRecursive(attr) {\n        if (attr.left || attr.nested || attr.right || attr.cyclic) {\n            return true;\n        }\n        return false;\n    }\n    function isCatNested(attrs, count) {\n        let i = 0;\n        let j = 0;\n        let k = 0;\n        /* 1. if any child is nested, CAT is nested */ for(i = 0; i < count; i += 1){\n            if (attrs[i].nested) {\n                return true;\n            }\n        }\n        /* 2.) the left-most right recursive child\n               is followed by at least one non-empty child */ for(i = 0; i < count; i += 1){\n            if (attrs[i].right && !attrs[i].leaf) {\n                for(j = i + 1; j < count; j += 1){\n                    if (!isEmptyOnly(attrs[j])) {\n                        return true;\n                    }\n                }\n            }\n        }\n        /* 3.) the right-most left recursive child\n               is preceded by at least one non-empty child */ for(i = count - 1; i >= 0; i -= 1){\n            if (attrs[i].left && !attrs[i].leaf) {\n                for(j = i - 1; j >= 0; j -= 1){\n                    if (!isEmptyOnly(attrs[j])) {\n                        return true;\n                    }\n                }\n            }\n        }\n        /* 4. there is at lease one recursive child between\n              the left-most and right-most non-recursive, non-empty children */ for(i = 0; i < count; i += 1){\n            if (!attrs[i].empty && !isRecursive(attrs[i])) {\n                for(j = i + 1; j < count; j += 1){\n                    if (isRecursive(attrs[j])) {\n                        for(k = j + 1; k < count; k += 1){\n                            if (!attrs[k].empty && !isRecursive(attrs[k])) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /* none of the above */ return false;\n    }\n    function isCatCyclic(attrs, count) {\n        /* if all children are cyclic, CAT is cyclic */ for(let i = 0; i < count; i += 1){\n            if (!attrs[i].cyclic) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function isCatLeft(attrs, count) {\n        /* if the left-most non-empty is left, CAT is left */ for(let i = 0; i < count; i += 1){\n            if (attrs[i].left) {\n                return true;\n            }\n            if (!attrs[i].empty) {\n                return false;\n            }\n        /* keep looking */ }\n        return false; /* all left-most are empty */ \n    }\n    function isCatRight(attrs, count) {\n        /* if the right-most non-empty is right, CAT is right */ for(let i = count - 1; i >= 0; i -= 1){\n            if (attrs[i].right) {\n                return true;\n            }\n            if (!attrs[i].empty) {\n                return false;\n            }\n        /* keep looking */ }\n        return false;\n    }\n    function isCatEmpty(attrs, count) {\n        /* if all children are empty, CAT is empty */ for(let i = 0; i < count; i += 1){\n            if (!attrs[i].empty) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function isCatFinite(attrs, count) {\n        /* if all children are finite, CAT is finite */ for(let i = 0; i < count; i += 1){\n            if (!attrs[i].finite) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function cat(stateArg, opcodes, opIndex, iAttr) {\n        let i = 0;\n        const opCat = opcodes[opIndex];\n        const count = opCat.children.length;\n        /* generate an empty array of child attributes */ const childAttrs = [];\n        for(i = 0; i < count; i += 1){\n            childAttrs.push(stateArg.attrGen());\n        }\n        for(i = 0; i < count; i += 1){\n            // eslint-disable-next-line no-use-before-define\n            opEval(stateArg, opcodes, opCat.children[i], childAttrs[i]);\n        }\n        iAttr.left = isCatLeft(childAttrs, count);\n        iAttr.right = isCatRight(childAttrs, count);\n        iAttr.nested = isCatNested(childAttrs, count);\n        iAttr.empty = isCatEmpty(childAttrs, count);\n        iAttr.finite = isCatFinite(childAttrs, count);\n        iAttr.cyclic = isCatCyclic(childAttrs, count);\n    }\n    function alt(stateArg, opcodes, opIndex, iAttr) {\n        let i = 0;\n        const opAlt = opcodes[opIndex];\n        const count = opAlt.children.length;\n        /* generate an empty array of child attributes */ const childAttrs = [];\n        for(i = 0; i < count; i += 1){\n            childAttrs.push(stateArg.attrGen());\n        }\n        for(i = 0; i < count; i += 1){\n            // eslint-disable-next-line no-use-before-define\n            opEval(stateArg, opcodes, opAlt.children[i], childAttrs[i]);\n        }\n        /* if any child attribute is true, ALT is true */ iAttr.left = false;\n        iAttr.right = false;\n        iAttr.nested = false;\n        iAttr.empty = false;\n        iAttr.finite = false;\n        iAttr.cyclic = false;\n        for(i = 0; i < count; i += 1){\n            if (childAttrs[i].left) {\n                iAttr.left = true;\n            }\n            if (childAttrs[i].nested) {\n                iAttr.nested = true;\n            }\n            if (childAttrs[i].right) {\n                iAttr.right = true;\n            }\n            if (childAttrs[i].empty) {\n                iAttr.empty = true;\n            }\n            if (childAttrs[i].finite) {\n                iAttr.finite = true;\n            }\n            if (childAttrs[i].cyclic) {\n                iAttr.cyclic = true;\n            }\n        }\n    }\n    function bkr(stateArg, opcodes, opIndex, iAttr) {\n        const opBkr = opcodes[opIndex];\n        if (opBkr.index >= stateArg.ruleCount) {\n            /* use UDT values */ iAttr.empty = stateArg.udts[opBkr.index - stateArg.ruleCount].empty;\n            iAttr.finite = true;\n        } else {\n            /* use the empty and finite values from the back referenced rule */ // eslint-disable-next-line no-use-before-define\n            ruleAttrsEval(stateArg, opBkr.index, iAttr);\n            /* however, this is a terminal node like TLS */ iAttr.left = false;\n            iAttr.nested = false;\n            iAttr.right = false;\n            iAttr.cyclic = false;\n        }\n    }\n    function opEval(stateArg, opcodes, opIndex, iAttr) {\n        stateArg.attrInit(iAttr);\n        const opi = opcodes[opIndex];\n        switch(opi.type){\n            case id.ALT:\n                alt(stateArg, opcodes, opIndex, iAttr);\n                break;\n            case id.CAT:\n                cat(stateArg, opcodes, opIndex, iAttr);\n                break;\n            case id.REP:\n                opEval(stateArg, opcodes, opIndex + 1, iAttr);\n                if (opi.min === 0) {\n                    iAttr.empty = true;\n                    iAttr.finite = true;\n                }\n                break;\n            case id.RNM:\n                // eslint-disable-next-line no-use-before-define\n                ruleAttrsEval(stateArg, opcodes[opIndex].index, iAttr);\n                break;\n            case id.BKR:\n                bkr(stateArg, opcodes, opIndex, iAttr);\n                break;\n            case id.AND:\n            case id.NOT:\n            case id.BKA:\n            case id.BKN:\n                opEval(stateArg, opcodes, opIndex + 1, iAttr);\n                iAttr.empty = true;\n                break;\n            case id.TLS:\n                iAttr.empty = !opcodes[opIndex].string.length;\n                iAttr.finite = true;\n                iAttr.cyclic = false;\n                break;\n            case id.TBS:\n            case id.TRG:\n                iAttr.empty = false;\n                iAttr.finite = true;\n                iAttr.cyclic = false;\n                break;\n            case id.UDT:\n                iAttr.empty = opi.empty;\n                iAttr.finite = true;\n                iAttr.cyclic = false;\n                break;\n            case id.ABG:\n            case id.AEN:\n                iAttr.empty = true;\n                iAttr.finite = true;\n                iAttr.cyclic = false;\n                break;\n            default:\n                throw new Error(`unknown opcode type: ${opi}`);\n        }\n    }\n    // The main logic for handling rules that:\n    //  - have already be evaluated\n    //  - have not been evaluated and is the first occurrence on this branch\n    //  - second occurrence on this branch for the start rule\n    //  - second occurrence on this branch for non-start rules\n    function ruleAttrsEval(stateArg, ruleIndex, iAttr) {\n        const attri = stateArg.attrsWorking[ruleIndex];\n        if (attri.isComplete) {\n            /* just use the completed values */ stateArg.attrCopy(iAttr, attri);\n        } else if (!attri.isOpen) {\n            /* open the rule and traverse it */ attri.isOpen = true;\n            opEval(stateArg, attri.rule.opcodes, 0, iAttr);\n            /* complete this rule's attributes */ attri.left = iAttr.left;\n            attri.right = iAttr.right;\n            attri.nested = iAttr.nested;\n            attri.empty = iAttr.empty;\n            attri.finite = iAttr.finite;\n            attri.cyclic = iAttr.cyclic;\n            attri.leaf = false;\n            attri.isOpen = false;\n            attri.isComplete = true;\n        } else if (ruleIndex === stateArg.startRule) {\n            /* use recursive leaf values */ if (ruleIndex === stateArg.startRule) {\n                iAttr.left = true;\n                iAttr.right = true;\n                iAttr.cyclic = true;\n                iAttr.leaf = true;\n            }\n        } else {\n            /* non-start rule terminal leaf */ iAttr.finite = true;\n        }\n    }\n    // The main driver for the attribute generation.\n    const ruleAttributes = (stateArg)=>{\n        state = stateArg;\n        let i = 0;\n        let j = 0;\n        const iAttr = state.attrGen();\n        for(i = 0; i < state.ruleCount; i += 1){\n            /* initialize working attributes */ for(j = 0; j < state.ruleCount; j += 1){\n                state.attrInit(state.attrsWorking[j]);\n            }\n            state.startRule = i;\n            ruleAttrsEval(state, i, iAttr);\n            /* save off the working attributes for this rule */ state.attrCopy(state.attrs[i], state.attrsWorking[i]);\n        }\n        state.attributesComplete = true;\n        let attri = null;\n        for(i = 0; i < state.ruleCount; i += 1){\n            attri = state.attrs[i];\n            if (attri.left || !attri.finite || attri.cyclic) {\n                const temp = state.attrGen(attri.rule);\n                state.attrCopy(temp, attri);\n                state.attrsErrors.push(temp);\n                state.attrsErrorCount += 1;\n            }\n        }\n    };\n    const truth = (val)=>val ? \"t\" : \"f\";\n    const tError = (val)=>val ? \"e\" : \"f\";\n    const fError = (val)=>val ? \"t\" : \"e\";\n    const showAttr = (seq, index, attr, dep)=>{\n        let str = `${seq}:${index}:`;\n        str += `${tError(attr.left)} `;\n        str += `${truth(attr.nested)} `;\n        str += `${truth(attr.right)} `;\n        str += `${tError(attr.cyclic)} `;\n        str += `${fError(attr.finite)} `;\n        str += `${truth(attr.empty)}:`;\n        str += `${state.typeToString(dep.recursiveType)}:`;\n        str += dep.recursiveType === id.ATTR_MR ? dep.groupNumber : \"-\";\n        str += `:${attr.rule.name}\\n`;\n        return str;\n    };\n    const showLegend = ()=>{\n        let str = \"LEGEND - t=true, f=false, e=error\\n\";\n        str += \"sequence:rule index:left nested right cyclic finite empty:type:group number:rule name\\n\";\n        return str;\n    };\n    const showAttributeErrors = ()=>{\n        let attri = null;\n        let depi = null;\n        let str = \"\";\n        str += \"RULE ATTRIBUTES WITH ERRORS\\n\";\n        str += showLegend();\n        if (state.attrsErrorCount) {\n            for(let i = 0; i < state.attrsErrorCount; i += 1){\n                attri = state.attrsErrors[i];\n                depi = state.ruleDeps[attri.rule.index];\n                str += showAttr(i, attri.rule.index, attri, depi);\n            }\n        } else {\n            str += \"<none>\\n\";\n        }\n        return str;\n    };\n    const show = (type)=>{\n        let i = 0;\n        let ii = 0;\n        let attri = null;\n        let depi = null;\n        let str = \"\";\n        let { ruleIndexes } = state;\n        // let udtIndexes = state.udtIndexes;\n        if (type === 97) {\n            ruleIndexes = state.ruleAlphaIndexes;\n        // udtIndexes = state.udtAlphaIndexes;\n        } else if (type === 116) {\n            ruleIndexes = state.ruleTypeIndexes;\n        // udtIndexes = state.udtAlphaIndexes;\n        }\n        /* show all attributes */ for(i = 0; i < state.ruleCount; i += 1){\n            ii = ruleIndexes[i];\n            attri = state.attrs[ii];\n            depi = state.ruleDeps[ii];\n            str += showAttr(i, ii, attri, depi);\n        }\n        return str;\n    };\n    // Display the rule attributes.\n    // - order\n    //      - \"index\" or \"i\", index order (default)\n    //      - \"alpha\" or \"a\", alphabetical order\n    //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n    //      - none of above, index order (default)\n    const showAttributes = (order = \"index\")=>{\n        if (!state.attributesComplete) {\n            throw new Error(`${thisFile}:showAttributes: attributes not available`);\n        }\n        let str = \"\";\n        const leader = \"RULE ATTRIBUTES\\n\";\n        if (order.charCodeAt(0) === 97) {\n            str += \"alphabetical by rule name\\n\";\n            str += leader;\n            str += showLegend();\n            str += show(97);\n        } else if (order.charCodeAt(0) === 116) {\n            str += \"ordered by rule type\\n\";\n            str += leader;\n            str += showLegend();\n            str += show(116);\n        } else {\n            str += \"ordered by rule index\\n\";\n            str += leader;\n            str += showLegend();\n            str += show();\n        }\n        return str;\n    };\n    /* Destructuring assignment - see MDN Web Docs */ return {\n        ruleAttributes,\n        showAttributes,\n        showAttributeErrors\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtYXR0cmlidXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O3VGQUd1RixHQUN2RiwrREFBK0Q7O0FBQy9EQSxPQUFPQyxPQUFPLEdBQUcsU0FBVUM7SUFDekIsTUFBTUMsS0FBS0MsbUJBQU9BLENBQUM7SUFDbkIsTUFBTUMsV0FBVztJQUNqQixJQUFJQyxRQUFRO0lBQ1osU0FBU0MsWUFBWUMsSUFBSTtRQUN2QixJQUFJQSxLQUFLQyxJQUFJLElBQUlELEtBQUtFLE1BQU0sSUFBSUYsS0FBS0csS0FBSyxJQUFJSCxLQUFLSSxNQUFNLEVBQUU7WUFDekQsT0FBTztRQUNUO1FBQ0EsT0FBT0osS0FBS0ssS0FBSztJQUNuQjtJQUNBLFNBQVNDLFlBQVlOLElBQUk7UUFDdkIsSUFBSUEsS0FBS0MsSUFBSSxJQUFJRCxLQUFLRSxNQUFNLElBQUlGLEtBQUtHLEtBQUssSUFBSUgsS0FBS0ksTUFBTSxFQUFFO1lBQ3pELE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUNBLFNBQVNHLFlBQVlDLEtBQUssRUFBRUMsS0FBSztRQUMvQixJQUFJQyxJQUFJO1FBQ1IsSUFBSUMsSUFBSTtRQUNSLElBQUlDLElBQUk7UUFDUiw0Q0FBNEMsR0FDNUMsSUFBS0YsSUFBSSxHQUFHQSxJQUFJRCxPQUFPQyxLQUFLLEVBQUc7WUFDN0IsSUFBSUYsS0FBSyxDQUFDRSxFQUFFLENBQUNSLE1BQU0sRUFBRTtnQkFDbkIsT0FBTztZQUNUO1FBQ0Y7UUFDQTsyREFDdUQsR0FDdkQsSUFBS1EsSUFBSSxHQUFHQSxJQUFJRCxPQUFPQyxLQUFLLEVBQUc7WUFDN0IsSUFBSUYsS0FBSyxDQUFDRSxFQUFFLENBQUNQLEtBQUssSUFBSSxDQUFDSyxLQUFLLENBQUNFLEVBQUUsQ0FBQ0csSUFBSSxFQUFFO2dCQUNwQyxJQUFLRixJQUFJRCxJQUFJLEdBQUdD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QzlDLE1BQU1lLGlCQUFpQixDQUFDQyxRQUFRLE9BQU87UUFDckMsSUFBSSxDQUFDbkcsTUFBTXdFLGtCQUFrQixFQUFFO1lBQzdCLE1BQU0sSUFBSVYsTUFBTSxDQUFDLEVBQUUvRCxTQUFTLHlDQUF5QyxDQUFDO1FBQ3hFO1FBQ0EsSUFBSW9GLE1BQU07UUFDVixNQUFNaUIsU0FBUztRQUNmLElBQUlELE1BQU1FLFVBQVUsQ0FBQyxPQUFPLElBQUk7WUFDOUJsQixPQUFPO1lBQ1BBLE9BQU9pQjtZQUNQakIsT0FBT007WUFDUE4sT0FBT1UsS0FBSztRQUNkLE9BQU8sSUFBSU0sTUFBTUUsVUFBVSxDQUFDLE9BQU8sS0FBSztZQUN0Q2xCLE9BQU87WUFDUEEsT0FBT2lCO1lBQ1BqQixPQUFPTTtZQUNQTixPQUFPVSxLQUFLO1FBQ2QsT0FBTztZQUNMVixPQUFPO1lBQ1BBLE9BQU9pQjtZQUNQakIsT0FBT007WUFDUE4sT0FBT1U7UUFDVDtRQUNBLE9BQU9WO0lBQ1Q7SUFFQSwrQ0FBK0MsR0FDL0MsT0FBTztRQUFFWjtRQUFnQjJCO1FBQWdCUjtJQUFvQjtBQUMvRCIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtYXR0cmlidXRlcy5qcz85MDkyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGRvZXMgdGhlIGhlYXZ5IGxpZnRpbmcgZm9yIGF0dHJpYnV0ZSBnZW5lcmF0aW9uLlxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gZXhwb3J0UnVsZUF0dHJpYnV0ZXMoKSB7XG4gIGNvbnN0IGlkID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9pZGVudGlmaWVycycpO1xuICBjb25zdCB0aGlzRmlsZSA9ICdydWxlLWF0dHJpYnV0ZXMuanMnO1xuICBsZXQgc3RhdGUgPSBudWxsO1xuICBmdW5jdGlvbiBpc0VtcHR5T25seShhdHRyKSB7XG4gICAgaWYgKGF0dHIubGVmdCB8fCBhdHRyLm5lc3RlZCB8fCBhdHRyLnJpZ2h0IHx8IGF0dHIuY3ljbGljKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhdHRyLmVtcHR5O1xuICB9XG4gIGZ1bmN0aW9uIGlzUmVjdXJzaXZlKGF0dHIpIHtcbiAgICBpZiAoYXR0ci5sZWZ0IHx8IGF0dHIubmVzdGVkIHx8IGF0dHIucmlnaHQgfHwgYXR0ci5jeWNsaWMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gaXNDYXROZXN0ZWQoYXR0cnMsIGNvdW50KSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgayA9IDA7XG4gICAgLyogMS4gaWYgYW55IGNoaWxkIGlzIG5lc3RlZCwgQ0FUIGlzIG5lc3RlZCAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoYXR0cnNbaV0ubmVzdGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiAyLikgdGhlIGxlZnQtbW9zdCByaWdodCByZWN1cnNpdmUgY2hpbGRcbiAgICAgICAgICAgICAgIGlzIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBub24tZW1wdHkgY2hpbGQgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKGF0dHJzW2ldLnJpZ2h0ICYmICFhdHRyc1tpXS5sZWFmKSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgY291bnQ7IGogKz0gMSkge1xuICAgICAgICAgIGlmICghaXNFbXB0eU9ubHkoYXR0cnNbal0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogMy4pIHRoZSByaWdodC1tb3N0IGxlZnQgcmVjdXJzaXZlIGNoaWxkXG4gICAgICAgICAgICAgICBpcyBwcmVjZWRlZCBieSBhdCBsZWFzdCBvbmUgbm9uLWVtcHR5IGNoaWxkICovXG4gICAgZm9yIChpID0gY291bnQgLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKGF0dHJzW2ldLmxlZnQgJiYgIWF0dHJzW2ldLmxlYWYpIHtcbiAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgaWYgKCFpc0VtcHR5T25seShhdHRyc1tqXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiA0LiB0aGVyZSBpcyBhdCBsZWFzZSBvbmUgcmVjdXJzaXZlIGNoaWxkIGJldHdlZW5cbiAgICAgICAgICAgICAgdGhlIGxlZnQtbW9zdCBhbmQgcmlnaHQtbW9zdCBub24tcmVjdXJzaXZlLCBub24tZW1wdHkgY2hpbGRyZW4gKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKCFhdHRyc1tpXS5lbXB0eSAmJiAhaXNSZWN1cnNpdmUoYXR0cnNbaV0pKSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgY291bnQ7IGogKz0gMSkge1xuICAgICAgICAgIGlmIChpc1JlY3Vyc2l2ZShhdHRyc1tqXSkpIHtcbiAgICAgICAgICAgIGZvciAoayA9IGogKyAxOyBrIDwgY291bnQ7IGsgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoIWF0dHJzW2tdLmVtcHR5ICYmICFpc1JlY3Vyc2l2ZShhdHRyc1trXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIG5vbmUgb2YgdGhlIGFib3ZlICovXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2F0Q3ljbGljKGF0dHJzLCBjb3VudCkge1xuICAgIC8qIGlmIGFsbCBjaGlsZHJlbiBhcmUgY3ljbGljLCBDQVQgaXMgY3ljbGljICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoIWF0dHJzW2ldLmN5Y2xpYykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2F0TGVmdChhdHRycywgY291bnQpIHtcbiAgICAvKiBpZiB0aGUgbGVmdC1tb3N0IG5vbi1lbXB0eSBpcyBsZWZ0LCBDQVQgaXMgbGVmdCAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKGF0dHJzW2ldLmxlZnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJzW2ldLmVtcHR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8qIGtlZXAgbG9va2luZyAqL1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7IC8qIGFsbCBsZWZ0LW1vc3QgYXJlIGVtcHR5ICovXG4gIH1cbiAgZnVuY3Rpb24gaXNDYXRSaWdodChhdHRycywgY291bnQpIHtcbiAgICAvKiBpZiB0aGUgcmlnaHQtbW9zdCBub24tZW1wdHkgaXMgcmlnaHQsIENBVCBpcyByaWdodCAqL1xuICAgIGZvciAobGV0IGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAoYXR0cnNbaV0ucmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJzW2ldLmVtcHR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8qIGtlZXAgbG9va2luZyAqL1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gaXNDYXRFbXB0eShhdHRycywgY291bnQpIHtcbiAgICAvKiBpZiBhbGwgY2hpbGRyZW4gYXJlIGVtcHR5LCBDQVQgaXMgZW1wdHkgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmICghYXR0cnNbaV0uZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBpc0NhdEZpbml0ZShhdHRycywgY291bnQpIHtcbiAgICAvKiBpZiBhbGwgY2hpbGRyZW4gYXJlIGZpbml0ZSwgQ0FUIGlzIGZpbml0ZSAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKCFhdHRyc1tpXS5maW5pdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjYXQoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IG9wQ2F0ID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBjb25zdCBjb3VudCA9IG9wQ2F0LmNoaWxkcmVuLmxlbmd0aDtcblxuICAgIC8qIGdlbmVyYXRlIGFuIGVtcHR5IGFycmF5IG9mIGNoaWxkIGF0dHJpYnV0ZXMgKi9cbiAgICBjb25zdCBjaGlsZEF0dHJzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGNoaWxkQXR0cnMucHVzaChzdGF0ZUFyZy5hdHRyR2VuKCkpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICBvcEV2YWwoc3RhdGVBcmcsIG9wY29kZXMsIG9wQ2F0LmNoaWxkcmVuW2ldLCBjaGlsZEF0dHJzW2ldKTtcbiAgICB9XG4gICAgaUF0dHIubGVmdCA9IGlzQ2F0TGVmdChjaGlsZEF0dHJzLCBjb3VudCk7XG4gICAgaUF0dHIucmlnaHQgPSBpc0NhdFJpZ2h0KGNoaWxkQXR0cnMsIGNvdW50KTtcbiAgICBpQXR0ci5uZXN0ZWQgPSBpc0NhdE5lc3RlZChjaGlsZEF0dHJzLCBjb3VudCk7XG4gICAgaUF0dHIuZW1wdHkgPSBpc0NhdEVtcHR5KGNoaWxkQXR0cnMsIGNvdW50KTtcbiAgICBpQXR0ci5maW5pdGUgPSBpc0NhdEZpbml0ZShjaGlsZEF0dHJzLCBjb3VudCk7XG4gICAgaUF0dHIuY3ljbGljID0gaXNDYXRDeWNsaWMoY2hpbGRBdHRycywgY291bnQpO1xuICB9XG4gIGZ1bmN0aW9uIGFsdChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3Qgb3BBbHQgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IGNvdW50ID0gb3BBbHQuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgLyogZ2VuZXJhdGUgYW4gZW1wdHkgYXJyYXkgb2YgY2hpbGQgYXR0cmlidXRlcyAqL1xuICAgIGNvbnN0IGNoaWxkQXR0cnMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgY2hpbGRBdHRycy5wdXNoKHN0YXRlQXJnLmF0dHJHZW4oKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIG9wRXZhbChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BBbHQuY2hpbGRyZW5baV0sIGNoaWxkQXR0cnNbaV0pO1xuICAgIH1cblxuICAgIC8qIGlmIGFueSBjaGlsZCBhdHRyaWJ1dGUgaXMgdHJ1ZSwgQUxUIGlzIHRydWUgKi9cbiAgICBpQXR0ci5sZWZ0ID0gZmFsc2U7XG4gICAgaUF0dHIucmlnaHQgPSBmYWxzZTtcbiAgICBpQXR0ci5uZXN0ZWQgPSBmYWxzZTtcbiAgICBpQXR0ci5lbXB0eSA9IGZhbHNlO1xuICAgIGlBdHRyLmZpbml0ZSA9IGZhbHNlO1xuICAgIGlBdHRyLmN5Y2xpYyA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoY2hpbGRBdHRyc1tpXS5sZWZ0KSB7XG4gICAgICAgIGlBdHRyLmxlZnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkQXR0cnNbaV0ubmVzdGVkKSB7XG4gICAgICAgIGlBdHRyLm5lc3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRBdHRyc1tpXS5yaWdodCkge1xuICAgICAgICBpQXR0ci5yaWdodCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRBdHRyc1tpXS5lbXB0eSkge1xuICAgICAgICBpQXR0ci5lbXB0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRBdHRyc1tpXS5maW5pdGUpIHtcbiAgICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEF0dHJzW2ldLmN5Y2xpYykge1xuICAgICAgICBpQXR0ci5jeWNsaWMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBia3Ioc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKSB7XG4gICAgY29uc3Qgb3BCa3IgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGlmIChvcEJrci5pbmRleCA+PSBzdGF0ZUFyZy5ydWxlQ291bnQpIHtcbiAgICAgIC8qIHVzZSBVRFQgdmFsdWVzICovXG4gICAgICBpQXR0ci5lbXB0eSA9IHN0YXRlQXJnLnVkdHNbb3BCa3IuaW5kZXggLSBzdGF0ZUFyZy5ydWxlQ291bnRdLmVtcHR5O1xuICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogdXNlIHRoZSBlbXB0eSBhbmQgZmluaXRlIHZhbHVlcyBmcm9tIHRoZSBiYWNrIHJlZmVyZW5jZWQgcnVsZSAqL1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICBydWxlQXR0cnNFdmFsKHN0YXRlQXJnLCBvcEJrci5pbmRleCwgaUF0dHIpO1xuXG4gICAgICAvKiBob3dldmVyLCB0aGlzIGlzIGEgdGVybWluYWwgbm9kZSBsaWtlIFRMUyAqL1xuICAgICAgaUF0dHIubGVmdCA9IGZhbHNlO1xuICAgICAgaUF0dHIubmVzdGVkID0gZmFsc2U7XG4gICAgICBpQXR0ci5yaWdodCA9IGZhbHNlO1xuICAgICAgaUF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3BFdmFsKHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4LCBpQXR0cikge1xuICAgIHN0YXRlQXJnLmF0dHJJbml0KGlBdHRyKTtcbiAgICBjb25zdCBvcGkgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN3aXRjaCAob3BpLnR5cGUpIHtcbiAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICBhbHQoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgY2F0KHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4LCBpQXR0cik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5SRVA6XG4gICAgICAgIG9wRXZhbChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCArIDEsIGlBdHRyKTtcbiAgICAgICAgaWYgKG9waS5taW4gPT09IDApIHtcbiAgICAgICAgICBpQXR0ci5lbXB0eSA9IHRydWU7XG4gICAgICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuUk5NOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcnVsZUF0dHJzRXZhbChzdGF0ZUFyZywgb3Bjb2Rlc1tvcEluZGV4XS5pbmRleCwgaUF0dHIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICBia3Ioc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkFORDpcbiAgICAgIGNhc2UgaWQuTk9UOlxuICAgICAgY2FzZSBpZC5CS0E6XG4gICAgICBjYXNlIGlkLkJLTjpcbiAgICAgICAgb3BFdmFsKHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4ICsgMSwgaUF0dHIpO1xuICAgICAgICBpQXR0ci5lbXB0eSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgIGlBdHRyLmVtcHR5ID0gIW9wY29kZXNbb3BJbmRleF0uc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5UQlM6XG4gICAgICBjYXNlIGlkLlRSRzpcbiAgICAgICAgaUF0dHIuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5VRFQ6XG4gICAgICAgIGlBdHRyLmVtcHR5ID0gb3BpLmVtcHR5O1xuICAgICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgICAgICBpQXR0ci5jeWNsaWMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkFCRzpcbiAgICAgIGNhc2UgaWQuQUVOOlxuICAgICAgICBpQXR0ci5lbXB0eSA9IHRydWU7XG4gICAgICAgIGlBdHRyLmZpbml0ZSA9IHRydWU7XG4gICAgICAgIGlBdHRyLmN5Y2xpYyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBvcGNvZGUgdHlwZTogJHtvcGl9YCk7XG4gICAgfVxuICB9XG4gIC8vIFRoZSBtYWluIGxvZ2ljIGZvciBoYW5kbGluZyBydWxlcyB0aGF0OlxuICAvLyAgLSBoYXZlIGFscmVhZHkgYmUgZXZhbHVhdGVkXG4gIC8vICAtIGhhdmUgbm90IGJlZW4gZXZhbHVhdGVkIGFuZCBpcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvbiB0aGlzIGJyYW5jaFxuICAvLyAgLSBzZWNvbmQgb2NjdXJyZW5jZSBvbiB0aGlzIGJyYW5jaCBmb3IgdGhlIHN0YXJ0IHJ1bGVcbiAgLy8gIC0gc2Vjb25kIG9jY3VycmVuY2Ugb24gdGhpcyBicmFuY2ggZm9yIG5vbi1zdGFydCBydWxlc1xuICBmdW5jdGlvbiBydWxlQXR0cnNFdmFsKHN0YXRlQXJnLCBydWxlSW5kZXgsIGlBdHRyKSB7XG4gICAgY29uc3QgYXR0cmkgPSBzdGF0ZUFyZy5hdHRyc1dvcmtpbmdbcnVsZUluZGV4XTtcbiAgICBpZiAoYXR0cmkuaXNDb21wbGV0ZSkge1xuICAgICAgLyoganVzdCB1c2UgdGhlIGNvbXBsZXRlZCB2YWx1ZXMgKi9cbiAgICAgIHN0YXRlQXJnLmF0dHJDb3B5KGlBdHRyLCBhdHRyaSk7XG4gICAgfSBlbHNlIGlmICghYXR0cmkuaXNPcGVuKSB7XG4gICAgICAvKiBvcGVuIHRoZSBydWxlIGFuZCB0cmF2ZXJzZSBpdCAqL1xuICAgICAgYXR0cmkuaXNPcGVuID0gdHJ1ZTtcbiAgICAgIG9wRXZhbChzdGF0ZUFyZywgYXR0cmkucnVsZS5vcGNvZGVzLCAwLCBpQXR0cik7XG4gICAgICAvKiBjb21wbGV0ZSB0aGlzIHJ1bGUncyBhdHRyaWJ1dGVzICovXG4gICAgICBhdHRyaS5sZWZ0ID0gaUF0dHIubGVmdDtcbiAgICAgIGF0dHJpLnJpZ2h0ID0gaUF0dHIucmlnaHQ7XG4gICAgICBhdHRyaS5uZXN0ZWQgPSBpQXR0ci5uZXN0ZWQ7XG4gICAgICBhdHRyaS5lbXB0eSA9IGlBdHRyLmVtcHR5O1xuICAgICAgYXR0cmkuZmluaXRlID0gaUF0dHIuZmluaXRlO1xuICAgICAgYXR0cmkuY3ljbGljID0gaUF0dHIuY3ljbGljO1xuICAgICAgYXR0cmkubGVhZiA9IGZhbHNlO1xuICAgICAgYXR0cmkuaXNPcGVuID0gZmFsc2U7XG4gICAgICBhdHRyaS5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJ1bGVJbmRleCA9PT0gc3RhdGVBcmcuc3RhcnRSdWxlKSB7XG4gICAgICAvKiB1c2UgcmVjdXJzaXZlIGxlYWYgdmFsdWVzICovXG4gICAgICBpZiAocnVsZUluZGV4ID09PSBzdGF0ZUFyZy5zdGFydFJ1bGUpIHtcbiAgICAgICAgaUF0dHIubGVmdCA9IHRydWU7XG4gICAgICAgIGlBdHRyLnJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIuY3ljbGljID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIubGVhZiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIG5vbi1zdGFydCBydWxlIHRlcm1pbmFsIGxlYWYgKi9cbiAgICAgIGlBdHRyLmZpbml0ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIFRoZSBtYWluIGRyaXZlciBmb3IgdGhlIGF0dHJpYnV0ZSBnZW5lcmF0aW9uLlxuICBjb25zdCBydWxlQXR0cmlidXRlcyA9IChzdGF0ZUFyZykgPT4ge1xuICAgIHN0YXRlID0gc3RhdGVBcmc7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBjb25zdCBpQXR0ciA9IHN0YXRlLmF0dHJHZW4oKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIC8qIGluaXRpYWxpemUgd29ya2luZyBhdHRyaWJ1dGVzICovXG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3RhdGUucnVsZUNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgc3RhdGUuYXR0ckluaXQoc3RhdGUuYXR0cnNXb3JraW5nW2pdKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnN0YXJ0UnVsZSA9IGk7XG4gICAgICBydWxlQXR0cnNFdmFsKHN0YXRlLCBpLCBpQXR0cik7XG5cbiAgICAgIC8qIHNhdmUgb2ZmIHRoZSB3b3JraW5nIGF0dHJpYnV0ZXMgZm9yIHRoaXMgcnVsZSAqL1xuICAgICAgc3RhdGUuYXR0ckNvcHkoc3RhdGUuYXR0cnNbaV0sIHN0YXRlLmF0dHJzV29ya2luZ1tpXSk7XG4gICAgfVxuICAgIHN0YXRlLmF0dHJpYnV0ZXNDb21wbGV0ZSA9IHRydWU7XG4gICAgbGV0IGF0dHJpID0gbnVsbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIGF0dHJpID0gc3RhdGUuYXR0cnNbaV07XG4gICAgICBpZiAoYXR0cmkubGVmdCB8fCAhYXR0cmkuZmluaXRlIHx8IGF0dHJpLmN5Y2xpYykge1xuICAgICAgICBjb25zdCB0ZW1wID0gc3RhdGUuYXR0ckdlbihhdHRyaS5ydWxlKTtcbiAgICAgICAgc3RhdGUuYXR0ckNvcHkodGVtcCwgYXR0cmkpO1xuICAgICAgICBzdGF0ZS5hdHRyc0Vycm9ycy5wdXNoKHRlbXApO1xuICAgICAgICBzdGF0ZS5hdHRyc0Vycm9yQ291bnQgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHRydXRoID0gKHZhbCkgPT4gKHZhbCA/ICd0JyA6ICdmJyk7XG4gIGNvbnN0IHRFcnJvciA9ICh2YWwpID0+ICh2YWwgPyAnZScgOiAnZicpO1xuICBjb25zdCBmRXJyb3IgPSAodmFsKSA9PiAodmFsID8gJ3QnIDogJ2UnKTtcbiAgY29uc3Qgc2hvd0F0dHIgPSAoc2VxLCBpbmRleCwgYXR0ciwgZGVwKSA9PiB7XG4gICAgbGV0IHN0ciA9IGAke3NlcX06JHtpbmRleH06YDtcbiAgICBzdHIgKz0gYCR7dEVycm9yKGF0dHIubGVmdCl9IGA7XG4gICAgc3RyICs9IGAke3RydXRoKGF0dHIubmVzdGVkKX0gYDtcbiAgICBzdHIgKz0gYCR7dHJ1dGgoYXR0ci5yaWdodCl9IGA7XG4gICAgc3RyICs9IGAke3RFcnJvcihhdHRyLmN5Y2xpYyl9IGA7XG4gICAgc3RyICs9IGAke2ZFcnJvcihhdHRyLmZpbml0ZSl9IGA7XG4gICAgc3RyICs9IGAke3RydXRoKGF0dHIuZW1wdHkpfTpgO1xuICAgIHN0ciArPSBgJHtzdGF0ZS50eXBlVG9TdHJpbmcoZGVwLnJlY3Vyc2l2ZVR5cGUpfTpgO1xuICAgIHN0ciArPSBkZXAucmVjdXJzaXZlVHlwZSA9PT0gaWQuQVRUUl9NUiA/IGRlcC5ncm91cE51bWJlciA6ICctJztcbiAgICBzdHIgKz0gYDoke2F0dHIucnVsZS5uYW1lfVxcbmA7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBjb25zdCBzaG93TGVnZW5kID0gKCkgPT4ge1xuICAgIGxldCBzdHIgPSAnTEVHRU5EIC0gdD10cnVlLCBmPWZhbHNlLCBlPWVycm9yXFxuJztcbiAgICBzdHIgKz0gJ3NlcXVlbmNlOnJ1bGUgaW5kZXg6bGVmdCBuZXN0ZWQgcmlnaHQgY3ljbGljIGZpbml0ZSBlbXB0eTp0eXBlOmdyb3VwIG51bWJlcjpydWxlIG5hbWVcXG4nO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIGNvbnN0IHNob3dBdHRyaWJ1dGVFcnJvcnMgPSAoKSA9PiB7XG4gICAgbGV0IGF0dHJpID0gbnVsbDtcbiAgICBsZXQgZGVwaSA9IG51bGw7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIHN0ciArPSAnUlVMRSBBVFRSSUJVVEVTIFdJVEggRVJST1JTXFxuJztcbiAgICBzdHIgKz0gc2hvd0xlZ2VuZCgpO1xuICAgIGlmIChzdGF0ZS5hdHRyc0Vycm9yQ291bnQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuYXR0cnNFcnJvckNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgYXR0cmkgPSBzdGF0ZS5hdHRyc0Vycm9yc1tpXTtcbiAgICAgICAgZGVwaSA9IHN0YXRlLnJ1bGVEZXBzW2F0dHJpLnJ1bGUuaW5kZXhdO1xuICAgICAgICBzdHIgKz0gc2hvd0F0dHIoaSwgYXR0cmkucnVsZS5pbmRleCwgYXR0cmksIGRlcGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJzxub25lPlxcbic7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgY29uc3Qgc2hvdyA9ICh0eXBlKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBpaSA9IDA7XG4gICAgbGV0IGF0dHJpID0gbnVsbDtcbiAgICBsZXQgZGVwaSA9IG51bGw7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCB7IHJ1bGVJbmRleGVzIH0gPSBzdGF0ZTtcbiAgICAvLyBsZXQgdWR0SW5kZXhlcyA9IHN0YXRlLnVkdEluZGV4ZXM7XG4gICAgaWYgKHR5cGUgPT09IDk3KSB7XG4gICAgICBydWxlSW5kZXhlcyA9IHN0YXRlLnJ1bGVBbHBoYUluZGV4ZXM7XG4gICAgICAvLyB1ZHRJbmRleGVzID0gc3RhdGUudWR0QWxwaGFJbmRleGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMTE2KSB7XG4gICAgICBydWxlSW5kZXhlcyA9IHN0YXRlLnJ1bGVUeXBlSW5kZXhlcztcbiAgICAgIC8vIHVkdEluZGV4ZXMgPSBzdGF0ZS51ZHRBbHBoYUluZGV4ZXM7XG4gICAgfVxuICAgIC8qIHNob3cgYWxsIGF0dHJpYnV0ZXMgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlpID0gcnVsZUluZGV4ZXNbaV07XG4gICAgICBhdHRyaSA9IHN0YXRlLmF0dHJzW2lpXTtcbiAgICAgIGRlcGkgPSBzdGF0ZS5ydWxlRGVwc1tpaV07XG4gICAgICBzdHIgKz0gc2hvd0F0dHIoaSwgaWksIGF0dHJpLCBkZXBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvLyBEaXNwbGF5IHRoZSBydWxlIGF0dHJpYnV0ZXMuXG4gIC8vIC0gb3JkZXJcbiAgLy8gICAgICAtIFwiaW5kZXhcIiBvciBcImlcIiwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIC8vICAgICAgLSBcImFscGhhXCIgb3IgXCJhXCIsIGFscGhhYmV0aWNhbCBvcmRlclxuICAvLyAgICAgIC0gXCJ0eXBlXCIgb3IgXCJ0XCIsIG9yZGVyZWQgYnkgdHlwZSAoYWxwaGFiZXRpY2FsIHdpdGhpbiBlYWNoIHR5cGUvZ3JvdXApXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgY29uc3Qgc2hvd0F0dHJpYnV0ZXMgPSAob3JkZXIgPSAnaW5kZXgnKSA9PiB7XG4gICAgaWYgKCFzdGF0ZS5hdHRyaWJ1dGVzQ29tcGxldGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZX06c2hvd0F0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMgbm90IGF2YWlsYWJsZWApO1xuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgY29uc3QgbGVhZGVyID0gJ1JVTEUgQVRUUklCVVRFU1xcbic7XG4gICAgaWYgKG9yZGVyLmNoYXJDb2RlQXQoMCkgPT09IDk3KSB7XG4gICAgICBzdHIgKz0gJ2FscGhhYmV0aWNhbCBieSBydWxlIG5hbWVcXG4nO1xuICAgICAgc3RyICs9IGxlYWRlcjtcbiAgICAgIHN0ciArPSBzaG93TGVnZW5kKCk7XG4gICAgICBzdHIgKz0gc2hvdyg5Nyk7XG4gICAgfSBlbHNlIGlmIChvcmRlci5jaGFyQ29kZUF0KDApID09PSAxMTYpIHtcbiAgICAgIHN0ciArPSAnb3JkZXJlZCBieSBydWxlIHR5cGVcXG4nO1xuICAgICAgc3RyICs9IGxlYWRlcjtcbiAgICAgIHN0ciArPSBzaG93TGVnZW5kKCk7XG4gICAgICBzdHIgKz0gc2hvdygxMTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJ29yZGVyZWQgYnkgcnVsZSBpbmRleFxcbic7XG4gICAgICBzdHIgKz0gbGVhZGVyO1xuICAgICAgc3RyICs9IHNob3dMZWdlbmQoKTtcbiAgICAgIHN0ciArPSBzaG93KCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyogRGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IC0gc2VlIE1ETiBXZWIgRG9jcyAqL1xuICByZXR1cm4geyBydWxlQXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVFcnJvcnMgfTtcbn0pKCk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImV4cG9ydFJ1bGVBdHRyaWJ1dGVzIiwiaWQiLCJyZXF1aXJlIiwidGhpc0ZpbGUiLCJzdGF0ZSIsImlzRW1wdHlPbmx5IiwiYXR0ciIsImxlZnQiLCJuZXN0ZWQiLCJyaWdodCIsImN5Y2xpYyIsImVtcHR5IiwiaXNSZWN1cnNpdmUiLCJpc0NhdE5lc3RlZCIsImF0dHJzIiwiY291bnQiLCJpIiwiaiIsImsiLCJsZWFmIiwiaXNDYXRDeWNsaWMiLCJpc0NhdExlZnQiLCJpc0NhdFJpZ2h0IiwiaXNDYXRFbXB0eSIsImlzQ2F0RmluaXRlIiwiZmluaXRlIiwiY2F0Iiwic3RhdGVBcmciLCJvcGNvZGVzIiwib3BJbmRleCIsImlBdHRyIiwib3BDYXQiLCJjaGlsZHJlbiIsImxlbmd0aCIsImNoaWxkQXR0cnMiLCJwdXNoIiwiYXR0ckdlbiIsIm9wRXZhbCIsImFsdCIsIm9wQWx0IiwiYmtyIiwib3BCa3IiLCJpbmRleCIsInJ1bGVDb3VudCIsInVkdHMiLCJydWxlQXR0cnNFdmFsIiwiYXR0ckluaXQiLCJvcGkiLCJ0eXBlIiwiQUxUIiwiQ0FUIiwiUkVQIiwibWluIiwiUk5NIiwiQktSIiwiQU5EIiwiTk9UIiwiQktBIiwiQktOIiwiVExTIiwic3RyaW5nIiwiVEJTIiwiVFJHIiwiVURUIiwiQUJHIiwiQUVOIiwiRXJyb3IiLCJydWxlSW5kZXgiLCJhdHRyaSIsImF0dHJzV29ya2luZyIsImlzQ29tcGxldGUiLCJhdHRyQ29weSIsImlzT3BlbiIsInJ1bGUiLCJzdGFydFJ1bGUiLCJydWxlQXR0cmlidXRlcyIsImF0dHJpYnV0ZXNDb21wbGV0ZSIsInRlbXAiLCJhdHRyc0Vycm9ycyIsImF0dHJzRXJyb3JDb3VudCIsInRydXRoIiwidmFsIiwidEVycm9yIiwiZkVycm9yIiwic2hvd0F0dHIiLCJzZXEiLCJkZXAiLCJzdHIiLCJ0eXBlVG9TdHJpbmciLCJyZWN1cnNpdmVUeXBlIiwiQVRUUl9NUiIsImdyb3VwTnVtYmVyIiwibmFtZSIsInNob3dMZWdlbmQiLCJzaG93QXR0cmlidXRlRXJyb3JzIiwiZGVwaSIsInJ1bGVEZXBzIiwic2hvdyIsImlpIiwicnVsZUluZGV4ZXMiLCJydWxlQWxwaGFJbmRleGVzIiwicnVsZVR5cGVJbmRleGVzIiwic2hvd0F0dHJpYnV0ZXMiLCJvcmRlciIsImxlYWRlciIsImNoYXJDb2RlQXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-attributes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-dependencies.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-dependencies.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // Determine rule dependencies and types.\n// For each rule, determine which other rules it refers to\n// and which of the other rules refer back to it.\n//\n// Rule types are:\n//  - non-recursive - the rule never refers to itself, even indirectly\n//  - recursive - the rule refers to itself, possibly indirectly\n//  - mutually-recursive - belongs to a group of two or more rules, each of which refers to every other rule in the group, including itself.\n\nmodule.exports = (()=>{\n    const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n    let state = null; /* keep a global reference to the state for the show functions */ \n    /* scan the opcodes of the indexed rule and discover which rules it references and which rule refer back to it */ const scan = (ruleCount, ruleDeps, index, isScanned)=>{\n        let i = 0;\n        let j = 0;\n        const rdi = ruleDeps[index];\n        isScanned[index] = true;\n        const op = rdi.rule.opcodes;\n        for(i = 0; i < op.length; i += 1){\n            const opi = op[i];\n            if (opi.type === id.RNM) {\n                rdi.refersTo[opi.index] = true;\n                if (!isScanned[opi.index]) {\n                    scan(ruleCount, ruleDeps, opi.index, isScanned);\n                }\n                for(j = 0; j < ruleCount; j += 1){\n                    if (ruleDeps[opi.index].refersTo[j]) {\n                        rdi.refersTo[j] = true;\n                    }\n                }\n            } else if (opi.type === id.UDT) {\n                rdi.refersToUdt[opi.index] = true;\n            } else if (opi.type === id.BKR) {\n                if (opi.index < ruleCount) {\n                    rdi.refersTo[opi.index] = true;\n                    if (!isScanned[opi.index]) {\n                        scan(ruleCount, ruleDeps, opi.index, isScanned);\n                    }\n                } else {\n                    rdi.refersToUdt[ruleCount - opi.index] = true;\n                }\n            }\n        }\n    };\n    // Determine the rule dependencies, types and mutually recursive groups.\n    const ruleDependencies = (stateArg)=>{\n        state = stateArg; /* make it global */ \n        let i = 0;\n        let j = 0;\n        let groupCount = 0;\n        let rdi = null;\n        let rdj = null;\n        let newGroup = false;\n        state.dependenciesComplete = false;\n        /* make a working array of rule scanned markers */ const isScanned = state.falseArray(state.ruleCount);\n        /* discover the rule dependencies */ for(i = 0; i < state.ruleCount; i += 1){\n            state.falsifyArray(isScanned);\n            scan(state.ruleCount, state.ruleDeps, i, isScanned);\n        }\n        /* discover all rules referencing each rule */ for(i = 0; i < state.ruleCount; i += 1){\n            for(j = 0; j < state.ruleCount; j += 1){\n                if (i !== j) {\n                    if (state.ruleDeps[j].refersTo[i]) {\n                        state.ruleDeps[i].referencedBy[j] = true;\n                    }\n                }\n            }\n        }\n        /* find the non-recursive and recursive types */ for(i = 0; i < state.ruleCount; i += 1){\n            state.ruleDeps[i].recursiveType = id.ATTR_N;\n            if (state.ruleDeps[i].refersTo[i]) {\n                state.ruleDeps[i].recursiveType = id.ATTR_R;\n            }\n        }\n        /* find the mutually-recursive groups, if any */ groupCount = -1;\n        for(i = 0; i < state.ruleCount; i += 1){\n            rdi = state.ruleDeps[i];\n            if (rdi.recursiveType === id.ATTR_R) {\n                newGroup = true;\n                for(j = 0; j < state.ruleCount; j += 1){\n                    if (i !== j) {\n                        rdj = state.ruleDeps[j];\n                        if (rdj.recursiveType === id.ATTR_R) {\n                            if (rdi.refersTo[j] && rdj.refersTo[i]) {\n                                if (newGroup) {\n                                    groupCount += 1;\n                                    rdi.recursiveType = id.ATTR_MR;\n                                    rdi.groupNumber = groupCount;\n                                    newGroup = false;\n                                }\n                                rdj.recursiveType = id.ATTR_MR;\n                                rdj.groupNumber = groupCount;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        state.isMutuallyRecursive = groupCount > -1;\n        /* sort the rules/UDTS */ state.ruleAlphaIndexes.sort(state.compRulesAlpha);\n        state.ruleTypeIndexes.sort(state.compRulesAlpha);\n        state.ruleTypeIndexes.sort(state.compRulesType);\n        if (state.isMutuallyRecursive) {\n            state.ruleTypeIndexes.sort(state.compRulesGroup);\n        }\n        if (state.udtCount) {\n            state.udtAlphaIndexes.sort(state.compUdtsAlpha);\n        }\n        state.dependenciesComplete = true;\n    };\n    const show = (type = null)=>{\n        let i = 0;\n        let j = 0;\n        let count = 0;\n        let startSeg = 0;\n        const maxRule = state.ruleCount - 1;\n        const maxUdt = state.udtCount - 1;\n        const lineLength = 100;\n        let str = \"\";\n        let pre = \"\";\n        const toArrow = \"=> \";\n        const byArrow = \"<= \";\n        let first = false;\n        let rdi = null;\n        let { ruleIndexes } = state;\n        let { udtIndexes } = state;\n        if (type === 97) {\n            ruleIndexes = state.ruleAlphaIndexes;\n            udtIndexes = state.udtAlphaIndexes;\n        } else if (type === 116) {\n            ruleIndexes = state.ruleTypeIndexes;\n            udtIndexes = state.udtAlphaIndexes;\n        }\n        for(i = 0; i < state.ruleCount; i += 1){\n            rdi = state.ruleDeps[ruleIndexes[i]];\n            pre = `${ruleIndexes[i]}:${state.typeToString(rdi.recursiveType)}:`;\n            if (state.isMutuallyRecursive) {\n                pre += rdi.groupNumber > -1 ? rdi.groupNumber : \"-\";\n                pre += \":\";\n            }\n            pre += \" \";\n            str += `${pre + state.rules[ruleIndexes[i]].name}\\n`;\n            first = true;\n            count = 0;\n            startSeg = str.length;\n            str += pre;\n            for(j = 0; j < state.ruleCount; j += 1){\n                if (rdi.refersTo[ruleIndexes[j]]) {\n                    if (first) {\n                        str += toArrow;\n                        first = false;\n                        str += state.ruleDeps[ruleIndexes[j]].rule.name;\n                    } else {\n                        str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n                    }\n                    count += 1;\n                }\n                if (str.length - startSeg > lineLength && j !== maxRule) {\n                    str += `\\n${pre}${toArrow}`;\n                    startSeg = str.length;\n                }\n            }\n            if (state.udtCount) {\n                for(j = 0; j < state.udtCount; j += 1){\n                    if (rdi.refersToUdt[udtIndexes[j]]) {\n                        if (first) {\n                            str += toArrow;\n                            first = false;\n                            str += state.udts[udtIndexes[j]].name;\n                        } else {\n                            str += `, ${state.udts[udtIndexes[j]].name}`;\n                        }\n                        count += 1;\n                    }\n                    if (str.length - startSeg > lineLength && j !== maxUdt) {\n                        str += `\\n${pre}${toArrow}`;\n                        startSeg = str.length;\n                    }\n                }\n            }\n            if (count === 0) {\n                str += \"=> <none>\\n\";\n            }\n            if (first === false) {\n                str += \"\\n\";\n            }\n            first = true;\n            count = 0;\n            startSeg = str.length;\n            str += pre;\n            for(j = 0; j < state.ruleCount; j += 1){\n                if (rdi.referencedBy[ruleIndexes[j]]) {\n                    if (first) {\n                        str += byArrow;\n                        first = false;\n                        str += state.ruleDeps[ruleIndexes[j]].rule.name;\n                    } else {\n                        str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n                    }\n                    count += 1;\n                }\n                if (str.length - startSeg > lineLength && j !== maxRule) {\n                    str += `\\n${pre}${toArrow}`;\n                    startSeg = str.length;\n                }\n            }\n            if (count === 0) {\n                str += \"<= <none>\\n\";\n            }\n            if (first === false) {\n                str += \"\\n\";\n            }\n            str += \"\\n\";\n        }\n        return str;\n    };\n    // Display the rule dependencies.\n    // - order\n    //      - \"index\" or \"i\", index order (default)\n    //      - \"alpha\" or \"a\", alphabetical order\n    //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n    //      - none of above, index order (default)\n    const showRuleDependencies = (order = \"index\")=>{\n        let str = \"RULE DEPENDENCIES(index:type:[group number:])\\n\";\n        str += \"=> refers to rule names\\n\";\n        str += \"<= referenced by rule names\\n\";\n        if (!state.dependenciesComplete) {\n            return str;\n        }\n        if (order.charCodeAt(0) === 97) {\n            str += \"alphabetical by rule name\\n\";\n            str += show(97);\n        } else if (order.charCodeAt(0) === 116) {\n            str += \"ordered by rule type\\n\";\n            str += show(116);\n        } else {\n            str += \"ordered by rule index\\n\";\n            str += show(null);\n        }\n        return str;\n    };\n    /* Destructuring assignment - see MDN Web Docs */ return {\n        ruleDependencies,\n        showRuleDependencies\n    };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtZGVwZW5kZW5jaWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7dUZBR3VGLEdBQ3ZGLHlDQUF5QztBQUN6QywwREFBMEQ7QUFDMUQsaURBQWlEO0FBQ2pELEVBQUU7QUFDRixrQkFBa0I7QUFDbEIsc0VBQXNFO0FBQ3RFLGdFQUFnRTtBQUNoRSw0SUFBNEk7O0FBQzVJQSxPQUFPQyxPQUFPLEdBQUcsQ0FBQztJQUNoQixNQUFNQyxLQUFLQyxtQkFBT0EsQ0FBQztJQUNuQixJQUFJQyxRQUFRLE1BQU0sK0RBQStEO0lBRWpGLCtHQUErRyxHQUMvRyxNQUFNQyxPQUFPLENBQUNDLFdBQVdDLFVBQVVDLE9BQU9DO1FBQ3hDLElBQUlDLElBQUk7UUFDUixJQUFJQyxJQUFJO1FBQ1IsTUFBTUMsTUFBTUwsUUFBUSxDQUFDQyxNQUFNO1FBQzNCQyxTQUFTLENBQUNELE1BQU0sR0FBRztRQUNuQixNQUFNSyxLQUFLRCxJQUFJRSxJQUFJLENBQUNDLE9BQU87UUFDM0IsSUFBS0wsSUFBSSxHQUFHQSxJQUFJRyxHQUFHRyxNQUFNLEVBQUVOLEtBQUssRUFBRztZQUNqQyxNQUFNTyxNQUFNSixFQUFFLENBQUNILEVBQUU7WUFDakIsSUFBSU8sSUFBSUMsSUFBSSxLQUFLaEIsR0FBR2lCLEdBQUcsRUFBRTtnQkFDdkJQLElBQUlRLFFBQVEsQ0FBQ0gsSUFBSVQsS0FBSyxDQUFDLEdBQUc7Z0JBQzFCLElBQUksQ0FBQ0MsU0FBUyxDQUFDUSxJQUFJVCxLQUFLLENBQUMsRUFBRTtvQkFDekJILEtBQUtDLFdBQVdDLFVBQVVVLElBQUlULEtBQUssRUFBRUM7Z0JBQ3ZDO2dCQUNBLElBQUtFLElBQUksR0FBR0EsSUFBSUwsV0FBV0ssS0FBSyxFQUFHO29CQUNqQyxJQUFJSixRQUFRLENBQUNVLElBQUlULEtBQUssQ0FBQyxDQUFDWSxRQUFR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QixDQUFDQyxRQUFRLE9BQU87UUFDM0MsSUFBSVosTUFBTTtRQUNWQSxPQUFPO1FBQ1BBLE9BQU87UUFDUCxJQUFJLENBQUNsRCxNQUFNeUIsb0JBQW9CLEVBQUU7WUFDL0IsT0FBT3lCO1FBQ1Q7UUFFQSxJQUFJWSxNQUFNQyxVQUFVLENBQUMsT0FBTyxJQUFJO1lBQzlCYixPQUFPO1lBQ1BBLE9BQU9OLEtBQUs7UUFDZCxPQUFPLElBQUlrQixNQUFNQyxVQUFVLENBQUMsT0FBTyxLQUFLO1lBQ3RDYixPQUFPO1lBQ1BBLE9BQU9OLEtBQUs7UUFDZCxPQUFPO1lBQ0xNLE9BQU87WUFDUEEsT0FBT04sS0FBSztRQUNkO1FBQ0EsT0FBT007SUFDVDtJQUVBLCtDQUErQyxHQUMvQyxPQUFPO1FBQUU5QjtRQUFrQnlDO0lBQXFCO0FBQ2xEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvcnVsZS1kZXBlbmRlbmNpZXMuanM/ODhlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBEZXRlcm1pbmUgcnVsZSBkZXBlbmRlbmNpZXMgYW5kIHR5cGVzLlxuLy8gRm9yIGVhY2ggcnVsZSwgZGV0ZXJtaW5lIHdoaWNoIG90aGVyIHJ1bGVzIGl0IHJlZmVycyB0b1xuLy8gYW5kIHdoaWNoIG9mIHRoZSBvdGhlciBydWxlcyByZWZlciBiYWNrIHRvIGl0LlxuLy9cbi8vIFJ1bGUgdHlwZXMgYXJlOlxuLy8gIC0gbm9uLXJlY3Vyc2l2ZSAtIHRoZSBydWxlIG5ldmVyIHJlZmVycyB0byBpdHNlbGYsIGV2ZW4gaW5kaXJlY3RseVxuLy8gIC0gcmVjdXJzaXZlIC0gdGhlIHJ1bGUgcmVmZXJzIHRvIGl0c2VsZiwgcG9zc2libHkgaW5kaXJlY3RseVxuLy8gIC0gbXV0dWFsbHktcmVjdXJzaXZlIC0gYmVsb25ncyB0byBhIGdyb3VwIG9mIHR3byBvciBtb3JlIHJ1bGVzLCBlYWNoIG9mIHdoaWNoIHJlZmVycyB0byBldmVyeSBvdGhlciBydWxlIGluIHRoZSBncm91cCwgaW5jbHVkaW5nIGl0c2VsZi5cbm1vZHVsZS5leHBvcnRzID0gKCgpID0+IHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuLi9hcGctbGliL2lkZW50aWZpZXJzJyk7XG4gIGxldCBzdGF0ZSA9IG51bGw7IC8qIGtlZXAgYSBnbG9iYWwgcmVmZXJlbmNlIHRvIHRoZSBzdGF0ZSBmb3IgdGhlIHNob3cgZnVuY3Rpb25zICovXG5cbiAgLyogc2NhbiB0aGUgb3Bjb2RlcyBvZiB0aGUgaW5kZXhlZCBydWxlIGFuZCBkaXNjb3ZlciB3aGljaCBydWxlcyBpdCByZWZlcmVuY2VzIGFuZCB3aGljaCBydWxlIHJlZmVyIGJhY2sgdG8gaXQgKi9cbiAgY29uc3Qgc2NhbiA9IChydWxlQ291bnQsIHJ1bGVEZXBzLCBpbmRleCwgaXNTY2FubmVkKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBjb25zdCByZGkgPSBydWxlRGVwc1tpbmRleF07XG4gICAgaXNTY2FubmVkW2luZGV4XSA9IHRydWU7XG4gICAgY29uc3Qgb3AgPSByZGkucnVsZS5vcGNvZGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgb3BpID0gb3BbaV07XG4gICAgICBpZiAob3BpLnR5cGUgPT09IGlkLlJOTSkge1xuICAgICAgICByZGkucmVmZXJzVG9bb3BpLmluZGV4XSA9IHRydWU7XG4gICAgICAgIGlmICghaXNTY2FubmVkW29waS5pbmRleF0pIHtcbiAgICAgICAgICBzY2FuKHJ1bGVDb3VudCwgcnVsZURlcHMsIG9waS5pbmRleCwgaXNTY2FubmVkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgcnVsZUNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICBpZiAocnVsZURlcHNbb3BpLmluZGV4XS5yZWZlcnNUb1tqXSkge1xuICAgICAgICAgICAgcmRpLnJlZmVyc1RvW2pdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3BpLnR5cGUgPT09IGlkLlVEVCkge1xuICAgICAgICByZGkucmVmZXJzVG9VZHRbb3BpLmluZGV4XSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG9waS50eXBlID09PSBpZC5CS1IpIHtcbiAgICAgICAgaWYgKG9waS5pbmRleCA8IHJ1bGVDb3VudCkge1xuICAgICAgICAgIHJkaS5yZWZlcnNUb1tvcGkuaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIWlzU2Nhbm5lZFtvcGkuaW5kZXhdKSB7XG4gICAgICAgICAgICBzY2FuKHJ1bGVDb3VudCwgcnVsZURlcHMsIG9waS5pbmRleCwgaXNTY2FubmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmRpLnJlZmVyc1RvVWR0W3J1bGVDb3VudCAtIG9waS5pbmRleF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBEZXRlcm1pbmUgdGhlIHJ1bGUgZGVwZW5kZW5jaWVzLCB0eXBlcyBhbmQgbXV0dWFsbHkgcmVjdXJzaXZlIGdyb3Vwcy5cbiAgY29uc3QgcnVsZURlcGVuZGVuY2llcyA9IChzdGF0ZUFyZykgPT4ge1xuICAgIHN0YXRlID0gc3RhdGVBcmc7IC8qIG1ha2UgaXQgZ2xvYmFsICovXG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgZ3JvdXBDb3VudCA9IDA7XG4gICAgbGV0IHJkaSA9IG51bGw7XG4gICAgbGV0IHJkaiA9IG51bGw7XG4gICAgbGV0IG5ld0dyb3VwID0gZmFsc2U7XG4gICAgc3RhdGUuZGVwZW5kZW5jaWVzQ29tcGxldGUgPSBmYWxzZTtcblxuICAgIC8qIG1ha2UgYSB3b3JraW5nIGFycmF5IG9mIHJ1bGUgc2Nhbm5lZCBtYXJrZXJzICovXG4gICAgY29uc3QgaXNTY2FubmVkID0gc3RhdGUuZmFsc2VBcnJheShzdGF0ZS5ydWxlQ291bnQpO1xuXG4gICAgLyogZGlzY292ZXIgdGhlIHJ1bGUgZGVwZW5kZW5jaWVzICovXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICBzdGF0ZS5mYWxzaWZ5QXJyYXkoaXNTY2FubmVkKTtcbiAgICAgIHNjYW4oc3RhdGUucnVsZUNvdW50LCBzdGF0ZS5ydWxlRGVwcywgaSwgaXNTY2FubmVkKTtcbiAgICB9XG4gICAgLyogZGlzY292ZXIgYWxsIHJ1bGVzIHJlZmVyZW5jaW5nIGVhY2ggcnVsZSAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHN0YXRlLnJ1bGVDb3VudDsgaiArPSAxKSB7XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnJ1bGVEZXBzW2pdLnJlZmVyc1RvW2ldKSB7XG4gICAgICAgICAgICBzdGF0ZS5ydWxlRGVwc1tpXS5yZWZlcmVuY2VkQnlbal0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBmaW5kIHRoZSBub24tcmVjdXJzaXZlIGFuZCByZWN1cnNpdmUgdHlwZXMgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIHN0YXRlLnJ1bGVEZXBzW2ldLnJlY3Vyc2l2ZVR5cGUgPSBpZC5BVFRSX047XG4gICAgICBpZiAoc3RhdGUucnVsZURlcHNbaV0ucmVmZXJzVG9baV0pIHtcbiAgICAgICAgc3RhdGUucnVsZURlcHNbaV0ucmVjdXJzaXZlVHlwZSA9IGlkLkFUVFJfUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBmaW5kIHRoZSBtdXR1YWxseS1yZWN1cnNpdmUgZ3JvdXBzLCBpZiBhbnkgKi9cbiAgICBncm91cENvdW50ID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICByZGkgPSBzdGF0ZS5ydWxlRGVwc1tpXTtcbiAgICAgIGlmIChyZGkucmVjdXJzaXZlVHlwZSA9PT0gaWQuQVRUUl9SKSB7XG4gICAgICAgIG5ld0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0YXRlLnJ1bGVDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgIHJkaiA9IHN0YXRlLnJ1bGVEZXBzW2pdO1xuICAgICAgICAgICAgaWYgKHJkai5yZWN1cnNpdmVUeXBlID09PSBpZC5BVFRSX1IpIHtcbiAgICAgICAgICAgICAgaWYgKHJkaS5yZWZlcnNUb1tqXSAmJiByZGoucmVmZXJzVG9baV0pIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3R3JvdXApIHtcbiAgICAgICAgICAgICAgICAgIGdyb3VwQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgIHJkaS5yZWN1cnNpdmVUeXBlID0gaWQuQVRUUl9NUjtcbiAgICAgICAgICAgICAgICAgIHJkaS5ncm91cE51bWJlciA9IGdyb3VwQ291bnQ7XG4gICAgICAgICAgICAgICAgICBuZXdHcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZGoucmVjdXJzaXZlVHlwZSA9IGlkLkFUVFJfTVI7XG4gICAgICAgICAgICAgICAgcmRqLmdyb3VwTnVtYmVyID0gZ3JvdXBDb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5pc011dHVhbGx5UmVjdXJzaXZlID0gZ3JvdXBDb3VudCA+IC0xO1xuXG4gICAgLyogc29ydCB0aGUgcnVsZXMvVURUUyAqL1xuICAgIHN0YXRlLnJ1bGVBbHBoYUluZGV4ZXMuc29ydChzdGF0ZS5jb21wUnVsZXNBbHBoYSk7XG4gICAgc3RhdGUucnVsZVR5cGVJbmRleGVzLnNvcnQoc3RhdGUuY29tcFJ1bGVzQWxwaGEpO1xuICAgIHN0YXRlLnJ1bGVUeXBlSW5kZXhlcy5zb3J0KHN0YXRlLmNvbXBSdWxlc1R5cGUpO1xuICAgIGlmIChzdGF0ZS5pc011dHVhbGx5UmVjdXJzaXZlKSB7XG4gICAgICBzdGF0ZS5ydWxlVHlwZUluZGV4ZXMuc29ydChzdGF0ZS5jb21wUnVsZXNHcm91cCk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS51ZHRDb3VudCkge1xuICAgICAgc3RhdGUudWR0QWxwaGFJbmRleGVzLnNvcnQoc3RhdGUuY29tcFVkdHNBbHBoYSk7XG4gICAgfVxuXG4gICAgc3RhdGUuZGVwZW5kZW5jaWVzQ29tcGxldGUgPSB0cnVlO1xuICB9O1xuICBjb25zdCBzaG93ID0gKHR5cGUgPSBudWxsKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCBzdGFydFNlZyA9IDA7XG4gICAgY29uc3QgbWF4UnVsZSA9IHN0YXRlLnJ1bGVDb3VudCAtIDE7XG4gICAgY29uc3QgbWF4VWR0ID0gc3RhdGUudWR0Q291bnQgLSAxO1xuICAgIGNvbnN0IGxpbmVMZW5ndGggPSAxMDA7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBwcmUgPSAnJztcbiAgICBjb25zdCB0b0Fycm93ID0gJz0+ICc7XG4gICAgY29uc3QgYnlBcnJvdyA9ICc8PSAnO1xuICAgIGxldCBmaXJzdCA9IGZhbHNlO1xuICAgIGxldCByZGkgPSBudWxsO1xuICAgIGxldCB7IHJ1bGVJbmRleGVzIH0gPSBzdGF0ZTtcbiAgICBsZXQgeyB1ZHRJbmRleGVzIH0gPSBzdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gOTcpIHtcbiAgICAgIHJ1bGVJbmRleGVzID0gc3RhdGUucnVsZUFscGhhSW5kZXhlcztcbiAgICAgIHVkdEluZGV4ZXMgPSBzdGF0ZS51ZHRBbHBoYUluZGV4ZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAxMTYpIHtcbiAgICAgIHJ1bGVJbmRleGVzID0gc3RhdGUucnVsZVR5cGVJbmRleGVzO1xuICAgICAgdWR0SW5kZXhlcyA9IHN0YXRlLnVkdEFscGhhSW5kZXhlcztcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICByZGkgPSBzdGF0ZS5ydWxlRGVwc1tydWxlSW5kZXhlc1tpXV07XG4gICAgICBwcmUgPSBgJHtydWxlSW5kZXhlc1tpXX06JHtzdGF0ZS50eXBlVG9TdHJpbmcocmRpLnJlY3Vyc2l2ZVR5cGUpfTpgO1xuICAgICAgaWYgKHN0YXRlLmlzTXV0dWFsbHlSZWN1cnNpdmUpIHtcbiAgICAgICAgcHJlICs9IHJkaS5ncm91cE51bWJlciA+IC0xID8gcmRpLmdyb3VwTnVtYmVyIDogJy0nO1xuICAgICAgICBwcmUgKz0gJzonO1xuICAgICAgfVxuICAgICAgcHJlICs9ICcgJztcbiAgICAgIHN0ciArPSBgJHtwcmUgKyBzdGF0ZS5ydWxlc1tydWxlSW5kZXhlc1tpXV0ubmFtZX1cXG5gO1xuICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgY291bnQgPSAwO1xuICAgICAgc3RhcnRTZWcgPSBzdHIubGVuZ3RoO1xuICAgICAgc3RyICs9IHByZTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS5ydWxlQ291bnQ7IGogKz0gMSkge1xuICAgICAgICBpZiAocmRpLnJlZmVyc1RvW3J1bGVJbmRleGVzW2pdXSkge1xuICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgc3RyICs9IHRvQXJyb3c7XG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RyICs9IHN0YXRlLnJ1bGVEZXBzW3J1bGVJbmRleGVzW2pdXS5ydWxlLm5hbWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciArPSBgLCAke3N0YXRlLnJ1bGVEZXBzW3J1bGVJbmRleGVzW2pdXS5ydWxlLm5hbWV9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLmxlbmd0aCAtIHN0YXJ0U2VnID4gbGluZUxlbmd0aCAmJiBqICE9PSBtYXhSdWxlKSB7XG4gICAgICAgICAgc3RyICs9IGBcXG4ke3ByZX0ke3RvQXJyb3d9YDtcbiAgICAgICAgICBzdGFydFNlZyA9IHN0ci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS51ZHRDb3VudCkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3RhdGUudWR0Q291bnQ7IGogKz0gMSkge1xuICAgICAgICAgIGlmIChyZGkucmVmZXJzVG9VZHRbdWR0SW5kZXhlc1tqXV0pIHtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICBzdHIgKz0gdG9BcnJvdztcbiAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc3RyICs9IHN0YXRlLnVkdHNbdWR0SW5kZXhlc1tqXV0ubmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSBgLCAke3N0YXRlLnVkdHNbdWR0SW5kZXhlc1tqXV0ubmFtZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ci5sZW5ndGggLSBzdGFydFNlZyA+IGxpbmVMZW5ndGggJiYgaiAhPT0gbWF4VWR0KSB7XG4gICAgICAgICAgICBzdHIgKz0gYFxcbiR7cHJlfSR7dG9BcnJvd31gO1xuICAgICAgICAgICAgc3RhcnRTZWcgPSBzdHIubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHN0ciArPSAnPT4gPG5vbmU+XFxuJztcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgfVxuICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgY291bnQgPSAwO1xuICAgICAgc3RhcnRTZWcgPSBzdHIubGVuZ3RoO1xuICAgICAgc3RyICs9IHByZTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS5ydWxlQ291bnQ7IGogKz0gMSkge1xuICAgICAgICBpZiAocmRpLnJlZmVyZW5jZWRCeVtydWxlSW5kZXhlc1tqXV0pIHtcbiAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIHN0ciArPSBieUFycm93O1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0ciArPSBzdGF0ZS5ydWxlRGVwc1tydWxlSW5kZXhlc1tqXV0ucnVsZS5uYW1lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgKz0gYCwgJHtzdGF0ZS5ydWxlRGVwc1tydWxlSW5kZXhlc1tqXV0ucnVsZS5uYW1lfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggLSBzdGFydFNlZyA+IGxpbmVMZW5ndGggJiYgaiAhPT0gbWF4UnVsZSkge1xuICAgICAgICAgIHN0ciArPSBgXFxuJHtwcmV9JHt0b0Fycm93fWA7XG4gICAgICAgICAgc3RhcnRTZWcgPSBzdHIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgc3RyICs9ICc8PSA8bm9uZT5cXG4nO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0ID09PSBmYWxzZSkge1xuICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICB9XG4gICAgICBzdHIgKz0gJ1xcbic7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHJ1bGUgZGVwZW5kZW5jaWVzLlxuICAvLyAtIG9yZGVyXG4gIC8vICAgICAgLSBcImluZGV4XCIgb3IgXCJpXCIsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICAvLyAgICAgIC0gXCJhbHBoYVwiIG9yIFwiYVwiLCBhbHBoYWJldGljYWwgb3JkZXJcbiAgLy8gICAgICAtIFwidHlwZVwiIG9yIFwidFwiLCBvcmRlcmVkIGJ5IHR5cGUgKGFscGhhYmV0aWNhbCB3aXRoaW4gZWFjaCB0eXBlL2dyb3VwKVxuICAvLyAgICAgIC0gbm9uZSBvZiBhYm92ZSwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIGNvbnN0IHNob3dSdWxlRGVwZW5kZW5jaWVzID0gKG9yZGVyID0gJ2luZGV4JykgPT4ge1xuICAgIGxldCBzdHIgPSAnUlVMRSBERVBFTkRFTkNJRVMoaW5kZXg6dHlwZTpbZ3JvdXAgbnVtYmVyOl0pXFxuJztcbiAgICBzdHIgKz0gJz0+IHJlZmVycyB0byBydWxlIG5hbWVzXFxuJztcbiAgICBzdHIgKz0gJzw9IHJlZmVyZW5jZWQgYnkgcnVsZSBuYW1lc1xcbic7XG4gICAgaWYgKCFzdGF0ZS5kZXBlbmRlbmNpZXNDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBpZiAob3JkZXIuY2hhckNvZGVBdCgwKSA9PT0gOTcpIHtcbiAgICAgIHN0ciArPSAnYWxwaGFiZXRpY2FsIGJ5IHJ1bGUgbmFtZVxcbic7XG4gICAgICBzdHIgKz0gc2hvdyg5Nyk7XG4gICAgfSBlbHNlIGlmIChvcmRlci5jaGFyQ29kZUF0KDApID09PSAxMTYpIHtcbiAgICAgIHN0ciArPSAnb3JkZXJlZCBieSBydWxlIHR5cGVcXG4nO1xuICAgICAgc3RyICs9IHNob3coMTE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICdvcmRlcmVkIGJ5IHJ1bGUgaW5kZXhcXG4nO1xuICAgICAgc3RyICs9IHNob3cobnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyogRGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IC0gc2VlIE1ETiBXZWIgRG9jcyAqL1xuICByZXR1cm4geyBydWxlRGVwZW5kZW5jaWVzLCBzaG93UnVsZURlcGVuZGVuY2llcyB9O1xufSkoKTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiaWQiLCJyZXF1aXJlIiwic3RhdGUiLCJzY2FuIiwicnVsZUNvdW50IiwicnVsZURlcHMiLCJpbmRleCIsImlzU2Nhbm5lZCIsImkiLCJqIiwicmRpIiwib3AiLCJydWxlIiwib3Bjb2RlcyIsImxlbmd0aCIsIm9waSIsInR5cGUiLCJSTk0iLCJyZWZlcnNUbyIsIlVEVCIsInJlZmVyc1RvVWR0IiwiQktSIiwicnVsZURlcGVuZGVuY2llcyIsInN0YXRlQXJnIiwiZ3JvdXBDb3VudCIsInJkaiIsIm5ld0dyb3VwIiwiZGVwZW5kZW5jaWVzQ29tcGxldGUiLCJmYWxzZUFycmF5IiwiZmFsc2lmeUFycmF5IiwicmVmZXJlbmNlZEJ5IiwicmVjdXJzaXZlVHlwZSIsIkFUVFJfTiIsIkFUVFJfUiIsIkFUVFJfTVIiLCJncm91cE51bWJlciIsImlzTXV0dWFsbHlSZWN1cnNpdmUiLCJydWxlQWxwaGFJbmRleGVzIiwic29ydCIsImNvbXBSdWxlc0FscGhhIiwicnVsZVR5cGVJbmRleGVzIiwiY29tcFJ1bGVzVHlwZSIsImNvbXBSdWxlc0dyb3VwIiwidWR0Q291bnQiLCJ1ZHRBbHBoYUluZGV4ZXMiLCJjb21wVWR0c0FscGhhIiwic2hvdyIsImNvdW50Iiwic3RhcnRTZWciLCJtYXhSdWxlIiwibWF4VWR0IiwibGluZUxlbmd0aCIsInN0ciIsInByZSIsInRvQXJyb3ciLCJieUFycm93IiwiZmlyc3QiLCJydWxlSW5kZXhlcyIsInVkdEluZGV4ZXMiLCJ0eXBlVG9TdHJpbmciLCJydWxlcyIsIm5hbWUiLCJ1ZHRzIiwic2hvd1J1bGVEZXBlbmRlbmNpZXMiLCJvcmRlciIsImNoYXJDb2RlQXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/rule-dependencies.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/sabnf-grammar.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/sabnf-grammar.js ***!
  \**********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.2.1 [apg-js](https://github.com/ldthomas/apg-js)\n\nmodule.exports = function grammar() {\n    // ```\n    // SUMMARY\n    //      rules = 95\n    //       udts = 0\n    //    opcodes = 372\n    //        ---   ABNF original opcodes\n    //        ALT = 43\n    //        CAT = 48\n    //        REP = 34\n    //        RNM = 149\n    //        TLS = 2\n    //        TBS = 61\n    //        TRG = 35\n    //        ---   SABNF superset opcodes\n    //        UDT = 0\n    //        AND = 0\n    //        NOT = 0\n    //        BKA = 0\n    //        BKN = 0\n    //        BKR = 0\n    //        ABG = 0\n    //        AEN = 0\n    // characters = [9 - 126]\n    // ```\n    /* OBJECT IDENTIFIER (for internal parser use) */ this.grammarObject = \"grammarObject\";\n    /* RULES */ this.rules = [];\n    this.rules[0] = {\n        name: \"File\",\n        lower: \"file\",\n        index: 0,\n        isBkr: false\n    };\n    this.rules[1] = {\n        name: \"BlankLine\",\n        lower: \"blankline\",\n        index: 1,\n        isBkr: false\n    };\n    this.rules[2] = {\n        name: \"Rule\",\n        lower: \"rule\",\n        index: 2,\n        isBkr: false\n    };\n    this.rules[3] = {\n        name: \"RuleLookup\",\n        lower: \"rulelookup\",\n        index: 3,\n        isBkr: false\n    };\n    this.rules[4] = {\n        name: \"RuleNameTest\",\n        lower: \"rulenametest\",\n        index: 4,\n        isBkr: false\n    };\n    this.rules[5] = {\n        name: \"RuleName\",\n        lower: \"rulename\",\n        index: 5,\n        isBkr: false\n    };\n    this.rules[6] = {\n        name: \"RuleNameError\",\n        lower: \"rulenameerror\",\n        index: 6,\n        isBkr: false\n    };\n    this.rules[7] = {\n        name: \"DefinedAsTest\",\n        lower: \"definedastest\",\n        index: 7,\n        isBkr: false\n    };\n    this.rules[8] = {\n        name: \"DefinedAsError\",\n        lower: \"definedaserror\",\n        index: 8,\n        isBkr: false\n    };\n    this.rules[9] = {\n        name: \"DefinedAs\",\n        lower: \"definedas\",\n        index: 9,\n        isBkr: false\n    };\n    this.rules[10] = {\n        name: \"Defined\",\n        lower: \"defined\",\n        index: 10,\n        isBkr: false\n    };\n    this.rules[11] = {\n        name: \"IncAlt\",\n        lower: \"incalt\",\n        index: 11,\n        isBkr: false\n    };\n    this.rules[12] = {\n        name: \"RuleError\",\n        lower: \"ruleerror\",\n        index: 12,\n        isBkr: false\n    };\n    this.rules[13] = {\n        name: \"LineEndError\",\n        lower: \"lineenderror\",\n        index: 13,\n        isBkr: false\n    };\n    this.rules[14] = {\n        name: \"Alternation\",\n        lower: \"alternation\",\n        index: 14,\n        isBkr: false\n    };\n    this.rules[15] = {\n        name: \"Concatenation\",\n        lower: \"concatenation\",\n        index: 15,\n        isBkr: false\n    };\n    this.rules[16] = {\n        name: \"Repetition\",\n        lower: \"repetition\",\n        index: 16,\n        isBkr: false\n    };\n    this.rules[17] = {\n        name: \"Modifier\",\n        lower: \"modifier\",\n        index: 17,\n        isBkr: false\n    };\n    this.rules[18] = {\n        name: \"Predicate\",\n        lower: \"predicate\",\n        index: 18,\n        isBkr: false\n    };\n    this.rules[19] = {\n        name: \"BasicElement\",\n        lower: \"basicelement\",\n        index: 19,\n        isBkr: false\n    };\n    this.rules[20] = {\n        name: \"BasicElementErr\",\n        lower: \"basicelementerr\",\n        index: 20,\n        isBkr: false\n    };\n    this.rules[21] = {\n        name: \"Group\",\n        lower: \"group\",\n        index: 21,\n        isBkr: false\n    };\n    this.rules[22] = {\n        name: \"GroupError\",\n        lower: \"grouperror\",\n        index: 22,\n        isBkr: false\n    };\n    this.rules[23] = {\n        name: \"GroupOpen\",\n        lower: \"groupopen\",\n        index: 23,\n        isBkr: false\n    };\n    this.rules[24] = {\n        name: \"GroupClose\",\n        lower: \"groupclose\",\n        index: 24,\n        isBkr: false\n    };\n    this.rules[25] = {\n        name: \"Option\",\n        lower: \"option\",\n        index: 25,\n        isBkr: false\n    };\n    this.rules[26] = {\n        name: \"OptionError\",\n        lower: \"optionerror\",\n        index: 26,\n        isBkr: false\n    };\n    this.rules[27] = {\n        name: \"OptionOpen\",\n        lower: \"optionopen\",\n        index: 27,\n        isBkr: false\n    };\n    this.rules[28] = {\n        name: \"OptionClose\",\n        lower: \"optionclose\",\n        index: 28,\n        isBkr: false\n    };\n    this.rules[29] = {\n        name: \"RnmOp\",\n        lower: \"rnmop\",\n        index: 29,\n        isBkr: false\n    };\n    this.rules[30] = {\n        name: \"BkrOp\",\n        lower: \"bkrop\",\n        index: 30,\n        isBkr: false\n    };\n    this.rules[31] = {\n        name: \"bkrModifier\",\n        lower: \"bkrmodifier\",\n        index: 31,\n        isBkr: false\n    };\n    this.rules[32] = {\n        name: \"cs\",\n        lower: \"cs\",\n        index: 32,\n        isBkr: false\n    };\n    this.rules[33] = {\n        name: \"ci\",\n        lower: \"ci\",\n        index: 33,\n        isBkr: false\n    };\n    this.rules[34] = {\n        name: \"um\",\n        lower: \"um\",\n        index: 34,\n        isBkr: false\n    };\n    this.rules[35] = {\n        name: \"pm\",\n        lower: \"pm\",\n        index: 35,\n        isBkr: false\n    };\n    this.rules[36] = {\n        name: \"bkr-name\",\n        lower: \"bkr-name\",\n        index: 36,\n        isBkr: false\n    };\n    this.rules[37] = {\n        name: \"rname\",\n        lower: \"rname\",\n        index: 37,\n        isBkr: false\n    };\n    this.rules[38] = {\n        name: \"uname\",\n        lower: \"uname\",\n        index: 38,\n        isBkr: false\n    };\n    this.rules[39] = {\n        name: \"ename\",\n        lower: \"ename\",\n        index: 39,\n        isBkr: false\n    };\n    this.rules[40] = {\n        name: \"UdtOp\",\n        lower: \"udtop\",\n        index: 40,\n        isBkr: false\n    };\n    this.rules[41] = {\n        name: \"udt-non-empty\",\n        lower: \"udt-non-empty\",\n        index: 41,\n        isBkr: false\n    };\n    this.rules[42] = {\n        name: \"udt-empty\",\n        lower: \"udt-empty\",\n        index: 42,\n        isBkr: false\n    };\n    this.rules[43] = {\n        name: \"RepOp\",\n        lower: \"repop\",\n        index: 43,\n        isBkr: false\n    };\n    this.rules[44] = {\n        name: \"AltOp\",\n        lower: \"altop\",\n        index: 44,\n        isBkr: false\n    };\n    this.rules[45] = {\n        name: \"CatOp\",\n        lower: \"catop\",\n        index: 45,\n        isBkr: false\n    };\n    this.rules[46] = {\n        name: \"StarOp\",\n        lower: \"starop\",\n        index: 46,\n        isBkr: false\n    };\n    this.rules[47] = {\n        name: \"AndOp\",\n        lower: \"andop\",\n        index: 47,\n        isBkr: false\n    };\n    this.rules[48] = {\n        name: \"NotOp\",\n        lower: \"notop\",\n        index: 48,\n        isBkr: false\n    };\n    this.rules[49] = {\n        name: \"BkaOp\",\n        lower: \"bkaop\",\n        index: 49,\n        isBkr: false\n    };\n    this.rules[50] = {\n        name: \"BknOp\",\n        lower: \"bknop\",\n        index: 50,\n        isBkr: false\n    };\n    this.rules[51] = {\n        name: \"AbgOp\",\n        lower: \"abgop\",\n        index: 51,\n        isBkr: false\n    };\n    this.rules[52] = {\n        name: \"AenOp\",\n        lower: \"aenop\",\n        index: 52,\n        isBkr: false\n    };\n    this.rules[53] = {\n        name: \"TrgOp\",\n        lower: \"trgop\",\n        index: 53,\n        isBkr: false\n    };\n    this.rules[54] = {\n        name: \"TbsOp\",\n        lower: \"tbsop\",\n        index: 54,\n        isBkr: false\n    };\n    this.rules[55] = {\n        name: \"TlsOp\",\n        lower: \"tlsop\",\n        index: 55,\n        isBkr: false\n    };\n    this.rules[56] = {\n        name: \"TlsCase\",\n        lower: \"tlscase\",\n        index: 56,\n        isBkr: false\n    };\n    this.rules[57] = {\n        name: \"TlsOpen\",\n        lower: \"tlsopen\",\n        index: 57,\n        isBkr: false\n    };\n    this.rules[58] = {\n        name: \"TlsClose\",\n        lower: \"tlsclose\",\n        index: 58,\n        isBkr: false\n    };\n    this.rules[59] = {\n        name: \"TlsString\",\n        lower: \"tlsstring\",\n        index: 59,\n        isBkr: false\n    };\n    this.rules[60] = {\n        name: \"StringTab\",\n        lower: \"stringtab\",\n        index: 60,\n        isBkr: false\n    };\n    this.rules[61] = {\n        name: \"ClsOp\",\n        lower: \"clsop\",\n        index: 61,\n        isBkr: false\n    };\n    this.rules[62] = {\n        name: \"ClsOpen\",\n        lower: \"clsopen\",\n        index: 62,\n        isBkr: false\n    };\n    this.rules[63] = {\n        name: \"ClsClose\",\n        lower: \"clsclose\",\n        index: 63,\n        isBkr: false\n    };\n    this.rules[64] = {\n        name: \"ClsString\",\n        lower: \"clsstring\",\n        index: 64,\n        isBkr: false\n    };\n    this.rules[65] = {\n        name: \"ProsVal\",\n        lower: \"prosval\",\n        index: 65,\n        isBkr: false\n    };\n    this.rules[66] = {\n        name: \"ProsValOpen\",\n        lower: \"prosvalopen\",\n        index: 66,\n        isBkr: false\n    };\n    this.rules[67] = {\n        name: \"ProsValString\",\n        lower: \"prosvalstring\",\n        index: 67,\n        isBkr: false\n    };\n    this.rules[68] = {\n        name: \"ProsValClose\",\n        lower: \"prosvalclose\",\n        index: 68,\n        isBkr: false\n    };\n    this.rules[69] = {\n        name: \"rep-min\",\n        lower: \"rep-min\",\n        index: 69,\n        isBkr: false\n    };\n    this.rules[70] = {\n        name: \"rep-min-max\",\n        lower: \"rep-min-max\",\n        index: 70,\n        isBkr: false\n    };\n    this.rules[71] = {\n        name: \"rep-max\",\n        lower: \"rep-max\",\n        index: 71,\n        isBkr: false\n    };\n    this.rules[72] = {\n        name: \"rep-num\",\n        lower: \"rep-num\",\n        index: 72,\n        isBkr: false\n    };\n    this.rules[73] = {\n        name: \"dString\",\n        lower: \"dstring\",\n        index: 73,\n        isBkr: false\n    };\n    this.rules[74] = {\n        name: \"xString\",\n        lower: \"xstring\",\n        index: 74,\n        isBkr: false\n    };\n    this.rules[75] = {\n        name: \"bString\",\n        lower: \"bstring\",\n        index: 75,\n        isBkr: false\n    };\n    this.rules[76] = {\n        name: \"Dec\",\n        lower: \"dec\",\n        index: 76,\n        isBkr: false\n    };\n    this.rules[77] = {\n        name: \"Hex\",\n        lower: \"hex\",\n        index: 77,\n        isBkr: false\n    };\n    this.rules[78] = {\n        name: \"Bin\",\n        lower: \"bin\",\n        index: 78,\n        isBkr: false\n    };\n    this.rules[79] = {\n        name: \"dmin\",\n        lower: \"dmin\",\n        index: 79,\n        isBkr: false\n    };\n    this.rules[80] = {\n        name: \"dmax\",\n        lower: \"dmax\",\n        index: 80,\n        isBkr: false\n    };\n    this.rules[81] = {\n        name: \"bmin\",\n        lower: \"bmin\",\n        index: 81,\n        isBkr: false\n    };\n    this.rules[82] = {\n        name: \"bmax\",\n        lower: \"bmax\",\n        index: 82,\n        isBkr: false\n    };\n    this.rules[83] = {\n        name: \"xmin\",\n        lower: \"xmin\",\n        index: 83,\n        isBkr: false\n    };\n    this.rules[84] = {\n        name: \"xmax\",\n        lower: \"xmax\",\n        index: 84,\n        isBkr: false\n    };\n    this.rules[85] = {\n        name: \"dnum\",\n        lower: \"dnum\",\n        index: 85,\n        isBkr: false\n    };\n    this.rules[86] = {\n        name: \"bnum\",\n        lower: \"bnum\",\n        index: 86,\n        isBkr: false\n    };\n    this.rules[87] = {\n        name: \"xnum\",\n        lower: \"xnum\",\n        index: 87,\n        isBkr: false\n    };\n    this.rules[88] = {\n        name: \"alphanum\",\n        lower: \"alphanum\",\n        index: 88,\n        isBkr: false\n    };\n    this.rules[89] = {\n        name: \"owsp\",\n        lower: \"owsp\",\n        index: 89,\n        isBkr: false\n    };\n    this.rules[90] = {\n        name: \"wsp\",\n        lower: \"wsp\",\n        index: 90,\n        isBkr: false\n    };\n    this.rules[91] = {\n        name: \"space\",\n        lower: \"space\",\n        index: 91,\n        isBkr: false\n    };\n    this.rules[92] = {\n        name: \"comment\",\n        lower: \"comment\",\n        index: 92,\n        isBkr: false\n    };\n    this.rules[93] = {\n        name: \"LineEnd\",\n        lower: \"lineend\",\n        index: 93,\n        isBkr: false\n    };\n    this.rules[94] = {\n        name: \"LineContinue\",\n        lower: \"linecontinue\",\n        index: 94,\n        isBkr: false\n    };\n    /* UDTS */ this.udts = [];\n    /* OPCODES */ /* File */ this.rules[0].opcodes = [];\n    this.rules[0].opcodes[0] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[0].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3,\n            4\n        ]\n    }; // ALT\n    this.rules[0].opcodes[2] = {\n        type: 4,\n        index: 1\n    }; // RNM(BlankLine)\n    this.rules[0].opcodes[3] = {\n        type: 4,\n        index: 2\n    }; // RNM(Rule)\n    this.rules[0].opcodes[4] = {\n        type: 4,\n        index: 12\n    }; // RNM(RuleError)\n    /* BlankLine */ this.rules[1].opcodes = [];\n    this.rules[1].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            5,\n            7\n        ]\n    }; // CAT\n    this.rules[1].opcodes[1] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[1].opcodes[2] = {\n        type: 1,\n        children: [\n            3,\n            4\n        ]\n    }; // ALT\n    this.rules[1].opcodes[3] = {\n        type: 6,\n        string: [\n            32\n        ]\n    }; // TBS\n    this.rules[1].opcodes[4] = {\n        type: 6,\n        string: [\n            9\n        ]\n    }; // TBS\n    this.rules[1].opcodes[5] = {\n        type: 3,\n        min: 0,\n        max: 1\n    }; // REP\n    this.rules[1].opcodes[6] = {\n        type: 4,\n        index: 92\n    }; // RNM(comment)\n    this.rules[1].opcodes[7] = {\n        type: 4,\n        index: 93\n    }; // RNM(LineEnd)\n    /* Rule */ this.rules[2].opcodes = [];\n    this.rules[2].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2,\n            3,\n            4\n        ]\n    }; // CAT\n    this.rules[2].opcodes[1] = {\n        type: 4,\n        index: 3\n    }; // RNM(RuleLookup)\n    this.rules[2].opcodes[2] = {\n        type: 4,\n        index: 89\n    }; // RNM(owsp)\n    this.rules[2].opcodes[3] = {\n        type: 4,\n        index: 14\n    }; // RNM(Alternation)\n    this.rules[2].opcodes[4] = {\n        type: 1,\n        children: [\n            5,\n            8\n        ]\n    }; // ALT\n    this.rules[2].opcodes[5] = {\n        type: 2,\n        children: [\n            6,\n            7\n        ]\n    }; // CAT\n    this.rules[2].opcodes[6] = {\n        type: 4,\n        index: 89\n    }; // RNM(owsp)\n    this.rules[2].opcodes[7] = {\n        type: 4,\n        index: 93\n    }; // RNM(LineEnd)\n    this.rules[2].opcodes[8] = {\n        type: 2,\n        children: [\n            9,\n            10\n        ]\n    }; // CAT\n    this.rules[2].opcodes[9] = {\n        type: 4,\n        index: 13\n    }; // RNM(LineEndError)\n    this.rules[2].opcodes[10] = {\n        type: 4,\n        index: 93\n    }; // RNM(LineEnd)\n    /* RuleLookup */ this.rules[3].opcodes = [];\n    this.rules[3].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2,\n            3\n        ]\n    }; // CAT\n    this.rules[3].opcodes[1] = {\n        type: 4,\n        index: 4\n    }; // RNM(RuleNameTest)\n    this.rules[3].opcodes[2] = {\n        type: 4,\n        index: 89\n    }; // RNM(owsp)\n    this.rules[3].opcodes[3] = {\n        type: 4,\n        index: 7\n    }; // RNM(DefinedAsTest)\n    /* RuleNameTest */ this.rules[4].opcodes = [];\n    this.rules[4].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2\n        ]\n    }; // ALT\n    this.rules[4].opcodes[1] = {\n        type: 4,\n        index: 5\n    }; // RNM(RuleName)\n    this.rules[4].opcodes[2] = {\n        type: 4,\n        index: 6\n    }; // RNM(RuleNameError)\n    /* RuleName */ this.rules[5].opcodes = [];\n    this.rules[5].opcodes[0] = {\n        type: 4,\n        index: 88\n    }; // RNM(alphanum)\n    /* RuleNameError */ this.rules[6].opcodes = [];\n    this.rules[6].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[6].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3\n        ]\n    }; // ALT\n    this.rules[6].opcodes[2] = {\n        type: 5,\n        min: 33,\n        max: 60\n    }; // TRG\n    this.rules[6].opcodes[3] = {\n        type: 5,\n        min: 62,\n        max: 126\n    }; // TRG\n    /* DefinedAsTest */ this.rules[7].opcodes = [];\n    this.rules[7].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2\n        ]\n    }; // ALT\n    this.rules[7].opcodes[1] = {\n        type: 4,\n        index: 9\n    }; // RNM(DefinedAs)\n    this.rules[7].opcodes[2] = {\n        type: 4,\n        index: 8\n    }; // RNM(DefinedAsError)\n    /* DefinedAsError */ this.rules[8].opcodes = [];\n    this.rules[8].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: 2\n    }; // REP\n    this.rules[8].opcodes[1] = {\n        type: 5,\n        min: 33,\n        max: 126\n    }; // TRG\n    /* DefinedAs */ this.rules[9].opcodes = [];\n    this.rules[9].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2\n        ]\n    }; // ALT\n    this.rules[9].opcodes[1] = {\n        type: 4,\n        index: 11\n    }; // RNM(IncAlt)\n    this.rules[9].opcodes[2] = {\n        type: 4,\n        index: 10\n    }; // RNM(Defined)\n    /* Defined */ this.rules[10].opcodes = [];\n    this.rules[10].opcodes[0] = {\n        type: 6,\n        string: [\n            61\n        ]\n    }; // TBS\n    /* IncAlt */ this.rules[11].opcodes = [];\n    this.rules[11].opcodes[0] = {\n        type: 6,\n        string: [\n            61,\n            47\n        ]\n    }; // TBS\n    /* RuleError */ this.rules[12].opcodes = [];\n    this.rules[12].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            6\n        ]\n    }; // CAT\n    this.rules[12].opcodes[1] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[12].opcodes[2] = {\n        type: 1,\n        children: [\n            3,\n            4,\n            5\n        ]\n    }; // ALT\n    this.rules[12].opcodes[3] = {\n        type: 5,\n        min: 32,\n        max: 126\n    }; // TRG\n    this.rules[12].opcodes[4] = {\n        type: 6,\n        string: [\n            9\n        ]\n    }; // TBS\n    this.rules[12].opcodes[5] = {\n        type: 4,\n        index: 94\n    }; // RNM(LineContinue)\n    this.rules[12].opcodes[6] = {\n        type: 4,\n        index: 93\n    }; // RNM(LineEnd)\n    /* LineEndError */ this.rules[13].opcodes = [];\n    this.rules[13].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[13].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3,\n            4\n        ]\n    }; // ALT\n    this.rules[13].opcodes[2] = {\n        type: 5,\n        min: 32,\n        max: 126\n    }; // TRG\n    this.rules[13].opcodes[3] = {\n        type: 6,\n        string: [\n            9\n        ]\n    }; // TBS\n    this.rules[13].opcodes[4] = {\n        type: 4,\n        index: 94\n    }; // RNM(LineContinue)\n    /* Alternation */ this.rules[14].opcodes = [];\n    this.rules[14].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[14].opcodes[1] = {\n        type: 4,\n        index: 15\n    }; // RNM(Concatenation)\n    this.rules[14].opcodes[2] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[14].opcodes[3] = {\n        type: 2,\n        children: [\n            4,\n            5,\n            6\n        ]\n    }; // CAT\n    this.rules[14].opcodes[4] = {\n        type: 4,\n        index: 89\n    }; // RNM(owsp)\n    this.rules[14].opcodes[5] = {\n        type: 4,\n        index: 44\n    }; // RNM(AltOp)\n    this.rules[14].opcodes[6] = {\n        type: 4,\n        index: 15\n    }; // RNM(Concatenation)\n    /* Concatenation */ this.rules[15].opcodes = [];\n    this.rules[15].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[15].opcodes[1] = {\n        type: 4,\n        index: 16\n    }; // RNM(Repetition)\n    this.rules[15].opcodes[2] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[15].opcodes[3] = {\n        type: 2,\n        children: [\n            4,\n            5\n        ]\n    }; // CAT\n    this.rules[15].opcodes[4] = {\n        type: 4,\n        index: 45\n    }; // RNM(CatOp)\n    this.rules[15].opcodes[5] = {\n        type: 4,\n        index: 16\n    }; // RNM(Repetition)\n    /* Repetition */ this.rules[16].opcodes = [];\n    this.rules[16].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            3\n        ]\n    }; // CAT\n    this.rules[16].opcodes[1] = {\n        type: 3,\n        min: 0,\n        max: 1\n    }; // REP\n    this.rules[16].opcodes[2] = {\n        type: 4,\n        index: 17\n    }; // RNM(Modifier)\n    this.rules[16].opcodes[3] = {\n        type: 1,\n        children: [\n            4,\n            5,\n            6,\n            7\n        ]\n    }; // ALT\n    this.rules[16].opcodes[4] = {\n        type: 4,\n        index: 21\n    }; // RNM(Group)\n    this.rules[16].opcodes[5] = {\n        type: 4,\n        index: 25\n    }; // RNM(Option)\n    this.rules[16].opcodes[6] = {\n        type: 4,\n        index: 19\n    }; // RNM(BasicElement)\n    this.rules[16].opcodes[7] = {\n        type: 4,\n        index: 20\n    }; // RNM(BasicElementErr)\n    /* Modifier */ this.rules[17].opcodes = [];\n    this.rules[17].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            5\n        ]\n    }; // ALT\n    this.rules[17].opcodes[1] = {\n        type: 2,\n        children: [\n            2,\n            3\n        ]\n    }; // CAT\n    this.rules[17].opcodes[2] = {\n        type: 4,\n        index: 18\n    }; // RNM(Predicate)\n    this.rules[17].opcodes[3] = {\n        type: 3,\n        min: 0,\n        max: 1\n    }; // REP\n    this.rules[17].opcodes[4] = {\n        type: 4,\n        index: 43\n    }; // RNM(RepOp)\n    this.rules[17].opcodes[5] = {\n        type: 4,\n        index: 43\n    }; // RNM(RepOp)\n    /* Predicate */ this.rules[18].opcodes = [];\n    this.rules[18].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2,\n            3,\n            4\n        ]\n    }; // ALT\n    this.rules[18].opcodes[1] = {\n        type: 4,\n        index: 49\n    }; // RNM(BkaOp)\n    this.rules[18].opcodes[2] = {\n        type: 4,\n        index: 50\n    }; // RNM(BknOp)\n    this.rules[18].opcodes[3] = {\n        type: 4,\n        index: 47\n    }; // RNM(AndOp)\n    this.rules[18].opcodes[4] = {\n        type: 4,\n        index: 48\n    }; // RNM(NotOp)\n    /* BasicElement */ this.rules[19].opcodes = [];\n    this.rules[19].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n            7,\n            8,\n            9,\n            10\n        ]\n    }; // ALT\n    this.rules[19].opcodes[1] = {\n        type: 4,\n        index: 40\n    }; // RNM(UdtOp)\n    this.rules[19].opcodes[2] = {\n        type: 4,\n        index: 29\n    }; // RNM(RnmOp)\n    this.rules[19].opcodes[3] = {\n        type: 4,\n        index: 53\n    }; // RNM(TrgOp)\n    this.rules[19].opcodes[4] = {\n        type: 4,\n        index: 54\n    }; // RNM(TbsOp)\n    this.rules[19].opcodes[5] = {\n        type: 4,\n        index: 55\n    }; // RNM(TlsOp)\n    this.rules[19].opcodes[6] = {\n        type: 4,\n        index: 61\n    }; // RNM(ClsOp)\n    this.rules[19].opcodes[7] = {\n        type: 4,\n        index: 30\n    }; // RNM(BkrOp)\n    this.rules[19].opcodes[8] = {\n        type: 4,\n        index: 51\n    }; // RNM(AbgOp)\n    this.rules[19].opcodes[9] = {\n        type: 4,\n        index: 52\n    }; // RNM(AenOp)\n    this.rules[19].opcodes[10] = {\n        type: 4,\n        index: 65\n    }; // RNM(ProsVal)\n    /* BasicElementErr */ this.rules[20].opcodes = [];\n    this.rules[20].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[20].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3,\n            4,\n            5\n        ]\n    }; // ALT\n    this.rules[20].opcodes[2] = {\n        type: 5,\n        min: 33,\n        max: 40\n    }; // TRG\n    this.rules[20].opcodes[3] = {\n        type: 5,\n        min: 42,\n        max: 46\n    }; // TRG\n    this.rules[20].opcodes[4] = {\n        type: 5,\n        min: 48,\n        max: 92\n    }; // TRG\n    this.rules[20].opcodes[5] = {\n        type: 5,\n        min: 94,\n        max: 126\n    }; // TRG\n    /* Group */ this.rules[21].opcodes = [];\n    this.rules[21].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2,\n            3\n        ]\n    }; // CAT\n    this.rules[21].opcodes[1] = {\n        type: 4,\n        index: 23\n    }; // RNM(GroupOpen)\n    this.rules[21].opcodes[2] = {\n        type: 4,\n        index: 14\n    }; // RNM(Alternation)\n    this.rules[21].opcodes[3] = {\n        type: 1,\n        children: [\n            4,\n            5\n        ]\n    }; // ALT\n    this.rules[21].opcodes[4] = {\n        type: 4,\n        index: 24\n    }; // RNM(GroupClose)\n    this.rules[21].opcodes[5] = {\n        type: 4,\n        index: 22\n    }; // RNM(GroupError)\n    /* GroupError */ this.rules[22].opcodes = [];\n    this.rules[22].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[22].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3,\n            4,\n            5\n        ]\n    }; // ALT\n    this.rules[22].opcodes[2] = {\n        type: 5,\n        min: 33,\n        max: 40\n    }; // TRG\n    this.rules[22].opcodes[3] = {\n        type: 5,\n        min: 42,\n        max: 46\n    }; // TRG\n    this.rules[22].opcodes[4] = {\n        type: 5,\n        min: 48,\n        max: 92\n    }; // TRG\n    this.rules[22].opcodes[5] = {\n        type: 5,\n        min: 94,\n        max: 126\n    }; // TRG\n    /* GroupOpen */ this.rules[23].opcodes = [];\n    this.rules[23].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[23].opcodes[1] = {\n        type: 6,\n        string: [\n            40\n        ]\n    }; // TBS\n    this.rules[23].opcodes[2] = {\n        type: 4,\n        index: 89\n    }; // RNM(owsp)\n    /* GroupClose */ this.rules[24].opcodes = [];\n    this.rules[24].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[24].opcodes[1] = {\n        type: 4,\n        index: 89\n    }; // RNM(owsp)\n    this.rules[24].opcodes[2] = {\n        type: 6,\n        string: [\n            41\n        ]\n    }; // TBS\n    /* Option */ this.rules[25].opcodes = [];\n    this.rules[25].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2,\n            3\n        ]\n    }; // CAT\n    this.rules[25].opcodes[1] = {\n        type: 4,\n        index: 27\n    }; // RNM(OptionOpen)\n    this.rules[25].opcodes[2] = {\n        type: 4,\n        index: 14\n    }; // RNM(Alternation)\n    this.rules[25].opcodes[3] = {\n        type: 1,\n        children: [\n            4,\n            5\n        ]\n    }; // ALT\n    this.rules[25].opcodes[4] = {\n        type: 4,\n        index: 28\n    }; // RNM(OptionClose)\n    this.rules[25].opcodes[5] = {\n        type: 4,\n        index: 26\n    }; // RNM(OptionError)\n    /* OptionError */ this.rules[26].opcodes = [];\n    this.rules[26].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[26].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3,\n            4,\n            5\n        ]\n    }; // ALT\n    this.rules[26].opcodes[2] = {\n        type: 5,\n        min: 33,\n        max: 40\n    }; // TRG\n    this.rules[26].opcodes[3] = {\n        type: 5,\n        min: 42,\n        max: 46\n    }; // TRG\n    this.rules[26].opcodes[4] = {\n        type: 5,\n        min: 48,\n        max: 92\n    }; // TRG\n    this.rules[26].opcodes[5] = {\n        type: 5,\n        min: 94,\n        max: 126\n    }; // TRG\n    /* OptionOpen */ this.rules[27].opcodes = [];\n    this.rules[27].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[27].opcodes[1] = {\n        type: 6,\n        string: [\n            91\n        ]\n    }; // TBS\n    this.rules[27].opcodes[2] = {\n        type: 4,\n        index: 89\n    }; // RNM(owsp)\n    /* OptionClose */ this.rules[28].opcodes = [];\n    this.rules[28].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[28].opcodes[1] = {\n        type: 4,\n        index: 89\n    }; // RNM(owsp)\n    this.rules[28].opcodes[2] = {\n        type: 6,\n        string: [\n            93\n        ]\n    }; // TBS\n    /* RnmOp */ this.rules[29].opcodes = [];\n    this.rules[29].opcodes[0] = {\n        type: 4,\n        index: 88\n    }; // RNM(alphanum)\n    /* BkrOp */ this.rules[30].opcodes = [];\n    this.rules[30].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2,\n            4\n        ]\n    }; // CAT\n    this.rules[30].opcodes[1] = {\n        type: 6,\n        string: [\n            92\n        ]\n    }; // TBS\n    this.rules[30].opcodes[2] = {\n        type: 3,\n        min: 0,\n        max: 1\n    }; // REP\n    this.rules[30].opcodes[3] = {\n        type: 4,\n        index: 31\n    }; // RNM(bkrModifier)\n    this.rules[30].opcodes[4] = {\n        type: 4,\n        index: 36\n    }; // RNM(bkr-name)\n    /* bkrModifier */ this.rules[31].opcodes = [];\n    this.rules[31].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            7,\n            13,\n            19\n        ]\n    }; // ALT\n    this.rules[31].opcodes[1] = {\n        type: 2,\n        children: [\n            2,\n            3\n        ]\n    }; // CAT\n    this.rules[31].opcodes[2] = {\n        type: 4,\n        index: 32\n    }; // RNM(cs)\n    this.rules[31].opcodes[3] = {\n        type: 3,\n        min: 0,\n        max: 1\n    }; // REP\n    this.rules[31].opcodes[4] = {\n        type: 1,\n        children: [\n            5,\n            6\n        ]\n    }; // ALT\n    this.rules[31].opcodes[5] = {\n        type: 4,\n        index: 34\n    }; // RNM(um)\n    this.rules[31].opcodes[6] = {\n        type: 4,\n        index: 35\n    }; // RNM(pm)\n    this.rules[31].opcodes[7] = {\n        type: 2,\n        children: [\n            8,\n            9\n        ]\n    }; // CAT\n    this.rules[31].opcodes[8] = {\n        type: 4,\n        index: 33\n    }; // RNM(ci)\n    this.rules[31].opcodes[9] = {\n        type: 3,\n        min: 0,\n        max: 1\n    }; // REP\n    this.rules[31].opcodes[10] = {\n        type: 1,\n        children: [\n            11,\n            12\n        ]\n    }; // ALT\n    this.rules[31].opcodes[11] = {\n        type: 4,\n        index: 34\n    }; // RNM(um)\n    this.rules[31].opcodes[12] = {\n        type: 4,\n        index: 35\n    }; // RNM(pm)\n    this.rules[31].opcodes[13] = {\n        type: 2,\n        children: [\n            14,\n            15\n        ]\n    }; // CAT\n    this.rules[31].opcodes[14] = {\n        type: 4,\n        index: 34\n    }; // RNM(um)\n    this.rules[31].opcodes[15] = {\n        type: 3,\n        min: 0,\n        max: 1\n    }; // REP\n    this.rules[31].opcodes[16] = {\n        type: 1,\n        children: [\n            17,\n            18\n        ]\n    }; // ALT\n    this.rules[31].opcodes[17] = {\n        type: 4,\n        index: 32\n    }; // RNM(cs)\n    this.rules[31].opcodes[18] = {\n        type: 4,\n        index: 33\n    }; // RNM(ci)\n    this.rules[31].opcodes[19] = {\n        type: 2,\n        children: [\n            20,\n            21\n        ]\n    }; // CAT\n    this.rules[31].opcodes[20] = {\n        type: 4,\n        index: 35\n    }; // RNM(pm)\n    this.rules[31].opcodes[21] = {\n        type: 3,\n        min: 0,\n        max: 1\n    }; // REP\n    this.rules[31].opcodes[22] = {\n        type: 1,\n        children: [\n            23,\n            24\n        ]\n    }; // ALT\n    this.rules[31].opcodes[23] = {\n        type: 4,\n        index: 32\n    }; // RNM(cs)\n    this.rules[31].opcodes[24] = {\n        type: 4,\n        index: 33\n    }; // RNM(ci)\n    /* cs */ this.rules[32].opcodes = [];\n    this.rules[32].opcodes[0] = {\n        type: 6,\n        string: [\n            37,\n            115\n        ]\n    }; // TBS\n    /* ci */ this.rules[33].opcodes = [];\n    this.rules[33].opcodes[0] = {\n        type: 6,\n        string: [\n            37,\n            105\n        ]\n    }; // TBS\n    /* um */ this.rules[34].opcodes = [];\n    this.rules[34].opcodes[0] = {\n        type: 6,\n        string: [\n            37,\n            117\n        ]\n    }; // TBS\n    /* pm */ this.rules[35].opcodes = [];\n    this.rules[35].opcodes[0] = {\n        type: 6,\n        string: [\n            37,\n            112\n        ]\n    }; // TBS\n    /* bkr-name */ this.rules[36].opcodes = [];\n    this.rules[36].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2,\n            3\n        ]\n    }; // ALT\n    this.rules[36].opcodes[1] = {\n        type: 4,\n        index: 38\n    }; // RNM(uname)\n    this.rules[36].opcodes[2] = {\n        type: 4,\n        index: 39\n    }; // RNM(ename)\n    this.rules[36].opcodes[3] = {\n        type: 4,\n        index: 37\n    }; // RNM(rname)\n    /* rname */ this.rules[37].opcodes = [];\n    this.rules[37].opcodes[0] = {\n        type: 4,\n        index: 88\n    }; // RNM(alphanum)\n    /* uname */ this.rules[38].opcodes = [];\n    this.rules[38].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[38].opcodes[1] = {\n        type: 6,\n        string: [\n            117,\n            95\n        ]\n    }; // TBS\n    this.rules[38].opcodes[2] = {\n        type: 4,\n        index: 88\n    }; // RNM(alphanum)\n    /* ename */ this.rules[39].opcodes = [];\n    this.rules[39].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[39].opcodes[1] = {\n        type: 6,\n        string: [\n            101,\n            95\n        ]\n    }; // TBS\n    this.rules[39].opcodes[2] = {\n        type: 4,\n        index: 88\n    }; // RNM(alphanum)\n    /* UdtOp */ this.rules[40].opcodes = [];\n    this.rules[40].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2\n        ]\n    }; // ALT\n    this.rules[40].opcodes[1] = {\n        type: 4,\n        index: 42\n    }; // RNM(udt-empty)\n    this.rules[40].opcodes[2] = {\n        type: 4,\n        index: 41\n    }; // RNM(udt-non-empty)\n    /* udt-non-empty */ this.rules[41].opcodes = [];\n    this.rules[41].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[41].opcodes[1] = {\n        type: 6,\n        string: [\n            117,\n            95\n        ]\n    }; // TBS\n    this.rules[41].opcodes[2] = {\n        type: 4,\n        index: 88\n    }; // RNM(alphanum)\n    /* udt-empty */ this.rules[42].opcodes = [];\n    this.rules[42].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[42].opcodes[1] = {\n        type: 6,\n        string: [\n            101,\n            95\n        ]\n    }; // TBS\n    this.rules[42].opcodes[2] = {\n        type: 4,\n        index: 88\n    }; // RNM(alphanum)\n    /* RepOp */ this.rules[43].opcodes = [];\n    this.rules[43].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            5,\n            8,\n            11,\n            12\n        ]\n    }; // ALT\n    this.rules[43].opcodes[1] = {\n        type: 2,\n        children: [\n            2,\n            3,\n            4\n        ]\n    }; // CAT\n    this.rules[43].opcodes[2] = {\n        type: 4,\n        index: 69\n    }; // RNM(rep-min)\n    this.rules[43].opcodes[3] = {\n        type: 4,\n        index: 46\n    }; // RNM(StarOp)\n    this.rules[43].opcodes[4] = {\n        type: 4,\n        index: 71\n    }; // RNM(rep-max)\n    this.rules[43].opcodes[5] = {\n        type: 2,\n        children: [\n            6,\n            7\n        ]\n    }; // CAT\n    this.rules[43].opcodes[6] = {\n        type: 4,\n        index: 69\n    }; // RNM(rep-min)\n    this.rules[43].opcodes[7] = {\n        type: 4,\n        index: 46\n    }; // RNM(StarOp)\n    this.rules[43].opcodes[8] = {\n        type: 2,\n        children: [\n            9,\n            10\n        ]\n    }; // CAT\n    this.rules[43].opcodes[9] = {\n        type: 4,\n        index: 46\n    }; // RNM(StarOp)\n    this.rules[43].opcodes[10] = {\n        type: 4,\n        index: 71\n    }; // RNM(rep-max)\n    this.rules[43].opcodes[11] = {\n        type: 4,\n        index: 46\n    }; // RNM(StarOp)\n    this.rules[43].opcodes[12] = {\n        type: 4,\n        index: 70\n    }; // RNM(rep-min-max)\n    /* AltOp */ this.rules[44].opcodes = [];\n    this.rules[44].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[44].opcodes[1] = {\n        type: 6,\n        string: [\n            47\n        ]\n    }; // TBS\n    this.rules[44].opcodes[2] = {\n        type: 4,\n        index: 89\n    }; // RNM(owsp)\n    /* CatOp */ this.rules[45].opcodes = [];\n    this.rules[45].opcodes[0] = {\n        type: 4,\n        index: 90\n    }; // RNM(wsp)\n    /* StarOp */ this.rules[46].opcodes = [];\n    this.rules[46].opcodes[0] = {\n        type: 6,\n        string: [\n            42\n        ]\n    }; // TBS\n    /* AndOp */ this.rules[47].opcodes = [];\n    this.rules[47].opcodes[0] = {\n        type: 6,\n        string: [\n            38\n        ]\n    }; // TBS\n    /* NotOp */ this.rules[48].opcodes = [];\n    this.rules[48].opcodes[0] = {\n        type: 6,\n        string: [\n            33\n        ]\n    }; // TBS\n    /* BkaOp */ this.rules[49].opcodes = [];\n    this.rules[49].opcodes[0] = {\n        type: 6,\n        string: [\n            38,\n            38\n        ]\n    }; // TBS\n    /* BknOp */ this.rules[50].opcodes = [];\n    this.rules[50].opcodes[0] = {\n        type: 6,\n        string: [\n            33,\n            33\n        ]\n    }; // TBS\n    /* AbgOp */ this.rules[51].opcodes = [];\n    this.rules[51].opcodes[0] = {\n        type: 6,\n        string: [\n            37,\n            94\n        ]\n    }; // TBS\n    /* AenOp */ this.rules[52].opcodes = [];\n    this.rules[52].opcodes[0] = {\n        type: 6,\n        string: [\n            37,\n            36\n        ]\n    }; // TBS\n    /* TrgOp */ this.rules[53].opcodes = [];\n    this.rules[53].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[53].opcodes[1] = {\n        type: 6,\n        string: [\n            37\n        ]\n    }; // TBS\n    this.rules[53].opcodes[2] = {\n        type: 1,\n        children: [\n            3,\n            8,\n            13\n        ]\n    }; // ALT\n    this.rules[53].opcodes[3] = {\n        type: 2,\n        children: [\n            4,\n            5,\n            6,\n            7\n        ]\n    }; // CAT\n    this.rules[53].opcodes[4] = {\n        type: 4,\n        index: 76\n    }; // RNM(Dec)\n    this.rules[53].opcodes[5] = {\n        type: 4,\n        index: 79\n    }; // RNM(dmin)\n    this.rules[53].opcodes[6] = {\n        type: 6,\n        string: [\n            45\n        ]\n    }; // TBS\n    this.rules[53].opcodes[7] = {\n        type: 4,\n        index: 80\n    }; // RNM(dmax)\n    this.rules[53].opcodes[8] = {\n        type: 2,\n        children: [\n            9,\n            10,\n            11,\n            12\n        ]\n    }; // CAT\n    this.rules[53].opcodes[9] = {\n        type: 4,\n        index: 77\n    }; // RNM(Hex)\n    this.rules[53].opcodes[10] = {\n        type: 4,\n        index: 83\n    }; // RNM(xmin)\n    this.rules[53].opcodes[11] = {\n        type: 6,\n        string: [\n            45\n        ]\n    }; // TBS\n    this.rules[53].opcodes[12] = {\n        type: 4,\n        index: 84\n    }; // RNM(xmax)\n    this.rules[53].opcodes[13] = {\n        type: 2,\n        children: [\n            14,\n            15,\n            16,\n            17\n        ]\n    }; // CAT\n    this.rules[53].opcodes[14] = {\n        type: 4,\n        index: 78\n    }; // RNM(Bin)\n    this.rules[53].opcodes[15] = {\n        type: 4,\n        index: 81\n    }; // RNM(bmin)\n    this.rules[53].opcodes[16] = {\n        type: 6,\n        string: [\n            45\n        ]\n    }; // TBS\n    this.rules[53].opcodes[17] = {\n        type: 4,\n        index: 82\n    }; // RNM(bmax)\n    /* TbsOp */ this.rules[54].opcodes = [];\n    this.rules[54].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[54].opcodes[1] = {\n        type: 6,\n        string: [\n            37\n        ]\n    }; // TBS\n    this.rules[54].opcodes[2] = {\n        type: 1,\n        children: [\n            3,\n            10,\n            17\n        ]\n    }; // ALT\n    this.rules[54].opcodes[3] = {\n        type: 2,\n        children: [\n            4,\n            5,\n            6\n        ]\n    }; // CAT\n    this.rules[54].opcodes[4] = {\n        type: 4,\n        index: 76\n    }; // RNM(Dec)\n    this.rules[54].opcodes[5] = {\n        type: 4,\n        index: 73\n    }; // RNM(dString)\n    this.rules[54].opcodes[6] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[54].opcodes[7] = {\n        type: 2,\n        children: [\n            8,\n            9\n        ]\n    }; // CAT\n    this.rules[54].opcodes[8] = {\n        type: 6,\n        string: [\n            46\n        ]\n    }; // TBS\n    this.rules[54].opcodes[9] = {\n        type: 4,\n        index: 73\n    }; // RNM(dString)\n    this.rules[54].opcodes[10] = {\n        type: 2,\n        children: [\n            11,\n            12,\n            13\n        ]\n    }; // CAT\n    this.rules[54].opcodes[11] = {\n        type: 4,\n        index: 77\n    }; // RNM(Hex)\n    this.rules[54].opcodes[12] = {\n        type: 4,\n        index: 74\n    }; // RNM(xString)\n    this.rules[54].opcodes[13] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[54].opcodes[14] = {\n        type: 2,\n        children: [\n            15,\n            16\n        ]\n    }; // CAT\n    this.rules[54].opcodes[15] = {\n        type: 6,\n        string: [\n            46\n        ]\n    }; // TBS\n    this.rules[54].opcodes[16] = {\n        type: 4,\n        index: 74\n    }; // RNM(xString)\n    this.rules[54].opcodes[17] = {\n        type: 2,\n        children: [\n            18,\n            19,\n            20\n        ]\n    }; // CAT\n    this.rules[54].opcodes[18] = {\n        type: 4,\n        index: 78\n    }; // RNM(Bin)\n    this.rules[54].opcodes[19] = {\n        type: 4,\n        index: 75\n    }; // RNM(bString)\n    this.rules[54].opcodes[20] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[54].opcodes[21] = {\n        type: 2,\n        children: [\n            22,\n            23\n        ]\n    }; // CAT\n    this.rules[54].opcodes[22] = {\n        type: 6,\n        string: [\n            46\n        ]\n    }; // TBS\n    this.rules[54].opcodes[23] = {\n        type: 4,\n        index: 75\n    }; // RNM(bString)\n    /* TlsOp */ this.rules[55].opcodes = [];\n    this.rules[55].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2,\n            3,\n            4\n        ]\n    }; // CAT\n    this.rules[55].opcodes[1] = {\n        type: 4,\n        index: 56\n    }; // RNM(TlsCase)\n    this.rules[55].opcodes[2] = {\n        type: 4,\n        index: 57\n    }; // RNM(TlsOpen)\n    this.rules[55].opcodes[3] = {\n        type: 4,\n        index: 59\n    }; // RNM(TlsString)\n    this.rules[55].opcodes[4] = {\n        type: 4,\n        index: 58\n    }; // RNM(TlsClose)\n    /* TlsCase */ this.rules[56].opcodes = [];\n    this.rules[56].opcodes[0] = {\n        type: 3,\n        min: 0,\n        max: 1\n    }; // REP\n    this.rules[56].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3\n        ]\n    }; // ALT\n    this.rules[56].opcodes[2] = {\n        type: 7,\n        string: [\n            37,\n            105\n        ]\n    }; // TLS\n    this.rules[56].opcodes[3] = {\n        type: 7,\n        string: [\n            37,\n            115\n        ]\n    }; // TLS\n    /* TlsOpen */ this.rules[57].opcodes = [];\n    this.rules[57].opcodes[0] = {\n        type: 6,\n        string: [\n            34\n        ]\n    }; // TBS\n    /* TlsClose */ this.rules[58].opcodes = [];\n    this.rules[58].opcodes[0] = {\n        type: 6,\n        string: [\n            34\n        ]\n    }; // TBS\n    /* TlsString */ this.rules[59].opcodes = [];\n    this.rules[59].opcodes[0] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[59].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3,\n            4\n        ]\n    }; // ALT\n    this.rules[59].opcodes[2] = {\n        type: 5,\n        min: 32,\n        max: 33\n    }; // TRG\n    this.rules[59].opcodes[3] = {\n        type: 5,\n        min: 35,\n        max: 126\n    }; // TRG\n    this.rules[59].opcodes[4] = {\n        type: 4,\n        index: 60\n    }; // RNM(StringTab)\n    /* StringTab */ this.rules[60].opcodes = [];\n    this.rules[60].opcodes[0] = {\n        type: 6,\n        string: [\n            9\n        ]\n    }; // TBS\n    /* ClsOp */ this.rules[61].opcodes = [];\n    this.rules[61].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2,\n            3\n        ]\n    }; // CAT\n    this.rules[61].opcodes[1] = {\n        type: 4,\n        index: 62\n    }; // RNM(ClsOpen)\n    this.rules[61].opcodes[2] = {\n        type: 4,\n        index: 64\n    }; // RNM(ClsString)\n    this.rules[61].opcodes[3] = {\n        type: 4,\n        index: 63\n    }; // RNM(ClsClose)\n    /* ClsOpen */ this.rules[62].opcodes = [];\n    this.rules[62].opcodes[0] = {\n        type: 6,\n        string: [\n            39\n        ]\n    }; // TBS\n    /* ClsClose */ this.rules[63].opcodes = [];\n    this.rules[63].opcodes[0] = {\n        type: 6,\n        string: [\n            39\n        ]\n    }; // TBS\n    /* ClsString */ this.rules[64].opcodes = [];\n    this.rules[64].opcodes[0] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[64].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3,\n            4\n        ]\n    }; // ALT\n    this.rules[64].opcodes[2] = {\n        type: 5,\n        min: 32,\n        max: 38\n    }; // TRG\n    this.rules[64].opcodes[3] = {\n        type: 5,\n        min: 40,\n        max: 126\n    }; // TRG\n    this.rules[64].opcodes[4] = {\n        type: 4,\n        index: 60\n    }; // RNM(StringTab)\n    /* ProsVal */ this.rules[65].opcodes = [];\n    this.rules[65].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2,\n            3\n        ]\n    }; // CAT\n    this.rules[65].opcodes[1] = {\n        type: 4,\n        index: 66\n    }; // RNM(ProsValOpen)\n    this.rules[65].opcodes[2] = {\n        type: 4,\n        index: 67\n    }; // RNM(ProsValString)\n    this.rules[65].opcodes[3] = {\n        type: 4,\n        index: 68\n    }; // RNM(ProsValClose)\n    /* ProsValOpen */ this.rules[66].opcodes = [];\n    this.rules[66].opcodes[0] = {\n        type: 6,\n        string: [\n            60\n        ]\n    }; // TBS\n    /* ProsValString */ this.rules[67].opcodes = [];\n    this.rules[67].opcodes[0] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[67].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3,\n            4\n        ]\n    }; // ALT\n    this.rules[67].opcodes[2] = {\n        type: 5,\n        min: 32,\n        max: 61\n    }; // TRG\n    this.rules[67].opcodes[3] = {\n        type: 5,\n        min: 63,\n        max: 126\n    }; // TRG\n    this.rules[67].opcodes[4] = {\n        type: 4,\n        index: 60\n    }; // RNM(StringTab)\n    /* ProsValClose */ this.rules[68].opcodes = [];\n    this.rules[68].opcodes[0] = {\n        type: 6,\n        string: [\n            62\n        ]\n    }; // TBS\n    /* rep-min */ this.rules[69].opcodes = [];\n    this.rules[69].opcodes[0] = {\n        type: 4,\n        index: 72\n    }; // RNM(rep-num)\n    /* rep-min-max */ this.rules[70].opcodes = [];\n    this.rules[70].opcodes[0] = {\n        type: 4,\n        index: 72\n    }; // RNM(rep-num)\n    /* rep-max */ this.rules[71].opcodes = [];\n    this.rules[71].opcodes[0] = {\n        type: 4,\n        index: 72\n    }; // RNM(rep-num)\n    /* rep-num */ this.rules[72].opcodes = [];\n    this.rules[72].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[72].opcodes[1] = {\n        type: 5,\n        min: 48,\n        max: 57\n    }; // TRG\n    /* dString */ this.rules[73].opcodes = [];\n    this.rules[73].opcodes[0] = {\n        type: 4,\n        index: 85\n    }; // RNM(dnum)\n    /* xString */ this.rules[74].opcodes = [];\n    this.rules[74].opcodes[0] = {\n        type: 4,\n        index: 87\n    }; // RNM(xnum)\n    /* bString */ this.rules[75].opcodes = [];\n    this.rules[75].opcodes[0] = {\n        type: 4,\n        index: 86\n    }; // RNM(bnum)\n    /* Dec */ this.rules[76].opcodes = [];\n    this.rules[76].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2\n        ]\n    }; // ALT\n    this.rules[76].opcodes[1] = {\n        type: 6,\n        string: [\n            68\n        ]\n    }; // TBS\n    this.rules[76].opcodes[2] = {\n        type: 6,\n        string: [\n            100\n        ]\n    }; // TBS\n    /* Hex */ this.rules[77].opcodes = [];\n    this.rules[77].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2\n        ]\n    }; // ALT\n    this.rules[77].opcodes[1] = {\n        type: 6,\n        string: [\n            88\n        ]\n    }; // TBS\n    this.rules[77].opcodes[2] = {\n        type: 6,\n        string: [\n            120\n        ]\n    }; // TBS\n    /* Bin */ this.rules[78].opcodes = [];\n    this.rules[78].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2\n        ]\n    }; // ALT\n    this.rules[78].opcodes[1] = {\n        type: 6,\n        string: [\n            66\n        ]\n    }; // TBS\n    this.rules[78].opcodes[2] = {\n        type: 6,\n        string: [\n            98\n        ]\n    }; // TBS\n    /* dmin */ this.rules[79].opcodes = [];\n    this.rules[79].opcodes[0] = {\n        type: 4,\n        index: 85\n    }; // RNM(dnum)\n    /* dmax */ this.rules[80].opcodes = [];\n    this.rules[80].opcodes[0] = {\n        type: 4,\n        index: 85\n    }; // RNM(dnum)\n    /* bmin */ this.rules[81].opcodes = [];\n    this.rules[81].opcodes[0] = {\n        type: 4,\n        index: 86\n    }; // RNM(bnum)\n    /* bmax */ this.rules[82].opcodes = [];\n    this.rules[82].opcodes[0] = {\n        type: 4,\n        index: 86\n    }; // RNM(bnum)\n    /* xmin */ this.rules[83].opcodes = [];\n    this.rules[83].opcodes[0] = {\n        type: 4,\n        index: 87\n    }; // RNM(xnum)\n    /* xmax */ this.rules[84].opcodes = [];\n    this.rules[84].opcodes[0] = {\n        type: 4,\n        index: 87\n    }; // RNM(xnum)\n    /* dnum */ this.rules[85].opcodes = [];\n    this.rules[85].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[85].opcodes[1] = {\n        type: 5,\n        min: 48,\n        max: 57\n    }; // TRG\n    /* bnum */ this.rules[86].opcodes = [];\n    this.rules[86].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[86].opcodes[1] = {\n        type: 5,\n        min: 48,\n        max: 49\n    }; // TRG\n    /* xnum */ this.rules[87].opcodes = [];\n    this.rules[87].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[87].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3,\n            4\n        ]\n    }; // ALT\n    this.rules[87].opcodes[2] = {\n        type: 5,\n        min: 48,\n        max: 57\n    }; // TRG\n    this.rules[87].opcodes[3] = {\n        type: 5,\n        min: 65,\n        max: 70\n    }; // TRG\n    this.rules[87].opcodes[4] = {\n        type: 5,\n        min: 97,\n        max: 102\n    }; // TRG\n    /* alphanum */ this.rules[88].opcodes = [];\n    this.rules[88].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            4\n        ]\n    }; // CAT\n    this.rules[88].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3\n        ]\n    }; // ALT\n    this.rules[88].opcodes[2] = {\n        type: 5,\n        min: 97,\n        max: 122\n    }; // TRG\n    this.rules[88].opcodes[3] = {\n        type: 5,\n        min: 65,\n        max: 90\n    }; // TRG\n    this.rules[88].opcodes[4] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[88].opcodes[5] = {\n        type: 1,\n        children: [\n            6,\n            7,\n            8,\n            9\n        ]\n    }; // ALT\n    this.rules[88].opcodes[6] = {\n        type: 5,\n        min: 97,\n        max: 122\n    }; // TRG\n    this.rules[88].opcodes[7] = {\n        type: 5,\n        min: 65,\n        max: 90\n    }; // TRG\n    this.rules[88].opcodes[8] = {\n        type: 5,\n        min: 48,\n        max: 57\n    }; // TRG\n    this.rules[88].opcodes[9] = {\n        type: 6,\n        string: [\n            45\n        ]\n    }; // TBS\n    /* owsp */ this.rules[89].opcodes = [];\n    this.rules[89].opcodes[0] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[89].opcodes[1] = {\n        type: 4,\n        index: 91\n    }; // RNM(space)\n    /* wsp */ this.rules[90].opcodes = [];\n    this.rules[90].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[90].opcodes[1] = {\n        type: 4,\n        index: 91\n    }; // RNM(space)\n    /* space */ this.rules[91].opcodes = [];\n    this.rules[91].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2,\n            3,\n            4\n        ]\n    }; // ALT\n    this.rules[91].opcodes[1] = {\n        type: 6,\n        string: [\n            32\n        ]\n    }; // TBS\n    this.rules[91].opcodes[2] = {\n        type: 6,\n        string: [\n            9\n        ]\n    }; // TBS\n    this.rules[91].opcodes[3] = {\n        type: 4,\n        index: 92\n    }; // RNM(comment)\n    this.rules[91].opcodes[4] = {\n        type: 4,\n        index: 94\n    }; // RNM(LineContinue)\n    /* comment */ this.rules[92].opcodes = [];\n    this.rules[92].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[92].opcodes[1] = {\n        type: 6,\n        string: [\n            59\n        ]\n    }; // TBS\n    this.rules[92].opcodes[2] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[92].opcodes[3] = {\n        type: 1,\n        children: [\n            4,\n            5\n        ]\n    }; // ALT\n    this.rules[92].opcodes[4] = {\n        type: 5,\n        min: 32,\n        max: 126\n    }; // TRG\n    this.rules[92].opcodes[5] = {\n        type: 6,\n        string: [\n            9\n        ]\n    }; // TBS\n    /* LineEnd */ this.rules[93].opcodes = [];\n    this.rules[93].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2,\n            3\n        ]\n    }; // ALT\n    this.rules[93].opcodes[1] = {\n        type: 6,\n        string: [\n            13,\n            10\n        ]\n    }; // TBS\n    this.rules[93].opcodes[2] = {\n        type: 6,\n        string: [\n            10\n        ]\n    }; // TBS\n    this.rules[93].opcodes[3] = {\n        type: 6,\n        string: [\n            13\n        ]\n    }; // TBS\n    /* LineContinue */ this.rules[94].opcodes = [];\n    this.rules[94].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            5\n        ]\n    }; // CAT\n    this.rules[94].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3,\n            4\n        ]\n    }; // ALT\n    this.rules[94].opcodes[2] = {\n        type: 6,\n        string: [\n            13,\n            10\n        ]\n    }; // TBS\n    this.rules[94].opcodes[3] = {\n        type: 6,\n        string: [\n            10\n        ]\n    }; // TBS\n    this.rules[94].opcodes[4] = {\n        type: 6,\n        string: [\n            13\n        ]\n    }; // TBS\n    this.rules[94].opcodes[5] = {\n        type: 1,\n        children: [\n            6,\n            7\n        ]\n    }; // ALT\n    this.rules[94].opcodes[6] = {\n        type: 6,\n        string: [\n            32\n        ]\n    }; // TBS\n    this.rules[94].opcodes[7] = {\n        type: 6,\n        string: [\n            9\n        ]\n    }; // TBS\n    // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n    this.toString = function toString() {\n        let str = \"\";\n        str += \";\\n\";\n        str += \"; ABNF for JavaScript APG 2.0 SABNF\\n\";\n        str += \"; RFC 5234 with some restrictions and additions.\\n\";\n        str += \"; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\\n\";\n        str += ';  - accepts %s\"string\" as a case-sensitive string\\n';\n        str += ';  - accepts %i\"string\" as a case-insensitive string\\n';\n        str += ';  - accepts \"string\" as a case-insensitive string\\n';\n        str += \";\\n\";\n        str += \"; Some restrictions:\\n\";\n        str += \";   1. Rules must begin at first character of each line.\\n\";\n        str += \";      Indentations on first rule and rules thereafter are not allowed.\\n\";\n        str += \";   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\\n\";\n        str += \";   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\\n\";\n        str += \";      However, a working parser cannot be generated from them.\\n\";\n        str += \";\\n\";\n        str += \"; Super set (SABNF) additions:\\n\";\n        str += \";   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\\n\";\n        str += \";      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\\n\";\n        str += \";      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\\n\";\n        str += \";      e.g. &%d13 or &rule or !(A / B)\\n\";\n        str += \";   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\\n\";\n        str += \";      'name' is alpha followed by alpha/num/hyphen just like a rule name.\\n\";\n        str += \";      u_name may be used as an element but no rule definition is given.\\n\";\n        str += \";      e.g. rule = A / u_myUdt\\n\";\n        str += ';           A = \"a\"\\n';\n        str += \";      would be a valid grammar.\\n\";\n        str += \";   3. Case-sensitive, single-quoted strings are accepted.\\n\";\n        str += \";      e.g. 'abc' would be equivalent to %d97.98.99\\n\";\n        str += ';      (kept for backward compatibility, but superseded by %s\"abc\")  \\n';\n        str += \"; New 12/26/2015\\n\";\n        str += \";   4. Look-behind operators are accepted as element prefixes.\\n\";\n        str += \";      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\\n\";\n        str += \";      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\\n\";\n        str += \";      e.g. &&%d13 or &&rule or !!(A / B)\\n\";\n        str += \";   5. Back reference operators, i.e. \\\\rulename, are accepted.\\n\";\n        str += \";      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\\n\";\n        str += \";      to match is a phrase previously matched by the rule 'rulename'.\\n\";\n        str += \";      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\\n\";\n        str += \";      In universal mode, \\\\rulename matches the last match to 'rulename' regardless of where it was found.\\n\";\n        str += \";      In parent-frame mode, \\\\rulename matches only the last match found on the parent's frame or parse tree level.\\n\";\n        str += \";      Back reference modifiers can be used to specify case and mode.\\n\";\n        str += \";      \\\\A defaults to case-insensitive and universal mode, e.g. \\\\A === \\\\%i%uA\\n\";\n        str += \";      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\\n\";\n        str += \";      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\\n\";\n        str += \";      Case and mode modifiers can appear in any order, e.g. \\\\%s%pA === \\\\%p%sA. \\n\";\n        str += \";   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\\n\";\n        str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n        str += \";   8. String end anchor, AEN(%$) matches the end of the input string location.\\n\";\n        str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n        str += \";\\n\";\n        str += \"File            = *(BlankLine / Rule / RuleError)\\n\";\n        str += \"BlankLine       = *(%d32/%d9) [comment] LineEnd\\n\";\n        str += \"Rule            = RuleLookup owsp Alternation ((owsp LineEnd)\\n\";\n        str += \"                / (LineEndError LineEnd))\\n\";\n        str += \"RuleLookup      = RuleNameTest owsp DefinedAsTest\\n\";\n        str += \"RuleNameTest    = RuleName/RuleNameError\\n\";\n        str += \"RuleName        = alphanum\\n\";\n        str += \"RuleNameError   = 1*(%d33-60/%d62-126)\\n\";\n        str += \"DefinedAsTest   = DefinedAs / DefinedAsError\\n\";\n        str += \"DefinedAsError  = 1*2%d33-126\\n\";\n        str += \"DefinedAs       = IncAlt / Defined\\n\";\n        str += \"Defined         = %d61\\n\";\n        str += \"IncAlt          = %d61.47\\n\";\n        str += \"RuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\\n\";\n        str += \"LineEndError    = 1*(%d32-126 / %d9  / LineContinue)\\n\";\n        str += \"Alternation     = Concatenation *(owsp AltOp Concatenation)\\n\";\n        str += \"Concatenation   = Repetition *(CatOp Repetition)\\n\";\n        str += \"Repetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\\n\";\n        str += \"Modifier        = (Predicate [RepOp])\\n\";\n        str += \"                / RepOp\\n\";\n        str += \"Predicate       = BkaOp\\n\";\n        str += \"                / BknOp\\n\";\n        str += \"                / AndOp\\n\";\n        str += \"                / NotOp\\n\";\n        str += \"BasicElement    = UdtOp\\n\";\n        str += \"                / RnmOp\\n\";\n        str += \"                / TrgOp\\n\";\n        str += \"                / TbsOp\\n\";\n        str += \"                / TlsOp\\n\";\n        str += \"                / ClsOp\\n\";\n        str += \"                / BkrOp\\n\";\n        str += \"                / AbgOp\\n\";\n        str += \"                / AenOp\\n\";\n        str += \"                / ProsVal\\n\";\n        str += \"BasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\\n\";\n        str += \"Group           = GroupOpen  Alternation (GroupClose / GroupError)\\n\";\n        str += \"GroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n        str += \"GroupOpen       = %d40 owsp\\n\";\n        str += \"GroupClose      = owsp %d41\\n\";\n        str += \"Option          = OptionOpen Alternation (OptionClose / OptionError)\\n\";\n        str += \"OptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n        str += \"OptionOpen      = %d91 owsp\\n\";\n        str += \"OptionClose     = owsp %d93\\n\";\n        str += \"RnmOp           = alphanum\\n\";\n        str += \"BkrOp           = %d92 [bkrModifier] bkr-name\\n\";\n        str += \"bkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\\n\";\n        str += \"cs              = '%s'\\n\";\n        str += \"ci              = '%i'\\n\";\n        str += \"um              = '%u'\\n\";\n        str += \"pm              = '%p'\\n\";\n        str += \"bkr-name        = uname / ename / rname\\n\";\n        str += \"rname           = alphanum\\n\";\n        str += \"uname           = %d117.95 alphanum\\n\";\n        str += \"ename           = %d101.95 alphanum\\n\";\n        str += \"UdtOp           = udt-empty\\n\";\n        str += \"                / udt-non-empty\\n\";\n        str += \"udt-non-empty   = %d117.95 alphanum\\n\";\n        str += \"udt-empty       = %d101.95 alphanum\\n\";\n        str += \"RepOp           = (rep-min StarOp rep-max)\\n\";\n        str += \"                / (rep-min StarOp)\\n\";\n        str += \"                / (StarOp rep-max)\\n\";\n        str += \"                / StarOp\\n\";\n        str += \"                / rep-min-max\\n\";\n        str += \"AltOp           = %d47 owsp\\n\";\n        str += \"CatOp           = wsp\\n\";\n        str += \"StarOp          = %d42\\n\";\n        str += \"AndOp           = %d38\\n\";\n        str += \"NotOp           = %d33\\n\";\n        str += \"BkaOp           = %d38.38\\n\";\n        str += \"BknOp           = %d33.33\\n\";\n        str += \"AbgOp           = %d37.94\\n\";\n        str += \"AenOp           = %d37.36\\n\";\n        str += \"TrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\\n\";\n        str += \"TbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\\n\";\n        str += \"TlsOp           = TlsCase TlsOpen TlsString TlsClose\\n\";\n        str += 'TlsCase         = [\"%i\" / \"%s\"]\\n';\n        str += \"TlsOpen         = %d34\\n\";\n        str += \"TlsClose        = %d34\\n\";\n        str += \"TlsString       = *(%d32-33/%d35-126/StringTab)\\n\";\n        str += \"StringTab       = %d9\\n\";\n        str += \"ClsOp           = ClsOpen ClsString ClsClose\\n\";\n        str += \"ClsOpen         = %d39\\n\";\n        str += \"ClsClose        = %d39\\n\";\n        str += \"ClsString       = *(%d32-38/%d40-126/StringTab)\\n\";\n        str += \"ProsVal         = ProsValOpen ProsValString ProsValClose\\n\";\n        str += \"ProsValOpen     = %d60\\n\";\n        str += \"ProsValString   = *(%d32-61/%d63-126/StringTab)\\n\";\n        str += \"ProsValClose    = %d62\\n\";\n        str += \"rep-min         = rep-num\\n\";\n        str += \"rep-min-max     = rep-num\\n\";\n        str += \"rep-max         = rep-num\\n\";\n        str += \"rep-num         = 1*(%d48-57)\\n\";\n        str += \"dString         = dnum\\n\";\n        str += \"xString         = xnum\\n\";\n        str += \"bString         = bnum\\n\";\n        str += \"Dec             = (%d68/%d100)\\n\";\n        str += \"Hex             = (%d88/%d120)\\n\";\n        str += \"Bin             = (%d66/%d98)\\n\";\n        str += \"dmin            = dnum\\n\";\n        str += \"dmax            = dnum\\n\";\n        str += \"bmin            = bnum\\n\";\n        str += \"bmax            = bnum\\n\";\n        str += \"xmin            = xnum\\n\";\n        str += \"xmax            = xnum\\n\";\n        str += \"dnum            = 1*(%d48-57)\\n\";\n        str += \"bnum            = 1*%d48-49\\n\";\n        str += \"xnum            = 1*(%d48-57 / %d65-70 / %d97-102)\\n\";\n        str += \";\\n\";\n        str += \"; Basics\\n\";\n        str += \"alphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\\n\";\n        str += \"owsp            = *space\\n\";\n        str += \"wsp             = 1*space\\n\";\n        str += \"space           = %d32\\n\";\n        str += \"                / %d9\\n\";\n        str += \"                / comment\\n\";\n        str += \"                / LineContinue\\n\";\n        str += \"comment         = %d59 *(%d32-126 / %d9)\\n\";\n        str += \"LineEnd         = %d13.10\\n\";\n        str += \"                / %d10\\n\";\n        str += \"                / %d13\\n\";\n        str += \"LineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\\n\";\n        return str;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NhYm5mLWdyYW1tYXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsMEVBQTBFO0FBQzFFLDZFQUE2RTtBQUM3RSxFQUFFO0FBQ0Ysa0ZBQWtGOztBQUNsRkEsT0FBT0MsT0FBTyxHQUFHLFNBQVNDO0lBQ3hCLE1BQU07SUFDTixVQUFVO0lBQ1Ysa0JBQWtCO0lBQ2xCLGlCQUFpQjtJQUNqQixtQkFBbUI7SUFDbkIscUNBQXFDO0lBQ3JDLGtCQUFrQjtJQUNsQixrQkFBa0I7SUFDbEIsa0JBQWtCO0lBQ2xCLG1CQUFtQjtJQUNuQixpQkFBaUI7SUFDakIsa0JBQWtCO0lBQ2xCLGtCQUFrQjtJQUNsQixzQ0FBc0M7SUFDdEMsaUJBQWlCO0lBQ2pCLGlCQUFpQjtJQUNqQixpQkFBaUI7SUFDakIsaUJBQWlCO0lBQ2pCLGlCQUFpQjtJQUNqQixpQkFBaUI7SUFDakIsaUJBQWlCO0lBQ2pCLGlCQUFpQjtJQUNqQix5QkFBeUI7SUFDekIsTUFBTTtJQUNOLCtDQUErQyxHQUMvQyxJQUFJLENBQUNDLGFBQWEsR0FBRztJQUVyQixTQUFTLEdBQ1QsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtJQUNmLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsR0FBRztRQUFDQyxNQUFNO1FBQVFDLE9BQU87UUFBUUMsT0FBTztRQUFHQyxPQUFPO0lBQUs7SUFDcEUsSUFBSSxDQUFDSixLQUFLLENBQUMsRUFBRSxHQUFHO1FBQUNDLE1BQU07UUFBYUMsT0FBTztRQUFhQyxPQUFPO1FBQUdDLE9BQU87SUFBSztJQUM5RSxJQUFJLENBQUNKLEtBQUssQ0FBQyxFQUFFLEdBQUc7UUFBQ0MsTUFBTTtRQUFRQyxPQUFPO1FBQVFDLE9BQU87UUFBR0MsT0FBTztJQUFLO0lBQ3BFLElBQUksQ0FBQ0osS0FBSyxDQUFDLEVBQUUsR0FBRztRQUFDQyxNQUFNO1FBQWND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QUFDLEdBQUcsR0FBRztRQUFDQyxNQUFNO1FBQVNDLE9BQU87UUFBU0MsT0FBTztRQUFJQyxPQUFPO0lBQUs7SUFDeEUsSUFBSSxDQUFDSixLQUFLLENBQUMsR0FBRyxHQUFHO1FBQUNDLE1BQU07UUFBVUMsT0FBTztRQUFVQyxPQUFPO1FBQUlDLE9BQU87SUFBSztJQUMxRSxJQUFJLENBQUNKLEtBQUssQ0FBQyxHQUFHLEdBQUc7UUFBQ0MsTUFBTTtRQUFTQyxPQUFPO1FBQVNDLE9BQU87UUFBSUMsT0FBTztJQUFLO0lBQ3hFLElBQUksQ0FBQ0osS0FBSyxDQUFDLEdBQUcsR0FBRztRQUFDQyxNQUFNO1FBQVNDLE9BQU87UUFBU0MsT0FBTztRQUFJQyxPQUFPO0lBQUs7SUFDeEUsSUFBSSxDQUFDSixLQUFLLENBQUMsR0FBRyxHQUFHO1FBQUNDLE1BQU07UUFBU0MsT0FBTztRQUFTQyxPQUFPO1FBQUlDLE9BQU87SUFBSztJQUN4RSxJQUFJLENBQUNKLEtBQUssQ0FBQyxHQUFHLEdBQUc7UUFBQ0MsTUFBTTtRQUFTQyxPQUFPO1FBQVNDLE9BQU87UUFBSUMsT0FBTztJQUFLO0lBQ3hFLElBQUksQ0FBQ0osS0FBSyxDQUFDLEdBQUcsR0FBRztRQUFDQyxNQUFNO1FBQVNDLE9BQU87UUFBU0MsT0FBTztRQUFJQyxPQUFPO0lBQUs7SUFDeEUsSUFBSSxDQUFDSixLQUFLLENBQUMsR0FBRyxHQUFHO1FBQUNDLE1BQU07UUFBU0MsT0FBTztRQUFTQyxPQUFPO1FBQUlDLE9BQU87SUFBSztJQUN4RSxJQUFJLENBQUNKLEtBQUssQ0FBQyxHQUFHLEdBQUc7UUFBQ0MsTUFBTTtRQUFTQyxPQUFPO1FBQVNDLE9BQU87UUFBSUMsT0FBTztJQUFLO0lBQ3hFLElBQUksQ0FBQ0osS0FBSyxDQUFDLEdBQUcsR0FBRztRQUFDQyxNQUFNO1FBQVNDLE9BQU87UUFBU0MsT0FBTztRQUFJQyxPQUFPO0lBQUs7SUFDeEUsSUFBSSxDQUFDSixLQUFLLENBQUMsR0FBRyxHQUFHO1FBQUNDLE1BQU07UUFBU0MsT0FBTztRQUFT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LE9BQU87UUFBT0MsT0FBTztRQUFJQyxPQUFPO0lBQUs7SUFDcEUsSUFBSSxDQUFDSixLQUFLLENBQUMsR0FBRyxHQUFHO1FBQUNDLE1BQU07UUFBT0MsT0FBTztRQUFPQyxPQUFPO1FBQUlDLE9BQU87SUFBSztJQUNwRSxJQUFJLENBQUNKLEtBQUssQ0FBQyxHQUFHLEdBQUc7UUFBQ0MsTUFBTTtRQUFPQyxPQUFPO1FBQU9DLE9BQU87UUFBSUMsT0FBTztJQUFLO0lBQ3BFLElBQUksQ0FBQ0osS0FBSyxDQUFDLEdBQUcsR0FBRztRQUFDQyxNQUFNO1FBQVFDLE9BQU87UUFBUUMsT0FBTztRQUFJQyxPQUFPO0lBQUs7SUFDdEUsSUFBSSxDQUFDSixLQUFLLENBQUMsR0FBRyxHQUFHO1FBQUNDLE1BQU07UUFBUUMsT0FBTztRQUFRQyxPQUFPO1FBQUlDLE9BQU87SUFBSztJQUN0RSxJQUFJLENBQUNKLEtBQUssQ0FBQyxHQUFHLEdBQUc7UUFBQ0MsTUFBTTtRQUFRQyxPQUFPO1FBQVFDLE9BQU87UUFBSUMsT0FBTztJQUFLO0lBQ3RFLElBQUksQ0FBQ0osS0FBSyxDQUFDLEdBQUcsR0FBRztRQUFDQyxNQUFNO1FBQVFDLE9BQU87UUFBUUMsT0FBTztRQUFJQyxPQUFPO0lBQUs7SUFDdEUsSUFBSSxDQUFDSixLQUFLLENBQUMsR0FBRyxHQUFHO1FBQUNDLE1BQU07UUFBUUMsT0FBTztRQUFRQyxPQUFPO1FBQUlDLE9BQU87SUFBSztJQUN0RSxJQUFJLENBQUNKLEtBQUssQ0FBQyxHQUFHLEdBQUc7UUFBQ0MsTUFBTTtRQUFRQyxPQUFPO1FBQVFDLE9BQU87UUFBSUMsT0FBTztJQUFLO0lBQ3RFLElBQUksQ0FBQ0osS0FBSyxDQUFDLEdBQUcsR0FBRztRQUFDQyxNQUFNO1FBQVFDLE9BQU87UUFBUUMsT0FBTztRQUFJQyxPQUFPO0lBQUs7SUFDdEUsSUFBSSxDQUFDSixLQUFLLENBQUMsR0FBRyxHQUFHO1FBQUNDLE1BQU07UUFBUUMsT0FBTztRQUFRQyxPQUFPO1FBQUlDLE9BQU87SUFBSztJQUN0RSxJ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QU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1AsT0FBT0E7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2FibmYtZ3JhbW1hci5qcz80NWRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIzIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWQ8YnI+XG4vLyAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpPGJyPlxuLy9cbi8vIEdlbmVyYXRlZCBieSBhcGctanMsIFZlcnNpb24gNC4yLjEgW2FwZy1qc10oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qcylcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ3JhbW1hcigpe1xuICAvLyBgYGBcbiAgLy8gU1VNTUFSWVxuICAvLyAgICAgIHJ1bGVzID0gOTVcbiAgLy8gICAgICAgdWR0cyA9IDBcbiAgLy8gICAgb3Bjb2RlcyA9IDM3MlxuICAvLyAgICAgICAgLS0tICAgQUJORiBvcmlnaW5hbCBvcGNvZGVzXG4gIC8vICAgICAgICBBTFQgPSA0M1xuICAvLyAgICAgICAgQ0FUID0gNDhcbiAgLy8gICAgICAgIFJFUCA9IDM0XG4gIC8vICAgICAgICBSTk0gPSAxNDlcbiAgLy8gICAgICAgIFRMUyA9IDJcbiAgLy8gICAgICAgIFRCUyA9IDYxXG4gIC8vICAgICAgICBUUkcgPSAzNVxuICAvLyAgICAgICAgLS0tICAgU0FCTkYgc3VwZXJzZXQgb3Bjb2Rlc1xuICAvLyAgICAgICAgVURUID0gMFxuICAvLyAgICAgICAgQU5EID0gMFxuICAvLyAgICAgICAgTk9UID0gMFxuICAvLyAgICAgICAgQktBID0gMFxuICAvLyAgICAgICAgQktOID0gMFxuICAvLyAgICAgICAgQktSID0gMFxuICAvLyAgICAgICAgQUJHID0gMFxuICAvLyAgICAgICAgQUVOID0gMFxuICAvLyBjaGFyYWN0ZXJzID0gWzkgLSAxMjZdXG4gIC8vIGBgYFxuICAvKiBPQkpFQ1QgSURFTlRJRklFUiAoZm9yIGludGVybmFsIHBhcnNlciB1c2UpICovXG4gIHRoaXMuZ3JhbW1hck9iamVjdCA9ICdncmFtbWFyT2JqZWN0JztcblxuICAvKiBSVUxFUyAqL1xuICB0aGlzLnJ1bGVzID0gW107XG4gIHRoaXMucnVsZXNbMF0gPSB7bmFtZTogJ0ZpbGUnLCBsb3dlcjogJ2ZpbGUnLCBpbmRleDogMCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxXSA9IHtuYW1lOiAnQmxhbmtMaW5lJywgbG93ZXI6ICdibGFua2xpbmUnLCBpbmRleDogMSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1syXSA9IHtuYW1lOiAnUnVsZScsIGxvd2VyOiAncnVsZScsIGluZGV4OiAyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzNdID0ge25hbWU6ICdSdWxlTG9va3VwJywgbG93ZXI6ICdydWxlbG9va3VwJywgaW5kZXg6IDMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNF0gPSB7bmFtZTogJ1J1bGVOYW1lVGVzdCcsIGxvd2VyOiAncnVsZW5hbWV0ZXN0JywgaW5kZXg6IDQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNV0gPSB7bmFtZTogJ1J1bGVOYW1lJywgbG93ZXI6ICdydWxlbmFtZScsIGluZGV4OiA1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzZdID0ge25hbWU6ICdSdWxlTmFtZUVycm9yJywgbG93ZXI6ICdydWxlbmFtZWVycm9yJywgaW5kZXg6IDYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbN10gPSB7bmFtZTogJ0RlZmluZWRBc1Rlc3QnLCBsb3dlcjogJ2RlZmluZWRhc3Rlc3QnLCBpbmRleDogNywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4XSA9IHtuYW1lOiAnRGVmaW5lZEFzRXJyb3InLCBsb3dlcjogJ2RlZmluZWRhc2Vycm9yJywgaW5kZXg6IDgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbOV0gPSB7bmFtZTogJ0RlZmluZWRBcycsIGxvd2VyOiAnZGVmaW5lZGFzJywgaW5kZXg6IDksIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTBdID0ge25hbWU6ICdEZWZpbmVkJywgbG93ZXI6ICdkZWZpbmVkJywgaW5kZXg6IDEwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzExXSA9IHtuYW1lOiAnSW5jQWx0JywgbG93ZXI6ICdpbmNhbHQnLCBpbmRleDogMTEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTJdID0ge25hbWU6ICdSdWxlRXJyb3InLCBsb3dlcjogJ3J1bGVlcnJvcicsIGluZGV4OiAxMiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxM10gPSB7bmFtZTogJ0xpbmVFbmRFcnJvcicsIGxvd2VyOiAnbGluZWVuZGVycm9yJywgaW5kZXg6IDEzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzE0XSA9IHtuYW1lOiAnQWx0ZXJuYXRpb24nLCBsb3dlcjogJ2FsdGVybmF0aW9uJywgaW5kZXg6IDE0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzE1XSA9IHtuYW1lOiAnQ29uY2F0ZW5hdGlvbicsIGxvd2VyOiAnY29uY2F0ZW5hdGlvbicsIGluZGV4OiAxNSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxNl0gPSB7bmFtZTogJ1JlcGV0aXRpb24nLCBsb3dlcjogJ3JlcGV0aXRpb24nLCBpbmRleDogMTYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMTddID0ge25hbWU6ICdNb2RpZmllcicsIGxvd2VyOiAnbW9kaWZpZXInLCBpbmRleDogMTcsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMThdID0ge25hbWU6ICdQcmVkaWNhdGUnLCBsb3dlcjogJ3ByZWRpY2F0ZScsIGluZGV4OiAxOCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1sxOV0gPSB7bmFtZTogJ0Jhc2ljRWxlbWVudCcsIGxvd2VyOiAnYmFzaWNlbGVtZW50JywgaW5kZXg6IDE5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzIwXSA9IHtuYW1lOiAnQmFzaWNFbGVtZW50RXJyJywgbG93ZXI6ICdiYXNpY2VsZW1lbnRlcnInLCBpbmRleDogMjAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjFdID0ge25hbWU6ICdHcm91cCcsIGxvd2VyOiAnZ3JvdXAnLCBpbmRleDogMjEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjJdID0ge25hbWU6ICdHcm91cEVycm9yJywgbG93ZXI6ICdncm91cGVycm9yJywgaW5kZXg6IDIyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzIzXSA9IHtuYW1lOiAnR3JvdXBPcGVuJywgbG93ZXI6ICdncm91cG9wZW4nLCBpbmRleDogMjMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjRdID0ge25hbWU6ICdHcm91cENsb3NlJywgbG93ZXI6ICdncm91cGNsb3NlJywgaW5kZXg6IDI0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzI1XSA9IHtuYW1lOiAnT3B0aW9uJywgbG93ZXI6ICdvcHRpb24nLCBpbmRleDogMjUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjZdID0ge25hbWU6ICdPcHRpb25FcnJvcicsIGxvd2VyOiAnb3B0aW9uZXJyb3InLCBpbmRleDogMjYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMjddID0ge25hbWU6ICdPcHRpb25PcGVuJywgbG93ZXI6ICdvcHRpb25vcGVuJywgaW5kZXg6IDI3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzI4XSA9IHtuYW1lOiAnT3B0aW9uQ2xvc2UnLCBsb3dlcjogJ29wdGlvbmNsb3NlJywgaW5kZXg6IDI4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzI5XSA9IHtuYW1lOiAnUm5tT3AnLCBsb3dlcjogJ3JubW9wJywgaW5kZXg6IDI5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMwXSA9IHtuYW1lOiAnQmtyT3AnLCBsb3dlcjogJ2Jrcm9wJywgaW5kZXg6IDMwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMxXSA9IHtuYW1lOiAnYmtyTW9kaWZpZXInLCBsb3dlcjogJ2Jrcm1vZGlmaWVyJywgaW5kZXg6IDMxLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMyXSA9IHtuYW1lOiAnY3MnLCBsb3dlcjogJ2NzJywgaW5kZXg6IDMyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzMzXSA9IHtuYW1lOiAnY2knLCBsb3dlcjogJ2NpJywgaW5kZXg6IDMzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM0XSA9IHtuYW1lOiAndW0nLCBsb3dlcjogJ3VtJywgaW5kZXg6IDM0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM1XSA9IHtuYW1lOiAncG0nLCBsb3dlcjogJ3BtJywgaW5kZXg6IDM1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM2XSA9IHtuYW1lOiAnYmtyLW5hbWUnLCBsb3dlcjogJ2Jrci1uYW1lJywgaW5kZXg6IDM2LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM3XSA9IHtuYW1lOiAncm5hbWUnLCBsb3dlcjogJ3JuYW1lJywgaW5kZXg6IDM3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM4XSA9IHtuYW1lOiAndW5hbWUnLCBsb3dlcjogJ3VuYW1lJywgaW5kZXg6IDM4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzM5XSA9IHtuYW1lOiAnZW5hbWUnLCBsb3dlcjogJ2VuYW1lJywgaW5kZXg6IDM5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQwXSA9IHtuYW1lOiAnVWR0T3AnLCBsb3dlcjogJ3VkdG9wJywgaW5kZXg6IDQwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQxXSA9IHtuYW1lOiAndWR0LW5vbi1lbXB0eScsIGxvd2VyOiAndWR0LW5vbi1lbXB0eScsIGluZGV4OiA0MSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s0Ml0gPSB7bmFtZTogJ3VkdC1lbXB0eScsIGxvd2VyOiAndWR0LWVtcHR5JywgaW5kZXg6IDQyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQzXSA9IHtuYW1lOiAnUmVwT3AnLCBsb3dlcjogJ3JlcG9wJywgaW5kZXg6IDQzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQ0XSA9IHtuYW1lOiAnQWx0T3AnLCBsb3dlcjogJ2FsdG9wJywgaW5kZXg6IDQ0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQ1XSA9IHtuYW1lOiAnQ2F0T3AnLCBsb3dlcjogJ2NhdG9wJywgaW5kZXg6IDQ1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzQ2XSA9IHtuYW1lOiAnU3Rhck9wJywgbG93ZXI6ICdzdGFyb3AnLCBpbmRleDogNDYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDddID0ge25hbWU6ICdBbmRPcCcsIGxvd2VyOiAnYW5kb3AnLCBpbmRleDogNDcsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDhdID0ge25hbWU6ICdOb3RPcCcsIGxvd2VyOiAnbm90b3AnLCBpbmRleDogNDgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNDldID0ge25hbWU6ICdCa2FPcCcsIGxvd2VyOiAnYmthb3AnLCBpbmRleDogNDksIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTBdID0ge25hbWU6ICdCa25PcCcsIGxvd2VyOiAnYmtub3AnLCBpbmRleDogNTAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTFdID0ge25hbWU6ICdBYmdPcCcsIGxvd2VyOiAnYWJnb3AnLCBpbmRleDogNTEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTJdID0ge25hbWU6ICdBZW5PcCcsIGxvd2VyOiAnYWVub3AnLCBpbmRleDogNTIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTNdID0ge25hbWU6ICdUcmdPcCcsIGxvd2VyOiAndHJnb3AnLCBpbmRleDogNTMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTRdID0ge25hbWU6ICdUYnNPcCcsIGxvd2VyOiAndGJzb3AnLCBpbmRleDogNTQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTVdID0ge25hbWU6ICdUbHNPcCcsIGxvd2VyOiAndGxzb3AnLCBpbmRleDogNTUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNTZdID0ge25hbWU6ICdUbHNDYXNlJywgbG93ZXI6ICd0bHNjYXNlJywgaW5kZXg6IDU2LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzU3XSA9IHtuYW1lOiAnVGxzT3BlbicsIGxvd2VyOiAndGxzb3BlbicsIGluZGV4OiA1NywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1OF0gPSB7bmFtZTogJ1Rsc0Nsb3NlJywgbG93ZXI6ICd0bHNjbG9zZScsIGluZGV4OiA1OCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s1OV0gPSB7bmFtZTogJ1Rsc1N0cmluZycsIGxvd2VyOiAndGxzc3RyaW5nJywgaW5kZXg6IDU5LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzYwXSA9IHtuYW1lOiAnU3RyaW5nVGFiJywgbG93ZXI6ICdzdHJpbmd0YWInLCBpbmRleDogNjAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjFdID0ge25hbWU6ICdDbHNPcCcsIGxvd2VyOiAnY2xzb3AnLCBpbmRleDogNjEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjJdID0ge25hbWU6ICdDbHNPcGVuJywgbG93ZXI6ICdjbHNvcGVuJywgaW5kZXg6IDYyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzYzXSA9IHtuYW1lOiAnQ2xzQ2xvc2UnLCBsb3dlcjogJ2Nsc2Nsb3NlJywgaW5kZXg6IDYzLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY0XSA9IHtuYW1lOiAnQ2xzU3RyaW5nJywgbG93ZXI6ICdjbHNzdHJpbmcnLCBpbmRleDogNjQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNjVdID0ge25hbWU6ICdQcm9zVmFsJywgbG93ZXI6ICdwcm9zdmFsJywgaW5kZXg6IDY1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY2XSA9IHtuYW1lOiAnUHJvc1ZhbE9wZW4nLCBsb3dlcjogJ3Byb3N2YWxvcGVuJywgaW5kZXg6IDY2LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY3XSA9IHtuYW1lOiAnUHJvc1ZhbFN0cmluZycsIGxvd2VyOiAncHJvc3ZhbHN0cmluZycsIGluZGV4OiA2NywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s2OF0gPSB7bmFtZTogJ1Byb3NWYWxDbG9zZScsIGxvd2VyOiAncHJvc3ZhbGNsb3NlJywgaW5kZXg6IDY4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzY5XSA9IHtuYW1lOiAncmVwLW1pbicsIGxvd2VyOiAncmVwLW1pbicsIGluZGV4OiA2OSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3MF0gPSB7bmFtZTogJ3JlcC1taW4tbWF4JywgbG93ZXI6ICdyZXAtbWluLW1heCcsIGluZGV4OiA3MCwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3MV0gPSB7bmFtZTogJ3JlcC1tYXgnLCBsb3dlcjogJ3JlcC1tYXgnLCBpbmRleDogNzEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzJdID0ge25hbWU6ICdyZXAtbnVtJywgbG93ZXI6ICdyZXAtbnVtJywgaW5kZXg6IDcyLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzczXSA9IHtuYW1lOiAnZFN0cmluZycsIGxvd2VyOiAnZHN0cmluZycsIGluZGV4OiA3MywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3NF0gPSB7bmFtZTogJ3hTdHJpbmcnLCBsb3dlcjogJ3hzdHJpbmcnLCBpbmRleDogNzQsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzVdID0ge25hbWU6ICdiU3RyaW5nJywgbG93ZXI6ICdic3RyaW5nJywgaW5kZXg6IDc1LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzc2XSA9IHtuYW1lOiAnRGVjJywgbG93ZXI6ICdkZWMnLCBpbmRleDogNzYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNzddID0ge25hbWU6ICdIZXgnLCBsb3dlcjogJ2hleCcsIGluZGV4OiA3NywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s3OF0gPSB7bmFtZTogJ0JpbicsIGxvd2VyOiAnYmluJywgaW5kZXg6IDc4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzc5XSA9IHtuYW1lOiAnZG1pbicsIGxvd2VyOiAnZG1pbicsIGluZGV4OiA3OSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4MF0gPSB7bmFtZTogJ2RtYXgnLCBsb3dlcjogJ2RtYXgnLCBpbmRleDogODAsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODFdID0ge25hbWU6ICdibWluJywgbG93ZXI6ICdibWluJywgaW5kZXg6IDgxLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzgyXSA9IHtuYW1lOiAnYm1heCcsIGxvd2VyOiAnYm1heCcsIGluZGV4OiA4MiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4M10gPSB7bmFtZTogJ3htaW4nLCBsb3dlcjogJ3htaW4nLCBpbmRleDogODMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODRdID0ge25hbWU6ICd4bWF4JywgbG93ZXI6ICd4bWF4JywgaW5kZXg6IDg0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzg1XSA9IHtuYW1lOiAnZG51bScsIGxvd2VyOiAnZG51bScsIGluZGV4OiA4NSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4Nl0gPSB7bmFtZTogJ2JudW0nLCBsb3dlcjogJ2JudW0nLCBpbmRleDogODYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbODddID0ge25hbWU6ICd4bnVtJywgbG93ZXI6ICd4bnVtJywgaW5kZXg6IDg3LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzg4XSA9IHtuYW1lOiAnYWxwaGFudW0nLCBsb3dlcjogJ2FscGhhbnVtJywgaW5kZXg6IDg4LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzg5XSA9IHtuYW1lOiAnb3dzcCcsIGxvd2VyOiAnb3dzcCcsIGluZGV4OiA4OSwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s5MF0gPSB7bmFtZTogJ3dzcCcsIGxvd2VyOiAnd3NwJywgaW5kZXg6IDkwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzkxXSA9IHtuYW1lOiAnc3BhY2UnLCBsb3dlcjogJ3NwYWNlJywgaW5kZXg6IDkxLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzkyXSA9IHtuYW1lOiAnY29tbWVudCcsIGxvd2VyOiAnY29tbWVudCcsIGluZGV4OiA5MiwgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s5M10gPSB7bmFtZTogJ0xpbmVFbmQnLCBsb3dlcjogJ2xpbmVlbmQnLCBpbmRleDogOTMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbOTRdID0ge25hbWU6ICdMaW5lQ29udGludWUnLCBsb3dlcjogJ2xpbmVjb250aW51ZScsIGluZGV4OiA5NCwgaXNCa3I6IGZhbHNlfTtcblxuICAvKiBVRFRTICovXG4gIHRoaXMudWR0cyA9IFtdO1xuXG4gIC8qIE9QQ09ERVMgKi9cbiAgLyogRmlsZSAqL1xuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMX07Ly8gUk5NKEJsYW5rTGluZSlcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiAyfTsvLyBSTk0oUnVsZSlcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiAxMn07Ly8gUk5NKFJ1bGVFcnJvcilcblxuICAvKiBCbGFua0xpbmUgKi9cbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsNSw3XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbMl0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFszLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzNdID0ge3R5cGU6IDYsIHN0cmluZzogWzMyXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA0LCBpbmRleDogOTJ9Oy8vIFJOTShjb21tZW50KVxuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbN10gPSB7dHlwZTogNCwgaW5kZXg6IDkzfTsvLyBSTk0oTGluZUVuZClcblxuICAvKiBSdWxlICovXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogM307Ly8gUk5NKFJ1bGVMb29rdXApXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDE0fTsvLyBSTk0oQWx0ZXJuYXRpb24pXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzUsOF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbNV0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs2LDddfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzZdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogOTN9Oy8vIFJOTShMaW5lRW5kKVxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbOF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs5LDEwXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s5XSA9IHt0eXBlOiA0LCBpbmRleDogMTN9Oy8vIFJOTShMaW5lRW5kRXJyb3IpXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1sxMF0gPSB7dHlwZTogNCwgaW5kZXg6IDkzfTsvLyBSTk0oTGluZUVuZClcblxuICAvKiBSdWxlTG9va3VwICovXG4gIHRoaXMucnVsZXNbM10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDR9Oy8vIFJOTShSdWxlTmFtZVRlc3QpXG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDd9Oy8vIFJOTShEZWZpbmVkQXNUZXN0KVxuXG4gIC8qIFJ1bGVOYW1lVGVzdCAqL1xuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNX07Ly8gUk5NKFJ1bGVOYW1lKVxuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDZ9Oy8vIFJOTShSdWxlTmFtZUVycm9yKVxuXG4gIC8qIFJ1bGVOYW1lICovXG4gIHRoaXMucnVsZXNbNV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg4fTsvLyBSTk0oYWxwaGFudW0pXG5cbiAgLyogUnVsZU5hbWVFcnJvciAqL1xuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXNbMl0gPSB7dHlwZTogNSwgbWluOiAzMywgbWF4OiA2MH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDYyLCBtYXg6IDEyNn07Ly8gVFJHXG5cbiAgLyogRGVmaW5lZEFzVGVzdCAqL1xuICB0aGlzLnJ1bGVzWzddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbN10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogOX07Ly8gUk5NKERlZmluZWRBcylcbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4fTsvLyBSTk0oRGVmaW5lZEFzRXJyb3IpXG5cbiAgLyogRGVmaW5lZEFzRXJyb3IgKi9cbiAgdGhpcy5ydWxlc1s4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogMn07Ly8gUkVQXG4gIHRoaXMucnVsZXNbOF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDMzLCBtYXg6IDEyNn07Ly8gVFJHXG5cbiAgLyogRGVmaW5lZEFzICovXG4gIHRoaXMucnVsZXNbOV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzldLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s5XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAxMX07Ly8gUk5NKEluY0FsdClcbiAgdGhpcy5ydWxlc1s5XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiAxMH07Ly8gUk5NKERlZmluZWQpXG5cbiAgLyogRGVmaW5lZCAqL1xuICB0aGlzLnJ1bGVzWzEwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTBdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjFdfTsvLyBUQlNcblxuICAvKiBJbmNBbHQgKi9cbiAgdGhpcy5ydWxlc1sxMV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzExXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzYxLDQ3XX07Ly8gVEJTXG5cbiAgLyogUnVsZUVycm9yICovXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsNl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzFdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXNbMl0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFszLDQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogMzIsIG1heDogMTI2fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDk0fTsvLyBSTk0oTGluZUNvbnRpbnVlKVxuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzZdID0ge3R5cGU6IDQsIGluZGV4OiA5M307Ly8gUk5NKExpbmVFbmQpXG5cbiAgLyogTGluZUVuZEVycm9yICovXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxM10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzEzXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxM10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXNbM10gPSB7dHlwZTogNiwgc3RyaW5nOiBbOV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzEzXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA5NH07Ly8gUk5NKExpbmVDb250aW51ZSlcblxuICAvKiBBbHRlcm5hdGlvbiAqL1xuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxNF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogMTV9Oy8vIFJOTShDb25jYXRlbmF0aW9uKVxuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzWzJdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbM10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs0LDUsNl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDQ0fTsvLyBSTk0oQWx0T3ApXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDE1fTsvLyBSTk0oQ29uY2F0ZW5hdGlvbilcblxuICAvKiBDb25jYXRlbmF0aW9uICovXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxNV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAxNn07Ly8gUk5NKFJlcGV0aXRpb24pXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXNbMl0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1sxNV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzQsNV19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA0NX07Ly8gUk5NKENhdE9wKVxuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiAxNn07Ly8gUk5NKFJlcGV0aXRpb24pXG5cbiAgLyogUmVwZXRpdGlvbiAqL1xuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDE3fTsvLyBSTk0oTW9kaWZpZXIpXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbM10gPSB7dHlwZTogMSwgY2hpbGRyZW46IFs0LDUsNiw3XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDIxfTsvLyBSTk0oR3JvdXApXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDI1fTsvLyBSTk0oT3B0aW9uKVxuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzWzZdID0ge3R5cGU6IDQsIGluZGV4OiAxOX07Ly8gUk5NKEJhc2ljRWxlbWVudClcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogMjB9Oy8vIFJOTShCYXNpY0VsZW1lbnRFcnIpXG5cbiAgLyogTW9kaWZpZXIgKi9cbiAgdGhpcy5ydWxlc1sxN10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSw1XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXNbMV0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsyLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxN10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMTh9Oy8vIFJOTShQcmVkaWNhdGUpXG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXNbM10gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IDF9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA0M307Ly8gUk5NKFJlcE9wKVxuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiA0M307Ly8gUk5NKFJlcE9wKVxuXG4gIC8qIFByZWRpY2F0ZSAqL1xuICB0aGlzLnJ1bGVzWzE4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDQ5fTsvLyBSTk0oQmthT3ApXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDUwfTsvLyBSTk0oQmtuT3ApXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDQ3fTsvLyBSTk0oQW5kT3ApXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDQ4fTsvLyBSTk0oTm90T3ApXG5cbiAgLyogQmFzaWNFbGVtZW50ICovXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsMiwzLDQsNSw2LDcsOCw5LDEwXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDQwfTsvLyBSTk0oVWR0T3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDI5fTsvLyBSTk0oUm5tT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDUzfTsvLyBSTk0oVHJnT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDU0fTsvLyBSTk0oVGJzT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDU1fTsvLyBSTk0oVGxzT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDYxfTsvLyBSTk0oQ2xzT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbN10gPSB7dHlwZTogNCwgaW5kZXg6IDMwfTsvLyBSTk0oQmtyT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbOF0gPSB7dHlwZTogNCwgaW5kZXg6IDUxfTsvLyBSTk0oQWJnT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbOV0gPSB7dHlwZTogNCwgaW5kZXg6IDUyfTsvLyBSTk0oQWVuT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbMTBdID0ge3R5cGU6IDQsIGluZGV4OiA2NX07Ly8gUk5NKFByb3NWYWwpXG5cbiAgLyogQmFzaWNFbGVtZW50RXJyICovXG4gIHRoaXMucnVsZXNbMjBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syMF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogMzMsIG1heDogNDB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogNDIsIG1heDogNDZ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogNDgsIG1heDogOTJ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzVdID0ge3R5cGU6IDUsIG1pbjogOTQsIG1heDogMTI2fTsvLyBUUkdcblxuICAvKiBHcm91cCAqL1xuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAyM307Ly8gUk5NKEdyb3VwT3BlbilcbiAgdGhpcy5ydWxlc1syMV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMTR9Oy8vIFJOTShBbHRlcm5hdGlvbilcbiAgdGhpcy5ydWxlc1syMV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiAyNH07Ly8gUk5NKEdyb3VwQ2xvc2UpXG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDIyfTsvLyBSTk0oR3JvdXBFcnJvcilcblxuICAvKiBHcm91cEVycm9yICovXG4gIHRoaXMucnVsZXNbMjJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syMl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDQsNV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzJdID0ge3R5cGU6IDUsIG1pbjogMzMsIG1heDogNDB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzNdID0ge3R5cGU6IDUsIG1pbjogNDIsIG1heDogNDZ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogNDgsIG1heDogOTJ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzVdID0ge3R5cGU6IDUsIG1pbjogOTQsIG1heDogMTI2fTsvLyBUUkdcblxuICAvKiBHcm91cE9wZW4gKi9cbiAgdGhpcy5ydWxlc1syM10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzIzXS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjNdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDBdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1syM10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODl9Oy8vIFJOTShvd3NwKVxuXG4gIC8qIEdyb3VwQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1syNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzI0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjRdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcbiAgdGhpcy5ydWxlc1syNF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs0MV19Oy8vIFRCU1xuXG4gIC8qIE9wdGlvbiAqL1xuICB0aGlzLnJ1bGVzWzI1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzI1XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAyN307Ly8gUk5NKE9wdGlvbk9wZW4pXG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDE0fTsvLyBSTk0oQWx0ZXJuYXRpb24pXG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbM10gPSB7dHlwZTogMSwgY2hpbGRyZW46IFs0LDVdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1syNV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogMjh9Oy8vIFJOTShPcHRpb25DbG9zZSlcbiAgdGhpcy5ydWxlc1syNV0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA0LCBpbmRleDogMjZ9Oy8vIFJOTShPcHRpb25FcnJvcilcblxuICAvKiBPcHRpb25FcnJvciAqL1xuICB0aGlzLnJ1bGVzWzI2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjZdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0LDVdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMzLCBtYXg6IDQwfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDQyLCBtYXg6IDQ2fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDkyfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiA1LCBtaW46IDk0LCBtYXg6IDEyNn07Ly8gVFJHXG5cbiAgLyogT3B0aW9uT3BlbiAqL1xuICB0aGlzLnJ1bGVzWzI3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjddLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syN10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5MV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzI3XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OX07Ly8gUk5NKG93c3ApXG5cbiAgLyogT3B0aW9uQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1syOF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzI4XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjhdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcbiAgdGhpcy5ydWxlc1syOF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5M119Oy8vIFRCU1xuXG4gIC8qIFJubU9wICovXG4gIHRoaXMucnVsZXNbMjldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syOV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBCa3JPcCAqL1xuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsNF19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzkyXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXNbMl0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IDF9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiAzMX07Ly8gUk5NKGJrck1vZGlmaWVyKVxuICB0aGlzLnJ1bGVzWzMwXS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiAzNn07Ly8gUk5NKGJrci1uYW1lKVxuXG4gIC8qIGJrck1vZGlmaWVyICovXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzEsNywxMywxOV19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMiwzXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDMyfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbM10gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IDF9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzRdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbNSw2XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbNV0gPSB7dHlwZTogNCwgaW5kZXg6IDM0fTsvLyBSTk0odW0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDM1fTsvLyBSTk0ocG0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbN10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs4LDldfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1s4XSA9IHt0eXBlOiA0LCBpbmRleDogMzN9Oy8vIFJOTShjaSlcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1s5XSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMTEsMTJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxMV0gPSB7dHlwZTogNCwgaW5kZXg6IDM0fTsvLyBSTk0odW0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTJdID0ge3R5cGU6IDQsIGluZGV4OiAzNX07Ly8gUk5NKHBtKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzEzXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzE0LDE1XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTRdID0ge3R5cGU6IDQsIGluZGV4OiAzNH07Ly8gUk5NKHVtKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzE1XSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTZdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMTcsMThdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxN10gPSB7dHlwZTogNCwgaW5kZXg6IDMyfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMThdID0ge3R5cGU6IDQsIGluZGV4OiAzM307Ly8gUk5NKGNpKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzE5XSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzIwLDIxXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjBdID0ge3R5cGU6IDQsIGluZGV4OiAzNX07Ly8gUk5NKHBtKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzIxXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjJdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMjMsMjRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1syM10gPSB7dHlwZTogNCwgaW5kZXg6IDMyfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjRdID0ge3R5cGU6IDQsIGluZGV4OiAzM307Ly8gUk5NKGNpKVxuXG4gIC8qIGNzICovXG4gIHRoaXMucnVsZXNbMzJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szMl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNywxMTVdfTsvLyBUQlNcblxuICAvKiBjaSAqL1xuICB0aGlzLnJ1bGVzWzMzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzNdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzcsMTA1XX07Ly8gVEJTXG5cbiAgLyogdW0gKi9cbiAgdGhpcy5ydWxlc1szNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzM0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM3LDExN119Oy8vIFRCU1xuXG4gIC8qIHBtICovXG4gIHRoaXMucnVsZXNbMzVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szNV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNywxMTJdfTsvLyBUQlNcblxuICAvKiBia3ItbmFtZSAqL1xuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzZdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAzOH07Ly8gUk5NKHVuYW1lKVxuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiAzOX07Ly8gUk5NKGVuYW1lKVxuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiAzN307Ly8gUk5NKHJuYW1lKVxuXG4gIC8qIHJuYW1lICovXG4gIHRoaXMucnVsZXNbMzddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szN10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiB1bmFtZSAqL1xuICB0aGlzLnJ1bGVzWzM4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzhdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szOF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMTcsOTVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1szOF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBlbmFtZSAqL1xuICB0aGlzLnJ1bGVzWzM5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMzldLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szOV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMDEsOTVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1szOV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBVZHRPcCAqL1xuICB0aGlzLnJ1bGVzWzQwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDBdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDJdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s0MF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNDJ9Oy8vIFJOTSh1ZHQtZW1wdHkpXG4gIHRoaXMucnVsZXNbNDBdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDQxfTsvLyBSTk0odWR0LW5vbi1lbXB0eSlcblxuICAvKiB1ZHQtbm9uLWVtcHR5ICovXG4gIHRoaXMucnVsZXNbNDFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0MV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzQxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzExNyw5NV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzQxXS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4OH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIHVkdC1lbXB0eSAqL1xuICB0aGlzLnJ1bGVzWzQyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDJdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0Ml0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMDEsOTVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s0Ml0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogODh9Oy8vIFJOTShhbHBoYW51bSlcblxuICAvKiBSZXBPcCAqL1xuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDUsOCwxMSwxMl19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzFdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNjl9Oy8vIFJOTShyZXAtbWluKVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA0Nn07Ly8gUk5NKFN0YXJPcClcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNzF9Oy8vIFJOTShyZXAtbWF4KVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzVdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbNiw3XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbNl0gPSB7dHlwZTogNCwgaW5kZXg6IDY5fTsvLyBSTk0ocmVwLW1pbilcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogNDZ9Oy8vIFJOTShTdGFyT3ApXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbOF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs5LDEwXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbOV0gPSB7dHlwZTogNCwgaW5kZXg6IDQ2fTsvLyBSTk0oU3Rhck9wKVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzEwXSA9IHt0eXBlOiA0LCBpbmRleDogNzF9Oy8vIFJOTShyZXAtbWF4KVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzExXSA9IHt0eXBlOiA0LCBpbmRleDogNDZ9Oy8vIFJOTShTdGFyT3ApXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbMTJdID0ge3R5cGU6IDQsIGluZGV4OiA3MH07Ly8gUk5NKHJlcC1taW4tbWF4KVxuXG4gIC8qIEFsdE9wICovXG4gIHRoaXMucnVsZXNbNDRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0NF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzQ0XS5vcGNvZGVzWzFdID0ge3R5cGU6IDYsIHN0cmluZzogWzQ3XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNDRdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDg5fTsvLyBSTk0ob3dzcClcblxuICAvKiBDYXRPcCAqL1xuICB0aGlzLnJ1bGVzWzQ1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDVdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDkwfTsvLyBSTk0od3NwKVxuXG4gIC8qIFN0YXJPcCAqL1xuICB0aGlzLnJ1bGVzWzQ2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDZdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDJdfTsvLyBUQlNcblxuICAvKiBBbmRPcCAqL1xuICB0aGlzLnJ1bGVzWzQ3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDddLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzhdfTsvLyBUQlNcblxuICAvKiBOb3RPcCAqL1xuICB0aGlzLnJ1bGVzWzQ4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDhdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzNdfTsvLyBUQlNcblxuICAvKiBCa2FPcCAqL1xuICB0aGlzLnJ1bGVzWzQ5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDldLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzgsMzhdfTsvLyBUQlNcblxuICAvKiBCa25PcCAqL1xuICB0aGlzLnJ1bGVzWzUwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTBdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzMsMzNdfTsvLyBUQlNcblxuICAvKiBBYmdPcCAqL1xuICB0aGlzLnJ1bGVzWzUxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTFdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzcsOTRdfTsvLyBUQlNcblxuICAvKiBBZW5PcCAqL1xuICB0aGlzLnJ1bGVzWzUyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTJdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzcsMzZdfTsvLyBUQlNcblxuICAvKiBUcmdPcCAqL1xuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszN119Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzJdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMyw4LDEzXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbM10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFs0LDUsNiw3XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDc2fTsvLyBSTk0oRGVjKVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiA3OX07Ly8gUk5NKGRtaW4pXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbNl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA0LCBpbmRleDogODB9Oy8vIFJOTShkbWF4KVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzhdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbOSwxMCwxMSwxMl19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzldID0ge3R5cGU6IDQsIGluZGV4OiA3N307Ly8gUk5NKEhleClcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxMF0gPSB7dHlwZTogNCwgaW5kZXg6IDgzfTsvLyBSTk0oeG1pbilcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDVdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxMl0gPSB7dHlwZTogNCwgaW5kZXg6IDg0fTsvLyBSTk0oeG1heClcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxM10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxNCwxNSwxNiwxN119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzE0XSA9IHt0eXBlOiA0LCBpbmRleDogNzh9Oy8vIFJOTShCaW4pXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTVdID0ge3R5cGU6IDQsIGluZGV4OiA4MX07Ly8gUk5NKGJtaW4pXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTZdID0ge3R5cGU6IDYsIHN0cmluZzogWzQ1XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTddID0ge3R5cGU6IDQsIGluZGV4OiA4Mn07Ly8gUk5NKGJtYXgpXG5cbiAgLyogVGJzT3AgKi9cbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzddfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzMsMTAsMTddfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzQsNSw2XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDc2fTsvLyBSTk0oRGVjKVxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzVdID0ge3R5cGU6IDQsIGluZGV4OiA3M307Ly8gUk5NKGRTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbNl0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiAyLCBjaGlsZHJlbjogWzgsOV19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzhdID0ge3R5cGU6IDYsIHN0cmluZzogWzQ2XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbOV0gPSB7dHlwZTogNCwgaW5kZXg6IDczfTsvLyBSTk0oZFN0cmluZylcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxMSwxMiwxM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzExXSA9IHt0eXBlOiA0LCBpbmRleDogNzd9Oy8vIFJOTShIZXgpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTJdID0ge3R5cGU6IDQsIGluZGV4OiA3NH07Ly8gUk5NKHhTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTNdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTRdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMTUsMTZdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxNV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDZdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxNl0gPSB7dHlwZTogNCwgaW5kZXg6IDc0fTsvLyBSTk0oeFN0cmluZylcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxN10gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxOCwxOSwyMF19Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzE4XSA9IHt0eXBlOiA0LCBpbmRleDogNzh9Oy8vIFJOTShCaW4pXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTldID0ge3R5cGU6IDQsIGluZGV4OiA3NX07Ly8gUk5NKGJTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMjBdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMjFdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMjIsMjNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syMl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDZdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syM10gPSB7dHlwZTogNCwgaW5kZXg6IDc1fTsvLyBSTk0oYlN0cmluZylcblxuICAvKiBUbHNPcCAqL1xuICB0aGlzLnJ1bGVzWzU1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTVdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTVdLm9wY29kZXNbMV0gPSB7dHlwZTogNCwgaW5kZXg6IDU2fTsvLyBSTk0oVGxzQ2FzZSlcbiAgdGhpcy5ydWxlc1s1NV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNTd9Oy8vIFJOTShUbHNPcGVuKVxuICB0aGlzLnJ1bGVzWzU1XS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA1OX07Ly8gUk5NKFRsc1N0cmluZylcbiAgdGhpcy5ydWxlc1s1NV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogNTh9Oy8vIFJOTShUbHNDbG9zZSlcblxuICAvKiBUbHNDYXNlICovXG4gIHRoaXMucnVsZXNbNTZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNTZdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA3LCBzdHJpbmc6IFszNywxMDVdfTsvLyBUTFNcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA3LCBzdHJpbmc6IFszNywxMTVdfTsvLyBUTFNcblxuICAvKiBUbHNPcGVuICovXG4gIHRoaXMucnVsZXNbNTddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1N10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNF19Oy8vIFRCU1xuXG4gIC8qIFRsc0Nsb3NlICovXG4gIHRoaXMucnVsZXNbNThdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1OF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFszNF19Oy8vIFRCU1xuXG4gIC8qIFRsc1N0cmluZyAqL1xuICB0aGlzLnJ1bGVzWzU5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s1OV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbMl0gPSB7dHlwZTogNSwgbWluOiAzMiwgbWF4OiAzM307Ly8gVFJHXG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbM10gPSB7dHlwZTogNSwgbWluOiAzNSwgbWF4OiAxMjZ9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzU5XS5vcGNvZGVzWzRdID0ge3R5cGU6IDQsIGluZGV4OiA2MH07Ly8gUk5NKFN0cmluZ1RhYilcblxuICAvKiBTdHJpbmdUYWIgKi9cbiAgdGhpcy5ydWxlc1s2MF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzYwXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzldfTsvLyBUQlNcblxuICAvKiBDbHNPcCAqL1xuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjFdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM119Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA2Mn07Ly8gUk5NKENsc09wZW4pXG4gIHRoaXMucnVsZXNbNjFdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDY0fTsvLyBSTk0oQ2xzU3RyaW5nKVxuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA2M307Ly8gUk5NKENsc0Nsb3NlKVxuXG4gIC8qIENsc09wZW4gKi9cbiAgdGhpcy5ydWxlc1s2Ml0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzYyXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM5XX07Ly8gVEJTXG5cbiAgLyogQ2xzQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1s2M10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzYzXS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzM5XX07Ly8gVEJTXG5cbiAgLyogQ2xzU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNjRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzY0XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDM4fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDQwLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNjRdLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDYwfTsvLyBSTk0oU3RyaW5nVGFiKVxuXG4gIC8qIFByb3NWYWwgKi9cbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzY1XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSwyLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogNjZ9Oy8vIFJOTShQcm9zVmFsT3BlbilcbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNjd9Oy8vIFJOTShQcm9zVmFsU3RyaW5nKVxuICB0aGlzLnJ1bGVzWzY1XS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA2OH07Ly8gUk5NKFByb3NWYWxDbG9zZSlcblxuICAvKiBQcm9zVmFsT3BlbiAqL1xuICB0aGlzLnJ1bGVzWzY2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjZdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjBdfTsvLyBUQlNcblxuICAvKiBQcm9zVmFsU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNjddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzY3XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDYxfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDYzLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNjddLm9wY29kZXNbNF0gPSB7dHlwZTogNCwgaW5kZXg6IDYwfTsvLyBSTk0oU3RyaW5nVGFiKVxuXG4gIC8qIFByb3NWYWxDbG9zZSAqL1xuICB0aGlzLnJ1bGVzWzY4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjhdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjJdfTsvLyBUQlNcblxuICAvKiByZXAtbWluICovXG4gIHRoaXMucnVsZXNbNjldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2OV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogNzJ9Oy8vIFJOTShyZXAtbnVtKVxuXG4gIC8qIHJlcC1taW4tbWF4ICovXG4gIHRoaXMucnVsZXNbNzBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3MF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogNzJ9Oy8vIFJOTShyZXAtbnVtKVxuXG4gIC8qIHJlcC1tYXggKi9cbiAgdGhpcy5ydWxlc1s3MV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzcxXS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA3Mn07Ly8gUk5NKHJlcC1udW0pXG5cbiAgLyogcmVwLW51bSAqL1xuICB0aGlzLnJ1bGVzWzcyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzJdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s3Ml0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDU3fTsvLyBUUkdcblxuICAvKiBkU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNzNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3M10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODV9Oy8vIFJOTShkbnVtKVxuXG4gIC8qIHhTdHJpbmcgKi9cbiAgdGhpcy5ydWxlc1s3NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4N307Ly8gUk5NKHhudW0pXG5cbiAgLyogYlN0cmluZyAqL1xuICB0aGlzLnJ1bGVzWzc1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzVdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg2fTsvLyBSTk0oYm51bSlcblxuICAvKiBEZWMgKi9cbiAgdGhpcy5ydWxlc1s3Nl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc2XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNzZdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjhdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s3Nl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMDBdfTsvLyBUQlNcblxuICAvKiBIZXggKi9cbiAgdGhpcy5ydWxlc1s3N10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc3XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNzddLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbODhdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s3N10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMjBdfTsvLyBUQlNcblxuICAvKiBCaW4gKi9cbiAgdGhpcy5ydWxlc1s3OF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc4XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNzhdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNjZdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s3OF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5OF19Oy8vIFRCU1xuXG4gIC8qIGRtaW4gKi9cbiAgdGhpcy5ydWxlc1s3OV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc5XS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4NX07Ly8gUk5NKGRudW0pXG5cbiAgLyogZG1heCAqL1xuICB0aGlzLnJ1bGVzWzgwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODBdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg1fTsvLyBSTk0oZG51bSlcblxuICAvKiBibWluICovXG4gIHRoaXMucnVsZXNbODFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4MV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODZ9Oy8vIFJOTShibnVtKVxuXG4gIC8qIGJtYXggKi9cbiAgdGhpcy5ydWxlc1s4Ml0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzgyXS5vcGNvZGVzWzBdID0ge3R5cGU6IDQsIGluZGV4OiA4Nn07Ly8gUk5NKGJudW0pXG5cbiAgLyogeG1pbiAqL1xuICB0aGlzLnJ1bGVzWzgzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODNdLm9wY29kZXNbMF0gPSB7dHlwZTogNCwgaW5kZXg6IDg3fTsvLyBSTk0oeG51bSlcblxuICAvKiB4bWF4ICovXG4gIHRoaXMucnVsZXNbODRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4NF0ub3Bjb2Rlc1swXSA9IHt0eXBlOiA0LCBpbmRleDogODd9Oy8vIFJOTSh4bnVtKVxuXG4gIC8qIGRudW0gKi9cbiAgdGhpcy5ydWxlc1s4NV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg1XS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbODVdLm9wY29kZXNbMV0gPSB7dHlwZTogNSwgbWluOiA0OCwgbWF4OiA1N307Ly8gVFJHXG5cbiAgLyogYm51bSAqL1xuICB0aGlzLnJ1bGVzWzg2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODZdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4Nl0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDQ5fTsvLyBUUkdcblxuICAvKiB4bnVtICovXG4gIHRoaXMucnVsZXNbODddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzg3XS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDU3fTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDY1LCBtYXg6IDcwfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA1LCBtaW46IDk3LCBtYXg6IDEwMn07Ly8gVFJHXG5cbiAgLyogYWxwaGFudW0gKi9cbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg4XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSw0XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA1LCBtaW46IDk3LCBtYXg6IDEyMn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbM10gPSB7dHlwZTogNSwgbWluOiA2NSwgbWF4OiA5MH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbNF0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s1XSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzYsNyw4LDldfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s2XSA9IHt0eXBlOiA1LCBtaW46IDk3LCBtYXg6IDEyMn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbN10gPSB7dHlwZTogNSwgbWluOiA2NSwgbWF4OiA5MH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbOF0gPSB7dHlwZTogNSwgbWluOiA0OCwgbWF4OiA1N307Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbOV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbNDVdfTsvLyBUQlNcblxuICAvKiBvd3NwICovXG4gIHRoaXMucnVsZXNbODldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4OV0ub3Bjb2Rlc1swXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHl9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzg5XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA5MX07Ly8gUk5NKHNwYWNlKVxuXG4gIC8qIHdzcCAqL1xuICB0aGlzLnJ1bGVzWzkwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTBdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s5MF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA0LCBpbmRleDogOTF9Oy8vIFJOTShzcGFjZSlcblxuICAvKiBzcGFjZSAqL1xuICB0aGlzLnJ1bGVzWzkxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTFdLm9wY29kZXNbMF0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsxLDIsMyw0XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbOTFdLm9wY29kZXNbMV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzJdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5MV0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTFdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDkyfTsvLyBSTk0oY29tbWVudClcbiAgdGhpcy5ydWxlc1s5MV0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogOTR9Oy8vIFJOTShMaW5lQ29udGludWUpXG5cbiAgLyogY29tbWVudCAqL1xuICB0aGlzLnJ1bGVzWzkyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s5Ml0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs1OV19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzkyXS5vcGNvZGVzWzJdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbM10gPSB7dHlwZTogMSwgY2hpbGRyZW46IFs0LDVdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s5Ml0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbNV0gPSB7dHlwZTogNiwgc3RyaW5nOiBbOV19Oy8vIFRCU1xuXG4gIC8qIExpbmVFbmQgKi9cbiAgdGhpcy5ydWxlc1s5M10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzkzXS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s5M10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMywxMF19Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzkzXS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzEwXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTNdLm9wY29kZXNbM10gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTNdfTsvLyBUQlNcblxuICAvKiBMaW5lQ29udGludWUgKi9cbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDIsIGNoaWxkcmVuOiBbMSw1XX07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbMV0gPSB7dHlwZTogMSwgY2hpbGRyZW46IFsyLDMsNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzJdID0ge3R5cGU6IDYsIHN0cmluZzogWzEzLDEwXX07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbM10gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTBdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxM119Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzVdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbNiw3XX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbNl0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMzJdfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1s3XSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG5cbiAgLy8gVGhlIGB0b1N0cmluZygpYCBmdW5jdGlvbiB3aWxsIGRpc3BsYXkgdGhlIG9yaWdpbmFsIGdyYW1tYXIgZmlsZShzKSB0aGF0IHByb2R1Y2VkIHRoZXNlIG9wY29kZXMuXG4gIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIHN0ciArPSBcIjtcXG5cIjtcbiAgICBzdHIgKz0gXCI7IEFCTkYgZm9yIEphdmFTY3JpcHQgQVBHIDIuMCBTQUJORlxcblwiO1xuICAgIHN0ciArPSBcIjsgUkZDIDUyMzQgd2l0aCBzb21lIHJlc3RyaWN0aW9ucyBhbmQgYWRkaXRpb25zLlxcblwiO1xuICAgIHN0ciArPSBcIjsgVXBkYXRlZCAxMS8yNC8yMDE1IGZvciBSRkMgNzQwNSBjYXNlLXNlbnNpdGl2ZSBsaXRlcmFsIHN0cmluZyBub3RhdGlvblxcblwiO1xuICAgIHN0ciArPSBcIjsgIC0gYWNjZXB0cyAlc1xcXCJzdHJpbmdcXFwiIGFzIGEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgLSBhY2NlcHRzICVpXFxcInN0cmluZ1xcXCIgYXMgYSBjYXNlLWluc2Vuc2l0aXZlIHN0cmluZ1xcblwiO1xuICAgIHN0ciArPSBcIjsgIC0gYWNjZXB0cyBcXFwic3RyaW5nXFxcIiBhcyBhIGNhc2UtaW5zZW5zaXRpdmUgc3RyaW5nXFxuXCI7XG4gICAgc3RyICs9IFwiO1xcblwiO1xuICAgIHN0ciArPSBcIjsgU29tZSByZXN0cmljdGlvbnM6XFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDEuIFJ1bGVzIG11c3QgYmVnaW4gYXQgZmlyc3QgY2hhcmFjdGVyIG9mIGVhY2ggbGluZS5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgSW5kZW50YXRpb25zIG9uIGZpcnN0IHJ1bGUgYW5kIHJ1bGVzIHRoZXJlYWZ0ZXIgYXJlIG5vdCBhbGxvd2VkLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAyLiBSZWxheGVkIGxpbmUgZW5kaW5ncy4gQ1JMRiwgTEYgb3IgQ1IgYXJlIGFjY2VwdGVkIGFzIHZhbGlkIGxpbmUgZW5kaW5nLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAzLiBQcm9zZSB2YWx1ZXMsIGkuZS4gPHByb3NlIHZhbHVlPiwgYXJlIGFjY2VwdGVkIGFzIHZhbGlkIGdyYW1tYXIgc3ludGF4LlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBIb3dldmVyLCBhIHdvcmtpbmcgcGFyc2VyIGNhbm5vdCBiZSBnZW5lcmF0ZWQgZnJvbSB0aGVtLlxcblwiO1xuICAgIHN0ciArPSBcIjtcXG5cIjtcbiAgICBzdHIgKz0gXCI7IFN1cGVyIHNldCAoU0FCTkYpIGFkZGl0aW9uczpcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgMS4gTG9vay1haGVhZCAoc3ludGFjdGljIHByZWRpY2F0ZSkgb3BlcmF0b3JzIGFyZSBhY2NlcHRlZCBhcyBlbGVtZW50IHByZWZpeGVzLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAmIGlzIHRoZSBwb3NpdGl2ZSBsb29rLWFoZWFkIG9wZXJhdG9yLCBzdWNjZWVkcyBhbmQgYmFja3RyYWNrcyBpZiB0aGUgbG9vay1haGVhZCBwaHJhc2UgaXMgZm91bmRcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgISBpcyB0aGUgbmVnYXRpdmUgbG9vay1haGVhZCBvcGVyYXRvciwgc3VjY2VlZHMgYW5kIGJhY2t0cmFja3MgaWYgdGhlIGxvb2stYWhlYWQgcGhyYXNlIGlzIE5PVCBmb3VuZFxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBlLmcuICYlZDEzIG9yICZydWxlIG9yICEoQSAvIEIpXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDIuIFVzZXItRGVmaW5lZCBUZXJtaW5hbHMgKFVEVCkgb2YgdGhlIGZvcm0sIHVfbmFtZSBhbmQgZV9uYW1lIGFyZSBhY2NlcHRlZC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgJ25hbWUnIGlzIGFscGhhIGZvbGxvd2VkIGJ5IGFscGhhL251bS9oeXBoZW4ganVzdCBsaWtlIGEgcnVsZSBuYW1lLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICB1X25hbWUgbWF5IGJlIHVzZWQgYXMgYW4gZWxlbWVudCBidXQgbm8gcnVsZSBkZWZpbml0aW9uIGlzIGdpdmVuLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBlLmcuIHJ1bGUgPSBBIC8gdV9teVVkdFxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAgICAgIEEgPSBcXFwiYVxcXCJcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgd291bGQgYmUgYSB2YWxpZCBncmFtbWFyLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAzLiBDYXNlLXNlbnNpdGl2ZSwgc2luZ2xlLXF1b3RlZCBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgZS5nLiAnYWJjJyB3b3VsZCBiZSBlcXVpdmFsZW50IHRvICVkOTcuOTguOTlcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgKGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGJ1dCBzdXBlcnNlZGVkIGJ5ICVzXFxcImFiY1xcXCIpICBcXG5cIjtcbiAgICBzdHIgKz0gXCI7IE5ldyAxMi8yNi8yMDE1XFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDQuIExvb2stYmVoaW5kIG9wZXJhdG9ycyBhcmUgYWNjZXB0ZWQgYXMgZWxlbWVudCBwcmVmaXhlcy5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgJiYgaXMgdGhlIHBvc2l0aXZlIGxvb2stYmVoaW5kIG9wZXJhdG9yLCBzdWNjZWVkcyBhbmQgYmFja3RyYWNrcyBpZiB0aGUgbG9vay1iZWhpbmQgcGhyYXNlIGlzIGZvdW5kXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgICEhIGlzIHRoZSBuZWdhdGl2ZSBsb29rLWJlaGluZCBvcGVyYXRvciwgc3VjY2VlZHMgYW5kIGJhY2t0cmFja3MgaWYgdGhlIGxvb2stYmVoaW5kIHBocmFzZSBpcyBOT1QgZm91bmRcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgZS5nLiAmJiVkMTMgb3IgJiZydWxlIG9yICEhKEEgLyBCKVxcblwiO1xuICAgIHN0ciArPSBcIjsgICA1LiBCYWNrIHJlZmVyZW5jZSBvcGVyYXRvcnMsIGkuZS4gXFxcXHJ1bGVuYW1lLCBhcmUgYWNjZXB0ZWQuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIEEgYmFjayByZWZlcmVuY2Ugb3BlcmF0b3IgYWN0cyBsaWtlIGEgVExTIG9yIFRCUyB0ZXJtaW5hbCBleGNlcHQgdGhhdCB0aGUgcGhyYXNlIGl0IGF0dGVtcHRzXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIHRvIG1hdGNoIGlzIGEgcGhyYXNlIHByZXZpb3VzbHkgbWF0Y2hlZCBieSB0aGUgcnVsZSAncnVsZW5hbWUnLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBUaGVyZSBhcmUgdHdvIG1vZGVzIG9mIHByZXZpb3VzIHBocmFzZSBtYXRjaGluZyAtIHRoZSBwYXJlbnQtZnJhbWUgbW9kZSBhbmQgdGhlIHVuaXZlcnNhbCBtb2RlLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBJbiB1bml2ZXJzYWwgbW9kZSwgXFxcXHJ1bGVuYW1lIG1hdGNoZXMgdGhlIGxhc3QgbWF0Y2ggdG8gJ3J1bGVuYW1lJyByZWdhcmRsZXNzIG9mIHdoZXJlIGl0IHdhcyBmb3VuZC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgSW4gcGFyZW50LWZyYW1lIG1vZGUsIFxcXFxydWxlbmFtZSBtYXRjaGVzIG9ubHkgdGhlIGxhc3QgbWF0Y2ggZm91bmQgb24gdGhlIHBhcmVudCdzIGZyYW1lIG9yIHBhcnNlIHRyZWUgbGV2ZWwuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIEJhY2sgcmVmZXJlbmNlIG1vZGlmaWVycyBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGNhc2UgYW5kIG1vZGUuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIFxcXFxBIGRlZmF1bHRzIHRvIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHVuaXZlcnNhbCBtb2RlLCBlLmcuIFxcXFxBID09PSBcXFxcJWkldUFcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgTW9kaWZpZXJzICVpIGFuZCAlcyBkZXRlcm1pbmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FzZS1zZW5zaXRpdmUgbW9kZSwgcmVzcGVjdGl2ZWx5LlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBNb2RpZmllcnMgJXUgYW5kICVwIGRldGVybWluZSB1bml2ZXJzYWwgbW9kZSBhbmQgcGFyZW50IGZyYW1lIG1vZGUsIHJlc3BlY3RpdmVseS5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgQ2FzZSBhbmQgbW9kZSBtb2RpZmllcnMgY2FuIGFwcGVhciBpbiBhbnkgb3JkZXIsIGUuZy4gXFxcXCVzJXBBID09PSBcXFxcJXAlc0EuIFxcblwiO1xuICAgIHN0ciArPSBcIjsgICA3LiBTdHJpbmcgYmVnaW4gYW5jaG9yLCBBQkcoJV4pIG1hdGNoZXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgaW5wdXQgc3RyaW5nIGxvY2F0aW9uLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBSZXR1cm5zIEVNUFRZIG9yIE5PTUFUQ0guIE5ldmVyIGNvbnN1bWVzIGFueSBjaGFyYWN0ZXJzLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICA4LiBTdHJpbmcgZW5kIGFuY2hvciwgQUVOKCUkKSBtYXRjaGVzIHRoZSBlbmQgb2YgdGhlIGlucHV0IHN0cmluZyBsb2NhdGlvbi5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgUmV0dXJucyBFTVBUWSBvciBOT01BVENILiBOZXZlciBjb25zdW1lcyBhbnkgY2hhcmFjdGVycy5cXG5cIjtcbiAgICBzdHIgKz0gXCI7XFxuXCI7XG4gICAgc3RyICs9IFwiRmlsZSAgICAgICAgICAgID0gKihCbGFua0xpbmUgLyBSdWxlIC8gUnVsZUVycm9yKVxcblwiO1xuICAgIHN0ciArPSBcIkJsYW5rTGluZSAgICAgICA9ICooJWQzMi8lZDkpIFtjb21tZW50XSBMaW5lRW5kXFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZSAgICAgICAgICAgID0gUnVsZUxvb2t1cCBvd3NwIEFsdGVybmF0aW9uICgob3dzcCBMaW5lRW5kKVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIChMaW5lRW5kRXJyb3IgTGluZUVuZCkpXFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZUxvb2t1cCAgICAgID0gUnVsZU5hbWVUZXN0IG93c3AgRGVmaW5lZEFzVGVzdFxcblwiO1xuICAgIHN0ciArPSBcIlJ1bGVOYW1lVGVzdCAgICA9IFJ1bGVOYW1lL1J1bGVOYW1lRXJyb3JcXG5cIjtcbiAgICBzdHIgKz0gXCJSdWxlTmFtZSAgICAgICAgPSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcIlJ1bGVOYW1lRXJyb3IgICA9IDEqKCVkMzMtNjAvJWQ2Mi0xMjYpXFxuXCI7XG4gICAgc3RyICs9IFwiRGVmaW5lZEFzVGVzdCAgID0gRGVmaW5lZEFzIC8gRGVmaW5lZEFzRXJyb3JcXG5cIjtcbiAgICBzdHIgKz0gXCJEZWZpbmVkQXNFcnJvciAgPSAxKjIlZDMzLTEyNlxcblwiO1xuICAgIHN0ciArPSBcIkRlZmluZWRBcyAgICAgICA9IEluY0FsdCAvIERlZmluZWRcXG5cIjtcbiAgICBzdHIgKz0gXCJEZWZpbmVkICAgICAgICAgPSAlZDYxXFxuXCI7XG4gICAgc3RyICs9IFwiSW5jQWx0ICAgICAgICAgID0gJWQ2MS40N1xcblwiO1xuICAgIHN0ciArPSBcIlJ1bGVFcnJvciAgICAgICA9IDEqKCVkMzItMTI2IC8gJWQ5ICAvIExpbmVDb250aW51ZSkgTGluZUVuZFxcblwiO1xuICAgIHN0ciArPSBcIkxpbmVFbmRFcnJvciAgICA9IDEqKCVkMzItMTI2IC8gJWQ5ICAvIExpbmVDb250aW51ZSlcXG5cIjtcbiAgICBzdHIgKz0gXCJBbHRlcm5hdGlvbiAgICAgPSBDb25jYXRlbmF0aW9uICoob3dzcCBBbHRPcCBDb25jYXRlbmF0aW9uKVxcblwiO1xuICAgIHN0ciArPSBcIkNvbmNhdGVuYXRpb24gICA9IFJlcGV0aXRpb24gKihDYXRPcCBSZXBldGl0aW9uKVxcblwiO1xuICAgIHN0ciArPSBcIlJlcGV0aXRpb24gICAgICA9IFtNb2RpZmllcl0gKEdyb3VwIC8gT3B0aW9uIC8gQmFzaWNFbGVtZW50IC8gQmFzaWNFbGVtZW50RXJyKVxcblwiO1xuICAgIHN0ciArPSBcIk1vZGlmaWVyICAgICAgICA9IChQcmVkaWNhdGUgW1JlcE9wXSlcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBSZXBPcFxcblwiO1xuICAgIHN0ciArPSBcIlByZWRpY2F0ZSAgICAgICA9IEJrYU9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gQmtuT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBBbmRPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIE5vdE9wXFxuXCI7XG4gICAgc3RyICs9IFwiQmFzaWNFbGVtZW50ICAgID0gVWR0T3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBSbm1PcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIFRyZ09wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gVGJzT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBUbHNPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIENsc09wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gQmtyT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBBYmdPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIEFlbk9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gUHJvc1ZhbFxcblwiO1xuICAgIHN0ciArPSBcIkJhc2ljRWxlbWVudEVyciA9IDEqKCVkMzMtNDAvJWQ0Mi00Ni8lZDQ4LTkyLyVkOTQtMTI2KVxcblwiO1xuICAgIHN0ciArPSBcIkdyb3VwICAgICAgICAgICA9IEdyb3VwT3BlbiAgQWx0ZXJuYXRpb24gKEdyb3VwQ2xvc2UgLyBHcm91cEVycm9yKVxcblwiO1xuICAgIHN0ciArPSBcIkdyb3VwRXJyb3IgICAgICA9IDEqKCVkMzMtNDAvJWQ0Mi00Ni8lZDQ4LTkyLyVkOTQtMTI2KSA7IHNhbWUgYXMgQmFzaWNFbGVtZW50RXJyXFxuXCI7XG4gICAgc3RyICs9IFwiR3JvdXBPcGVuICAgICAgID0gJWQ0MCBvd3NwXFxuXCI7XG4gICAgc3RyICs9IFwiR3JvdXBDbG9zZSAgICAgID0gb3dzcCAlZDQxXFxuXCI7XG4gICAgc3RyICs9IFwiT3B0aW9uICAgICAgICAgID0gT3B0aW9uT3BlbiBBbHRlcm5hdGlvbiAoT3B0aW9uQ2xvc2UgLyBPcHRpb25FcnJvcilcXG5cIjtcbiAgICBzdHIgKz0gXCJPcHRpb25FcnJvciAgICAgPSAxKiglZDMzLTQwLyVkNDItNDYvJWQ0OC05Mi8lZDk0LTEyNikgOyBzYW1lIGFzIEJhc2ljRWxlbWVudEVyclxcblwiO1xuICAgIHN0ciArPSBcIk9wdGlvbk9wZW4gICAgICA9ICVkOTEgb3dzcFxcblwiO1xuICAgIHN0ciArPSBcIk9wdGlvbkNsb3NlICAgICA9IG93c3AgJWQ5M1xcblwiO1xuICAgIHN0ciArPSBcIlJubU9wICAgICAgICAgICA9IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiQmtyT3AgICAgICAgICAgID0gJWQ5MiBbYmtyTW9kaWZpZXJdIGJrci1uYW1lXFxuXCI7XG4gICAgc3RyICs9IFwiYmtyTW9kaWZpZXIgICAgID0gKGNzIFt1bSAvIHBtXSkgLyAoY2kgW3VtIC8gcG1dKSAvICh1bSBbY3MgL2NpXSkgLyAocG0gW2NzIC8gY2ldKVxcblwiO1xuICAgIHN0ciArPSBcImNzICAgICAgICAgICAgICA9ICclcydcXG5cIjtcbiAgICBzdHIgKz0gXCJjaSAgICAgICAgICAgICAgPSAnJWknXFxuXCI7XG4gICAgc3RyICs9IFwidW0gICAgICAgICAgICAgID0gJyV1J1xcblwiO1xuICAgIHN0ciArPSBcInBtICAgICAgICAgICAgICA9ICclcCdcXG5cIjtcbiAgICBzdHIgKz0gXCJia3ItbmFtZSAgICAgICAgPSB1bmFtZSAvIGVuYW1lIC8gcm5hbWVcXG5cIjtcbiAgICBzdHIgKz0gXCJybmFtZSAgICAgICAgICAgPSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcInVuYW1lICAgICAgICAgICA9ICVkMTE3Ljk1IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiZW5hbWUgICAgICAgICAgID0gJWQxMDEuOTUgYWxwaGFudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJVZHRPcCAgICAgICAgICAgPSB1ZHQtZW1wdHlcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyB1ZHQtbm9uLWVtcHR5XFxuXCI7XG4gICAgc3RyICs9IFwidWR0LW5vbi1lbXB0eSAgID0gJWQxMTcuOTUgYWxwaGFudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJ1ZHQtZW1wdHkgICAgICAgPSAlZDEwMS45NSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcIlJlcE9wICAgICAgICAgICA9IChyZXAtbWluIFN0YXJPcCByZXAtbWF4KVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIChyZXAtbWluIFN0YXJPcClcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyAoU3Rhck9wIHJlcC1tYXgpXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gU3Rhck9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gcmVwLW1pbi1tYXhcXG5cIjtcbiAgICBzdHIgKz0gXCJBbHRPcCAgICAgICAgICAgPSAlZDQ3IG93c3BcXG5cIjtcbiAgICBzdHIgKz0gXCJDYXRPcCAgICAgICAgICAgPSB3c3BcXG5cIjtcbiAgICBzdHIgKz0gXCJTdGFyT3AgICAgICAgICAgPSAlZDQyXFxuXCI7XG4gICAgc3RyICs9IFwiQW5kT3AgICAgICAgICAgID0gJWQzOFxcblwiO1xuICAgIHN0ciArPSBcIk5vdE9wICAgICAgICAgICA9ICVkMzNcXG5cIjtcbiAgICBzdHIgKz0gXCJCa2FPcCAgICAgICAgICAgPSAlZDM4LjM4XFxuXCI7XG4gICAgc3RyICs9IFwiQmtuT3AgICAgICAgICAgID0gJWQzMy4zM1xcblwiO1xuICAgIHN0ciArPSBcIkFiZ09wICAgICAgICAgICA9ICVkMzcuOTRcXG5cIjtcbiAgICBzdHIgKz0gXCJBZW5PcCAgICAgICAgICAgPSAlZDM3LjM2XFxuXCI7XG4gICAgc3RyICs9IFwiVHJnT3AgICAgICAgICAgID0gJWQzNyAoKERlYyBkbWluICVkNDUgZG1heCkgLyAoSGV4IHhtaW4gJWQ0NSB4bWF4KSAvIChCaW4gYm1pbiAlZDQ1IGJtYXgpKVxcblwiO1xuICAgIHN0ciArPSBcIlRic09wICAgICAgICAgICA9ICVkMzcgKChEZWMgZFN0cmluZyAqKCVkNDYgZFN0cmluZykpIC8gKEhleCB4U3RyaW5nICooJWQ0NiB4U3RyaW5nKSkgLyAoQmluIGJTdHJpbmcgKiglZDQ2IGJTdHJpbmcpKSlcXG5cIjtcbiAgICBzdHIgKz0gXCJUbHNPcCAgICAgICAgICAgPSBUbHNDYXNlIFRsc09wZW4gVGxzU3RyaW5nIFRsc0Nsb3NlXFxuXCI7XG4gICAgc3RyICs9IFwiVGxzQ2FzZSAgICAgICAgID0gW1xcXCIlaVxcXCIgLyBcXFwiJXNcXFwiXVxcblwiO1xuICAgIHN0ciArPSBcIlRsc09wZW4gICAgICAgICA9ICVkMzRcXG5cIjtcbiAgICBzdHIgKz0gXCJUbHNDbG9zZSAgICAgICAgPSAlZDM0XFxuXCI7XG4gICAgc3RyICs9IFwiVGxzU3RyaW5nICAgICAgID0gKiglZDMyLTMzLyVkMzUtMTI2L1N0cmluZ1RhYilcXG5cIjtcbiAgICBzdHIgKz0gXCJTdHJpbmdUYWIgICAgICAgPSAlZDlcXG5cIjtcbiAgICBzdHIgKz0gXCJDbHNPcCAgICAgICAgICAgPSBDbHNPcGVuIENsc1N0cmluZyBDbHNDbG9zZVxcblwiO1xuICAgIHN0ciArPSBcIkNsc09wZW4gICAgICAgICA9ICVkMzlcXG5cIjtcbiAgICBzdHIgKz0gXCJDbHNDbG9zZSAgICAgICAgPSAlZDM5XFxuXCI7XG4gICAgc3RyICs9IFwiQ2xzU3RyaW5nICAgICAgID0gKiglZDMyLTM4LyVkNDAtMTI2L1N0cmluZ1RhYilcXG5cIjtcbiAgICBzdHIgKz0gXCJQcm9zVmFsICAgICAgICAgPSBQcm9zVmFsT3BlbiBQcm9zVmFsU3RyaW5nIFByb3NWYWxDbG9zZVxcblwiO1xuICAgIHN0ciArPSBcIlByb3NWYWxPcGVuICAgICA9ICVkNjBcXG5cIjtcbiAgICBzdHIgKz0gXCJQcm9zVmFsU3RyaW5nICAgPSAqKCVkMzItNjEvJWQ2My0xMjYvU3RyaW5nVGFiKVxcblwiO1xuICAgIHN0ciArPSBcIlByb3NWYWxDbG9zZSAgICA9ICVkNjJcXG5cIjtcbiAgICBzdHIgKz0gXCJyZXAtbWluICAgICAgICAgPSByZXAtbnVtXFxuXCI7XG4gICAgc3RyICs9IFwicmVwLW1pbi1tYXggICAgID0gcmVwLW51bVxcblwiO1xuICAgIHN0ciArPSBcInJlcC1tYXggICAgICAgICA9IHJlcC1udW1cXG5cIjtcbiAgICBzdHIgKz0gXCJyZXAtbnVtICAgICAgICAgPSAxKiglZDQ4LTU3KVxcblwiO1xuICAgIHN0ciArPSBcImRTdHJpbmcgICAgICAgICA9IGRudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJ4U3RyaW5nICAgICAgICAgPSB4bnVtXFxuXCI7XG4gICAgc3RyICs9IFwiYlN0cmluZyAgICAgICAgID0gYm51bVxcblwiO1xuICAgIHN0ciArPSBcIkRlYyAgICAgICAgICAgICA9ICglZDY4LyVkMTAwKVxcblwiO1xuICAgIHN0ciArPSBcIkhleCAgICAgICAgICAgICA9ICglZDg4LyVkMTIwKVxcblwiO1xuICAgIHN0ciArPSBcIkJpbiAgICAgICAgICAgICA9ICglZDY2LyVkOTgpXFxuXCI7XG4gICAgc3RyICs9IFwiZG1pbiAgICAgICAgICAgID0gZG51bVxcblwiO1xuICAgIHN0ciArPSBcImRtYXggICAgICAgICAgICA9IGRudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJibWluICAgICAgICAgICAgPSBibnVtXFxuXCI7XG4gICAgc3RyICs9IFwiYm1heCAgICAgICAgICAgID0gYm51bVxcblwiO1xuICAgIHN0ciArPSBcInhtaW4gICAgICAgICAgICA9IHhudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJ4bWF4ICAgICAgICAgICAgPSB4bnVtXFxuXCI7XG4gICAgc3RyICs9IFwiZG51bSAgICAgICAgICAgID0gMSooJWQ0OC01NylcXG5cIjtcbiAgICBzdHIgKz0gXCJibnVtICAgICAgICAgICAgPSAxKiVkNDgtNDlcXG5cIjtcbiAgICBzdHIgKz0gXCJ4bnVtICAgICAgICAgICAgPSAxKiglZDQ4LTU3IC8gJWQ2NS03MCAvICVkOTctMTAyKVxcblwiO1xuICAgIHN0ciArPSBcIjtcXG5cIjtcbiAgICBzdHIgKz0gXCI7IEJhc2ljc1xcblwiO1xuICAgIHN0ciArPSBcImFscGhhbnVtICAgICAgICA9ICglZDk3LTEyMi8lZDY1LTkwKSAqKCVkOTctMTIyLyVkNjUtOTAvJWQ0OC01Ny8lZDQ1KVxcblwiO1xuICAgIHN0ciArPSBcIm93c3AgICAgICAgICAgICA9ICpzcGFjZVxcblwiO1xuICAgIHN0ciArPSBcIndzcCAgICAgICAgICAgICA9IDEqc3BhY2VcXG5cIjtcbiAgICBzdHIgKz0gXCJzcGFjZSAgICAgICAgICAgPSAlZDMyXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gJWQ5XFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gY29tbWVudFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIExpbmVDb250aW51ZVxcblwiO1xuICAgIHN0ciArPSBcImNvbW1lbnQgICAgICAgICA9ICVkNTkgKiglZDMyLTEyNiAvICVkOSlcXG5cIjtcbiAgICBzdHIgKz0gXCJMaW5lRW5kICAgICAgICAgPSAlZDEzLjEwXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gJWQxMFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvICVkMTNcXG5cIjtcbiAgICBzdHIgKz0gXCJMaW5lQ29udGludWUgICAgPSAoJWQxMy4xMCAvICVkMTAgLyAlZDEzKSAoJWQzMiAvICVkOSlcXG5cIjtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImdyYW1tYXIiLCJncmFtbWFyT2JqZWN0IiwicnVsZXMiLCJuYW1lIiwibG93ZXIiLCJpbmRleCIsImlzQmtyIiwidWR0cyIsIm9wY29kZXMiLCJ0eXBlIiwibWluIiwibWF4IiwiSW5maW5pdHkiLCJjaGlsZHJlbiIsInN0cmluZyIsInRvU3RyaW5nIiwic3RyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/sabnf-grammar.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-callbacks.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-callbacks.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // These are the AST translation callback functions used by the scanner\n// to analyze the characters and lines.\nconst ids = __webpack_require__(/*! ../apg-lib/identifiers */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\nconst utils = __webpack_require__(/*! ../apg-lib/utilities */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\");\nfunction semLine(state, chars, phraseIndex, phraseCount, data) {\n    if (state === ids.SEM_PRE) {\n        data.endLength = 0;\n        data.textLength = 0;\n        data.invalidCount = 0;\n    } else {\n        data.lines.push({\n            lineNo: data.lines.length,\n            beginChar: phraseIndex,\n            length: phraseCount,\n            textLength: data.textLength,\n            endType: data.endType,\n            invalidChars: data.invalidCount\n        });\n    }\n    return ids.SEM_OK;\n}\nfunction semLineText(state, chars, phraseIndex, phraseCount, data) {\n    if (state === ids.SEM_PRE) {\n        data.textLength = phraseCount;\n    }\n    return ids.SEM_OK;\n}\nfunction semLastLine(state, chars, phraseIndex, phraseCount, data) {\n    if (state === ids.SEM_PRE) {\n        data.endLength = 0;\n        data.textLength = 0;\n        data.invalidCount = 0;\n    } else if (data.strict) {\n        data.lines.push({\n            lineNo: data.lines.length,\n            beginChar: phraseIndex,\n            length: phraseCount,\n            textLength: phraseCount,\n            endType: \"none\",\n            invalidChars: data.invalidCount\n        });\n        data.errors.push({\n            line: data.lineNo,\n            char: phraseIndex + phraseCount,\n            msg: \"no line end on last line - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)\"\n        });\n    } else {\n        /* add a line ender */ chars.push(10);\n        data.lines.push({\n            lineNo: data.lines.length,\n            beginChar: phraseIndex,\n            length: phraseCount + 1,\n            textLength: phraseCount,\n            endType: \"LF\",\n            invalidChars: data.invalidCount\n        });\n    }\n    return ids.SEM_OK;\n}\nfunction semInvalid(state, chars, phraseIndex, phraseCount, data) {\n    if (state === ids.SEM_PRE) {\n        data.errors.push({\n            line: data.lineNo,\n            char: phraseIndex,\n            msg: `invalid character found '\\\\x${utils.charToHex(chars[phraseIndex])}'`\n        });\n    }\n    return ids.SEM_OK;\n}\nfunction semEnd(state, chars, phraseIndex, phraseCount, data) {\n    if (state === ids.SEM_POST) {\n        data.lineNo += 1;\n    }\n    return ids.SEM_OK;\n}\nfunction semLF(state, chars, phraseIndex, phraseCount, data) {\n    if (state === ids.SEM_PRE) {\n        data.endType = \"LF\";\n        if (data.strict) {\n            data.errors.push({\n                line: data.lineNo,\n                char: phraseIndex,\n                msg: \"line end character LF(\\\\n, \\\\x0A) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)\"\n            });\n        }\n    }\n    return ids.SEM_OK;\n}\nfunction semCR(state, chars, phraseIndex, phraseCount, data) {\n    if (state === ids.SEM_PRE) {\n        data.endType = \"CR\";\n        if (data.strict) {\n            data.errors.push({\n                line: data.lineNo,\n                char: phraseIndex,\n                msg: \"line end character CR(\\\\r, \\\\x0D) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)\"\n            });\n        }\n    }\n    return ids.SEM_OK;\n}\nfunction semCRLF(state, chars, phraseIndex, phraseCount, data) {\n    if (state === ids.SEM_PRE) {\n        data.endType = \"CRLF\";\n    }\n    return ids.SEM_OK;\n}\nconst callbacks = [];\ncallbacks.line = semLine;\ncallbacks[\"line-text\"] = semLineText;\ncallbacks[\"last-line\"] = semLastLine;\ncallbacks.invalid = semInvalid;\ncallbacks.end = semEnd;\ncallbacks.lf = semLF;\ncallbacks.cr = semCR;\ncallbacks.crlf = semCRLF;\nexports.callbacks = callbacks;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItY2FsbGJhY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7dUZBR3VGLEdBQ3ZGLHVFQUF1RTtBQUN2RSx1Q0FBdUM7QUFDdkMsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFFdEIsU0FBU0UsUUFBUUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxJQUFJO0lBQzNELElBQUlKLFVBQVVKLElBQUlTLE9BQU8sRUFBRTtRQUN6QkQsS0FBS0UsU0FBUyxHQUFHO1FBQ2pCRixLQUFLRyxVQUFVLEdBQUc7UUFDbEJILEtBQUtJLFlBQVksR0FBRztJQUN0QixPQUFPO1FBQ0xKLEtBQUtLLEtBQUssQ0FBQ0MsSUFBSSxDQUFDO1lBQ2RDLFFBQVFQLEtBQUtLLEtBQUssQ0FBQ0csTUFBTTtZQUN6QkMsV0FBV1g7WUFDWFUsUUFBUVQ7WUFDUkksWUFBWUgsS0FBS0csVUFBVTtZQUMzQk8sU0FBU1YsS0FBS1UsT0FBTztZQUNyQkMsY0FBY1gsS0FBS0ksWUFBWTtRQUNqQztJQUNGO0lBQ0EsT0FBT1osSUFBSW9CLE1BQU07QUFDbkI7QUFDQSxTQUFTQyxZQUFZakIsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxJQUFJO0lBQy9ELElBQUlKLFVBQVVKLElBQUlTLE9BQU8sRUFBRTtRQUN6QkQsS0FBS0csVUFBVSxHQUFHSjtJQUNwQjtJQUNBLE9BQU9QLElBQUlvQixNQUFNO0FBQ25CO0FBQ0EsU0FBU0UsWUFBWWxCLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsSUFBSTtJQUMvRCxJQUFJSixVQUFVSixJQUFJUyxPQUFPLEVBQUU7UUFDekJELEtBQUtFLFNBQVMsR0FBRztR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R0FBR2Q7QUFDekJjLFNBQVMsQ0FBQyxZQUFZLEdBQUdiO0FBQ3pCYSxVQUFVQyxPQUFPLEdBQUdSO0FBQ3BCTyxVQUFVRSxHQUFHLEdBQUdQO0FBQ2hCSyxVQUFVRyxFQUFFLEdBQUdOO0FBQ2ZHLFVBQVVJLEVBQUUsR0FBR047QUFDZkUsVUFBVUssSUFBSSxHQUFHTjtBQUNqQk8saUJBQWlCLEdBQUdOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2Nhbm5lci1jYWxsYmFja3MuanM/NGMyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGVzZSBhcmUgdGhlIEFTVCB0cmFuc2xhdGlvbiBjYWxsYmFjayBmdW5jdGlvbnMgdXNlZCBieSB0aGUgc2Nhbm5lclxuLy8gdG8gYW5hbHl6ZSB0aGUgY2hhcmFjdGVycyBhbmQgbGluZXMuXG5jb25zdCBpZHMgPSByZXF1aXJlKCcuLi9hcGctbGliL2lkZW50aWZpZXJzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL2FwZy1saWIvdXRpbGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHNlbUxpbmUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZW5kTGVuZ3RoID0gMDtcbiAgICBkYXRhLnRleHRMZW5ndGggPSAwO1xuICAgIGRhdGEuaW52YWxpZENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLmxpbmVzLnB1c2goe1xuICAgICAgbGluZU5vOiBkYXRhLmxpbmVzLmxlbmd0aCxcbiAgICAgIGJlZ2luQ2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICBsZW5ndGg6IHBocmFzZUNvdW50LFxuICAgICAgdGV4dExlbmd0aDogZGF0YS50ZXh0TGVuZ3RoLFxuICAgICAgZW5kVHlwZTogZGF0YS5lbmRUeXBlLFxuICAgICAgaW52YWxpZENoYXJzOiBkYXRhLmludmFsaWRDb3VudCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUxpbmVUZXh0KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QUkUpIHtcbiAgICBkYXRhLnRleHRMZW5ndGggPSBwaHJhc2VDb3VudDtcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUxhc3RMaW5lKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QUkUpIHtcbiAgICBkYXRhLmVuZExlbmd0aCA9IDA7XG4gICAgZGF0YS50ZXh0TGVuZ3RoID0gMDtcbiAgICBkYXRhLmludmFsaWRDb3VudCA9IDA7XG4gIH0gZWxzZSBpZiAoZGF0YS5zdHJpY3QpIHtcbiAgICBkYXRhLmxpbmVzLnB1c2goe1xuICAgICAgbGluZU5vOiBkYXRhLmxpbmVzLmxlbmd0aCxcbiAgICAgIGJlZ2luQ2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICBsZW5ndGg6IHBocmFzZUNvdW50LFxuICAgICAgdGV4dExlbmd0aDogcGhyYXNlQ291bnQsXG4gICAgICBlbmRUeXBlOiAnbm9uZScsXG4gICAgICBpbnZhbGlkQ2hhcnM6IGRhdGEuaW52YWxpZENvdW50LFxuICAgIH0pO1xuICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgbGluZTogZGF0YS5saW5lTm8sXG4gICAgICBjaGFyOiBwaHJhc2VJbmRleCArIHBocmFzZUNvdW50LFxuICAgICAgbXNnOiAnbm8gbGluZSBlbmQgb24gbGFzdCBsaW5lIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVzIENSTEYoXFxcXHJcXFxcbiwgXFxcXHgwRFxcXFx4MEEpJyxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvKiBhZGQgYSBsaW5lIGVuZGVyICovXG4gICAgY2hhcnMucHVzaCgxMCk7XG4gICAgZGF0YS5saW5lcy5wdXNoKHtcbiAgICAgIGxpbmVObzogZGF0YS5saW5lcy5sZW5ndGgsXG4gICAgICBiZWdpbkNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgbGVuZ3RoOiBwaHJhc2VDb3VudCArIDEsXG4gICAgICB0ZXh0TGVuZ3RoOiBwaHJhc2VDb3VudCxcbiAgICAgIGVuZFR5cGU6ICdMRicsXG4gICAgICBpbnZhbGlkQ2hhcnM6IGRhdGEuaW52YWxpZENvdW50LFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuZnVuY3Rpb24gc2VtSW52YWxpZChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUFJFKSB7XG4gICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICBsaW5lOiBkYXRhLmxpbmVObyxcbiAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgbXNnOiBgaW52YWxpZCBjaGFyYWN0ZXIgZm91bmQgJ1xcXFx4JHt1dGlscy5jaGFyVG9IZXgoY2hhcnNbcGhyYXNlSW5kZXhdKX0nYCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUVuZChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUE9TVCkge1xuICAgIGRhdGEubGluZU5vICs9IDE7XG4gIH1cbiAgcmV0dXJuIGlkcy5TRU1fT0s7XG59XG5mdW5jdGlvbiBzZW1MRihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUFJFKSB7XG4gICAgZGF0YS5lbmRUeXBlID0gJ0xGJztcbiAgICBpZiAoZGF0YS5zdHJpY3QpIHtcbiAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICBsaW5lOiBkYXRhLmxpbmVObyxcbiAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgIG1zZzogJ2xpbmUgZW5kIGNoYXJhY3RlciBMRihcXFxcbiwgXFxcXHgwQSkgLSBzdHJpY3QgQUJORiBzcGVjaWZpZXMgQ1JMRihcXFxcclxcXFxuLCBcXFxceDBEXFxcXHgwQSknLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuZnVuY3Rpb24gc2VtQ1Ioc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZW5kVHlwZSA9ICdDUic7XG4gICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgbGluZTogZGF0YS5saW5lTm8sXG4gICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICBtc2c6ICdsaW5lIGVuZCBjaGFyYWN0ZXIgQ1IoXFxcXHIsIFxcXFx4MEQpIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVzIENSTEYoXFxcXHJcXFxcbiwgXFxcXHgwRFxcXFx4MEEpJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUNSTEYoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZW5kVHlwZSA9ICdDUkxGJztcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmNvbnN0IGNhbGxiYWNrcyA9IFtdO1xuY2FsbGJhY2tzLmxpbmUgPSBzZW1MaW5lO1xuY2FsbGJhY2tzWydsaW5lLXRleHQnXSA9IHNlbUxpbmVUZXh0O1xuY2FsbGJhY2tzWydsYXN0LWxpbmUnXSA9IHNlbUxhc3RMaW5lO1xuY2FsbGJhY2tzLmludmFsaWQgPSBzZW1JbnZhbGlkO1xuY2FsbGJhY2tzLmVuZCA9IHNlbUVuZDtcbmNhbGxiYWNrcy5sZiA9IHNlbUxGO1xuY2FsbGJhY2tzLmNyID0gc2VtQ1I7XG5jYWxsYmFja3MuY3JsZiA9IHNlbUNSTEY7XG5leHBvcnRzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiJdLCJuYW1lcyI6WyJpZHMiLCJyZXF1aXJlIiwidXRpbHMiLCJzZW1MaW5lIiwic3RhdGUiLCJjaGFycyIsInBocmFzZUluZGV4IiwicGhyYXNlQ291bnQiLCJkYXRhIiwiU0VNX1BSRSIsImVuZExlbmd0aCIsInRleHRMZW5ndGgiLCJpbnZhbGlkQ291bnQiLCJsaW5lcyIsInB1c2giLCJsaW5lTm8iLCJsZW5ndGgiLCJiZWdpbkNoYXIiLCJlbmRUeXBlIiwiaW52YWxpZENoYXJzIiwiU0VNX09LIiwic2VtTGluZVRleHQiLCJzZW1MYXN0TGluZSIsInN0cmljdCIsImVycm9ycyIsImxpbmUiLCJjaGFyIiwibXNnIiwic2VtSW52YWxpZCIsImNoYXJUb0hleCIsInNlbUVuZCIsIlNFTV9QT1NUIiwic2VtTEYiLCJzZW1DUiIsInNlbUNSTEYiLCJjYWxsYmFja3MiLCJpbnZhbGlkIiwiZW5kIiwibGYiLCJjciIsImNybGYiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-callbacks.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-grammar.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-grammar.js ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.2.1 [apg-js](https://github.com/ldthomas/apg-js)\n\nmodule.exports = function grammar() {\n    // ```\n    // SUMMARY\n    //      rules = 10\n    //       udts = 0\n    //    opcodes = 31\n    //        ---   ABNF original opcodes\n    //        ALT = 5\n    //        CAT = 2\n    //        REP = 4\n    //        RNM = 11\n    //        TLS = 0\n    //        TBS = 4\n    //        TRG = 5\n    //        ---   SABNF superset opcodes\n    //        UDT = 0\n    //        AND = 0\n    //        NOT = 0\n    //        BKA = 0\n    //        BKN = 0\n    //        BKR = 0\n    //        ABG = 0\n    //        AEN = 0\n    // characters = [0 - 4294967295]\n    // ```\n    /* OBJECT IDENTIFIER (for internal parser use) */ this.grammarObject = \"grammarObject\";\n    /* RULES */ this.rules = [];\n    this.rules[0] = {\n        name: \"file\",\n        lower: \"file\",\n        index: 0,\n        isBkr: false\n    };\n    this.rules[1] = {\n        name: \"line\",\n        lower: \"line\",\n        index: 1,\n        isBkr: false\n    };\n    this.rules[2] = {\n        name: \"line-text\",\n        lower: \"line-text\",\n        index: 2,\n        isBkr: false\n    };\n    this.rules[3] = {\n        name: \"last-line\",\n        lower: \"last-line\",\n        index: 3,\n        isBkr: false\n    };\n    this.rules[4] = {\n        name: \"valid\",\n        lower: \"valid\",\n        index: 4,\n        isBkr: false\n    };\n    this.rules[5] = {\n        name: \"invalid\",\n        lower: \"invalid\",\n        index: 5,\n        isBkr: false\n    };\n    this.rules[6] = {\n        name: \"end\",\n        lower: \"end\",\n        index: 6,\n        isBkr: false\n    };\n    this.rules[7] = {\n        name: \"CRLF\",\n        lower: \"crlf\",\n        index: 7,\n        isBkr: false\n    };\n    this.rules[8] = {\n        name: \"LF\",\n        lower: \"lf\",\n        index: 8,\n        isBkr: false\n    };\n    this.rules[9] = {\n        name: \"CR\",\n        lower: \"cr\",\n        index: 9,\n        isBkr: false\n    };\n    /* UDTS */ this.udts = [];\n    /* OPCODES */ /* file */ this.rules[0].opcodes = [];\n    this.rules[0].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            3\n        ]\n    }; // CAT\n    this.rules[0].opcodes[1] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[0].opcodes[2] = {\n        type: 4,\n        index: 1\n    }; // RNM(line)\n    this.rules[0].opcodes[3] = {\n        type: 3,\n        min: 0,\n        max: 1\n    }; // REP\n    this.rules[0].opcodes[4] = {\n        type: 4,\n        index: 3\n    }; // RNM(last-line)\n    /* line */ this.rules[1].opcodes = [];\n    this.rules[1].opcodes[0] = {\n        type: 2,\n        children: [\n            1,\n            2\n        ]\n    }; // CAT\n    this.rules[1].opcodes[1] = {\n        type: 4,\n        index: 2\n    }; // RNM(line-text)\n    this.rules[1].opcodes[2] = {\n        type: 4,\n        index: 6\n    }; // RNM(end)\n    /* line-text */ this.rules[2].opcodes = [];\n    this.rules[2].opcodes[0] = {\n        type: 3,\n        min: 0,\n        max: Infinity\n    }; // REP\n    this.rules[2].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3\n        ]\n    }; // ALT\n    this.rules[2].opcodes[2] = {\n        type: 4,\n        index: 4\n    }; // RNM(valid)\n    this.rules[2].opcodes[3] = {\n        type: 4,\n        index: 5\n    }; // RNM(invalid)\n    /* last-line */ this.rules[3].opcodes = [];\n    this.rules[3].opcodes[0] = {\n        type: 3,\n        min: 1,\n        max: Infinity\n    }; // REP\n    this.rules[3].opcodes[1] = {\n        type: 1,\n        children: [\n            2,\n            3\n        ]\n    }; // ALT\n    this.rules[3].opcodes[2] = {\n        type: 4,\n        index: 4\n    }; // RNM(valid)\n    this.rules[3].opcodes[3] = {\n        type: 4,\n        index: 5\n    }; // RNM(invalid)\n    /* valid */ this.rules[4].opcodes = [];\n    this.rules[4].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2\n        ]\n    }; // ALT\n    this.rules[4].opcodes[1] = {\n        type: 5,\n        min: 32,\n        max: 126\n    }; // TRG\n    this.rules[4].opcodes[2] = {\n        type: 6,\n        string: [\n            9\n        ]\n    }; // TBS\n    /* invalid */ this.rules[5].opcodes = [];\n    this.rules[5].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2,\n            3,\n            4\n        ]\n    }; // ALT\n    this.rules[5].opcodes[1] = {\n        type: 5,\n        min: 0,\n        max: 8\n    }; // TRG\n    this.rules[5].opcodes[2] = {\n        type: 5,\n        min: 11,\n        max: 12\n    }; // TRG\n    this.rules[5].opcodes[3] = {\n        type: 5,\n        min: 14,\n        max: 31\n    }; // TRG\n    this.rules[5].opcodes[4] = {\n        type: 5,\n        min: 127,\n        max: 4294967295\n    }; // TRG\n    /* end */ this.rules[6].opcodes = [];\n    this.rules[6].opcodes[0] = {\n        type: 1,\n        children: [\n            1,\n            2,\n            3\n        ]\n    }; // ALT\n    this.rules[6].opcodes[1] = {\n        type: 4,\n        index: 7\n    }; // RNM(CRLF)\n    this.rules[6].opcodes[2] = {\n        type: 4,\n        index: 8\n    }; // RNM(LF)\n    this.rules[6].opcodes[3] = {\n        type: 4,\n        index: 9\n    }; // RNM(CR)\n    /* CRLF */ this.rules[7].opcodes = [];\n    this.rules[7].opcodes[0] = {\n        type: 6,\n        string: [\n            13,\n            10\n        ]\n    }; // TBS\n    /* LF */ this.rules[8].opcodes = [];\n    this.rules[8].opcodes[0] = {\n        type: 6,\n        string: [\n            10\n        ]\n    }; // TBS\n    /* CR */ this.rules[9].opcodes = [];\n    this.rules[9].opcodes[0] = {\n        type: 6,\n        string: [\n            13\n        ]\n    }; // TBS\n    // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n    this.toString = function toString() {\n        let str = \"\";\n        str += \"file = *line [last-line]\\n\";\n        str += \"line = line-text end\\n\";\n        str += \"line-text = *(valid/invalid)\\n\";\n        str += \"last-line = 1*(valid/invalid)\\n\";\n        str += \"valid = %d32-126 / %d9\\n\";\n        str += \"invalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\\n\";\n        str += \"end = CRLF / LF / CR\\n\";\n        str += \"CRLF = %d13.10\\n\";\n        str += \"LF = %d10\\n\";\n        str += \"CR = %d13\\n\";\n        return str;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItZ3JhbW1hci5qcyIsIm1hcHBpbmdzIjoiQUFBQSwwRUFBMEU7QUFDMUUsNkVBQTZFO0FBQzdFLEVBQUU7QUFDRixrRkFBa0Y7O0FBQ2xGQSxPQUFPQyxPQUFPLEdBQUcsU0FBU0M7SUFDeEIsTUFBTTtJQUNOLFVBQVU7SUFDVixrQkFBa0I7SUFDbEIsaUJBQWlCO0lBQ2pCLGtCQUFrQjtJQUNsQixxQ0FBcUM7SUFDckMsaUJBQWlCO0lBQ2pCLGlCQUFpQjtJQUNqQixpQkFBaUI7SUFDakIsa0JBQWtCO0lBQ2xCLGlCQUFpQjtJQUNqQixpQkFBaUI7SUFDakIsaUJBQWlCO0lBQ2pCLHNDQUFzQztJQUN0QyxpQkFBaUI7SUFDakIsaUJBQWlCO0lBQ2pCLGlCQUFpQjtJQUNqQixpQkFBaUI7SUFDakIsaUJBQWlCO0lBQ2pCLGlCQUFpQjtJQUNqQixpQkFBaUI7SUFDakIsaUJBQWlCO0lBQ2pCLGdDQUFnQztJQUNoQyxNQUFNO0lBQ04sK0NBQStDLEdBQy9DLElBQUksQ0FBQ0MsYUFBYSxHQUFHO0lBRXJCLFNBQVMsR0FDVCxJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO0lBQ2YsSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxHQUFHO1FBQUNDLE1BQU07UUFBUUMsT0FBTztRQUFRQyxPQUFPO1FBQUdDLE9BQU87SUFBSztJQUNwRSxJQUFJLENBQUNKLEtBQUssQ0FBQyxFQUFFLEdBQUc7UUFBQ0MsTUFBTTtRQUFRQyxPQUFPO1FBQVFDLE9BQU87UUFBR0MsT0FBTztJQUFLO0lBQ3BFLElBQUksQ0FBQ0osS0FBSyxDQUFDLEVBQUUsR0FBRztRQUFDQyxNQUFNO1FBQWFDLE9BQU87UUFBYUMsT0FBTztRQUFHQyxPQUFPO0lBQUs7SUFDOUUsSUFBSSxDQUFDSixLQUFLLENBQUMsRUFBRSxHQUFHO1FBQUNDLE1BQU07UUFB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SUFBSUMsTUFBTTtRQUNWQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1BBLE9BQU87UUFDUEEsT0FBTztRQUNQQSxPQUFPO1FBQ1AsT0FBT0E7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2Nhbm5lci1ncmFtbWFyLmpzP2VlOGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjMgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZDxicj5cbi8vICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSk8YnI+XG4vL1xuLy8gR2VuZXJhdGVkIGJ5IGFwZy1qcywgVmVyc2lvbiA0LjIuMSBbYXBnLWpzXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBncmFtbWFyKCl7XG4gIC8vIGBgYFxuICAvLyBTVU1NQVJZXG4gIC8vICAgICAgcnVsZXMgPSAxMFxuICAvLyAgICAgICB1ZHRzID0gMFxuICAvLyAgICBvcGNvZGVzID0gMzFcbiAgLy8gICAgICAgIC0tLSAgIEFCTkYgb3JpZ2luYWwgb3Bjb2Rlc1xuICAvLyAgICAgICAgQUxUID0gNVxuICAvLyAgICAgICAgQ0FUID0gMlxuICAvLyAgICAgICAgUkVQID0gNFxuICAvLyAgICAgICAgUk5NID0gMTFcbiAgLy8gICAgICAgIFRMUyA9IDBcbiAgLy8gICAgICAgIFRCUyA9IDRcbiAgLy8gICAgICAgIFRSRyA9IDVcbiAgLy8gICAgICAgIC0tLSAgIFNBQk5GIHN1cGVyc2V0IG9wY29kZXNcbiAgLy8gICAgICAgIFVEVCA9IDBcbiAgLy8gICAgICAgIEFORCA9IDBcbiAgLy8gICAgICAgIE5PVCA9IDBcbiAgLy8gICAgICAgIEJLQSA9IDBcbiAgLy8gICAgICAgIEJLTiA9IDBcbiAgLy8gICAgICAgIEJLUiA9IDBcbiAgLy8gICAgICAgIEFCRyA9IDBcbiAgLy8gICAgICAgIEFFTiA9IDBcbiAgLy8gY2hhcmFjdGVycyA9IFswIC0gNDI5NDk2NzI5NV1cbiAgLy8gYGBgXG4gIC8qIE9CSkVDVCBJREVOVElGSUVSIChmb3IgaW50ZXJuYWwgcGFyc2VyIHVzZSkgKi9cbiAgdGhpcy5ncmFtbWFyT2JqZWN0ID0gJ2dyYW1tYXJPYmplY3QnO1xuXG4gIC8qIFJVTEVTICovXG4gIHRoaXMucnVsZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1swXSA9IHtuYW1lOiAnZmlsZScsIGxvd2VyOiAnZmlsZScsIGluZGV4OiAwLCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzFdID0ge25hbWU6ICdsaW5lJywgbG93ZXI6ICdsaW5lJywgaW5kZXg6IDEsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbMl0gPSB7bmFtZTogJ2xpbmUtdGV4dCcsIGxvd2VyOiAnbGluZS10ZXh0JywgaW5kZXg6IDIsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbM10gPSB7bmFtZTogJ2xhc3QtbGluZScsIGxvd2VyOiAnbGFzdC1saW5lJywgaW5kZXg6IDMsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNF0gPSB7bmFtZTogJ3ZhbGlkJywgbG93ZXI6ICd2YWxpZCcsIGluZGV4OiA0LCBpc0JrcjogZmFsc2V9O1xuICB0aGlzLnJ1bGVzWzVdID0ge25hbWU6ICdpbnZhbGlkJywgbG93ZXI6ICdpbnZhbGlkJywgaW5kZXg6IDUsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbNl0gPSB7bmFtZTogJ2VuZCcsIGxvd2VyOiAnZW5kJywgaW5kZXg6IDYsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbN10gPSB7bmFtZTogJ0NSTEYnLCBsb3dlcjogJ2NybGYnLCBpbmRleDogNywgaXNCa3I6IGZhbHNlfTtcbiAgdGhpcy5ydWxlc1s4XSA9IHtuYW1lOiAnTEYnLCBsb3dlcjogJ2xmJywgaW5kZXg6IDgsIGlzQmtyOiBmYWxzZX07XG4gIHRoaXMucnVsZXNbOV0gPSB7bmFtZTogJ0NSJywgbG93ZXI6ICdjcicsIGluZGV4OiA5LCBpc0JrcjogZmFsc2V9O1xuXG4gIC8qIFVEVFMgKi9cbiAgdGhpcy51ZHRzID0gW107XG5cbiAgLyogT1BDT0RFUyAqL1xuICAvKiBmaWxlICovXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDNdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzFdID0ge3R5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogMX07Ly8gUk5NKGxpbmUpXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1szXSA9IHt0eXBlOiAzLCBtaW46IDAsIG1heDogMX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1s0XSA9IHt0eXBlOiA0LCBpbmRleDogM307Ly8gUk5NKGxhc3QtbGluZSlcblxuICAvKiBsaW5lICovXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbMF0gPSB7dHlwZTogMiwgY2hpbGRyZW46IFsxLDJdfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiAyfTsvLyBSTk0obGluZS10ZXh0KVxuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDZ9Oy8vIFJOTShlbmQpXG5cbiAgLyogbGluZS10ZXh0ICovXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbMF0gPSB7dHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5fTsvLyBSRVBcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzFdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMiwzXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA0LCBpbmRleDogNH07Ly8gUk5NKHZhbGlkKVxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbM10gPSB7dHlwZTogNCwgaW5kZXg6IDV9Oy8vIFJOTShpbnZhbGlkKVxuXG4gIC8qIGxhc3QtbGluZSAqL1xuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzBdID0ge3R5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eX07Ly8gUkVQXG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1sxXSA9IHt0eXBlOiAxLCBjaGlsZHJlbjogWzIsM119Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXNbMl0gPSB7dHlwZTogNCwgaW5kZXg6IDR9Oy8vIFJOTSh2YWxpZClcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzNdID0ge3R5cGU6IDQsIGluZGV4OiA1fTsvLyBSTk0oaW52YWxpZClcblxuICAvKiB2YWxpZCAqL1xuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXX07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1sxXSA9IHt0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDEyNn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1syXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFs5XX07Ly8gVEJTXG5cbiAgLyogaW52YWxpZCAqL1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDMsNF19Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMV0gPSB7dHlwZTogNSwgbWluOiAwLCBtYXg6IDh9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMl0gPSB7dHlwZTogNSwgbWluOiAxMSwgbWF4OiAxMn07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNV0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA1LCBtaW46IDE0LCBtYXg6IDMxfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s1XS5vcGNvZGVzWzRdID0ge3R5cGU6IDUsIG1pbjogMTI3LCBtYXg6IDQyOTQ5NjcyOTV9Oy8vIFRSR1xuXG4gIC8qIGVuZCAqL1xuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzBdID0ge3R5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDNdfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzFdID0ge3R5cGU6IDQsIGluZGV4OiA3fTsvLyBSTk0oQ1JMRilcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzJdID0ge3R5cGU6IDQsIGluZGV4OiA4fTsvLyBSTk0oTEYpXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1szXSA9IHt0eXBlOiA0LCBpbmRleDogOX07Ly8gUk5NKENSKVxuXG4gIC8qIENSTEYgKi9cbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbN10ub3Bjb2Rlc1swXSA9IHt0eXBlOiA2LCBzdHJpbmc6IFsxMywxMF19Oy8vIFRCU1xuXG4gIC8qIExGICovXG4gIHRoaXMucnVsZXNbOF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzhdLm9wY29kZXNbMF0gPSB7dHlwZTogNiwgc3RyaW5nOiBbMTBdfTsvLyBUQlNcblxuICAvKiBDUiAqL1xuICB0aGlzLnJ1bGVzWzldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s5XS5vcGNvZGVzWzBdID0ge3R5cGU6IDYsIHN0cmluZzogWzEzXX07Ly8gVEJTXG5cbiAgLy8gVGhlIGB0b1N0cmluZygpYCBmdW5jdGlvbiB3aWxsIGRpc3BsYXkgdGhlIG9yaWdpbmFsIGdyYW1tYXIgZmlsZShzKSB0aGF0IHByb2R1Y2VkIHRoZXNlIG9wY29kZXMuXG4gIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIHN0ciArPSBcImZpbGUgPSAqbGluZSBbbGFzdC1saW5lXVxcblwiO1xuICAgIHN0ciArPSBcImxpbmUgPSBsaW5lLXRleHQgZW5kXFxuXCI7XG4gICAgc3RyICs9IFwibGluZS10ZXh0ID0gKih2YWxpZC9pbnZhbGlkKVxcblwiO1xuICAgIHN0ciArPSBcImxhc3QtbGluZSA9IDEqKHZhbGlkL2ludmFsaWQpXFxuXCI7XG4gICAgc3RyICs9IFwidmFsaWQgPSAlZDMyLTEyNiAvICVkOVxcblwiO1xuICAgIHN0ciArPSBcImludmFsaWQgPSAlZDAtOCAvICVkMTEtMTIgLyVkMTQtMzEgLyAleDdmLWZmZmZmZmZmXFxuXCI7XG4gICAgc3RyICs9IFwiZW5kID0gQ1JMRiAvIExGIC8gQ1JcXG5cIjtcbiAgICBzdHIgKz0gXCJDUkxGID0gJWQxMy4xMFxcblwiO1xuICAgIHN0ciArPSBcIkxGID0gJWQxMFxcblwiO1xuICAgIHN0ciArPSBcIkNSID0gJWQxM1xcblwiO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZ3JhbW1hciIsImdyYW1tYXJPYmplY3QiLCJydWxlcyIsIm5hbWUiLCJsb3dlciIsImluZGV4IiwiaXNCa3IiLCJ1ZHRzIiwib3Bjb2RlcyIsInR5cGUiLCJjaGlsZHJlbiIsIm1pbiIsIm1heCIsIkluZmluaXR5Iiwic3RyaW5nIiwidG9TdHJpbmciLCJzdHIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-grammar.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module reads the input grammar file and does a preliminary analysis\n// before attempting to parse it into a grammar object.\n// See:<br>\n// `./dist/scanner-grammar.bnf`<br>\n// for the grammar file this parser is based on.\n//\n// It has two primary functions.\n// - verify the character codes - no non-printing ASCII characters\n// - catalog the lines - create an array with a line object for each line.\n// The object carries information about the line number and character length which is used\n// by the parser generator primarily for error reporting.\n\nmodule.exports = function exfn(chars, errors, strict, trace) {\n    const thisFileName = \"scanner.js: \";\n    const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\");\n    const grammar = new (__webpack_require__(/*! ./scanner-grammar */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-grammar.js\"))();\n    const { callbacks } = __webpack_require__(/*! ./scanner-callbacks */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner-callbacks.js\");\n    /* Scan the grammar for character code errors and catalog the lines. */ const lines = [];\n    // eslint-disable-next-line new-cap\n    const parser = new apglib.parser();\n    // eslint-disable-next-line new-cap\n    parser.ast = new apglib.ast();\n    parser.ast.callbacks = callbacks;\n    if (trace) {\n        if (trace.traceObject !== \"traceObject\") {\n            throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n        }\n        parser.trace = trace;\n    }\n    /* parse the input SABNF grammar */ const test = parser.parse(grammar, \"file\", chars);\n    if (test.success !== true) {\n        errors.push({\n            line: 0,\n            char: 0,\n            msg: \"syntax analysis error analyzing input SABNF grammar\"\n        });\n        return;\n    }\n    const data = {\n        lines,\n        lineNo: 0,\n        errors,\n        strict: !!strict\n    };\n    /* translate (analyze) the input SABNF grammar */ parser.ast.translate(data);\n    // eslint-disable-next-line consistent-return\n    return lines;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozt1RkFHdUYsR0FDdkYsMkVBQTJFO0FBQzNFLHVEQUF1RDtBQUN2RCxXQUFXO0FBQ1gsbUNBQW1DO0FBQ25DLGdEQUFnRDtBQUNoRCxFQUFFO0FBQ0YsZ0NBQWdDO0FBQ2hDLGtFQUFrRTtBQUNsRSwwRUFBMEU7QUFDMUUsMEZBQTBGO0FBQzFGLHlEQUF5RDs7QUFDekRBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxLQUFLQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxLQUFLO0lBQ3pELE1BQU1DLGVBQWU7SUFDckIsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUM7SUFDdkIsTUFBTUMsVUFBVSxJQUFLRCxDQUFBQSxtQkFBT0EsQ0FBQywwSEFBbUI7SUFDaEQsTUFBTSxFQUFFRSxTQUFTLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7SUFFOUIscUVBQXFFLEdBQ3JFLE1BQU1HLFFBQVEsRUFBRTtJQUNoQixtQ0FBbUM7SUFDbkMsTUFBTUMsU0FBUyxJQUFJTCxPQUFPSyxNQUFNO0lBQ2hDLG1DQUFtQztJQUNuQ0EsT0FBT0MsR0FBRyxHQUFHLElBQUlOLE9BQU9NLEdBQUc7SUFDM0JELE9BQU9DLEdBQUcsQ0FBQ0gsU0FBUyxHQUFHQTtJQUN2QixJQUFJTCxPQUFPO1FBQ1QsSUFBSUEsTUFBTVMsV0FBVyxLQUFLLGVBQWU7WUFDdkMsTUFBTSxJQUFJQyxVQUFVLENBQUMsRUFBRVQsYUFBYSxvQ0FBb0MsQ0FBQztRQUMzRTtRQUNBTSxPQUFPUCxLQUFLLEdBQUdBO0lBQ2pCO0lBRUEsaUNBQWlDLEdBQ2pDLE1BQU1XLE9BQU9KLE9BQU9LLEtBQUssQ0FBQ1IsU0FBUyxRQUFRUDtJQUMzQyxJQUFJYyxLQUFLRSxPQUFPLEtBQUssTUFBTTtRQUN6QmYsT0FBT2dCLElBQUksQ0FBQztZQUNWQyxNQUFNO1lBQ05DLE1BQU07WUFDTkMsS0FBSztRQUNQO1FBQ0E7SUFDRjtJQUNBLE1BQU1DLE9BQU87UUFDWFo7UUFDQWEsUUFBUTtRQUNSckI7UUFDQUMsUUFBUSxDQUFDLENBQUNBO0lBQ1o7SUFFQSwrQ0FBK0MsR0FDL0NRLE9BQU9DLEdBQUcsQ0FBQ1ksU0FBUyxDQUFDRjtJQUNyQiw2Q0FBNkM7SUFDN0MsT0FBT1o7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXIuanM/MTlhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSByZWFkcyB0aGUgaW5wdXQgZ3JhbW1hciBmaWxlIGFuZCBkb2VzIGEgcHJlbGltaW5hcnkgYW5hbHlzaXNcbi8vIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHBhcnNlIGl0IGludG8gYSBncmFtbWFyIG9iamVjdC5cbi8vIFNlZTo8YnI+XG4vLyBgLi9kaXN0L3NjYW5uZXItZ3JhbW1hci5ibmZgPGJyPlxuLy8gZm9yIHRoZSBncmFtbWFyIGZpbGUgdGhpcyBwYXJzZXIgaXMgYmFzZWQgb24uXG4vL1xuLy8gSXQgaGFzIHR3byBwcmltYXJ5IGZ1bmN0aW9ucy5cbi8vIC0gdmVyaWZ5IHRoZSBjaGFyYWN0ZXIgY29kZXMgLSBubyBub24tcHJpbnRpbmcgQVNDSUkgY2hhcmFjdGVyc1xuLy8gLSBjYXRhbG9nIHRoZSBsaW5lcyAtIGNyZWF0ZSBhbiBhcnJheSB3aXRoIGEgbGluZSBvYmplY3QgZm9yIGVhY2ggbGluZS5cbi8vIFRoZSBvYmplY3QgY2FycmllcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluZSBudW1iZXIgYW5kIGNoYXJhY3RlciBsZW5ndGggd2hpY2ggaXMgdXNlZFxuLy8gYnkgdGhlIHBhcnNlciBnZW5lcmF0b3IgcHJpbWFyaWx5IGZvciBlcnJvciByZXBvcnRpbmcuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4Zm4oY2hhcnMsIGVycm9ycywgc3RyaWN0LCB0cmFjZSkge1xuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnc2Nhbm5lci5qczogJztcbiAgY29uc3QgYXBnbGliID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHMnKTtcbiAgY29uc3QgZ3JhbW1hciA9IG5ldyAocmVxdWlyZSgnLi9zY2FubmVyLWdyYW1tYXInKSkoKTtcbiAgY29uc3QgeyBjYWxsYmFja3MgfSA9IHJlcXVpcmUoJy4vc2Nhbm5lci1jYWxsYmFja3MnKTtcblxuICAvKiBTY2FuIHRoZSBncmFtbWFyIGZvciBjaGFyYWN0ZXIgY29kZSBlcnJvcnMgYW5kIGNhdGFsb2cgdGhlIGxpbmVzLiAqL1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICBjb25zdCBwYXJzZXIgPSBuZXcgYXBnbGliLnBhcnNlcigpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICBwYXJzZXIuYXN0ID0gbmV3IGFwZ2xpYi5hc3QoKTtcbiAgcGFyc2VyLmFzdC5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gIGlmICh0cmFjZSkge1xuICAgIGlmICh0cmFjZS50cmFjZU9iamVjdCAhPT0gJ3RyYWNlT2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0aGlzRmlsZU5hbWV9dHJhY2UgYXJndW1lbnQgaXMgbm90IGEgdHJhY2Ugb2JqZWN0YCk7XG4gICAgfVxuICAgIHBhcnNlci50cmFjZSA9IHRyYWNlO1xuICB9XG5cbiAgLyogcGFyc2UgdGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgKi9cbiAgY29uc3QgdGVzdCA9IHBhcnNlci5wYXJzZShncmFtbWFyLCAnZmlsZScsIGNoYXJzKTtcbiAgaWYgKHRlc3Quc3VjY2VzcyAhPT0gdHJ1ZSkge1xuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIGxpbmU6IDAsXG4gICAgICBjaGFyOiAwLFxuICAgICAgbXNnOiAnc3ludGF4IGFuYWx5c2lzIGVycm9yIGFuYWx5emluZyBpbnB1dCBTQUJORiBncmFtbWFyJyxcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGF0YSA9IHtcbiAgICBsaW5lcyxcbiAgICBsaW5lTm86IDAsXG4gICAgZXJyb3JzLFxuICAgIHN0cmljdDogISFzdHJpY3QsXG4gIH07XG5cbiAgLyogdHJhbnNsYXRlIChhbmFseXplKSB0aGUgaW5wdXQgU0FCTkYgZ3JhbW1hciAqL1xuICBwYXJzZXIuYXN0LnRyYW5zbGF0ZShkYXRhKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIHJldHVybiBsaW5lcztcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImV4Zm4iLCJjaGFycyIsImVycm9ycyIsInN0cmljdCIsInRyYWNlIiwidGhpc0ZpbGVOYW1lIiwiYXBnbGliIiwicmVxdWlyZSIsImdyYW1tYXIiLCJjYWxsYmFja3MiLCJsaW5lcyIsInBhcnNlciIsImFzdCIsInRyYWNlT2JqZWN0IiwiVHlwZUVycm9yIiwidGVzdCIsInBhcnNlIiwic3VjY2VzcyIsInB1c2giLCJsaW5lIiwiY2hhciIsIm1zZyIsImRhdGEiLCJsaW5lTm8iLCJ0cmFuc2xhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/scanner.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/semantic-callbacks.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/semantic-callbacks.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module has all of the AST translation callback functions for the semantic analysis\n// phase of the generator.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\n\nmodule.exports = function exfn() {\n    const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\");\n    const id = apglib.ids;\n    /* Some helper functions. */ const NameList = function NameList() {\n        this.names = [];\n        /* Adds a new rule name object to the list. Returns -1 if the name already exists. */ /* Returns the added name object if the name does not already exist. */ this.add = function add(name) {\n            let ret = -1;\n            const find = this.get(name);\n            if (find === -1) {\n                ret = {\n                    name,\n                    lower: name.toLowerCase(),\n                    index: this.names.length\n                };\n                this.names.push(ret);\n            }\n            return ret;\n        };\n        /* Brute-force look up. */ this.get = function get(name) {\n            let ret = -1;\n            const lower = name.toLowerCase();\n            for(let i = 0; i < this.names.length; i += 1){\n                if (this.names[i].lower === lower) {\n                    ret = this.names[i];\n                    break;\n                }\n            }\n            return ret;\n        };\n    };\n    /* converts text decimal numbers from, e.g. %d99, to an integer */ const decnum = function decnum(chars, beg, len) {\n        let num = 0;\n        for(let i = beg; i < beg + len; i += 1){\n            num = 10 * num + chars[i] - 48;\n        }\n        return num;\n    };\n    /* converts text binary numbers from, e.g. %b10, to an integer */ const binnum = function binnum(chars, beg, len) {\n        let num = 0;\n        for(let i = beg; i < beg + len; i += 1){\n            num = 2 * num + chars[i] - 48;\n        }\n        return num;\n    };\n    /* converts text hexadecimal numbers from, e.g. %xff, to an integer */ const hexnum = function hexnum(chars, beg, len) {\n        let num = 0;\n        for(let i = beg; i < beg + len; i += 1){\n            let digit = chars[i];\n            if (digit >= 48 && digit <= 57) {\n                digit -= 48;\n            } else if (digit >= 65 && digit <= 70) {\n                digit -= 55;\n            } else if (digit >= 97 && digit <= 102) {\n                digit -= 87;\n            } else {\n                throw new Error(\"hexnum out of range\");\n            }\n            num = 16 * num + digit;\n        }\n        return num;\n    };\n    // This is the prototype for all semantic analysis callback functions.\n    // ````\n    // state - the translator state\n    //   id.SEM_PRE for downward (pre-branch) traversal of the AST\n    //   id.SEM_POST for upward (post branch) traversal of the AST\n    // chars - the array of character codes for the input string\n    // phraseIndex - index into the chars array to the first\n    //               character of the phrase\n    // phraseCount - the number of characters in the phrase\n    // data - user-defined data passed to the translator\n    //        for use by the callback functions.\n    // @return id.SEM_OK, normal return.\n    //         id.SEM_SKIP in state id.SEM_PRE will\n    //         skip the branch below.\n    //         Any thing else is an error which will\n    //         stop the translation.\n    // ````\n    /*\n  function semCallbackPrototype(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n    } else if (state === id.SEM_POST) {\n    }\n    return ret;\n  }\n  */ // The AST callback functions.\n    function semFile(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            data.ruleNames = new NameList();\n            data.udtNames = new NameList();\n            data.rules = [];\n            data.udts = [];\n            data.rulesLineMap = [];\n            data.opcodes = [];\n            data.altStack = [];\n            data.topStack = null;\n            data.topRule = null;\n        } else if (state === id.SEM_POST) {\n            /* validate RNM rule names and set opcode rule index */ let nameObj;\n            data.rules.forEach((rule)=>{\n                rule.isBkr = false;\n                rule.opcodes.forEach((op)=>{\n                    if (op.type === id.RNM) {\n                        nameObj = data.ruleNames.get(op.index.name);\n                        if (nameObj === -1) {\n                            data.errors.push({\n                                line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                                char: op.index.phraseIndex,\n                                msg: `Rule name '${op.index.name}' used but not defined.`\n                            });\n                            op.index = -1;\n                        } else {\n                            op.index = nameObj.index;\n                        }\n                    }\n                });\n            });\n            /* validate BKR rule names and set opcode rule index */ data.udts.forEach((udt)=>{\n                udt.isBkr = false;\n            });\n            data.rules.forEach((rule)=>{\n                rule.opcodes.forEach((op)=>{\n                    if (op.type === id.BKR) {\n                        rule.hasBkr = true;\n                        nameObj = data.ruleNames.get(op.index.name);\n                        if (nameObj !== -1) {\n                            data.rules[nameObj.index].isBkr = true;\n                            op.index = nameObj.index;\n                        } else {\n                            nameObj = data.udtNames.get(op.index.name);\n                            if (nameObj !== -1) {\n                                data.udts[nameObj.index].isBkr = true;\n                                op.index = data.rules.length + nameObj.index;\n                            } else {\n                                data.errors.push({\n                                    line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                                    char: op.index.phraseIndex,\n                                    msg: `Back reference name '${op.index.name}' refers to undefined rule or unamed UDT.`\n                                });\n                                op.index = -1;\n                            }\n                        }\n                    }\n                });\n            });\n        }\n        return ret;\n    }\n    function semRule(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            data.altStack.length = 0;\n            data.topStack = null;\n            data.rulesLineMap.push({\n                line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                char: phraseIndex\n            });\n        }\n        return ret;\n    }\n    function semRuleLookup(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            data.ruleName = \"\";\n            data.definedas = \"\";\n        } else if (state === id.SEM_POST) {\n            let ruleName;\n            if (data.definedas === \"=\") {\n                ruleName = data.ruleNames.add(data.ruleName);\n                if (ruleName === -1) {\n                    data.definedas = null;\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: `Rule name '${data.ruleName}' previously defined.`\n                    });\n                } else {\n                    /* start a new rule */ data.topRule = {\n                        name: ruleName.name,\n                        lower: ruleName.lower,\n                        opcodes: [],\n                        index: ruleName.index\n                    };\n                    data.rules.push(data.topRule);\n                    data.opcodes = data.topRule.opcodes;\n                }\n            } else {\n                ruleName = data.ruleNames.get(data.ruleName);\n                if (ruleName === -1) {\n                    data.definedas = null;\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: `Rule name '${data.ruleName}' for incremental alternate not previously defined.`\n                    });\n                } else {\n                    data.topRule = data.rules[ruleName.index];\n                    data.opcodes = data.topRule.opcodes;\n                }\n            }\n        }\n        return ret;\n    }\n    function semAlternation(state, chars, phraseIndex, phraseCount, data) {\n        let ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            const TRUE = true;\n            while(TRUE){\n                if (data.definedas === null) {\n                    /* rule error - skip opcode generation */ ret = id.SEM_SKIP;\n                    break;\n                }\n                if (data.topStack === null) {\n                    /* top-level ALT */ if (data.definedas === \"=\") {\n                        /* \"=\" new rule */ data.topStack = {\n                            alt: {\n                                type: id.ALT,\n                                children: []\n                            },\n                            cat: null\n                        };\n                        data.altStack.push(data.topStack);\n                        data.opcodes.push(data.topStack.alt);\n                        break;\n                    }\n                    /* \"=/\" incremental alternate */ data.topStack = {\n                        alt: data.opcodes[0],\n                        cat: null\n                    };\n                    data.altStack.push(data.topStack);\n                    break;\n                }\n                /* lower-level ALT */ data.topStack = {\n                    alt: {\n                        type: id.ALT,\n                        children: []\n                    },\n                    cat: null\n                };\n                data.altStack.push(data.topStack);\n                data.opcodes.push(data.topStack.alt);\n                break;\n            }\n        } else if (state === id.SEM_POST) {\n            data.altStack.pop();\n            if (data.altStack.length > 0) {\n                data.topStack = data.altStack[data.altStack.length - 1];\n            } else {\n                data.topStack = null;\n            }\n        }\n        return ret;\n    }\n    function semConcatenation(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            data.topStack.alt.children.push(data.opcodes.length);\n            data.topStack.cat = {\n                type: id.CAT,\n                children: []\n            };\n            data.opcodes.push(data.topStack.cat);\n        } else if (state === id.SEM_POST) {\n            data.topStack.cat = null;\n        }\n        return ret;\n    }\n    function semRepetition(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            data.topStack.cat.children.push(data.opcodes.length);\n        }\n        return ret;\n    }\n    function semOptionOpen(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.opcodes.push({\n                type: id.REP,\n                min: 0,\n                max: 1,\n                char: phraseIndex\n            });\n        }\n        return ret;\n    }\n    function semRuleName(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            data.ruleName = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n        }\n        return ret;\n    }\n    function semDefined(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.definedas = \"=\";\n        }\n        return ret;\n    }\n    function semIncAlt(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.definedas = \"=/\";\n        }\n        return ret;\n    }\n    function semRepOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            data.min = 0;\n            data.max = Infinity;\n            data.topRep = {\n                type: id.REP,\n                min: 0,\n                max: Infinity\n            };\n            data.opcodes.push(data.topRep);\n        } else if (state === id.SEM_POST) {\n            if (data.min > data.max) {\n                data.errors.push({\n                    line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                    char: phraseIndex,\n                    msg: `repetition min cannot be greater than max: min: ${data.min}: max: ${data.max}`\n                });\n            }\n            data.topRep.min = data.min;\n            data.topRep.max = data.max;\n        }\n        return ret;\n    }\n    function semRepMin(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.min = decnum(chars, phraseIndex, phraseCount);\n        }\n        return ret;\n    }\n    function semRepMax(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.max = decnum(chars, phraseIndex, phraseCount);\n        }\n        return ret;\n    }\n    function semRepMinMax(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.max = decnum(chars, phraseIndex, phraseCount);\n            data.min = data.max;\n        }\n        return ret;\n    }\n    function semAndOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.opcodes.push({\n                type: id.AND\n            });\n        }\n        return ret;\n    }\n    function semNotOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.opcodes.push({\n                type: id.NOT\n            });\n        }\n        return ret;\n    }\n    function semRnmOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.opcodes.push({\n                type: id.RNM,\n                /* NOTE: this is temporary info, index will be replaced with integer later. */ /* Probably not the best coding practice but here you go. */ index: {\n                    phraseIndex,\n                    name: apglib.utils.charsToString(chars, phraseIndex, phraseCount)\n                }\n            });\n        }\n        return ret;\n    }\n    function semAbgOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.opcodes.push({\n                type: id.ABG\n            });\n        }\n        return ret;\n    }\n    function semAenOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.opcodes.push({\n                type: id.AEN\n            });\n        }\n        return ret;\n    }\n    function semBkaOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.opcodes.push({\n                type: id.BKA\n            });\n        }\n        return ret;\n    }\n    function semBknOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.opcodes.push({\n                type: id.BKN\n            });\n        }\n        return ret;\n    }\n    function semBkrOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            data.ci = true; /* default to case insensitive */ \n            data.cs = false;\n            data.um = true;\n            data.pm = false;\n        } else if (state === id.SEM_POST) {\n            data.opcodes.push({\n                type: id.BKR,\n                bkrCase: data.cs === true ? id.BKR_MODE_CS : id.BKR_MODE_CI,\n                bkrMode: data.pm === true ? id.BKR_MODE_PM : id.BKR_MODE_UM,\n                /* NOTE: this is temporary info, index will be replaced with integer later. */ /* Probably not the best coding practice but here you go. */ index: {\n                    phraseIndex: data.bkrname.phraseIndex,\n                    name: apglib.utils.charsToString(chars, data.bkrname.phraseIndex, data.bkrname.phraseLength)\n                }\n            });\n        }\n        return ret;\n    }\n    function semBkrCi(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.ci = true;\n        }\n        return ret;\n    }\n    function semBkrCs(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.cs = true;\n        }\n        return ret;\n    }\n    function semBkrUm(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.um = true;\n        }\n        return ret;\n    }\n    function semBkrPm(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.pm = true;\n        }\n        return ret;\n    }\n    function semBkrName(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.bkrname = {\n                phraseIndex,\n                phraseLength: phraseCount\n            };\n        }\n        return ret;\n    }\n    function semUdtEmpty(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n            let udtName = data.udtNames.add(name);\n            if (udtName === -1) {\n                udtName = data.udtNames.get(name);\n                if (udtName === -1) {\n                    throw new Error(\"semUdtEmpty: name look up error\");\n                }\n            } else {\n                data.udts.push({\n                    name: udtName.name,\n                    lower: udtName.lower,\n                    index: udtName.index,\n                    empty: true\n                });\n            }\n            data.opcodes.push({\n                type: id.UDT,\n                empty: true,\n                index: udtName.index\n            });\n        }\n        return ret;\n    }\n    function semUdtNonEmpty(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n            let udtName = data.udtNames.add(name);\n            if (udtName === -1) {\n                udtName = data.udtNames.get(name);\n                if (udtName === -1) {\n                    throw new Error(\"semUdtNonEmpty: name look up error\");\n                }\n            } else {\n                data.udts.push({\n                    name: udtName.name,\n                    lower: udtName.lower,\n                    index: udtName.index,\n                    empty: false\n                });\n            }\n            data.opcodes.push({\n                type: id.UDT,\n                empty: false,\n                index: udtName.index,\n                syntax: null,\n                semantic: null\n            });\n        }\n        return ret;\n    }\n    function semTlsOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            data.tlscase = true; /* default to case insensitive */ \n        }\n        return ret;\n    }\n    function semTlsCase(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            if (phraseCount > 0 && (chars[phraseIndex + 1] === 83 || chars[phraseIndex + 1] === 115)) {\n                data.tlscase = false; /* set to case sensitive */ \n            }\n        }\n        return ret;\n    }\n    function semTlsString(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            if (data.tlscase) {\n                const str = chars.slice(phraseIndex, phraseIndex + phraseCount);\n                for(let i = 0; i < str.length; i += 1){\n                    if (str[i] >= 65 && str[i] <= 90) {\n                        str[i] += 32;\n                    }\n                }\n                data.opcodes.push({\n                    type: id.TLS,\n                    string: str\n                });\n            } else {\n                data.opcodes.push({\n                    type: id.TBS,\n                    string: chars.slice(phraseIndex, phraseIndex + phraseCount)\n                });\n            }\n        }\n        return ret;\n    }\n    function semClsOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            if (phraseCount <= 2) {\n                /* only TLS is allowed to be empty */ data.opcodes.push({\n                    type: id.TLS,\n                    string: []\n                });\n            } else {\n                data.opcodes.push({\n                    type: id.TBS,\n                    string: chars.slice(phraseIndex + 1, phraseIndex + phraseCount - 1)\n                });\n            }\n        }\n        return ret;\n    }\n    function semTbsOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            data.tbsstr = [];\n        } else if (state === id.SEM_POST) {\n            data.opcodes.push({\n                type: id.TBS,\n                string: data.tbsstr\n            });\n        }\n        return ret;\n    }\n    function semTrgOp(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_PRE) {\n            data.min = 0;\n            data.max = 0;\n        } else if (state === id.SEM_POST) {\n            if (data.min > data.max) {\n                data.errors.push({\n                    line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                    char: phraseIndex,\n                    msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${data.min}: max: ${data.max}`\n                });\n            }\n            data.opcodes.push({\n                type: id.TRG,\n                min: data.min,\n                max: data.max\n            });\n        }\n        return ret;\n    }\n    function semDmin(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.min = decnum(chars, phraseIndex, phraseCount);\n        }\n        return ret;\n    }\n    function semDmax(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.max = decnum(chars, phraseIndex, phraseCount);\n        }\n        return ret;\n    }\n    function semBmin(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.min = binnum(chars, phraseIndex, phraseCount);\n        }\n        return ret;\n    }\n    function semBmax(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.max = binnum(chars, phraseIndex, phraseCount);\n        }\n        return ret;\n    }\n    function semXmin(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.min = hexnum(chars, phraseIndex, phraseCount);\n        }\n        return ret;\n    }\n    function semXmax(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.max = hexnum(chars, phraseIndex, phraseCount);\n        }\n        return ret;\n    }\n    function semDstring(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.tbsstr.push(decnum(chars, phraseIndex, phraseCount));\n        }\n        return ret;\n    }\n    function semBstring(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.tbsstr.push(binnum(chars, phraseIndex, phraseCount));\n        }\n        return ret;\n    }\n    function semXstring(state, chars, phraseIndex, phraseCount, data) {\n        const ret = id.SEM_OK;\n        if (state === id.SEM_POST) {\n            data.tbsstr.push(hexnum(chars, phraseIndex, phraseCount));\n        }\n        return ret;\n    }\n    // Define the callback functions to the AST object.\n    this.callbacks = [];\n    this.callbacks.abgop = semAbgOp;\n    this.callbacks.aenop = semAenOp;\n    this.callbacks.alternation = semAlternation;\n    this.callbacks.andop = semAndOp;\n    this.callbacks.bmax = semBmax;\n    this.callbacks.bmin = semBmin;\n    this.callbacks.bkaop = semBkaOp;\n    this.callbacks.bknop = semBknOp;\n    this.callbacks.bkrop = semBkrOp;\n    this.callbacks[\"bkr-name\"] = semBkrName;\n    this.callbacks.bstring = semBstring;\n    this.callbacks.clsop = semClsOp;\n    this.callbacks.ci = semBkrCi;\n    this.callbacks.cs = semBkrCs;\n    this.callbacks.um = semBkrUm;\n    this.callbacks.pm = semBkrPm;\n    this.callbacks.concatenation = semConcatenation;\n    this.callbacks.defined = semDefined;\n    this.callbacks.dmax = semDmax;\n    this.callbacks.dmin = semDmin;\n    this.callbacks.dstring = semDstring;\n    this.callbacks.file = semFile;\n    this.callbacks.incalt = semIncAlt;\n    this.callbacks.notop = semNotOp;\n    this.callbacks.optionopen = semOptionOpen;\n    this.callbacks[\"rep-max\"] = semRepMax;\n    this.callbacks[\"rep-min\"] = semRepMin;\n    this.callbacks[\"rep-min-max\"] = semRepMinMax;\n    this.callbacks.repetition = semRepetition;\n    this.callbacks.repop = semRepOp;\n    this.callbacks.rnmop = semRnmOp;\n    this.callbacks.rule = semRule;\n    this.callbacks.rulelookup = semRuleLookup;\n    this.callbacks.rulename = semRuleName;\n    this.callbacks.tbsop = semTbsOp;\n    this.callbacks.tlscase = semTlsCase;\n    this.callbacks.tlsstring = semTlsString;\n    this.callbacks.tlsop = semTlsOp;\n    this.callbacks.trgop = semTrgOp;\n    this.callbacks[\"udt-empty\"] = semUdtEmpty;\n    this.callbacks[\"udt-non-empty\"] = semUdtNonEmpty;\n    this.callbacks.xmax = semXmax;\n    this.callbacks.xmin = semXmin;\n    this.callbacks.xstring = semXstring;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NlbWFudGljLWNhbGxiYWNrcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O3VGQUd1RixHQUN2RiwwRkFBMEY7QUFDMUYsMEJBQTBCO0FBQzFCLFdBQVc7QUFDWCwwQ0FBMEM7QUFDMUMsOERBQThEOztBQUM5REEsT0FBT0MsT0FBTyxHQUFHLFNBQVNDO0lBQ3hCLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDO0lBQ3ZCLE1BQU1DLEtBQUtGLE9BQU9HLEdBQUc7SUFFckIsMEJBQTBCLEdBQzFCLE1BQU1DLFdBQVcsU0FBU0E7UUFDeEIsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtRQUNmLG1GQUFtRixHQUNuRixxRUFBcUUsR0FDckUsSUFBSSxDQUFDQyxHQUFHLEdBQUcsU0FBU0EsSUFBSUMsSUFBSTtZQUMxQixJQUFJQyxNQUFNLENBQUM7WUFDWCxNQUFNQyxPQUFPLElBQUksQ0FBQ0MsR0FBRyxDQUFDSDtZQUN0QixJQUFJRSxTQUFTLENBQUMsR0FBRztnQkFDZkQsTUFBTTtvQkFDSkQ7b0JBQ0FJLE9BQU9KLEtBQUtLLFdBQVc7b0JBQ3ZCQyxPQUFPLElBQUksQ0FBQ1IsS0FBSyxDQUFDUyxNQUFNO2dCQUMxQjtnQkFDQSxJQUFJLENBQUNULEtBQUssQ0FBQ1UsSUFBSSxDQUFDUDtZQUNsQjtZQUNBLE9BQU9BO1FBQ1Q7UUFDQSx3QkFBd0IsR0FDeEIsSUFBSSxDQUFDRSxHQUFHLEdBQUcsU0FBU0EsSUFBSUgsSUFBSTtZQUMxQixJQUFJQyxNQUFNLENBQUM7WUFDWCxNQUFNRyxRQUFRSixLQUFLSyxXQUFXO1lBQzlCLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ1gsS0FBSyxDQUFDUyxNQUFNLEVBQUVFLEtBQUssRUFBRztnQkFDN0MsSUFBSSxJQUFJLENBQUNYLEtBQUssQ0FBQ1csRUFBRSxDQUFDTCxL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QVMsQ0FBQytCLElBQUksR0FBR3BDO0lBQ3RCLElBQUksQ0FBQ0ssU0FBUyxDQUFDZ0MsT0FBTyxHQUFHakM7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9zZW1hbnRpYy1jYWxsYmFja3MuanM/MzM2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBoYXMgYWxsIG9mIHRoZSBBU1QgdHJhbnNsYXRpb24gY2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgc2VtYW50aWMgYW5hbHlzaXNcbi8vIHBoYXNlIG9mIHRoZSBnZW5lcmF0b3IuXG4vLyBTZWU6PGJyPlxuLy8gYC4vZGlzdC9hYm5mLWZvci1zYWJuZi1ncmFtbWFyLmJuZmA8YnI+XG4vLyBmb3IgdGhlIGdyYW1tYXIgZmlsZSB0aGVzZSBjYWxsYmFjayBmdW5jdGlvbnMgYXJlIGJhc2VkIG9uLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleGZuKCkge1xuICBjb25zdCBhcGdsaWIgPSByZXF1aXJlKCcuLi9hcGctbGliL25vZGUtZXhwb3J0cycpO1xuICBjb25zdCBpZCA9IGFwZ2xpYi5pZHM7XG5cbiAgLyogU29tZSBoZWxwZXIgZnVuY3Rpb25zLiAqL1xuICBjb25zdCBOYW1lTGlzdCA9IGZ1bmN0aW9uIE5hbWVMaXN0KCkge1xuICAgIHRoaXMubmFtZXMgPSBbXTtcbiAgICAvKiBBZGRzIGEgbmV3IHJ1bGUgbmFtZSBvYmplY3QgdG8gdGhlIGxpc3QuIFJldHVybnMgLTEgaWYgdGhlIG5hbWUgYWxyZWFkeSBleGlzdHMuICovXG4gICAgLyogUmV0dXJucyB0aGUgYWRkZWQgbmFtZSBvYmplY3QgaWYgdGhlIG5hbWUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gKi9cbiAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lKSB7XG4gICAgICBsZXQgcmV0ID0gLTE7XG4gICAgICBjb25zdCBmaW5kID0gdGhpcy5nZXQobmFtZSk7XG4gICAgICBpZiAoZmluZCA9PT0gLTEpIHtcbiAgICAgICAgcmV0ID0ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgbG93ZXI6IG5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBpbmRleDogdGhpcy5uYW1lcy5sZW5ndGgsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmFtZXMucHVzaChyZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIC8qIEJydXRlLWZvcmNlIGxvb2sgdXAuICovXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgbGV0IHJldCA9IC0xO1xuICAgICAgY29uc3QgbG93ZXIgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZXNbaV0ubG93ZXIgPT09IGxvd2VyKSB7XG4gICAgICAgICAgcmV0ID0gdGhpcy5uYW1lc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9O1xuICAvKiBjb252ZXJ0cyB0ZXh0IGRlY2ltYWwgbnVtYmVycyBmcm9tLCBlLmcuICVkOTksIHRvIGFuIGludGVnZXIgKi9cbiAgY29uc3QgZGVjbnVtID0gZnVuY3Rpb24gZGVjbnVtKGNoYXJzLCBiZWcsIGxlbikge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSBiZWc7IGkgPCBiZWcgKyBsZW47IGkgKz0gMSkge1xuICAgICAgbnVtID0gMTAgKiBudW0gKyBjaGFyc1tpXSAtIDQ4O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuICAvKiBjb252ZXJ0cyB0ZXh0IGJpbmFyeSBudW1iZXJzIGZyb20sIGUuZy4gJWIxMCwgdG8gYW4gaW50ZWdlciAqL1xuICBjb25zdCBiaW5udW0gPSBmdW5jdGlvbiBiaW5udW0oY2hhcnMsIGJlZywgbGVuKSB7XG4gICAgbGV0IG51bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGJlZzsgaSA8IGJlZyArIGxlbjsgaSArPSAxKSB7XG4gICAgICBudW0gPSAyICogbnVtICsgY2hhcnNbaV0gLSA0ODtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcbiAgLyogY29udmVydHMgdGV4dCBoZXhhZGVjaW1hbCBudW1iZXJzIGZyb20sIGUuZy4gJXhmZiwgdG8gYW4gaW50ZWdlciAqL1xuICBjb25zdCBoZXhudW0gPSBmdW5jdGlvbiBoZXhudW0oY2hhcnMsIGJlZywgbGVuKSB7XG4gICAgbGV0IG51bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGJlZzsgaSA8IGJlZyArIGxlbjsgaSArPSAxKSB7XG4gICAgICBsZXQgZGlnaXQgPSBjaGFyc1tpXTtcbiAgICAgIGlmIChkaWdpdCA+PSA0OCAmJiBkaWdpdCA8PSA1Nykge1xuICAgICAgICBkaWdpdCAtPSA0ODtcbiAgICAgIH0gZWxzZSBpZiAoZGlnaXQgPj0gNjUgJiYgZGlnaXQgPD0gNzApIHtcbiAgICAgICAgZGlnaXQgLT0gNTU7XG4gICAgICB9IGVsc2UgaWYgKGRpZ2l0ID49IDk3ICYmIGRpZ2l0IDw9IDEwMikge1xuICAgICAgICBkaWdpdCAtPSA4NztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4bnVtIG91dCBvZiByYW5nZScpO1xuICAgICAgfVxuICAgICAgbnVtID0gMTYgKiBudW0gKyBkaWdpdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHRoZSBwcm90b3R5cGUgZm9yIGFsbCBzZW1hbnRpYyBhbmFseXNpcyBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIC8vIGBgYGBcbiAgLy8gc3RhdGUgLSB0aGUgdHJhbnNsYXRvciBzdGF0ZVxuICAvLyAgIGlkLlNFTV9QUkUgZm9yIGRvd253YXJkIChwcmUtYnJhbmNoKSB0cmF2ZXJzYWwgb2YgdGhlIEFTVFxuICAvLyAgIGlkLlNFTV9QT1NUIGZvciB1cHdhcmQgKHBvc3QgYnJhbmNoKSB0cmF2ZXJzYWwgb2YgdGhlIEFTVFxuICAvLyBjaGFycyAtIHRoZSBhcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgZm9yIHRoZSBpbnB1dCBzdHJpbmdcbiAgLy8gcGhyYXNlSW5kZXggLSBpbmRleCBpbnRvIHRoZSBjaGFycyBhcnJheSB0byB0aGUgZmlyc3RcbiAgLy8gICAgICAgICAgICAgICBjaGFyYWN0ZXIgb2YgdGhlIHBocmFzZVxuICAvLyBwaHJhc2VDb3VudCAtIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0aGUgcGhyYXNlXG4gIC8vIGRhdGEgLSB1c2VyLWRlZmluZWQgZGF0YSBwYXNzZWQgdG8gdGhlIHRyYW5zbGF0b3JcbiAgLy8gICAgICAgIGZvciB1c2UgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgLy8gQHJldHVybiBpZC5TRU1fT0ssIG5vcm1hbCByZXR1cm4uXG4gIC8vICAgICAgICAgaWQuU0VNX1NLSVAgaW4gc3RhdGUgaWQuU0VNX1BSRSB3aWxsXG4gIC8vICAgICAgICAgc2tpcCB0aGUgYnJhbmNoIGJlbG93LlxuICAvLyAgICAgICAgIEFueSB0aGluZyBlbHNlIGlzIGFuIGVycm9yIHdoaWNoIHdpbGxcbiAgLy8gICAgICAgICBzdG9wIHRoZSB0cmFuc2xhdGlvbi5cbiAgLy8gYGBgYFxuICAvKlxuICBmdW5jdGlvbiBzZW1DYWxsYmFja1Byb3RvdHlwZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGxldCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAqL1xuICAvLyBUaGUgQVNUIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gc2VtRmlsZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEucnVsZU5hbWVzID0gbmV3IE5hbWVMaXN0KCk7XG4gICAgICBkYXRhLnVkdE5hbWVzID0gbmV3IE5hbWVMaXN0KCk7XG4gICAgICBkYXRhLnJ1bGVzID0gW107XG4gICAgICBkYXRhLnVkdHMgPSBbXTtcbiAgICAgIGRhdGEucnVsZXNMaW5lTWFwID0gW107XG4gICAgICBkYXRhLm9wY29kZXMgPSBbXTtcbiAgICAgIGRhdGEuYWx0U3RhY2sgPSBbXTtcbiAgICAgIGRhdGEudG9wU3RhY2sgPSBudWxsO1xuICAgICAgZGF0YS50b3BSdWxlID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgLyogdmFsaWRhdGUgUk5NIHJ1bGUgbmFtZXMgYW5kIHNldCBvcGNvZGUgcnVsZSBpbmRleCAqL1xuICAgICAgbGV0IG5hbWVPYmo7XG4gICAgICBkYXRhLnJ1bGVzLmZvckVhY2goKHJ1bGUpID0+IHtcbiAgICAgICAgcnVsZS5pc0JrciA9IGZhbHNlO1xuICAgICAgICBydWxlLm9wY29kZXMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gaWQuUk5NKSB7XG4gICAgICAgICAgICBuYW1lT2JqID0gZGF0YS5ydWxlTmFtZXMuZ2V0KG9wLmluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWVPYmogPT09IC0xKSB7XG4gICAgICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgb3AuaW5kZXgucGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgICAgIGNoYXI6IG9wLmluZGV4LnBocmFzZUluZGV4LFxuICAgICAgICAgICAgICAgIG1zZzogYFJ1bGUgbmFtZSAnJHtvcC5pbmRleC5uYW1lfScgdXNlZCBidXQgbm90IGRlZmluZWQuYCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG9wLmluZGV4ID0gLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcC5pbmRleCA9IG5hbWVPYmouaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLyogdmFsaWRhdGUgQktSIHJ1bGUgbmFtZXMgYW5kIHNldCBvcGNvZGUgcnVsZSBpbmRleCAqL1xuICAgICAgZGF0YS51ZHRzLmZvckVhY2goKHVkdCkgPT4ge1xuICAgICAgICB1ZHQuaXNCa3IgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgZGF0YS5ydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICAgIHJ1bGUub3Bjb2Rlcy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgIGlmIChvcC50eXBlID09PSBpZC5CS1IpIHtcbiAgICAgICAgICAgIHJ1bGUuaGFzQmtyID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWVPYmogPSBkYXRhLnJ1bGVOYW1lcy5nZXQob3AuaW5kZXgubmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZU9iaiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZGF0YS5ydWxlc1tuYW1lT2JqLmluZGV4XS5pc0JrciA9IHRydWU7XG4gICAgICAgICAgICAgIG9wLmluZGV4ID0gbmFtZU9iai5pbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWVPYmogPSBkYXRhLnVkdE5hbWVzLmdldChvcC5pbmRleC5uYW1lKTtcbiAgICAgICAgICAgICAgaWYgKG5hbWVPYmogIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZGF0YS51ZHRzW25hbWVPYmouaW5kZXhdLmlzQmtyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvcC5pbmRleCA9IGRhdGEucnVsZXMubGVuZ3RoICsgbmFtZU9iai5pbmRleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgb3AuaW5kZXgucGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgY2hhcjogb3AuaW5kZXgucGhyYXNlSW5kZXgsXG4gICAgICAgICAgICAgICAgICBtc2c6IGBCYWNrIHJlZmVyZW5jZSBuYW1lICcke29wLmluZGV4Lm5hbWV9JyByZWZlcnMgdG8gdW5kZWZpbmVkIHJ1bGUgb3IgdW5hbWVkIFVEVC5gLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wLmluZGV4ID0gLTE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUnVsZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEuYWx0U3RhY2subGVuZ3RoID0gMDtcbiAgICAgIGRhdGEudG9wU3RhY2sgPSBudWxsO1xuICAgICAgZGF0YS5ydWxlc0xpbmVNYXAucHVzaCh7XG4gICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJ1bGVMb29rdXAoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnJ1bGVOYW1lID0gJyc7XG4gICAgICBkYXRhLmRlZmluZWRhcyA9ICcnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBsZXQgcnVsZU5hbWU7XG4gICAgICBpZiAoZGF0YS5kZWZpbmVkYXMgPT09ICc9Jykge1xuICAgICAgICBydWxlTmFtZSA9IGRhdGEucnVsZU5hbWVzLmFkZChkYXRhLnJ1bGVOYW1lKTtcbiAgICAgICAgaWYgKHJ1bGVOYW1lID09PSAtMSkge1xuICAgICAgICAgIGRhdGEuZGVmaW5lZGFzID0gbnVsbDtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgICBtc2c6IGBSdWxlIG5hbWUgJyR7ZGF0YS5ydWxlTmFtZX0nIHByZXZpb3VzbHkgZGVmaW5lZC5gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIHN0YXJ0IGEgbmV3IHJ1bGUgKi9cbiAgICAgICAgICBkYXRhLnRvcFJ1bGUgPSB7XG4gICAgICAgICAgICBuYW1lOiBydWxlTmFtZS5uYW1lLFxuICAgICAgICAgICAgbG93ZXI6IHJ1bGVOYW1lLmxvd2VyLFxuICAgICAgICAgICAgb3Bjb2RlczogW10sXG4gICAgICAgICAgICBpbmRleDogcnVsZU5hbWUuaW5kZXgsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBkYXRhLnJ1bGVzLnB1c2goZGF0YS50b3BSdWxlKTtcbiAgICAgICAgICBkYXRhLm9wY29kZXMgPSBkYXRhLnRvcFJ1bGUub3Bjb2RlcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnVsZU5hbWUgPSBkYXRhLnJ1bGVOYW1lcy5nZXQoZGF0YS5ydWxlTmFtZSk7XG4gICAgICAgIGlmIChydWxlTmFtZSA9PT0gLTEpIHtcbiAgICAgICAgICBkYXRhLmRlZmluZWRhcyA9IG51bGw7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiBgUnVsZSBuYW1lICcke2RhdGEucnVsZU5hbWV9JyBmb3IgaW5jcmVtZW50YWwgYWx0ZXJuYXRlIG5vdCBwcmV2aW91c2x5IGRlZmluZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhLnRvcFJ1bGUgPSBkYXRhLnJ1bGVzW3J1bGVOYW1lLmluZGV4XTtcbiAgICAgICAgICBkYXRhLm9wY29kZXMgPSBkYXRhLnRvcFJ1bGUub3Bjb2RlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUFsdGVybmF0aW9uKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgbGV0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgICAgaWYgKGRhdGEuZGVmaW5lZGFzID09PSBudWxsKSB7XG4gICAgICAgICAgLyogcnVsZSBlcnJvciAtIHNraXAgb3Bjb2RlIGdlbmVyYXRpb24gKi9cbiAgICAgICAgICByZXQgPSBpZC5TRU1fU0tJUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS50b3BTdGFjayA9PT0gbnVsbCkge1xuICAgICAgICAgIC8qIHRvcC1sZXZlbCBBTFQgKi9cbiAgICAgICAgICBpZiAoZGF0YS5kZWZpbmVkYXMgPT09ICc9Jykge1xuICAgICAgICAgICAgLyogXCI9XCIgbmV3IHJ1bGUgKi9cbiAgICAgICAgICAgIGRhdGEudG9wU3RhY2sgPSB7XG4gICAgICAgICAgICAgIGFsdDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IGlkLkFMVCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNhdDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhLmFsdFN0YWNrLnB1c2goZGF0YS50b3BTdGFjayk7XG4gICAgICAgICAgICBkYXRhLm9wY29kZXMucHVzaChkYXRhLnRvcFN0YWNrLmFsdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogXCI9L1wiIGluY3JlbWVudGFsIGFsdGVybmF0ZSAqL1xuICAgICAgICAgIGRhdGEudG9wU3RhY2sgPSB7XG4gICAgICAgICAgICBhbHQ6IGRhdGEub3Bjb2Rlc1swXSxcbiAgICAgICAgICAgIGNhdDogbnVsbCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGRhdGEuYWx0U3RhY2sucHVzaChkYXRhLnRvcFN0YWNrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBsb3dlci1sZXZlbCBBTFQgKi9cbiAgICAgICAgZGF0YS50b3BTdGFjayA9IHtcbiAgICAgICAgICBhbHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IGlkLkFMVCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhdDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgZGF0YS5hbHRTdGFjay5wdXNoKGRhdGEudG9wU3RhY2spO1xuICAgICAgICBkYXRhLm9wY29kZXMucHVzaChkYXRhLnRvcFN0YWNrLmFsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLmFsdFN0YWNrLnBvcCgpO1xuICAgICAgaWYgKGRhdGEuYWx0U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICBkYXRhLnRvcFN0YWNrID0gZGF0YS5hbHRTdGFja1tkYXRhLmFsdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS50b3BTdGFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQ29uY2F0ZW5hdGlvbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEudG9wU3RhY2suYWx0LmNoaWxkcmVuLnB1c2goZGF0YS5vcGNvZGVzLmxlbmd0aCk7XG4gICAgICBkYXRhLnRvcFN0YWNrLmNhdCA9IHtcbiAgICAgICAgdHlwZTogaWQuQ0FULFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICB9O1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goZGF0YS50b3BTdGFjay5jYXQpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLnRvcFN0YWNrLmNhdCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUmVwZXRpdGlvbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEudG9wU3RhY2suY2F0LmNoaWxkcmVuLnB1c2goZGF0YS5vcGNvZGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtT3B0aW9uT3BlbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLlJFUCxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUnVsZU5hbWUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnJ1bGVOYW1lID0gYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtRGVmaW5lZChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLmRlZmluZWRhcyA9ICc9JztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1JbmNBbHQoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5kZWZpbmVkYXMgPSAnPS8nO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJlcE9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS5taW4gPSAwO1xuICAgICAgZGF0YS5tYXggPSBJbmZpbml0eTtcbiAgICAgIGRhdGEudG9wUmVwID0ge1xuICAgICAgICB0eXBlOiBpZC5SRVAsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiBJbmZpbml0eSxcbiAgICAgIH07XG4gICAgICBkYXRhLm9wY29kZXMucHVzaChkYXRhLnRvcFJlcCk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGlmIChkYXRhLm1pbiA+IGRhdGEubWF4KSB7XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgIG1zZzogYHJlcGV0aXRpb24gbWluIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gbWF4OiBtaW46ICR7ZGF0YS5taW59OiBtYXg6ICR7ZGF0YS5tYXh9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkYXRhLnRvcFJlcC5taW4gPSBkYXRhLm1pbjtcbiAgICAgIGRhdGEudG9wUmVwLm1heCA9IGRhdGEubWF4O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJlcE1pbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1pbiA9IGRlY251bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SZXBNYXgoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5tYXggPSBkZWNudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUmVwTWluTWF4KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWF4ID0gZGVjbnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgICAgZGF0YS5taW4gPSBkYXRhLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1BbmRPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLkFORCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbU5vdE9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuTk9ULFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUm5tT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5STk0sXG4gICAgICAgIC8qIE5PVEU6IHRoaXMgaXMgdGVtcG9yYXJ5IGluZm8sIGluZGV4IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBpbnRlZ2VyIGxhdGVyLiAqL1xuICAgICAgICAvKiBQcm9iYWJseSBub3QgdGhlIGJlc3QgY29kaW5nIHByYWN0aWNlIGJ1dCBoZXJlIHlvdSBnby4gKi9cbiAgICAgICAgaW5kZXg6IHtcbiAgICAgICAgICBwaHJhc2VJbmRleCxcbiAgICAgICAgICBuYW1lOiBhcGdsaWIudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUFiZ09wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuQUJHLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQWVuT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5BRU4sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca2FPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLkJLQSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJrbk9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuQktOLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtyT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLmNpID0gdHJ1ZTsgLyogZGVmYXVsdCB0byBjYXNlIGluc2Vuc2l0aXZlICovXG4gICAgICBkYXRhLmNzID0gZmFsc2U7XG4gICAgICBkYXRhLnVtID0gdHJ1ZTtcbiAgICAgIGRhdGEucG0gPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5CS1IsXG4gICAgICAgIGJrckNhc2U6IGRhdGEuY3MgPT09IHRydWUgPyBpZC5CS1JfTU9ERV9DUyA6IGlkLkJLUl9NT0RFX0NJLFxuICAgICAgICBia3JNb2RlOiBkYXRhLnBtID09PSB0cnVlID8gaWQuQktSX01PREVfUE0gOiBpZC5CS1JfTU9ERV9VTSxcbiAgICAgICAgLyogTk9URTogdGhpcyBpcyB0ZW1wb3JhcnkgaW5mbywgaW5kZXggd2lsbCBiZSByZXBsYWNlZCB3aXRoIGludGVnZXIgbGF0ZXIuICovXG4gICAgICAgIC8qIFByb2JhYmx5IG5vdCB0aGUgYmVzdCBjb2RpbmcgcHJhY3RpY2UgYnV0IGhlcmUgeW91IGdvLiAqL1xuICAgICAgICBpbmRleDoge1xuICAgICAgICAgIHBocmFzZUluZGV4OiBkYXRhLmJrcm5hbWUucGhyYXNlSW5kZXgsXG4gICAgICAgICAgbmFtZTogYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIGRhdGEuYmtybmFtZS5waHJhc2VJbmRleCwgZGF0YS5ia3JuYW1lLnBocmFzZUxlbmd0aCksXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca3JDaShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLmNpID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca3JDcyhzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLmNzID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca3JVbShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLnVtID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca3JQbShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLnBtID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca3JOYW1lKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEuYmtybmFtZSA9IHtcbiAgICAgICAgcGhyYXNlSW5kZXgsXG4gICAgICAgIHBocmFzZUxlbmd0aDogcGhyYXNlQ291bnQsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVVkdEVtcHR5KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhcGdsaWIudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICAgIGxldCB1ZHROYW1lID0gZGF0YS51ZHROYW1lcy5hZGQobmFtZSk7XG4gICAgICBpZiAodWR0TmFtZSA9PT0gLTEpIHtcbiAgICAgICAgdWR0TmFtZSA9IGRhdGEudWR0TmFtZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAodWR0TmFtZSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlbVVkdEVtcHR5OiBuYW1lIGxvb2sgdXAgZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS51ZHRzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHVkdE5hbWUubmFtZSxcbiAgICAgICAgICBsb3dlcjogdWR0TmFtZS5sb3dlcixcbiAgICAgICAgICBpbmRleDogdWR0TmFtZS5pbmRleCxcbiAgICAgICAgICBlbXB0eTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLlVEVCxcbiAgICAgICAgZW1wdHk6IHRydWUsXG4gICAgICAgIGluZGV4OiB1ZHROYW1lLmluZGV4LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtVWR0Tm9uRW1wdHkoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgY29uc3QgbmFtZSA9IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgICAgbGV0IHVkdE5hbWUgPSBkYXRhLnVkdE5hbWVzLmFkZChuYW1lKTtcbiAgICAgIGlmICh1ZHROYW1lID09PSAtMSkge1xuICAgICAgICB1ZHROYW1lID0gZGF0YS51ZHROYW1lcy5nZXQobmFtZSk7XG4gICAgICAgIGlmICh1ZHROYW1lID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VtVWR0Tm9uRW1wdHk6IG5hbWUgbG9vayB1cCBlcnJvcicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLnVkdHMucHVzaCh7XG4gICAgICAgICAgbmFtZTogdWR0TmFtZS5uYW1lLFxuICAgICAgICAgIGxvd2VyOiB1ZHROYW1lLmxvd2VyLFxuICAgICAgICAgIGluZGV4OiB1ZHROYW1lLmluZGV4LFxuICAgICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLlVEVCxcbiAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICBpbmRleDogdWR0TmFtZS5pbmRleCxcbiAgICAgICAgc3ludGF4OiBudWxsLFxuICAgICAgICBzZW1hbnRpYzogbnVsbCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVRsc09wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS50bHNjYXNlID0gdHJ1ZTsgLyogZGVmYXVsdCB0byBjYXNlIGluc2Vuc2l0aXZlICovXG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtVGxzQ2FzZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBpZiAocGhyYXNlQ291bnQgPiAwICYmIChjaGFyc1twaHJhc2VJbmRleCArIDFdID09PSA4MyB8fCBjaGFyc1twaHJhc2VJbmRleCArIDFdID09PSAxMTUpKSB7XG4gICAgICAgIGRhdGEudGxzY2FzZSA9IGZhbHNlOyAvKiBzZXQgdG8gY2FzZSBzZW5zaXRpdmUgKi9cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1UbHNTdHJpbmcoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgaWYgKGRhdGEudGxzY2FzZSkge1xuICAgICAgICBjb25zdCBzdHIgPSBjaGFycy5zbGljZShwaHJhc2VJbmRleCwgcGhyYXNlSW5kZXggKyBwaHJhc2VDb3VudCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHN0cltpXSA+PSA2NSAmJiBzdHJbaV0gPD0gOTApIHtcbiAgICAgICAgICAgIHN0cltpXSArPSAzMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGlkLlRMUyxcbiAgICAgICAgICBzdHJpbmc6IHN0cixcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogaWQuVEJTLFxuICAgICAgICAgIHN0cmluZzogY2hhcnMuc2xpY2UocGhyYXNlSW5kZXgsIHBocmFzZUluZGV4ICsgcGhyYXNlQ291bnQpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1DbHNPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBpZiAocGhyYXNlQ291bnQgPD0gMikge1xuICAgICAgICAvKiBvbmx5IFRMUyBpcyBhbGxvd2VkIHRvIGJlIGVtcHR5ICovXG4gICAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBpZC5UTFMsXG4gICAgICAgICAgc3RyaW5nOiBbXSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogaWQuVEJTLFxuICAgICAgICAgIHN0cmluZzogY2hhcnMuc2xpY2UocGhyYXNlSW5kZXggKyAxLCBwaHJhc2VJbmRleCArIHBocmFzZUNvdW50IC0gMSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVRic09wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS50YnNzdHIgPSBbXTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5UQlMsXG4gICAgICAgIHN0cmluZzogZGF0YS50YnNzdHIsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1UcmdPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEubWluID0gMDtcbiAgICAgIGRhdGEubWF4ID0gMDtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgaWYgKGRhdGEubWluID4gZGF0YS5tYXgpIHtcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgbXNnOiBgVFJHLCAoJWRtaW4tbWF4KSwgbWluIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gbWF4OiBtaW46ICR7ZGF0YS5taW59OiBtYXg6ICR7ZGF0YS5tYXh9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLlRSRyxcbiAgICAgICAgbWluOiBkYXRhLm1pbixcbiAgICAgICAgbWF4OiBkYXRhLm1heCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbURtaW4oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5taW4gPSBkZWNudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtRG1heChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1heCA9IGRlY251bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1CbWluKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWluID0gYmlubnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJtYXgoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5tYXggPSBiaW5udW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtWG1pbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1pbiA9IGhleG51bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1YbWF4KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWF4ID0gaGV4bnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbURzdHJpbmcoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS50YnNzdHIucHVzaChkZWNudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJzdHJpbmcoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS50YnNzdHIucHVzaChiaW5udW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVhzdHJpbmcoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS50YnNzdHIucHVzaChoZXhudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8vIERlZmluZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zIHRvIHRoZSBBU1Qgb2JqZWN0LlxuICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICB0aGlzLmNhbGxiYWNrcy5hYmdvcCA9IHNlbUFiZ09wO1xuICB0aGlzLmNhbGxiYWNrcy5hZW5vcCA9IHNlbUFlbk9wO1xuICB0aGlzLmNhbGxiYWNrcy5hbHRlcm5hdGlvbiA9IHNlbUFsdGVybmF0aW9uO1xuICB0aGlzLmNhbGxiYWNrcy5hbmRvcCA9IHNlbUFuZE9wO1xuICB0aGlzLmNhbGxiYWNrcy5ibWF4ID0gc2VtQm1heDtcbiAgdGhpcy5jYWxsYmFja3MuYm1pbiA9IHNlbUJtaW47XG4gIHRoaXMuY2FsbGJhY2tzLmJrYW9wID0gc2VtQmthT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmJrbm9wID0gc2VtQmtuT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmJrcm9wID0gc2VtQmtyT3A7XG4gIHRoaXMuY2FsbGJhY2tzWydia3ItbmFtZSddID0gc2VtQmtyTmFtZTtcbiAgdGhpcy5jYWxsYmFja3MuYnN0cmluZyA9IHNlbUJzdHJpbmc7XG4gIHRoaXMuY2FsbGJhY2tzLmNsc29wID0gc2VtQ2xzT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmNpID0gc2VtQmtyQ2k7XG4gIHRoaXMuY2FsbGJhY2tzLmNzID0gc2VtQmtyQ3M7XG4gIHRoaXMuY2FsbGJhY2tzLnVtID0gc2VtQmtyVW07XG4gIHRoaXMuY2FsbGJhY2tzLnBtID0gc2VtQmtyUG07XG4gIHRoaXMuY2FsbGJhY2tzLmNvbmNhdGVuYXRpb24gPSBzZW1Db25jYXRlbmF0aW9uO1xuICB0aGlzLmNhbGxiYWNrcy5kZWZpbmVkID0gc2VtRGVmaW5lZDtcbiAgdGhpcy5jYWxsYmFja3MuZG1heCA9IHNlbURtYXg7XG4gIHRoaXMuY2FsbGJhY2tzLmRtaW4gPSBzZW1EbWluO1xuICB0aGlzLmNhbGxiYWNrcy5kc3RyaW5nID0gc2VtRHN0cmluZztcbiAgdGhpcy5jYWxsYmFja3MuZmlsZSA9IHNlbUZpbGU7XG4gIHRoaXMuY2FsbGJhY2tzLmluY2FsdCA9IHNlbUluY0FsdDtcbiAgdGhpcy5jYWxsYmFja3Mubm90b3AgPSBzZW1Ob3RPcDtcbiAgdGhpcy5jYWxsYmFja3Mub3B0aW9ub3BlbiA9IHNlbU9wdGlvbk9wZW47XG4gIHRoaXMuY2FsbGJhY2tzWydyZXAtbWF4J10gPSBzZW1SZXBNYXg7XG4gIHRoaXMuY2FsbGJhY2tzWydyZXAtbWluJ10gPSBzZW1SZXBNaW47XG4gIHRoaXMuY2FsbGJhY2tzWydyZXAtbWluLW1heCddID0gc2VtUmVwTWluTWF4O1xuICB0aGlzLmNhbGxiYWNrcy5yZXBldGl0aW9uID0gc2VtUmVwZXRpdGlvbjtcbiAgdGhpcy5jYWxsYmFja3MucmVwb3AgPSBzZW1SZXBPcDtcbiAgdGhpcy5jYWxsYmFja3Mucm5tb3AgPSBzZW1Sbm1PcDtcbiAgdGhpcy5jYWxsYmFja3MucnVsZSA9IHNlbVJ1bGU7XG4gIHRoaXMuY2FsbGJhY2tzLnJ1bGVsb29rdXAgPSBzZW1SdWxlTG9va3VwO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlbmFtZSA9IHNlbVJ1bGVOYW1lO1xuICB0aGlzLmNhbGxiYWNrcy50YnNvcCA9IHNlbVRic09wO1xuICB0aGlzLmNhbGxiYWNrcy50bHNjYXNlID0gc2VtVGxzQ2FzZTtcbiAgdGhpcy5jYWxsYmFja3MudGxzc3RyaW5nID0gc2VtVGxzU3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy50bHNvcCA9IHNlbVRsc09wO1xuICB0aGlzLmNhbGxiYWNrcy50cmdvcCA9IHNlbVRyZ09wO1xuICB0aGlzLmNhbGxiYWNrc1sndWR0LWVtcHR5J10gPSBzZW1VZHRFbXB0eTtcbiAgdGhpcy5jYWxsYmFja3NbJ3VkdC1ub24tZW1wdHknXSA9IHNlbVVkdE5vbkVtcHR5O1xuICB0aGlzLmNhbGxiYWNrcy54bWF4ID0gc2VtWG1heDtcbiAgdGhpcy5jYWxsYmFja3MueG1pbiA9IHNlbVhtaW47XG4gIHRoaXMuY2FsbGJhY2tzLnhzdHJpbmcgPSBzZW1Yc3RyaW5nO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZXhmbiIsImFwZ2xpYiIsInJlcXVpcmUiLCJpZCIsImlkcyIsIk5hbWVMaXN0IiwibmFtZXMiLCJhZGQiLCJuYW1lIiwicmV0IiwiZmluZCIsImdldCIsImxvd2VyIiwidG9Mb3dlckNhc2UiLCJpbmRleCIsImxlbmd0aCIsInB1c2giLCJpIiwiZGVjbnVtIiwiY2hhcnMiLCJiZWciLCJsZW4iLCJudW0iLCJiaW5udW0iLCJoZXhudW0iLCJkaWdpdCIsIkVycm9yIiwic2VtRmlsZSIsInN0YXRlIiwicGhyYXNlSW5kZXgiLCJwaHJhc2VDb3VudCIsImRhdGEiLCJTRU1fT0siLCJTRU1fUFJFIiwicnVsZU5hbWVzIiwidWR0TmFtZXMiLCJydWxlcyIsInVkdHMiLCJydWxlc0xpbmVNYXAiLCJvcGNvZGVzIiwiYWx0U3RhY2siLCJ0b3BTdGFjayIsInRvcFJ1bGUiLCJTRU1fUE9TVCIsIm5hbWVPYmoiLCJmb3JFYWNoIiwicnVsZSIsImlzQmtyIiwib3AiLCJ0eXBlIiwiUk5NIiwiZXJyb3JzIiwibGluZSIsImZpbmRMaW5lIiwibGluZXMiLCJjaGFyc0xlbmd0aCIsImNoYXIiLCJtc2ciLCJ1ZHQiLCJCS1IiLCJoYXNCa3IiLCJzZW1SdWxlIiwic2VtUnVsZUxvb2t1cCIsInJ1bGVOYW1lIiwiZGVmaW5lZGFzIiwic2VtQWx0ZXJuYXRpb24iLCJUUlVFIiwiU0VNX1NLSVAiLCJhbHQiLCJBTFQiLCJjaGlsZHJlbiIsImNhdCIsInBvcCIsInNlbUNvbmNhdGVuYXRpb24iLCJDQVQiLCJzZW1SZXBldGl0aW9uIiwic2VtT3B0aW9uT3BlbiIsIlJFUCIsIm1pbiIsIm1heCIsInNlbVJ1bGVOYW1lIiwidXRpbHMiLCJjaGFyc1RvU3RyaW5nIiwic2VtRGVmaW5lZCIsInNlbUluY0FsdCIsInNlbVJlcE9wIiwiSW5maW5pdHkiLCJ0b3BSZXAiLCJzZW1SZXBNaW4iLCJzZW1SZXBNYXgiLCJzZW1SZXBNaW5NYXgiLCJzZW1BbmRPcCIsIkFORCIsInNlbU5vdE9wIiwiTk9UIiwic2VtUm5tT3AiLCJzZW1BYmdPcCIsIkFCRyIsInNlbUFlbk9wIiwiQUVOIiwic2VtQmthT3AiLCJCS0EiLCJzZW1Ca25PcCIsIkJLTiIsInNlbUJrck9wIiwiY2kiLCJjcyIsInVtIiwicG0iLCJia3JDYXNlIiwiQktSX01PREVfQ1MiLCJCS1JfTU9ERV9DSSIsImJrck1vZGUiLCJCS1JfTU9ERV9QTSIsIkJLUl9NT0RFX1VNIiwiYmtybmFtZSIsInBocmFzZUxlbmd0aCIsInNlbUJrckNpIiwic2VtQmtyQ3MiLCJzZW1Ca3JVbSIsInNlbUJrclBtIiwic2VtQmtyTmFtZSIsInNlbVVkdEVtcHR5IiwidWR0TmFtZSIsImVtcHR5IiwiVURUIiwic2VtVWR0Tm9uRW1wdHkiLCJzeW50YXgiLCJzZW1hbnRpYyIsInNlbVRsc09wIiwidGxzY2FzZSIsInNlbVRsc0Nhc2UiLCJzZW1UbHNTdHJpbmciLCJzdHIiLCJzbGljZSIsIlRMUyIsInN0cmluZyIsIlRCUyIsInNlbUNsc09wIiwic2VtVGJzT3AiLCJ0YnNzdHIiLCJzZW1UcmdPcCIsIlRSRyIsInNlbURtaW4iLCJzZW1EbWF4Iiwic2VtQm1pbiIsInNlbUJtYXgiLCJzZW1YbWluIiwic2VtWG1heCIsInNlbURzdHJpbmciLCJzZW1Cc3RyaW5nIiwic2VtWHN0cmluZyIsImNhbGxiYWNrcyIsImFiZ29wIiwiYWVub3AiLCJhbHRlcm5hdGlvbiIsImFuZG9wIiwiYm1heCIsImJtaW4iLCJia2FvcCIsImJrbm9wIiwiYmtyb3AiLCJic3RyaW5nIiwiY2xzb3AiLCJjb25jYXRlbmF0aW9uIiwiZGVmaW5lZCIsImRtYXgiLCJkbWluIiwiZHN0cmluZyIsImZpbGUiLCJpbmNhbHQiLCJub3RvcCIsIm9wdGlvbm9wZW4iLCJyZXBldGl0aW9uIiwicmVwb3AiLCJybm1vcCIsInJ1bGVsb29rdXAiLCJydWxlbmFtZSIsInRic29wIiwidGxzc3RyaW5nIiwidGxzb3AiLCJ0cmdvcCIsInhtYXgiLCJ4bWluIiwieHN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/semantic-callbacks.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/show-rules.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/show-rules.js ***!
  \*******************************************************************************************/
/***/ ((module) => {

"use strict";
eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ \nmodule.exports = function exfn() {\n    const thisFileName = \"show-rules.js\";\n    // Display the rules.\n    // This function may be called before the attributes calculation.\n    // Sorting is done independently from the attributes.\n    // - order\n    //      - \"index\" or \"i\", index order (default)\n    //      - \"alpha\" or \"a\", alphabetical order\n    //      - none of above, index order (default)\n    const showRules = function showRules(rulesIn = [], udtsIn = [], order = \"index\") {\n        const thisFuncName = \"showRules\";\n        let alphaArray = [];\n        let udtAlphaArray = [];\n        const indexArray = [];\n        const udtIndexArray = [];\n        const rules = rulesIn;\n        const udts = udtsIn;\n        const ruleCount = rulesIn.length;\n        const udtCount = udtsIn.length;\n        let str = \"RULE/UDT NAMES\";\n        let i;\n        function compRulesAlpha(left, right) {\n            if (rules[left].lower < rules[right].lower) {\n                return -1;\n            }\n            if (rules[left].lower > rules[right].lower) {\n                return 1;\n            }\n            return 0;\n        }\n        function compUdtsAlpha(left, right) {\n            if (udts[left].lower < udts[right].lower) {\n                return -1;\n            }\n            if (udts[left].lower > udts[right].lower) {\n                return 1;\n            }\n            return 0;\n        }\n        if (!(Array.isArray(rulesIn) && rulesIn.length)) {\n            throw new Error(`${thisFileName}:${thisFuncName}: rules arg must be array with length > 0`);\n        }\n        if (!Array.isArray(udtsIn)) {\n            throw new Error(`${thisFileName}:${thisFuncName}: udts arg must be array`);\n        }\n        for(i = 0; i < ruleCount; i += 1){\n            indexArray.push(i);\n        }\n        alphaArray = indexArray.slice(0);\n        alphaArray.sort(compRulesAlpha);\n        if (udtCount) {\n            for(i = 0; i < udtCount; i += 1){\n                udtIndexArray.push(i);\n            }\n            udtAlphaArray = udtIndexArray.slice(0);\n            udtAlphaArray.sort(compUdtsAlpha);\n        }\n        if (order.charCodeAt(0) === 97) {\n            str += \" - alphabetical by rule/UDT name\\n\";\n            for(i = 0; i < ruleCount; i += 1){\n                str += `${i}: ${alphaArray[i]}: ${rules[alphaArray[i]].name}\\n`;\n            }\n            if (udtCount) {\n                for(i = 0; i < udtCount; i += 1){\n                    str += `${i}: ${udtAlphaArray[i]}: ${udts[udtAlphaArray[i]].name}\\n`;\n                }\n            }\n        } else {\n            str += \" - ordered by rule/UDT index\\n\";\n            for(i = 0; i < ruleCount; i += 1){\n                str += `${i}: ${rules[i].name}\\n`;\n            }\n            if (udtCount) {\n                for(i = 0; i < udtCount; i += 1){\n                    str += `${i}: ${udts[i].name}\\n`;\n                }\n            }\n        }\n        return str;\n    };\n    return showRules;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3Nob3ctcnVsZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozt1RkFHdUY7QUFDdkZBLE9BQU9DLE9BQU8sR0FBRyxTQUFVQztJQUN6QixNQUFNQyxlQUFlO0lBQ3JCLHFCQUFxQjtJQUNyQixpRUFBaUU7SUFDakUscURBQXFEO0lBQ3JELFVBQVU7SUFDViwrQ0FBK0M7SUFDL0MsNENBQTRDO0lBQzVDLDhDQUE4QztJQUM5QyxNQUFNQyxZQUFZLFNBQVNBLFVBQVVDLFVBQVUsRUFBRSxFQUFFQyxTQUFTLEVBQUUsRUFBRUMsUUFBUSxPQUFPO1FBQzdFLE1BQU1DLGVBQWU7UUFDckIsSUFBSUMsYUFBYSxFQUFFO1FBQ25CLElBQUlDLGdCQUFnQixFQUFFO1FBQ3RCLE1BQU1DLGFBQWEsRUFBRTtRQUNyQixNQUFNQyxnQkFBZ0IsRUFBRTtRQUN4QixNQUFNQyxRQUFRUjtRQUNkLE1BQU1TLE9BQU9SO1FBQ2IsTUFBTVMsWUFBWVYsUUFBUVcsTUFBTTtRQUNoQyxNQUFNQyxXQUFXWCxPQUFPVSxNQUFNO1FBQzlCLElBQUlFLE1BQU07UUFDVixJQUFJQztRQUNKLFNBQVNDLGVBQWVDLElBQUksRUFBRUMsS0FBSztZQUNqQyxJQUFJVCxLQUFLLENBQUNRLEtBQUssQ0FBQ0UsS0FBSyxHQUFHVixLQUFLLENBQUNTLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFO2dCQUMxQyxPQUFPLENBQUM7WUFDVjtZQUNBLElBQUlWLEtBQUssQ0FBQ1EsS0FBSyxDQUFDRSxLQUFLLEdBQUdWLEtBQUssQ0FBQ1MsTUFBTSxDQUFDQyxLQUFLLEVBQUU7Z0JBQzFDLE9BQU87WUFDVDtZQUNBLE9BQU87UUFDVDtRQUNBLFNBQVNDLGNBQWNILElBQUksRUFBRUMsS0FBSztZQUNoQyxJQUFJUixJQUFJLENBQUNPLEtBQUssQ0FBQ0UsS0FBSyxHQUFHVCxJQUFJLENBQUNRLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFO2dCQUN4QyxPQUFPLENBQUM7WUFDVjtZQUNBLElBQUlULElBQUksQ0FBQ08sS0FBSyxDQUFDRSxLQUFLLEdBQUdULElBQUksQ0FBQ1EsTUFBTSxDQUFDQyxLQUFLLEVBQUU7Z0JBQ3hDLE9BQU87WUFDVDtZQUNBLE9BQU87UUFDVDtRQUNBLElBQUksQ0FBRUUsQ0FBQUEsTUFBTUMsT0FBTyxDQUFDckIsWUFBWUEsUUFBUVcsTUFBTSxHQUFHO1lBQy9DLE1BQU0sSUFBSVcsTUFBTSxDQUFDLEVBQUV4QixhQUFhLENBQUMsRUFBRUssYUFBYSx5Q0FBeUMsQ0FBQztRQUM1RjtRQUNBLElBQUksQ0FBQ2lCLE1BQU1DLE9BQU8sQ0FBQ3BCLFNBQVM7WUFDMUIsTUFBTSxJQUFJcUIsTUFBTSxDQUFDLEVBQUV4QixhQUFhLENBQUMsRUFBRUssYUFBYSx3QkFBd0IsQ0FBQztRQUMzRTtRQUVBLElBQUtXLElBQUksR0FBR0EsSUFBSUosV0FBV0ksS0FBSyxFQUFHO1lBQ2pDUixXQUFXaUIsSUFBSSxDQUFDVDtRQUNsQjtRQUNBVixhQUFhRSxXQUFXa0IsS0FBSyxDQUFDO1FBQzlCcEIsV0FBV3FCLElBQUksQ0FBQ1Y7UUFDaEIsSUFBSUgsVUFBVTtZQUNaLElBQUtFLElBQUksR0FBR0EsSUFBSUYsVUFBVUUsS0FBSyxFQUFHO2dCQUNoQ1AsY0FBY2dCLElBQUksQ0FBQ1Q7WUFDckI7WUFDQVQsZ0JBQWdCRSxjQUFjaUIsS0FBSyxDQUFDO1lBQ3BDbkIsY0FBY29CLElBQUksQ0FBQ047UUFDckI7UUFDQSxJQUFJakIsTUFBTXdCLFVBQVUsQ0FBQyxPQUFPLElBQUk7WUFDOUJiLE9BQU87WUFDUCxJQUFLQyxJQUFJLEdBQUdBLElBQUlKLFdBQVdJLEtBQUssRUFBRztnQkFDakNELE9BQU8sQ0FBQyxFQUFFQyxFQUFFLEVBQUUsRUFBRVYsVUFBVSxDQUFDVSxFQUFFLENBQUMsRUFBRSxFQUFFTixLQUFLLENBQUNKLFVBQVUsQ0FBQ1UsRUFBRSxDQUFDLENBQUNhLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDakU7WUFDQSxJQUFJZixVQUFVO2dCQUNaLElBQUtFLElBQUksR0FBR0EsSUFBSUYsVUFBVUUsS0FBSyxFQUFHO29CQUNoQ0QsT0FBTyxDQUFDLEVBQUVDLEVBQUUsRUFBRSxFQUFFVCxhQUFhLENBQUNTLEVBQUUsQ0FBQyxFQUFFLEVBQUVMLElBQUksQ0FBQ0osYUFBYSxDQUFDUyxFQUFFLENBQUMsQ0FBQ2EsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDdEU7WUFDRjtRQUNGLE9BQU87WUFDTGQsT0FBTztZQUNQLElBQUtDLElBQUksR0FBR0EsSUFBSUosV0FBV0ksS0FBSyxFQUFHO2dCQUNqQ0QsT0FBTyxDQUFDLEVBQUVDLEVBQUUsRUFBRSxFQUFFTixLQUFLLENBQUNNLEVBQUUsQ0FBQ2EsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUNuQztZQUNBLElBQUlmLFVBQVU7Z0JBQ1osSUFBS0UsSUFBSSxHQUFHQSxJQUFJRixVQUFVRSxLQUFLLEVBQUc7b0JBQ2hDRCxPQUFPLENBQUMsRUFBRUMsRUFBRSxFQUFFLEVBQUVMLElBQUksQ0FBQ0ssRUFBRSxDQUFDYSxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUNsQztZQUNGO1FBQ0Y7UUFDQSxPQUFPZDtJQUNUO0lBQ0EsT0FBT2Q7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3Nob3ctcnVsZXMuanM/NjVlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBleGZuKCkge1xuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnc2hvdy1ydWxlcy5qcyc7XG4gIC8vIERpc3BsYXkgdGhlIHJ1bGVzLlxuICAvLyBUaGlzIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYmVmb3JlIHRoZSBhdHRyaWJ1dGVzIGNhbGN1bGF0aW9uLlxuICAvLyBTb3J0aW5nIGlzIGRvbmUgaW5kZXBlbmRlbnRseSBmcm9tIHRoZSBhdHRyaWJ1dGVzLlxuICAvLyAtIG9yZGVyXG4gIC8vICAgICAgLSBcImluZGV4XCIgb3IgXCJpXCIsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICAvLyAgICAgIC0gXCJhbHBoYVwiIG9yIFwiYVwiLCBhbHBoYWJldGljYWwgb3JkZXJcbiAgLy8gICAgICAtIG5vbmUgb2YgYWJvdmUsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICBjb25zdCBzaG93UnVsZXMgPSBmdW5jdGlvbiBzaG93UnVsZXMocnVsZXNJbiA9IFtdLCB1ZHRzSW4gPSBbXSwgb3JkZXIgPSAnaW5kZXgnKSB7XG4gICAgY29uc3QgdGhpc0Z1bmNOYW1lID0gJ3Nob3dSdWxlcyc7XG4gICAgbGV0IGFscGhhQXJyYXkgPSBbXTtcbiAgICBsZXQgdWR0QWxwaGFBcnJheSA9IFtdO1xuICAgIGNvbnN0IGluZGV4QXJyYXkgPSBbXTtcbiAgICBjb25zdCB1ZHRJbmRleEFycmF5ID0gW107XG4gICAgY29uc3QgcnVsZXMgPSBydWxlc0luO1xuICAgIGNvbnN0IHVkdHMgPSB1ZHRzSW47XG4gICAgY29uc3QgcnVsZUNvdW50ID0gcnVsZXNJbi5sZW5ndGg7XG4gICAgY29uc3QgdWR0Q291bnQgPSB1ZHRzSW4ubGVuZ3RoO1xuICAgIGxldCBzdHIgPSAnUlVMRS9VRFQgTkFNRVMnO1xuICAgIGxldCBpO1xuICAgIGZ1bmN0aW9uIGNvbXBSdWxlc0FscGhhKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAocnVsZXNbbGVmdF0ubG93ZXIgPCBydWxlc1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHJ1bGVzW2xlZnRdLmxvd2VyID4gcnVsZXNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBVZHRzQWxwaGEobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmICh1ZHRzW2xlZnRdLmxvd2VyIDwgdWR0c1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHVkdHNbbGVmdF0ubG93ZXIgPiB1ZHRzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoIShBcnJheS5pc0FycmF5KHJ1bGVzSW4pICYmIHJ1bGVzSW4ubGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX06JHt0aGlzRnVuY05hbWV9OiBydWxlcyBhcmcgbXVzdCBiZSBhcnJheSB3aXRoIGxlbmd0aCA+IDBgKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVkdHNJbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9OiR7dGhpc0Z1bmNOYW1lfTogdWR0cyBhcmcgbXVzdCBiZSBhcnJheWApO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgaW5kZXhBcnJheS5wdXNoKGkpO1xuICAgIH1cbiAgICBhbHBoYUFycmF5ID0gaW5kZXhBcnJheS5zbGljZSgwKTtcbiAgICBhbHBoYUFycmF5LnNvcnQoY29tcFJ1bGVzQWxwaGEpO1xuICAgIGlmICh1ZHRDb3VudCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHVkdENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgdWR0SW5kZXhBcnJheS5wdXNoKGkpO1xuICAgICAgfVxuICAgICAgdWR0QWxwaGFBcnJheSA9IHVkdEluZGV4QXJyYXkuc2xpY2UoMCk7XG4gICAgICB1ZHRBbHBoYUFycmF5LnNvcnQoY29tcFVkdHNBbHBoYSk7XG4gICAgfVxuICAgIGlmIChvcmRlci5jaGFyQ29kZUF0KDApID09PSA5Nykge1xuICAgICAgc3RyICs9ICcgLSBhbHBoYWJldGljYWwgYnkgcnVsZS9VRFQgbmFtZVxcbic7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGAke2l9OiAke2FscGhhQXJyYXlbaV19OiAke3J1bGVzW2FscGhhQXJyYXlbaV1dLm5hbWV9XFxuYDtcbiAgICAgIH1cbiAgICAgIGlmICh1ZHRDb3VudCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdWR0Q291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgIHN0ciArPSBgJHtpfTogJHt1ZHRBbHBoYUFycmF5W2ldfTogJHt1ZHRzW3VkdEFscGhhQXJyYXlbaV1dLm5hbWV9XFxuYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAtIG9yZGVyZWQgYnkgcnVsZS9VRFQgaW5kZXhcXG4nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBgJHtpfTogJHtydWxlc1tpXS5uYW1lfVxcbmA7XG4gICAgICB9XG4gICAgICBpZiAodWR0Q291bnQpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHVkdENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICBzdHIgKz0gYCR7aX06ICR7dWR0c1tpXS5uYW1lfVxcbmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgcmV0dXJuIHNob3dSdWxlcztcbn0pKCk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImV4Zm4iLCJ0aGlzRmlsZU5hbWUiLCJzaG93UnVsZXMiLCJydWxlc0luIiwidWR0c0luIiwib3JkZXIiLCJ0aGlzRnVuY05hbWUiLCJhbHBoYUFycmF5IiwidWR0QWxwaGFBcnJheSIsImluZGV4QXJyYXkiLCJ1ZHRJbmRleEFycmF5IiwicnVsZXMiLCJ1ZHRzIiwicnVsZUNvdW50IiwibGVuZ3RoIiwidWR0Q291bnQiLCJzdHIiLCJpIiwiY29tcFJ1bGVzQWxwaGEiLCJsZWZ0IiwicmlnaHQiLCJsb3dlciIsImNvbXBVZHRzQWxwaGEiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsInB1c2giLCJzbGljZSIsInNvcnQiLCJjaGFyQ29kZUF0IiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/show-rules.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/syntax-callbacks.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/syntax-callbacks.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint-disable func-names */ /*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module has all of the callback functions for the syntax phase of the generation.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\n\nmodule.exports = function exfn() {\n    const thisFileName = \"syntax-callbacks.js: \";\n    const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\");\n    const id = apglib.ids;\n    let topAlt;\n    /* syntax, RNM, callback functions */ const synFile = function synFile(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                data.altStack = [];\n                data.repCount = 0;\n                break;\n            case id.EMPTY:\n                data.errors.push({\n                    line: 0,\n                    char: 0,\n                    msg: \"grammar file is empty\"\n                });\n                break;\n            case id.MATCH:\n                if (data.ruleCount === 0) {\n                    data.errors.push({\n                        line: 0,\n                        char: 0,\n                        msg: \"no rules defined\"\n                    });\n                }\n                break;\n            case id.NOMATCH:\n                throw new Error(`${thisFileName}synFile: grammar file NOMATCH: design error: should never happen.`);\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    // eslint-disable-next-line func-names\n    const synRule = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                data.altStack.length = 0;\n                topAlt = {\n                    groupOpen: null,\n                    groupError: false,\n                    optionOpen: null,\n                    optionError: false,\n                    tlsOpen: null,\n                    clsOpen: null,\n                    prosValOpen: null,\n                    basicError: false\n                };\n                data.altStack.push(topAlt);\n                break;\n            case id.EMPTY:\n                throw new Error(`${thisFileName}synRule: EMPTY: rule cannot be empty`);\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                data.ruleCount += 1;\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synRuleError = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                data.errors.push({\n                    line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                    char: phraseIndex,\n                    msg: \"Unrecognized SABNF line. Invalid rule, comment or blank line.\"\n                });\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synRuleNameError = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                data.errors.push({\n                    line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                    char: phraseIndex,\n                    msg: \"Rule names must be alphanum and begin with alphabetic character.\"\n                });\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synDefinedAsError = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                data.errors.push({\n                    line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                    char: phraseIndex,\n                    msg: \"Expected '=' or '=/'. Not found.\"\n                });\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synAndOp = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (data.strict) {\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: \"AND operator(&) found - strict ABNF specified.\"\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synNotOp = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (data.strict) {\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: \"NOT operator(!) found - strict ABNF specified.\"\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synBkaOp = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (data.strict) {\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: \"Positive look-behind operator(&&) found - strict ABNF specified.\"\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synBknOp = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (data.strict) {\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: \"Negative look-behind operator(!!) found - strict ABNF specified.\"\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synAbgOp = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (data.strict) {\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: \"Beginning of string anchor(%^) found - strict ABNF specified.\"\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synAenOp = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (data.strict) {\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: \"End of string anchor(%$) found - strict ABNF specified.\"\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synBkrOp = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (data.strict) {\n                    const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: `Back reference operator(${name}) found - strict ABNF specified.`\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synUdtOp = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (data.strict) {\n                    const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: `UDT operator found(${name}) - strict ABNF specified.`\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synTlsOpen = function(result, chars, phraseIndex) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                topAlt.tlsOpen = phraseIndex;\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synTlsString = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                data.stringTabChar = false;\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (data.stringTabChar !== false) {\n                    data.errors.push({\n                        line: data.findLine(data.lines, data.stringTabChar),\n                        char: data.stringTabChar,\n                        msg: \"Tab character (\\\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)\"\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synStringTab = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                data.stringTabChar = phraseIndex;\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synTlsClose = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                data.errors.push({\n                    line: data.findLine(data.lines, topAlt.tlsOpen),\n                    char: topAlt.tlsOpen,\n                    msg: 'Case-insensitive literal string(\"...\") opened but not closed.'\n                });\n                topAlt.basicError = true;\n                topAlt.tlsOpen = null;\n                break;\n            case id.MATCH:\n                topAlt.tlsOpen = null;\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synClsOpen = function(result, chars, phraseIndex) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                topAlt.clsOpen = phraseIndex;\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synClsString = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                data.stringTabChar = false;\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (data.stringTabChar !== false) {\n                    data.errors.push({\n                        line: data.findLine(data.lines, data.stringTabChar),\n                        char: data.stringTabChar,\n                        msg: \"Tab character (\\\\t, x09) not allowed in literal string.\"\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synClsClose = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                data.errors.push({\n                    line: data.findLine(data.lines, topAlt.clsOpen),\n                    char: topAlt.clsOpen,\n                    msg: \"Case-sensitive literal string('...') opened but not closed.\"\n                });\n                topAlt.clsOpen = null;\n                topAlt.basicError = true;\n                break;\n            case id.MATCH:\n                if (data.strict) {\n                    data.errors.push({\n                        line: data.findLine(data.lines, topAlt.clsOpen),\n                        char: topAlt.clsOpen,\n                        msg: \"Case-sensitive string operator('...') found - strict ABNF specified.\"\n                    });\n                }\n                topAlt.clsOpen = null;\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synProsValOpen = function(result, chars, phraseIndex) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                topAlt.prosValOpen = phraseIndex;\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synProsValString = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                data.stringTabChar = false;\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (data.stringTabChar !== false) {\n                    data.errors.push({\n                        line: data.findLine(data.lines, data.stringTabChar),\n                        char: data.stringTabChar,\n                        msg: \"Tab character (\\\\t, x09) not allowed in prose value string.\"\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synProsValClose = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                data.errors.push({\n                    line: data.findLine(data.lines, topAlt.prosValOpen),\n                    char: topAlt.prosValOpen,\n                    msg: \"Prose value operator(<...>) opened but not closed.\"\n                });\n                topAlt.basicError = true;\n                topAlt.prosValOpen = null;\n                break;\n            case id.MATCH:\n                data.errors.push({\n                    line: data.findLine(data.lines, topAlt.prosValOpen),\n                    char: topAlt.prosValOpen,\n                    msg: \"Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar.\"\n                });\n                topAlt.prosValOpen = null;\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synGroupOpen = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                topAlt = {\n                    groupOpen: phraseIndex,\n                    groupError: false,\n                    optionOpen: null,\n                    optionError: false,\n                    tlsOpen: null,\n                    clsOpen: null,\n                    prosValOpen: null,\n                    basicError: false\n                };\n                data.altStack.push(topAlt);\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synGroupClose = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                data.errors.push({\n                    line: data.findLine(data.lines, topAlt.groupOpen),\n                    char: topAlt.groupOpen,\n                    msg: 'Group \"(...)\" opened but not closed.'\n                });\n                topAlt = data.altStack.pop();\n                topAlt.groupError = true;\n                break;\n            case id.MATCH:\n                topAlt = data.altStack.pop();\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synOptionOpen = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                topAlt = {\n                    groupOpen: null,\n                    groupError: false,\n                    optionOpen: phraseIndex,\n                    optionError: false,\n                    tlsOpen: null,\n                    clsOpen: null,\n                    prosValOpen: null,\n                    basicError: false\n                };\n                data.altStack.push(topAlt);\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synOptionClose = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                data.errors.push({\n                    line: data.findLine(data.lines, topAlt.optionOpen),\n                    char: topAlt.optionOpen,\n                    msg: 'Option \"[...]\" opened but not closed.'\n                });\n                topAlt = data.altStack.pop();\n                topAlt.optionError = true;\n                break;\n            case id.MATCH:\n                topAlt = data.altStack.pop();\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synBasicElementError = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (topAlt.basicError === false) {\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: \"Unrecognized SABNF element.\"\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synLineEnd = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                if (result.phraseLength === 1 && data.strict) {\n                    const end = chars[phraseIndex] === 13 ? \"CR\" : \"LF\";\n                    data.errors.push({\n                        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                        char: phraseIndex,\n                        msg: `Line end '${end}' found - strict ABNF specified, only CRLF allowed.`\n                    });\n                }\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synLineEndError = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                break;\n            case id.MATCH:\n                data.errors.push({\n                    line: data.findLine(data.lines, phraseIndex, data.charsLength),\n                    char: phraseIndex,\n                    msg: \"Unrecognized grammar element or characters.\"\n                });\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    const synRepetition = function(result, chars, phraseIndex, data) {\n        switch(result.state){\n            case id.ACTIVE:\n                break;\n            case id.EMPTY:\n                break;\n            case id.NOMATCH:\n                data.repCount += 1;\n                break;\n            case id.MATCH:\n                data.repCount += 1;\n                break;\n            default:\n                throw new Error(`${thisFileName}synFile: unrecognized case.`);\n        }\n    };\n    // Define the list of callback functions.\n    this.callbacks = [];\n    this.callbacks.andop = synAndOp;\n    this.callbacks.basicelementerr = synBasicElementError;\n    this.callbacks.clsclose = synClsClose;\n    this.callbacks.clsopen = synClsOpen;\n    this.callbacks.clsstring = synClsString;\n    this.callbacks.definedaserror = synDefinedAsError;\n    this.callbacks.file = synFile;\n    this.callbacks.groupclose = synGroupClose;\n    this.callbacks.groupopen = synGroupOpen;\n    this.callbacks.lineenderror = synLineEndError;\n    this.callbacks.lineend = synLineEnd;\n    this.callbacks.notop = synNotOp;\n    this.callbacks.optionclose = synOptionClose;\n    this.callbacks.optionopen = synOptionOpen;\n    this.callbacks.prosvalclose = synProsValClose;\n    this.callbacks.prosvalopen = synProsValOpen;\n    this.callbacks.prosvalstring = synProsValString;\n    this.callbacks.repetition = synRepetition;\n    this.callbacks.rule = synRule;\n    this.callbacks.ruleerror = synRuleError;\n    this.callbacks.rulenameerror = synRuleNameError;\n    this.callbacks.stringtab = synStringTab;\n    this.callbacks.tlsclose = synTlsClose;\n    this.callbacks.tlsopen = synTlsOpen;\n    this.callbacks.tlsstring = synTlsString;\n    this.callbacks.udtop = synUdtOp;\n    this.callbacks.bkaop = synBkaOp;\n    this.callbacks.bknop = synBknOp;\n    this.callbacks.bkrop = synBkrOp;\n    this.callbacks.abgop = synAbgOp;\n    this.callbacks.aenop = synAenOp;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3N5bnRheC1jYWxsYmFja3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsNkJBQTZCLEdBQzdCOzs7dUZBR3VGLEdBQ3ZGLHdGQUF3RjtBQUN4RixXQUFXO0FBQ1gsMENBQTBDO0FBQzFDLDhEQUE4RDs7QUFDOURBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQztJQUN4QixNQUFNQyxlQUFlO0lBQ3JCLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDO0lBQ3ZCLE1BQU1DLEtBQUtGLE9BQU9HLEdBQUc7SUFDckIsSUFBSUM7SUFDSixtQ0FBbUMsR0FDbkMsTUFBTUMsVUFBVSxTQUFTQSxRQUFRQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsV0FBVyxFQUFFQyxJQUFJO1FBQy9ELE9BQVFILE9BQU9JLEtBQUs7WUFDbEIsS0FBS1IsR0FBR1MsTUFBTTtnQkFDWkYsS0FBS0csUUFBUSxHQUFHLEVBQUU7Z0JBQ2xCSCxLQUFLSSxRQUFRLEdBQUc7Z0JBQ2hCO1lBQ0YsS0FBS1gsR0FBR1ksS0FBSztnQkFDWEwsS0FBS00sTUFBTSxDQUFDQyxJQUFJLENBQUM7b0JBQ2ZDLE1BQU07b0JBQ05DLE1BQU07b0JBQ05DLEtBQUs7Z0JBQ1A7Z0JBQ0E7WUFDRixLQUFLakIsR0FBR2tCLEtBQUs7Z0JBQ1gsSUFBSVgsS0FBS1ksU0FBUyxLQUFLLEdBQUc7b0JBQ3hCWixLQUFLTSxNQUFNLENBQUNDLElBQUksQ0FBQzt3QkFDZkMsTUFBTTt3QkFDTkMsTUFBTTt3QkFDTkMsS0FBSztvQkFDUDtnQkFDRjtnQkFDQTtZQUNGLEtBQUtqQixHQUFHb0IsT0FBTztnQkFDYixNQUFNLElBQUlDLE1BQU0sQ0FBQyxFQUFFeEIsYUFBYSxpRUFBaUUsQ0FBQztZQUNwRztnQkFDRSxNQUFNLElBQUl3QixNQUFNLENBQUMsRUFBRXhCLGFBQWEsMkJBQTJCLENBQUM7UUFDaEU7SUFD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QUNzQixTQUFTLEdBQUd4QztJQUMzQixJQUFJLENBQUNrQixTQUFTLENBQUN1QixRQUFRLEdBQUd4QztJQUMxQixJQUFJLENBQUNpQixTQUFTLENBQUN3QixPQUFPLEdBQUc3QztJQUN6QixJQUFJLENBQUNxQixTQUFTLENBQUN5QixTQUFTLEdBQUc3QztJQUMzQixJQUFJLENBQUNvQixTQUFTLENBQUMwQixLQUFLLEdBQUdoRDtJQUN2QixJQUFJLENBQUNzQixTQUFTLENBQUMyQixLQUFLLEdBQUcxRDtJQUN2QixJQUFJLENBQUMrQixTQUFTLENBQUM0QixLQUFLLEdBQUcxRDtJQUN2QixJQUFJLENBQUM4QixTQUFTLENBQUM2QixLQUFLLEdBQUd4RDtJQUN2QixJQUFJLENBQUMyQixTQUFTLENBQUM4QixLQUFLLEdBQUczRDtJQUN2QixJQUFJLENBQUM2QixTQUFTLENBQUMrQixLQUFLLEdBQUczRDtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3N5bnRheC1jYWxsYmFja3MuanM/YmVhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzICovXG4vKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBoYXMgYWxsIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHRoZSBzeW50YXggcGhhc2Ugb2YgdGhlIGdlbmVyYXRpb24uXG4vLyBTZWU6PGJyPlxuLy8gYC4vZGlzdC9hYm5mLWZvci1zYWJuZi1ncmFtbWFyLmJuZmA8YnI+XG4vLyBmb3IgdGhlIGdyYW1tYXIgZmlsZSB0aGVzZSBjYWxsYmFjayBmdW5jdGlvbnMgYXJlIGJhc2VkIG9uLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleGZuKCkge1xuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnc3ludGF4LWNhbGxiYWNrcy5qczogJztcbiAgY29uc3QgYXBnbGliID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHMnKTtcbiAgY29uc3QgaWQgPSBhcGdsaWIuaWRzO1xuICBsZXQgdG9wQWx0O1xuICAvKiBzeW50YXgsIFJOTSwgY2FsbGJhY2sgZnVuY3Rpb25zICovXG4gIGNvbnN0IHN5bkZpbGUgPSBmdW5jdGlvbiBzeW5GaWxlKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBkYXRhLmFsdFN0YWNrID0gW107XG4gICAgICAgIGRhdGEucmVwQ291bnQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IDAsXG4gICAgICAgICAgY2hhcjogMCxcbiAgICAgICAgICBtc2c6ICdncmFtbWFyIGZpbGUgaXMgZW1wdHknLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoZGF0YS5ydWxlQ291bnQgPT09IDApIHtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IDAsXG4gICAgICAgICAgICBjaGFyOiAwLFxuICAgICAgICAgICAgbXNnOiAnbm8gcnVsZXMgZGVmaW5lZCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogZ3JhbW1hciBmaWxlIE5PTUFUQ0g6IGRlc2lnbiBlcnJvcjogc2hvdWxkIG5ldmVyIGhhcHBlbi5gKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICBjb25zdCBzeW5SdWxlID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBkYXRhLmFsdFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIHRvcEFsdCA9IHtcbiAgICAgICAgICBncm91cE9wZW46IG51bGwsXG4gICAgICAgICAgZ3JvdXBFcnJvcjogZmFsc2UsXG4gICAgICAgICAgb3B0aW9uT3BlbjogbnVsbCxcbiAgICAgICAgICBvcHRpb25FcnJvcjogZmFsc2UsXG4gICAgICAgICAgdGxzT3BlbjogbnVsbCxcbiAgICAgICAgICBjbHNPcGVuOiBudWxsLFxuICAgICAgICAgIHByb3NWYWxPcGVuOiBudWxsLFxuICAgICAgICAgIGJhc2ljRXJyb3I6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBkYXRhLmFsdFN0YWNrLnB1c2godG9wQWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5blJ1bGU6IEVNUFRZOiBydWxlIGNhbm5vdCBiZSBlbXB0eWApO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEucnVsZUNvdW50ICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blJ1bGVFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6ICdVbnJlY29nbml6ZWQgU0FCTkYgbGluZS4gSW52YWxpZCBydWxlLCBjb21tZW50IG9yIGJsYW5rIGxpbmUuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blJ1bGVOYW1lRXJyb3IgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgbXNnOiAnUnVsZSBuYW1lcyBtdXN0IGJlIGFscGhhbnVtIGFuZCBiZWdpbiB3aXRoIGFscGhhYmV0aWMgY2hhcmFjdGVyLicsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5EZWZpbmVkQXNFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6IFwiRXhwZWN0ZWQgJz0nIG9yICc9LycuIE5vdCBmb3VuZC5cIixcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkFuZE9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ0FORCBvcGVyYXRvcigmKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bk5vdE9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ05PVCBvcGVyYXRvcighKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkJrYU9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ1Bvc2l0aXZlIGxvb2stYmVoaW5kIG9wZXJhdG9yKCYmKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkJrbk9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ05lZ2F0aXZlIGxvb2stYmVoaW5kIG9wZXJhdG9yKCEhKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkFiZ09wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ0JlZ2lubmluZyBvZiBzdHJpbmcgYW5jaG9yKCVeKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkFlbk9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ0VuZCBvZiBzdHJpbmcgYW5jaG9yKCUkKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkJrck9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBhcGdsaWIudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHJlc3VsdC5waHJhc2VMZW5ndGgpO1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogYEJhY2sgcmVmZXJlbmNlIG9wZXJhdG9yKCR7bmFtZX0pIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLmAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luVWR0T3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcmVzdWx0LnBocmFzZUxlbmd0aCk7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiBgVURUIG9wZXJhdG9yIGZvdW5kKCR7bmFtZX0pIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLmAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luVGxzT3BlbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQudGxzT3BlbiA9IHBocmFzZUluZGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5UbHNTdHJpbmcgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuc3RyaW5nVGFiQ2hhciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmluZ1RhYkNoYXIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIGRhdGEuc3RyaW5nVGFiQ2hhciksXG4gICAgICAgICAgICBjaGFyOiBkYXRhLnN0cmluZ1RhYkNoYXIsXG4gICAgICAgICAgICBtc2c6IFwiVGFiIGNoYXJhY3RlciAoXFxcXHQsIHgwOSkgbm90IGFsbG93ZWQgaW4gbGl0ZXJhbCBzdHJpbmcgKHNlZSAncXVvdGVkLXN0cmluZycgZGVmaW5pdGlvbiwgUkZDIDc0MDUuKVwiLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blN0cmluZ1RhYiA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLnN0cmluZ1RhYkNoYXIgPSBwaHJhc2VJbmRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luVGxzQ2xvc2UgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgdG9wQWx0LnRsc09wZW4pLFxuICAgICAgICAgIGNoYXI6IHRvcEFsdC50bHNPcGVuLFxuICAgICAgICAgIG1zZzogJ0Nhc2UtaW5zZW5zaXRpdmUgbGl0ZXJhbCBzdHJpbmcoXCIuLi5cIikgb3BlbmVkIGJ1dCBub3QgY2xvc2VkLicsXG4gICAgICAgIH0pO1xuICAgICAgICB0b3BBbHQuYmFzaWNFcnJvciA9IHRydWU7XG4gICAgICAgIHRvcEFsdC50bHNPcGVuID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQudGxzT3BlbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkNsc09wZW4gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0LmNsc09wZW4gPSBwaHJhc2VJbmRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQ2xzU3RyaW5nID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBkYXRhLnN0cmluZ1RhYkNoYXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoZGF0YS5zdHJpbmdUYWJDaGFyICE9PSBmYWxzZSkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBkYXRhLnN0cmluZ1RhYkNoYXIpLFxuICAgICAgICAgICAgY2hhcjogZGF0YS5zdHJpbmdUYWJDaGFyLFxuICAgICAgICAgICAgbXNnOiAnVGFiIGNoYXJhY3RlciAoXFxcXHQsIHgwOSkgbm90IGFsbG93ZWQgaW4gbGl0ZXJhbCBzdHJpbmcuJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5DbHNDbG9zZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQuY2xzT3BlbiksXG4gICAgICAgICAgY2hhcjogdG9wQWx0LmNsc09wZW4sXG4gICAgICAgICAgbXNnOiBcIkNhc2Utc2Vuc2l0aXZlIGxpdGVyYWwgc3RyaW5nKCcuLi4nKSBvcGVuZWQgYnV0IG5vdCBjbG9zZWQuXCIsXG4gICAgICAgIH0pO1xuICAgICAgICB0b3BBbHQuY2xzT3BlbiA9IG51bGw7XG4gICAgICAgIHRvcEFsdC5iYXNpY0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoZGF0YS5zdHJpY3QpIHtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgdG9wQWx0LmNsc09wZW4pLFxuICAgICAgICAgICAgY2hhcjogdG9wQWx0LmNsc09wZW4sXG4gICAgICAgICAgICBtc2c6IFwiQ2FzZS1zZW5zaXRpdmUgc3RyaW5nIG9wZXJhdG9yKCcuLi4nKSBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC5cIixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0b3BBbHQuY2xzT3BlbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blByb3NWYWxPcGVuID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4KSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdC5wcm9zVmFsT3BlbiA9IHBocmFzZUluZGV4O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5Qcm9zVmFsU3RyaW5nID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBkYXRhLnN0cmluZ1RhYkNoYXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoZGF0YS5zdHJpbmdUYWJDaGFyICE9PSBmYWxzZSkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBkYXRhLnN0cmluZ1RhYkNoYXIpLFxuICAgICAgICAgICAgY2hhcjogZGF0YS5zdHJpbmdUYWJDaGFyLFxuICAgICAgICAgICAgbXNnOiAnVGFiIGNoYXJhY3RlciAoXFxcXHQsIHgwOSkgbm90IGFsbG93ZWQgaW4gcHJvc2UgdmFsdWUgc3RyaW5nLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUHJvc1ZhbENsb3NlID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHRvcEFsdC5wcm9zVmFsT3BlbiksXG4gICAgICAgICAgY2hhcjogdG9wQWx0LnByb3NWYWxPcGVuLFxuICAgICAgICAgIG1zZzogJ1Byb3NlIHZhbHVlIG9wZXJhdG9yKDwuLi4+KSBvcGVuZWQgYnV0IG5vdCBjbG9zZWQuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdC5iYXNpY0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdG9wQWx0LnByb3NWYWxPcGVuID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHRvcEFsdC5wcm9zVmFsT3BlbiksXG4gICAgICAgICAgY2hhcjogdG9wQWx0LnByb3NWYWxPcGVuLFxuICAgICAgICAgIG1zZzogJ1Byb3NlIHZhbHVlIG9wZXJhdG9yKDwuLi4+KSBmb3VuZC4gVGhlIEFCTkYgc3ludGF4IGlzIHZhbGlkLCBidXQgYSBwYXJzZXIgY2Fubm90IGJlIGdlbmVyYXRlZCBmcm9tIHRoaXMgZ3JhbW1hci4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdG9wQWx0LnByb3NWYWxPcGVuID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luR3JvdXBPcGVuID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdCA9IHtcbiAgICAgICAgICBncm91cE9wZW46IHBocmFzZUluZGV4LFxuICAgICAgICAgIGdyb3VwRXJyb3I6IGZhbHNlLFxuICAgICAgICAgIG9wdGlvbk9wZW46IG51bGwsXG4gICAgICAgICAgb3B0aW9uRXJyb3I6IGZhbHNlLFxuICAgICAgICAgIHRsc09wZW46IG51bGwsXG4gICAgICAgICAgY2xzT3BlbjogbnVsbCxcbiAgICAgICAgICBwcm9zVmFsT3BlbjogbnVsbCxcbiAgICAgICAgICBiYXNpY0Vycm9yOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgZGF0YS5hbHRTdGFjay5wdXNoKHRvcEFsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkdyb3VwQ2xvc2UgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgdG9wQWx0Lmdyb3VwT3BlbiksXG4gICAgICAgICAgY2hhcjogdG9wQWx0Lmdyb3VwT3BlbixcbiAgICAgICAgICBtc2c6ICdHcm91cCBcIiguLi4pXCIgb3BlbmVkIGJ1dCBub3QgY2xvc2VkLicsXG4gICAgICAgIH0pO1xuICAgICAgICB0b3BBbHQgPSBkYXRhLmFsdFN0YWNrLnBvcCgpO1xuICAgICAgICB0b3BBbHQuZ3JvdXBFcnJvciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0ID0gZGF0YS5hbHRTdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luT3B0aW9uT3BlbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQgPSB7XG4gICAgICAgICAgZ3JvdXBPcGVuOiBudWxsLFxuICAgICAgICAgIGdyb3VwRXJyb3I6IGZhbHNlLFxuICAgICAgICAgIG9wdGlvbk9wZW46IHBocmFzZUluZGV4LFxuICAgICAgICAgIG9wdGlvbkVycm9yOiBmYWxzZSxcbiAgICAgICAgICB0bHNPcGVuOiBudWxsLFxuICAgICAgICAgIGNsc09wZW46IG51bGwsXG4gICAgICAgICAgcHJvc1ZhbE9wZW46IG51bGwsXG4gICAgICAgICAgYmFzaWNFcnJvcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGRhdGEuYWx0U3RhY2sucHVzaCh0b3BBbHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5PcHRpb25DbG9zZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQub3B0aW9uT3BlbiksXG4gICAgICAgICAgY2hhcjogdG9wQWx0Lm9wdGlvbk9wZW4sXG4gICAgICAgICAgbXNnOiAnT3B0aW9uIFwiWy4uLl1cIiBvcGVuZWQgYnV0IG5vdCBjbG9zZWQuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdCA9IGRhdGEuYWx0U3RhY2sucG9wKCk7XG4gICAgICAgIHRvcEFsdC5vcHRpb25FcnJvciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0ID0gZGF0YS5hbHRTdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQmFzaWNFbGVtZW50RXJyb3IgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKHRvcEFsdC5iYXNpY0Vycm9yID09PSBmYWxzZSkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogJ1VucmVjb2duaXplZCBTQUJORiBlbGVtZW50LicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luTGluZUVuZCA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAocmVzdWx0LnBocmFzZUxlbmd0aCA9PT0gMSAmJiBkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGNvbnN0IGVuZCA9IGNoYXJzW3BocmFzZUluZGV4XSA9PT0gMTMgPyAnQ1InIDogJ0xGJztcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgICBtc2c6IGBMaW5lIGVuZCAnJHtlbmR9JyBmb3VuZCAtIHN0cmljdCBBQk5GIHNwZWNpZmllZCwgb25seSBDUkxGIGFsbG93ZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5MaW5lRW5kRXJyb3IgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgbXNnOiAnVW5yZWNvZ25pemVkIGdyYW1tYXIgZWxlbWVudCBvciBjaGFyYWN0ZXJzLicsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5SZXBldGl0aW9uID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBkYXRhLnJlcENvdW50ICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgZGF0YS5yZXBDb3VudCArPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICAvLyBEZWZpbmUgdGhlIGxpc3Qgb2YgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICB0aGlzLmNhbGxiYWNrcy5hbmRvcCA9IHN5bkFuZE9wO1xuICB0aGlzLmNhbGxiYWNrcy5iYXNpY2VsZW1lbnRlcnIgPSBzeW5CYXNpY0VsZW1lbnRFcnJvcjtcbiAgdGhpcy5jYWxsYmFja3MuY2xzY2xvc2UgPSBzeW5DbHNDbG9zZTtcbiAgdGhpcy5jYWxsYmFja3MuY2xzb3BlbiA9IHN5bkNsc09wZW47XG4gIHRoaXMuY2FsbGJhY2tzLmNsc3N0cmluZyA9IHN5bkNsc1N0cmluZztcbiAgdGhpcy5jYWxsYmFja3MuZGVmaW5lZGFzZXJyb3IgPSBzeW5EZWZpbmVkQXNFcnJvcjtcbiAgdGhpcy5jYWxsYmFja3MuZmlsZSA9IHN5bkZpbGU7XG4gIHRoaXMuY2FsbGJhY2tzLmdyb3VwY2xvc2UgPSBzeW5Hcm91cENsb3NlO1xuICB0aGlzLmNhbGxiYWNrcy5ncm91cG9wZW4gPSBzeW5Hcm91cE9wZW47XG4gIHRoaXMuY2FsbGJhY2tzLmxpbmVlbmRlcnJvciA9IHN5bkxpbmVFbmRFcnJvcjtcbiAgdGhpcy5jYWxsYmFja3MubGluZWVuZCA9IHN5bkxpbmVFbmQ7XG4gIHRoaXMuY2FsbGJhY2tzLm5vdG9wID0gc3luTm90T3A7XG4gIHRoaXMuY2FsbGJhY2tzLm9wdGlvbmNsb3NlID0gc3luT3B0aW9uQ2xvc2U7XG4gIHRoaXMuY2FsbGJhY2tzLm9wdGlvbm9wZW4gPSBzeW5PcHRpb25PcGVuO1xuICB0aGlzLmNhbGxiYWNrcy5wcm9zdmFsY2xvc2UgPSBzeW5Qcm9zVmFsQ2xvc2U7XG4gIHRoaXMuY2FsbGJhY2tzLnByb3N2YWxvcGVuID0gc3luUHJvc1ZhbE9wZW47XG4gIHRoaXMuY2FsbGJhY2tzLnByb3N2YWxzdHJpbmcgPSBzeW5Qcm9zVmFsU3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy5yZXBldGl0aW9uID0gc3luUmVwZXRpdGlvbjtcbiAgdGhpcy5jYWxsYmFja3MucnVsZSA9IHN5blJ1bGU7XG4gIHRoaXMuY2FsbGJhY2tzLnJ1bGVlcnJvciA9IHN5blJ1bGVFcnJvcjtcbiAgdGhpcy5jYWxsYmFja3MucnVsZW5hbWVlcnJvciA9IHN5blJ1bGVOYW1lRXJyb3I7XG4gIHRoaXMuY2FsbGJhY2tzLnN0cmluZ3RhYiA9IHN5blN0cmluZ1RhYjtcbiAgdGhpcy5jYWxsYmFja3MudGxzY2xvc2UgPSBzeW5UbHNDbG9zZTtcbiAgdGhpcy5jYWxsYmFja3MudGxzb3BlbiA9IHN5blRsc09wZW47XG4gIHRoaXMuY2FsbGJhY2tzLnRsc3N0cmluZyA9IHN5blRsc1N0cmluZztcbiAgdGhpcy5jYWxsYmFja3MudWR0b3AgPSBzeW5VZHRPcDtcbiAgdGhpcy5jYWxsYmFja3MuYmthb3AgPSBzeW5Ca2FPcDtcbiAgdGhpcy5jYWxsYmFja3MuYmtub3AgPSBzeW5Ca25PcDtcbiAgdGhpcy5jYWxsYmFja3MuYmtyb3AgPSBzeW5Ca3JPcDtcbiAgdGhpcy5jYWxsYmFja3MuYWJnb3AgPSBzeW5BYmdPcDtcbiAgdGhpcy5jYWxsYmFja3MuYWVub3AgPSBzeW5BZW5PcDtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImV4Zm4iLCJ0aGlzRmlsZU5hbWUiLCJhcGdsaWIiLCJyZXF1aXJlIiwiaWQiLCJpZHMiLCJ0b3BBbHQiLCJzeW5GaWxlIiwicmVzdWx0IiwiY2hhcnMiLCJwaHJhc2VJbmRleCIsImRhdGEiLCJzdGF0ZSIsIkFDVElWRSIsImFsdFN0YWNrIiwicmVwQ291bnQiLCJFTVBUWSIsImVycm9ycyIsInB1c2giLCJsaW5lIiwiY2hhciIsIm1zZyIsIk1BVENIIiwicnVsZUNvdW50IiwiTk9NQVRDSCIsIkVycm9yIiwic3luUnVsZSIsImxlbmd0aCIsImdyb3VwT3BlbiIsImdyb3VwRXJyb3IiLCJvcHRpb25PcGVuIiwib3B0aW9uRXJyb3IiLCJ0bHNPcGVuIiwiY2xzT3BlbiIsInByb3NWYWxPcGVuIiwiYmFzaWNFcnJvciIsInN5blJ1bGVFcnJvciIsImZpbmRMaW5lIiwibGluZXMiLCJjaGFyc0xlbmd0aCIsInN5blJ1bGVOYW1lRXJyb3IiLCJzeW5EZWZpbmVkQXNFcnJvciIsInN5bkFuZE9wIiwic3RyaWN0Iiwic3luTm90T3AiLCJzeW5Ca2FPcCIsInN5bkJrbk9wIiwic3luQWJnT3AiLCJzeW5BZW5PcCIsInN5bkJrck9wIiwibmFtZSIsInV0aWxzIiwiY2hhcnNUb1N0cmluZyIsInBocmFzZUxlbmd0aCIsInN5blVkdE9wIiwic3luVGxzT3BlbiIsInN5blRsc1N0cmluZyIsInN0cmluZ1RhYkNoYXIiLCJzeW5TdHJpbmdUYWIiLCJzeW5UbHNDbG9zZSIsInN5bkNsc09wZW4iLCJzeW5DbHNTdHJpbmciLCJzeW5DbHNDbG9zZSIsInN5blByb3NWYWxPcGVuIiwic3luUHJvc1ZhbFN0cmluZyIsInN5blByb3NWYWxDbG9zZSIsInN5bkdyb3VwT3BlbiIsInN5bkdyb3VwQ2xvc2UiLCJwb3AiLCJzeW5PcHRpb25PcGVuIiwic3luT3B0aW9uQ2xvc2UiLCJzeW5CYXNpY0VsZW1lbnRFcnJvciIsInN5bkxpbmVFbmQiLCJlbmQiLCJzeW5MaW5lRW5kRXJyb3IiLCJzeW5SZXBldGl0aW9uIiwiY2FsbGJhY2tzIiwiYW5kb3AiLCJiYXNpY2VsZW1lbnRlcnIiLCJjbHNjbG9zZSIsImNsc29wZW4iLCJjbHNzdHJpbmciLCJkZWZpbmVkYXNlcnJvciIsImZpbGUiLCJncm91cGNsb3NlIiwiZ3JvdXBvcGVuIiwibGluZWVuZGVycm9yIiwibGluZWVuZCIsIm5vdG9wIiwib3B0aW9uY2xvc2UiLCJvcHRpb25vcGVuIiwicHJvc3ZhbGNsb3NlIiwicHJvc3ZhbG9wZW4iLCJwcm9zdmFsc3RyaW5nIiwicmVwZXRpdGlvbiIsInJ1bGUiLCJydWxlZXJyb3IiLCJydWxlbmFtZWVycm9yIiwic3RyaW5ndGFiIiwidGxzY2xvc2UiLCJ0bHNvcGVuIiwidGxzc3RyaW5nIiwidWR0b3AiLCJia2FvcCIsImJrbm9wIiwiYmtyb3AiLCJhYmdvcCIsImFlbm9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-api/syntax-callbacks.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/converter.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/converter.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module exposes the public encoding, decoding and conversion functions.\n// Its private functions provide the disassembling and interpetation of the source and destination encoding types.\n// In the case of Unicode encodings, private functions determine the presence of Byte Order Marks (BOMs), if any.\n//\n// Throws \"TypeError\" exceptions on input errors.\n//\n\"use strict;\";\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\nconst trans = __webpack_require__(/*! ./transformers */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/transformers.js\");\n/* types */ const UTF8 = \"UTF8\";\nconst UTF16 = \"UTF16\";\nconst UTF16BE = \"UTF16BE\";\nconst UTF16LE = \"UTF16LE\";\nconst UTF32 = \"UTF32\";\nconst UTF32BE = \"UTF32BE\";\nconst UTF32LE = \"UTF32LE\";\nconst UINT7 = \"UINT7\";\nconst ASCII = \"ASCII\";\nconst BINARY = \"BINARY\";\nconst UINT8 = \"UINT8\";\nconst UINT16 = \"UINT16\";\nconst UINT16LE = \"UINT16LE\";\nconst UINT16BE = \"UINT16BE\";\nconst UINT32 = \"UINT32\";\nconst UINT32LE = \"UINT32LE\";\nconst UINT32BE = \"UINT32BE\";\nconst ESCAPED = \"ESCAPED\";\nconst STRING = \"STRING\";\n/* private functions */ // Find the UTF8 BOM, if any.\nconst bom8 = function bom8(src) {\n    src.type = UTF8;\n    const buf = src.data;\n    src.bom = 0;\n    if (buf.length >= 3) {\n        if (buf[0] === 0xef && buf[1] === 0xbb && buf[2] === 0xbf) {\n            src.bom = 3;\n        }\n    }\n};\n// Find the UTF16 BOM, if any, and determine the UTF16 type.\n// Defaults to UTF16BE.\n// Throws TypeError exception if BOM does not match the specified type.\nconst bom16 = function bom16(src) {\n    const buf = src.data;\n    src.bom = 0;\n    switch(src.type){\n        case UTF16:\n            src.type = UTF16BE;\n            if (buf.length >= 2) {\n                if (buf[0] === 0xfe && buf[1] === 0xff) {\n                    src.bom = 2;\n                } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n                    src.type = UTF16LE;\n                    src.bom = 2;\n                }\n            }\n            break;\n        case UTF16BE:\n            src.type = UTF16BE;\n            if (buf.length >= 2) {\n                if (buf[0] === 0xfe && buf[1] === 0xff) {\n                    src.bom = 2;\n                } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n                    throw new TypeError(`src type: \"${UTF16BE}\" specified but BOM is for \"${UTF16LE}\"`);\n                }\n            }\n            break;\n        case UTF16LE:\n            src.type = UTF16LE;\n            if (buf.length >= 0) {\n                if (buf[0] === 0xfe && buf[1] === 0xff) {\n                    throw new TypeError(`src type: \"${UTF16LE}\" specified but BOM is for \"${UTF16BE}\"`);\n                } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n                    src.bom = 2;\n                }\n            }\n            break;\n        default:\n            throw new TypeError(`UTF16 BOM: src type \"${src.type}\" unrecognized`);\n    }\n};\n// Find the UTF32 BOM, if any, and determine the UTF32 type.\n// Defaults to UTF32BE.\n// Throws exception if BOM does not match the specified type.\nconst bom32 = function bom32(src) {\n    const buf = src.data;\n    src.bom = 0;\n    switch(src.type){\n        case UTF32:\n            src.type = UTF32BE;\n            if (buf.length >= 4) {\n                if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n                    src.bom = 4;\n                }\n                if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n                    src.type = UTF32LE;\n                    src.bom = 4;\n                }\n            }\n            break;\n        case UTF32BE:\n            src.type = UTF32BE;\n            if (buf.length >= 4) {\n                if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n                    src.bom = 4;\n                }\n                if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n                    throw new TypeError(`src type: ${UTF32BE} specified but BOM is for ${UTF32LE}\"`);\n                }\n            }\n            break;\n        case UTF32LE:\n            src.type = UTF32LE;\n            if (buf.length >= 4) {\n                if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n                    throw new TypeError(`src type: \"${UTF32LE}\" specified but BOM is for \"${UTF32BE}\"`);\n                }\n                if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n                    src.bom = 4;\n                }\n            }\n            break;\n        default:\n            throw new TypeError(`UTF32 BOM: src type \"${src.type}\" unrecognized`);\n    }\n};\n// Validates the source encoding type and matching data.\n// If the BASE64: prefix is present, the base 64 decoding is done here as the initial step.\n// - For type STRING, data must be a JavaScript string.\n// - For type BASE64:*, data may be a string or Buffer.\n// - For all other types, data must be a Buffer.\n// - The BASE64: prefix is not allowed for type STRING.\nconst validateSrc = function validateSrc(type, data) {\n    function getType(typeArg) {\n        const ret = {\n            type: \"\",\n            base64: false\n        };\n        const rx = /^(base64:)?([a-zA-Z0-9]+)$/i;\n        const result = rx.exec(typeArg);\n        if (result) {\n            if (result[2]) {\n                ret.type = result[2].toUpperCase();\n            }\n            if (result[1]) {\n                ret.base64 = true;\n            }\n        }\n        return ret;\n    }\n    const ret = getType(type.toUpperCase());\n    if (ret.base64) {\n        /* handle base 64 */ if (ret.type === STRING) {\n            throw new TypeError(`type: \"${type} \"BASE64:\" prefix not allowed with type ${STRING}`);\n        }\n        if (Buffer.isBuffer(data)) {\n            ret.data = trans.base64.decode(data);\n        } else if (typeof data === \"string\") {\n            const buf = Buffer.from(data, \"ascii\");\n            ret.data = trans.base64.decode(buf);\n        } else {\n            throw new TypeError(`type: \"${type} unrecognized data type: typeof(data): ${typeof data}`);\n        }\n    } else {\n        ret.data = data;\n    }\n    switch(ret.type){\n        case UTF8:\n            bom8(ret);\n            break;\n        case UTF16:\n        case UTF16BE:\n        case UTF16LE:\n            bom16(ret);\n            break;\n        case UTF32:\n        case UTF32BE:\n        case UTF32LE:\n            bom32(ret);\n            break;\n        case UINT16:\n            ret.type = UINT16BE;\n            break;\n        case UINT32:\n            ret.type = UINT32BE;\n            break;\n        case ASCII:\n            ret.type = UINT7;\n            break;\n        case BINARY:\n            ret.type = UINT8;\n            break;\n        case UINT7:\n        case UINT8:\n        case UINT16LE:\n        case UINT16BE:\n        case UINT32LE:\n        case UINT32BE:\n        case STRING:\n        case ESCAPED:\n            break;\n        default:\n            throw new TypeError(`type: \"${type}\" not recognized`);\n    }\n    if (ret.type === STRING) {\n        if (typeof ret.data !== \"string\") {\n            throw new TypeError(`type: \"${type}\" but data is not a string`);\n        }\n    } else if (!Buffer.isBuffer(ret.data)) {\n        throw new TypeError(`type: \"${type}\" but data is not a Buffer`);\n    }\n    return ret;\n};\n// Disassembles and validates the destination type.\n// `chars` must be an Array of integers.\n// The :BASE64 suffix is not allowed for type STRING.\nconst validateDst = function validateDst(type, chars) {\n    function getType(typeArg) {\n        let fix;\n        let rem;\n        const ret = {\n            crlf: false,\n            lf: false,\n            base64: false,\n            type: \"\"\n        };\n        /* prefix, if any */ const TRUE = true;\n        while(TRUE){\n            rem = typeArg;\n            fix = typeArg.slice(0, 5);\n            if (fix === \"CRLF:\") {\n                ret.crlf = true;\n                rem = typeArg.slice(5);\n                break;\n            }\n            fix = typeArg.slice(0, 3);\n            if (fix === \"LF:\") {\n                ret.lf = true;\n                rem = typeArg.slice(3);\n                break;\n            }\n            break;\n        }\n        /* suffix, if any */ fix = rem.split(\":\");\n        if (fix.length === 1) {\n            // eslint-disable-next-line prefer-destructuring\n            ret.type = fix[0];\n        } else if (fix.length === 2 && fix[1] === \"BASE64\") {\n            ret.base64 = true;\n            // eslint-disable-next-line prefer-destructuring\n            ret.type = fix[0];\n        }\n        return ret;\n    }\n    if (!Array.isArray(chars)) {\n        throw new TypeError(`dst chars: not array: \"${typeof chars}`);\n    }\n    if (typeof type !== \"string\") {\n        throw new TypeError(`dst type: not string: \"${typeof type}`);\n    }\n    const ret = getType(type.toUpperCase());\n    switch(ret.type){\n        case UTF8:\n        case UTF16BE:\n        case UTF16LE:\n        case UTF32BE:\n        case UTF32LE:\n        case UINT7:\n        case UINT8:\n        case UINT16LE:\n        case UINT16BE:\n        case UINT32LE:\n        case UINT32BE:\n        case ESCAPED:\n            break;\n        case STRING:\n            if (ret.base64) {\n                throw new TypeError(`\":BASE64\" suffix not allowed with type ${STRING}`);\n            }\n            break;\n        case ASCII:\n            ret.type = UINT7;\n            break;\n        case BINARY:\n            ret.type = UINT8;\n            break;\n        case UTF16:\n            ret.type = UTF16BE;\n            break;\n        case UTF32:\n            ret.type = UTF32BE;\n            break;\n        case UINT16:\n            ret.type = UINT16BE;\n            break;\n        case UINT32:\n            ret.type = UINT32BE;\n            break;\n        default:\n            throw new TypeError(`dst type unrecognized: \"${type}\" : must have form [crlf:|lf:]type[:base64]`);\n    }\n    return ret;\n};\n// Select and call the requested encoding function.\nconst encode = function encode(type, chars) {\n    switch(type){\n        case UTF8:\n            return trans.utf8.encode(chars);\n        case UTF16BE:\n            return trans.utf16be.encode(chars);\n        case UTF16LE:\n            return trans.utf16le.encode(chars);\n        case UTF32BE:\n            return trans.utf32be.encode(chars);\n        case UTF32LE:\n            return trans.utf32le.encode(chars);\n        case UINT7:\n            return trans.uint7.encode(chars);\n        case UINT8:\n            return trans.uint8.encode(chars);\n        case UINT16BE:\n            return trans.uint16be.encode(chars);\n        case UINT16LE:\n            return trans.uint16le.encode(chars);\n        case UINT32BE:\n            return trans.uint32be.encode(chars);\n        case UINT32LE:\n            return trans.uint32le.encode(chars);\n        case STRING:\n            return trans.string.encode(chars);\n        case ESCAPED:\n            return trans.escaped.encode(chars);\n        default:\n            throw new TypeError(`encode type \"${type}\" not recognized`);\n    }\n};\n// Select and call the requested decoding function.\n// `src` contains BOM information as well as the source type and data.\nconst decode = function decode(src) {\n    switch(src.type){\n        case UTF8:\n            return trans.utf8.decode(src.data, src.bom);\n        case UTF16LE:\n            return trans.utf16le.decode(src.data, src.bom);\n        case UTF16BE:\n            return trans.utf16be.decode(src.data, src.bom);\n        case UTF32BE:\n            return trans.utf32be.decode(src.data, src.bom);\n        case UTF32LE:\n            return trans.utf32le.decode(src.data, src.bom);\n        case UINT7:\n            return trans.uint7.decode(src.data);\n        case UINT8:\n            return trans.uint8.decode(src.data);\n        case UINT16BE:\n            return trans.uint16be.decode(src.data);\n        case UINT16LE:\n            return trans.uint16le.decode(src.data);\n        case UINT32BE:\n            return trans.uint32be.decode(src.data);\n        case UINT32LE:\n            return trans.uint32le.decode(src.data);\n        case STRING:\n            return trans.string.decode(src.data);\n        case ESCAPED:\n            return trans.escaped.decode(src.data);\n        default:\n            throw new TypeError(`decode type \"${src.type}\" not recognized`);\n    }\n};\n// The public decoding function. Returns an array of integers.\nexports.decode = function exportsDecode(type, data) {\n    const src = validateSrc(type, data);\n    return decode(src);\n};\n// The public encoding function. Returns a Buffer-typed byte array.\nexports.encode = function exportsEncode(type, chars) {\n    let c;\n    let buf;\n    const dst = validateDst(type, chars);\n    if (dst.crlf) {\n        /* prefix with CRLF line end conversion, don't contaminate caller's chars array */ c = trans.lineEnds.crlf(chars);\n        buf = encode(dst.type, c);\n    } else if (dst.lf) {\n        /* prefix with LF line end conversion, don't contaminate caller's chars array */ c = trans.lineEnds.lf(chars);\n        buf = encode(dst.type, c);\n    } else {\n        buf = encode(dst.type, chars);\n    }\n    if (dst.base64) {\n        /* post base 64 encoding */ buf = trans.base64.encode(buf);\n    }\n    return buf;\n};\n// Converts data of type `srcType` to data of type `dstType`.\n// `srcData` may be a JavaScript String, or node.js Buffer, depending on the corresponding type.\nconst convert = function convert(srcType, srcData, dstType) {\n    return exports.encode(dstType, exports.decode(srcType, srcData));\n};\nexports.convert = convert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7dUZBR3VGLEdBQ3ZGLDhFQUE4RTtBQUM5RSxrSEFBa0g7QUFDbEgsaUhBQWlIO0FBQ2pILEVBQUU7QUFDRixpREFBaUQ7QUFDakQsRUFBRTtBQUVGO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFM0IsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFFdEIsU0FBUyxHQUNULE1BQU1FLE9BQU87QUFDYixNQUFNQyxRQUFRO0FBQ2QsTUFBTUMsVUFBVTtBQUNoQixNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxTQUFTO0FBQ2YsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLFNBQVM7QUFDZixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLFNBQVM7QUFFZixxQkFBcUIsR0FDckIsNkJBQTZCO0FBQzdCLE1BQU1DLE9BQU8sU0FBU0EsS0FBS0MsR0FBRztJQUM1QkEsSUFBSUMsSUFBSSxHQUFHckI7SUFDWCxNQUFNc0IsTUFBTUYsSUFBSUcsSUFBSTtJQUNwQkgsSUFBSUksR0FBRyxHQUFHO0lBQ1YsSUFBSUYsSUFBSUcsTUFBTSxJQUFJLEdBQUc7UUFDbkIsSUFBSUgsR0FBRyxDQUFDLEVBQUUsS0FBSyxRQUFRQSxHQUFHLENBQUMsRUFBRSxLQUFLLFFBQVFBLEdBQUcsQ0FBQyxFQUFFLEtBQUssTUFBTTtZQUN6REYsSUFBSUksR0FBRyxHQUFHO1FB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QUFJNEIsSUFBSXpCLElBQUksRUFBRTtRQUNaLGdGQUFnRixHQUNoRndCLElBQUl0RSxNQUFNd0UsUUFBUSxDQUFDMUIsSUFBSSxDQUFDSDtRQUN4QnBCLE1BQU04QixPQUFPa0IsSUFBSWpELElBQUksRUFBRWdEO0lBQ3pCLE9BQU8sSUFBSUMsSUFBSXhCLEVBQUUsRUFBRTtRQUNqQiw4RUFBOEUsR0FDOUV1QixJQUFJdEUsTUFBTXdFLFFBQVEsQ0FBQ3pCLEVBQUUsQ0FBQ0o7UUFDdEJwQixNQUFNOEIsT0FBT2tCLElBQUlqRCxJQUFJLEVBQUVnRDtJQUN6QixPQUFPO1FBQ0wvQyxNQUFNOEIsT0FBT2tCLElBQUlqRCxJQUFJLEVBQUVxQjtJQUN6QjtJQUNBLElBQUk0QixJQUFJckMsTUFBTSxFQUFFO1FBQ2QseUJBQXlCLEdBQ3pCWCxNQUFNdkIsTUFBTWtDLE1BQU0sQ0FBQ21CLE1BQU0sQ0FBQzlCO0lBQzVCO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLDZEQUE2RDtBQUM3RCxnR0FBZ0c7QUFDaEcsTUFBTWtELFVBQVUsU0FBU0EsUUFBUUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDeEQsT0FBT1QsUUFBUWQsTUFBTSxDQUFDdUIsU0FBU1QsUUFBUTNCLE1BQU0sQ0FBQ2tDLFNBQVNDO0FBQ3pEO0FBQ0FSLGVBQWUsR0FBR00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWNvbnYtYXBpL2NvbnZlcnRlci5qcz83ZDdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGV4cG9zZXMgdGhlIHB1YmxpYyBlbmNvZGluZywgZGVjb2RpbmcgYW5kIGNvbnZlcnNpb24gZnVuY3Rpb25zLlxuLy8gSXRzIHByaXZhdGUgZnVuY3Rpb25zIHByb3ZpZGUgdGhlIGRpc2Fzc2VtYmxpbmcgYW5kIGludGVycGV0YXRpb24gb2YgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZW5jb2RpbmcgdHlwZXMuXG4vLyBJbiB0aGUgY2FzZSBvZiBVbmljb2RlIGVuY29kaW5ncywgcHJpdmF0ZSBmdW5jdGlvbnMgZGV0ZXJtaW5lIHRoZSBwcmVzZW5jZSBvZiBCeXRlIE9yZGVyIE1hcmtzIChCT01zKSwgaWYgYW55LlxuLy9cbi8vIFRocm93cyBcIlR5cGVFcnJvclwiIGV4Y2VwdGlvbnMgb24gaW5wdXQgZXJyb3JzLlxuLy9cblxuJ3VzZSBzdHJpY3Q7JztcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuXG5jb25zdCB0cmFucyA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtZXJzJyk7XG5cbi8qIHR5cGVzICovXG5jb25zdCBVVEY4ID0gJ1VURjgnO1xuY29uc3QgVVRGMTYgPSAnVVRGMTYnO1xuY29uc3QgVVRGMTZCRSA9ICdVVEYxNkJFJztcbmNvbnN0IFVURjE2TEUgPSAnVVRGMTZMRSc7XG5jb25zdCBVVEYzMiA9ICdVVEYzMic7XG5jb25zdCBVVEYzMkJFID0gJ1VURjMyQkUnO1xuY29uc3QgVVRGMzJMRSA9ICdVVEYzMkxFJztcbmNvbnN0IFVJTlQ3ID0gJ1VJTlQ3JztcbmNvbnN0IEFTQ0lJID0gJ0FTQ0lJJztcbmNvbnN0IEJJTkFSWSA9ICdCSU5BUlknO1xuY29uc3QgVUlOVDggPSAnVUlOVDgnO1xuY29uc3QgVUlOVDE2ID0gJ1VJTlQxNic7XG5jb25zdCBVSU5UMTZMRSA9ICdVSU5UMTZMRSc7XG5jb25zdCBVSU5UMTZCRSA9ICdVSU5UMTZCRSc7XG5jb25zdCBVSU5UMzIgPSAnVUlOVDMyJztcbmNvbnN0IFVJTlQzMkxFID0gJ1VJTlQzMkxFJztcbmNvbnN0IFVJTlQzMkJFID0gJ1VJTlQzMkJFJztcbmNvbnN0IEVTQ0FQRUQgPSAnRVNDQVBFRCc7XG5jb25zdCBTVFJJTkcgPSAnU1RSSU5HJztcblxuLyogcHJpdmF0ZSBmdW5jdGlvbnMgKi9cbi8vIEZpbmQgdGhlIFVURjggQk9NLCBpZiBhbnkuXG5jb25zdCBib204ID0gZnVuY3Rpb24gYm9tOChzcmMpIHtcbiAgc3JjLnR5cGUgPSBVVEY4O1xuICBjb25zdCBidWYgPSBzcmMuZGF0YTtcbiAgc3JjLmJvbSA9IDA7XG4gIGlmIChidWYubGVuZ3RoID49IDMpIHtcbiAgICBpZiAoYnVmWzBdID09PSAweGVmICYmIGJ1ZlsxXSA9PT0gMHhiYiAmJiBidWZbMl0gPT09IDB4YmYpIHtcbiAgICAgIHNyYy5ib20gPSAzO1xuICAgIH1cbiAgfVxufTtcbi8vIEZpbmQgdGhlIFVURjE2IEJPTSwgaWYgYW55LCBhbmQgZGV0ZXJtaW5lIHRoZSBVVEYxNiB0eXBlLlxuLy8gRGVmYXVsdHMgdG8gVVRGMTZCRS5cbi8vIFRocm93cyBUeXBlRXJyb3IgZXhjZXB0aW9uIGlmIEJPTSBkb2VzIG5vdCBtYXRjaCB0aGUgc3BlY2lmaWVkIHR5cGUuXG5jb25zdCBib20xNiA9IGZ1bmN0aW9uIGJvbTE2KHNyYykge1xuICBjb25zdCBidWYgPSBzcmMuZGF0YTtcbiAgc3JjLmJvbSA9IDA7XG4gIHN3aXRjaCAoc3JjLnR5cGUpIHtcbiAgICBjYXNlIFVURjE2OlxuICAgICAgc3JjLnR5cGUgPSBVVEYxNkJFO1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPj0gMikge1xuICAgICAgICBpZiAoYnVmWzBdID09PSAweGZlICYmIGJ1ZlsxXSA9PT0gMHhmZikge1xuICAgICAgICAgIHNyYy5ib20gPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHhmZiAmJiBidWZbMV0gPT09IDB4ZmUpIHtcbiAgICAgICAgICBzcmMudHlwZSA9IFVURjE2TEU7XG4gICAgICAgICAgc3JjLmJvbSA9IDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMTZCRTpcbiAgICAgIHNyYy50eXBlID0gVVRGMTZCRTtcbiAgICAgIGlmIChidWYubGVuZ3RoID49IDIpIHtcbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMHhmZSAmJiBidWZbMV0gPT09IDB4ZmYpIHtcbiAgICAgICAgICBzcmMuYm9tID0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChidWZbMF0gPT09IDB4ZmYgJiYgYnVmWzFdID09PSAweGZlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3JjIHR5cGU6IFwiJHtVVEYxNkJFfVwiIHNwZWNpZmllZCBidXQgQk9NIGlzIGZvciBcIiR7VVRGMTZMRX1cImApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjE2TEU6XG4gICAgICBzcmMudHlwZSA9IFVURjE2TEU7XG4gICAgICBpZiAoYnVmLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgIGlmIChidWZbMF0gPT09IDB4ZmUgJiYgYnVmWzFdID09PSAweGZmKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3JjIHR5cGU6IFwiJHtVVEYxNkxFfVwiIHNwZWNpZmllZCBidXQgQk9NIGlzIGZvciBcIiR7VVRGMTZCRX1cImApO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHhmZiAmJiBidWZbMV0gPT09IDB4ZmUpIHtcbiAgICAgICAgICBzcmMuYm9tID0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVURjE2IEJPTTogc3JjIHR5cGUgXCIke3NyYy50eXBlfVwiIHVucmVjb2duaXplZGApO1xuICB9XG59O1xuLy8gRmluZCB0aGUgVVRGMzIgQk9NLCBpZiBhbnksIGFuZCBkZXRlcm1pbmUgdGhlIFVURjMyIHR5cGUuXG4vLyBEZWZhdWx0cyB0byBVVEYzMkJFLlxuLy8gVGhyb3dzIGV4Y2VwdGlvbiBpZiBCT00gZG9lcyBub3QgbWF0Y2ggdGhlIHNwZWNpZmllZCB0eXBlLlxuY29uc3QgYm9tMzIgPSBmdW5jdGlvbiBib20zMihzcmMpIHtcbiAgY29uc3QgYnVmID0gc3JjLmRhdGE7XG4gIHNyYy5ib20gPSAwO1xuICBzd2l0Y2ggKHNyYy50eXBlKSB7XG4gICAgY2FzZSBVVEYzMjpcbiAgICAgIHNyYy50eXBlID0gVVRGMzJCRTtcbiAgICAgIGlmIChidWYubGVuZ3RoID49IDQpIHtcbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMCAmJiBidWZbMV0gPT09IDAgJiYgYnVmWzJdID09PSAweGZlICYmIGJ1ZlszXSA9PT0gMHhmZikge1xuICAgICAgICAgIHNyYy5ib20gPSA0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZbMF0gPT09IDB4ZmYgJiYgYnVmWzFdID09PSAweGZlICYmIGJ1ZlsyXSA9PT0gMCAmJiBidWZbM10gPT09IDApIHtcbiAgICAgICAgICBzcmMudHlwZSA9IFVURjMyTEU7XG4gICAgICAgICAgc3JjLmJvbSA9IDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMzJCRTpcbiAgICAgIHNyYy50eXBlID0gVVRGMzJCRTtcbiAgICAgIGlmIChidWYubGVuZ3RoID49IDQpIHtcbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMCAmJiBidWZbMV0gPT09IDAgJiYgYnVmWzJdID09PSAweGZlICYmIGJ1ZlszXSA9PT0gMHhmZikge1xuICAgICAgICAgIHNyYy5ib20gPSA0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZbMF0gPT09IDB4ZmYgJiYgYnVmWzFdID09PSAweGZlICYmIGJ1ZlsyXSA9PT0gMCAmJiBidWZbM10gPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzcmMgdHlwZTogJHtVVEYzMkJFfSBzcGVjaWZpZWQgYnV0IEJPTSBpcyBmb3IgJHtVVEYzMkxFfVwiYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMzJMRTpcbiAgICAgIHNyYy50eXBlID0gVVRGMzJMRTtcbiAgICAgIGlmIChidWYubGVuZ3RoID49IDQpIHtcbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMCAmJiBidWZbMV0gPT09IDAgJiYgYnVmWzJdID09PSAweGZlICYmIGJ1ZlszXSA9PT0gMHhmZikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHNyYyB0eXBlOiBcIiR7VVRGMzJMRX1cIiBzcGVjaWZpZWQgYnV0IEJPTSBpcyBmb3IgXCIke1VURjMyQkV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmWzBdID09PSAweGZmICYmIGJ1ZlsxXSA9PT0gMHhmZSAmJiBidWZbMl0gPT09IDAgJiYgYnVmWzNdID09PSAwKSB7XG4gICAgICAgICAgc3JjLmJvbSA9IDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVVEYzMiBCT006IHNyYyB0eXBlIFwiJHtzcmMudHlwZX1cIiB1bnJlY29nbml6ZWRgKTtcbiAgfVxufTtcbi8vIFZhbGlkYXRlcyB0aGUgc291cmNlIGVuY29kaW5nIHR5cGUgYW5kIG1hdGNoaW5nIGRhdGEuXG4vLyBJZiB0aGUgQkFTRTY0OiBwcmVmaXggaXMgcHJlc2VudCwgdGhlIGJhc2UgNjQgZGVjb2RpbmcgaXMgZG9uZSBoZXJlIGFzIHRoZSBpbml0aWFsIHN0ZXAuXG4vLyAtIEZvciB0eXBlIFNUUklORywgZGF0YSBtdXN0IGJlIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4vLyAtIEZvciB0eXBlIEJBU0U2NDoqLCBkYXRhIG1heSBiZSBhIHN0cmluZyBvciBCdWZmZXIuXG4vLyAtIEZvciBhbGwgb3RoZXIgdHlwZXMsIGRhdGEgbXVzdCBiZSBhIEJ1ZmZlci5cbi8vIC0gVGhlIEJBU0U2NDogcHJlZml4IGlzIG5vdCBhbGxvd2VkIGZvciB0eXBlIFNUUklORy5cbmNvbnN0IHZhbGlkYXRlU3JjID0gZnVuY3Rpb24gdmFsaWRhdGVTcmModHlwZSwgZGF0YSkge1xuICBmdW5jdGlvbiBnZXRUeXBlKHR5cGVBcmcpIHtcbiAgICBjb25zdCByZXQgPSB7XG4gICAgICB0eXBlOiAnJyxcbiAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgfTtcbiAgICBjb25zdCByeCA9IC9eKGJhc2U2NDopPyhbYS16QS1aMC05XSspJC9pO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJ4LmV4ZWModHlwZUFyZyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKHJlc3VsdFsyXSkge1xuICAgICAgICByZXQudHlwZSA9IHJlc3VsdFsyXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdFsxXSkge1xuICAgICAgICByZXQuYmFzZTY0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBjb25zdCByZXQgPSBnZXRUeXBlKHR5cGUudG9VcHBlckNhc2UoKSk7XG4gIGlmIChyZXQuYmFzZTY0KSB7XG4gICAgLyogaGFuZGxlIGJhc2UgNjQgKi9cbiAgICBpZiAocmV0LnR5cGUgPT09IFNUUklORykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZTogXCIke3R5cGV9IFwiQkFTRTY0OlwiIHByZWZpeCBub3QgYWxsb3dlZCB3aXRoIHR5cGUgJHtTVFJJTkd9YCk7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIHJldC5kYXRhID0gdHJhbnMuYmFzZTY0LmRlY29kZShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oZGF0YSwgJ2FzY2lpJyk7XG4gICAgICByZXQuZGF0YSA9IHRyYW5zLmJhc2U2NC5kZWNvZGUoYnVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZTogXCIke3R5cGV9IHVucmVjb2duaXplZCBkYXRhIHR5cGU6IHR5cGVvZihkYXRhKTogJHt0eXBlb2YgZGF0YX1gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0LmRhdGEgPSBkYXRhO1xuICB9XG4gIHN3aXRjaCAocmV0LnR5cGUpIHtcbiAgICBjYXNlIFVURjg6XG4gICAgICBib204KHJldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjE2OlxuICAgIGNhc2UgVVRGMTZCRTpcbiAgICBjYXNlIFVURjE2TEU6XG4gICAgICBib20xNihyZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYzMjpcbiAgICBjYXNlIFVURjMyQkU6XG4gICAgY2FzZSBVVEYzMkxFOlxuICAgICAgYm9tMzIocmV0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVUlOVDE2OlxuICAgICAgcmV0LnR5cGUgPSBVSU5UMTZCRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVUlOVDMyOlxuICAgICAgcmV0LnR5cGUgPSBVSU5UMzJCRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQVNDSUk6XG4gICAgICByZXQudHlwZSA9IFVJTlQ3O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCSU5BUlk6XG4gICAgICByZXQudHlwZSA9IFVJTlQ4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVSU5UNzpcbiAgICBjYXNlIFVJTlQ4OlxuICAgIGNhc2UgVUlOVDE2TEU6XG4gICAgY2FzZSBVSU5UMTZCRTpcbiAgICBjYXNlIFVJTlQzMkxFOlxuICAgIGNhc2UgVUlOVDMyQkU6XG4gICAgY2FzZSBTVFJJTkc6XG4gICAgY2FzZSBFU0NBUEVEOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGU6IFwiJHt0eXBlfVwiIG5vdCByZWNvZ25pemVkYCk7XG4gIH1cbiAgaWYgKHJldC50eXBlID09PSBTVFJJTkcpIHtcbiAgICBpZiAodHlwZW9mIHJldC5kYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZTogXCIke3R5cGV9XCIgYnV0IGRhdGEgaXMgbm90IGEgc3RyaW5nYCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIocmV0LmRhdGEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZTogXCIke3R5cGV9XCIgYnV0IGRhdGEgaXMgbm90IGEgQnVmZmVyYCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBEaXNhc3NlbWJsZXMgYW5kIHZhbGlkYXRlcyB0aGUgZGVzdGluYXRpb24gdHlwZS5cbi8vIGBjaGFyc2AgbXVzdCBiZSBhbiBBcnJheSBvZiBpbnRlZ2Vycy5cbi8vIFRoZSA6QkFTRTY0IHN1ZmZpeCBpcyBub3QgYWxsb3dlZCBmb3IgdHlwZSBTVFJJTkcuXG5jb25zdCB2YWxpZGF0ZURzdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRHN0KHR5cGUsIGNoYXJzKSB7XG4gIGZ1bmN0aW9uIGdldFR5cGUodHlwZUFyZykge1xuICAgIGxldCBmaXg7XG4gICAgbGV0IHJlbTtcbiAgICBjb25zdCByZXQgPSB7XG4gICAgICBjcmxmOiBmYWxzZSxcbiAgICAgIGxmOiBmYWxzZSxcbiAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgICB0eXBlOiAnJyxcbiAgICB9O1xuICAgIC8qIHByZWZpeCwgaWYgYW55ICovXG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIHJlbSA9IHR5cGVBcmc7XG4gICAgICBmaXggPSB0eXBlQXJnLnNsaWNlKDAsIDUpO1xuICAgICAgaWYgKGZpeCA9PT0gJ0NSTEY6Jykge1xuICAgICAgICByZXQuY3JsZiA9IHRydWU7XG4gICAgICAgIHJlbSA9IHR5cGVBcmcuc2xpY2UoNSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZml4ID0gdHlwZUFyZy5zbGljZSgwLCAzKTtcbiAgICAgIGlmIChmaXggPT09ICdMRjonKSB7XG4gICAgICAgIHJldC5sZiA9IHRydWU7XG4gICAgICAgIHJlbSA9IHR5cGVBcmcuc2xpY2UoMyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8qIHN1ZmZpeCwgaWYgYW55ICovXG4gICAgZml4ID0gcmVtLnNwbGl0KCc6Jyk7XG4gICAgaWYgKGZpeC5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgcmV0LnR5cGUgPSBmaXhbMF07XG4gICAgfSBlbHNlIGlmIChmaXgubGVuZ3RoID09PSAyICYmIGZpeFsxXSA9PT0gJ0JBU0U2NCcpIHtcbiAgICAgIHJldC5iYXNlNjQgPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICByZXQudHlwZSA9IGZpeFswXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZHN0IGNoYXJzOiBub3QgYXJyYXk6IFwiJHt0eXBlb2YgY2hhcnN9YCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGRzdCB0eXBlOiBub3Qgc3RyaW5nOiBcIiR7dHlwZW9mIHR5cGV9YCk7XG4gIH1cbiAgY29uc3QgcmV0ID0gZ2V0VHlwZSh0eXBlLnRvVXBwZXJDYXNlKCkpO1xuICBzd2l0Y2ggKHJldC50eXBlKSB7XG4gICAgY2FzZSBVVEY4OlxuICAgIGNhc2UgVVRGMTZCRTpcbiAgICBjYXNlIFVURjE2TEU6XG4gICAgY2FzZSBVVEYzMkJFOlxuICAgIGNhc2UgVVRGMzJMRTpcbiAgICBjYXNlIFVJTlQ3OlxuICAgIGNhc2UgVUlOVDg6XG4gICAgY2FzZSBVSU5UMTZMRTpcbiAgICBjYXNlIFVJTlQxNkJFOlxuICAgIGNhc2UgVUlOVDMyTEU6XG4gICAgY2FzZSBVSU5UMzJCRTpcbiAgICBjYXNlIEVTQ0FQRUQ6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNUUklORzpcbiAgICAgIGlmIChyZXQuYmFzZTY0KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiOkJBU0U2NFwiIHN1ZmZpeCBub3QgYWxsb3dlZCB3aXRoIHR5cGUgJHtTVFJJTkd9YCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIEFTQ0lJOlxuICAgICAgcmV0LnR5cGUgPSBVSU5UNztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQklOQVJZOlxuICAgICAgcmV0LnR5cGUgPSBVSU5UODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMTY6XG4gICAgICByZXQudHlwZSA9IFVURjE2QkU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjMyOlxuICAgICAgcmV0LnR5cGUgPSBVVEYzMkJFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVSU5UMTY6XG4gICAgICByZXQudHlwZSA9IFVJTlQxNkJFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVSU5UMzI6XG4gICAgICByZXQudHlwZSA9IFVJTlQzMkJFO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGRzdCB0eXBlIHVucmVjb2duaXplZDogXCIke3R5cGV9XCIgOiBtdXN0IGhhdmUgZm9ybSBbY3JsZjp8bGY6XXR5cGVbOmJhc2U2NF1gKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIFNlbGVjdCBhbmQgY2FsbCB0aGUgcmVxdWVzdGVkIGVuY29kaW5nIGZ1bmN0aW9uLlxuY29uc3QgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHR5cGUsIGNoYXJzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgVVRGODpcbiAgICAgIHJldHVybiB0cmFucy51dGY4LmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVVEYxNkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjE2YmUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVURjE2TEU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMTZsZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVVRGMzJCRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYzMmJlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVVEYzMkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjMybGUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVJTlQ3OlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQ3LmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVSU5UODpcbiAgICAgIHJldHVybiB0cmFucy51aW50OC5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVUlOVDE2QkU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDE2YmUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVJTlQxNkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQxNmxlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVSU5UMzJCRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MzJiZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVUlOVDMyTEU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDMybGUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFNUUklORzpcbiAgICAgIHJldHVybiB0cmFucy5zdHJpbmcuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIEVTQ0FQRUQ6XG4gICAgICByZXR1cm4gdHJhbnMuZXNjYXBlZC5lbmNvZGUoY2hhcnMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBlbmNvZGUgdHlwZSBcIiR7dHlwZX1cIiBub3QgcmVjb2duaXplZGApO1xuICB9XG59O1xuLy8gU2VsZWN0IGFuZCBjYWxsIHRoZSByZXF1ZXN0ZWQgZGVjb2RpbmcgZnVuY3Rpb24uXG4vLyBgc3JjYCBjb250YWlucyBCT00gaW5mb3JtYXRpb24gYXMgd2VsbCBhcyB0aGUgc291cmNlIHR5cGUgYW5kIGRhdGEuXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3JjKSB7XG4gIHN3aXRjaCAoc3JjLnR5cGUpIHtcbiAgICBjYXNlIFVURjg6XG4gICAgICByZXR1cm4gdHJhbnMudXRmOC5kZWNvZGUoc3JjLmRhdGEsIHNyYy5ib20pO1xuICAgIGNhc2UgVVRGMTZMRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYxNmxlLmRlY29kZShzcmMuZGF0YSwgc3JjLmJvbSk7XG4gICAgY2FzZSBVVEYxNkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjE2YmUuZGVjb2RlKHNyYy5kYXRhLCBzcmMuYm9tKTtcbiAgICBjYXNlIFVURjMyQkU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMzJiZS5kZWNvZGUoc3JjLmRhdGEsIHNyYy5ib20pO1xuICAgIGNhc2UgVVRGMzJMRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYzMmxlLmRlY29kZShzcmMuZGF0YSwgc3JjLmJvbSk7XG4gICAgY2FzZSBVSU5UNzpcbiAgICAgIHJldHVybiB0cmFucy51aW50Ny5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGNhc2UgVUlOVDg6XG4gICAgICByZXR1cm4gdHJhbnMudWludDguZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIFVJTlQxNkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQxNmJlLmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBVSU5UMTZMRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MTZsZS5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGNhc2UgVUlOVDMyQkU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDMyYmUuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIFVJTlQzMkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQzMmxlLmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBTVFJJTkc6XG4gICAgICByZXR1cm4gdHJhbnMuc3RyaW5nLmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBFU0NBUEVEOlxuICAgICAgcmV0dXJuIHRyYW5zLmVzY2FwZWQuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGVjb2RlIHR5cGUgXCIke3NyYy50eXBlfVwiIG5vdCByZWNvZ25pemVkYCk7XG4gIH1cbn07XG5cbi8vIFRoZSBwdWJsaWMgZGVjb2RpbmcgZnVuY3Rpb24uIFJldHVybnMgYW4gYXJyYXkgb2YgaW50ZWdlcnMuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGV4cG9ydHNEZWNvZGUodHlwZSwgZGF0YSkge1xuICBjb25zdCBzcmMgPSB2YWxpZGF0ZVNyYyh0eXBlLCBkYXRhKTtcbiAgcmV0dXJuIGRlY29kZShzcmMpO1xufTtcbi8vIFRoZSBwdWJsaWMgZW5jb2RpbmcgZnVuY3Rpb24uIFJldHVybnMgYSBCdWZmZXItdHlwZWQgYnl0ZSBhcnJheS5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gZXhwb3J0c0VuY29kZSh0eXBlLCBjaGFycykge1xuICBsZXQgYztcbiAgbGV0IGJ1ZjtcbiAgY29uc3QgZHN0ID0gdmFsaWRhdGVEc3QodHlwZSwgY2hhcnMpO1xuICBpZiAoZHN0LmNybGYpIHtcbiAgICAvKiBwcmVmaXggd2l0aCBDUkxGIGxpbmUgZW5kIGNvbnZlcnNpb24sIGRvbid0IGNvbnRhbWluYXRlIGNhbGxlcidzIGNoYXJzIGFycmF5ICovXG4gICAgYyA9IHRyYW5zLmxpbmVFbmRzLmNybGYoY2hhcnMpO1xuICAgIGJ1ZiA9IGVuY29kZShkc3QudHlwZSwgYyk7XG4gIH0gZWxzZSBpZiAoZHN0LmxmKSB7XG4gICAgLyogcHJlZml4IHdpdGggTEYgbGluZSBlbmQgY29udmVyc2lvbiwgZG9uJ3QgY29udGFtaW5hdGUgY2FsbGVyJ3MgY2hhcnMgYXJyYXkgKi9cbiAgICBjID0gdHJhbnMubGluZUVuZHMubGYoY2hhcnMpO1xuICAgIGJ1ZiA9IGVuY29kZShkc3QudHlwZSwgYyk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gZW5jb2RlKGRzdC50eXBlLCBjaGFycyk7XG4gIH1cbiAgaWYgKGRzdC5iYXNlNjQpIHtcbiAgICAvKiBwb3N0IGJhc2UgNjQgZW5jb2RpbmcgKi9cbiAgICBidWYgPSB0cmFucy5iYXNlNjQuZW5jb2RlKGJ1Zik7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG4vLyBDb252ZXJ0cyBkYXRhIG9mIHR5cGUgYHNyY1R5cGVgIHRvIGRhdGEgb2YgdHlwZSBgZHN0VHlwZWAuXG4vLyBgc3JjRGF0YWAgbWF5IGJlIGEgSmF2YVNjcmlwdCBTdHJpbmcsIG9yIG5vZGUuanMgQnVmZmVyLCBkZXBlbmRpbmcgb24gdGhlIGNvcnJlc3BvbmRpbmcgdHlwZS5cbmNvbnN0IGNvbnZlcnQgPSBmdW5jdGlvbiBjb252ZXJ0KHNyY1R5cGUsIHNyY0RhdGEsIGRzdFR5cGUpIHtcbiAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlKGRzdFR5cGUsIGV4cG9ydHMuZGVjb2RlKHNyY1R5cGUsIHNyY0RhdGEpKTtcbn07XG5leHBvcnRzLmNvbnZlcnQgPSBjb252ZXJ0O1xuIl0sIm5hbWVzIjpbIkJ1ZmZlciIsInJlcXVpcmUiLCJ0cmFucyIsIlVURjgiLCJVVEYxNiIsIlVURjE2QkUiLCJVVEYxNkxFIiwiVVRGMzIiLCJVVEYzMkJFIiwiVVRGMzJMRSIsIlVJTlQ3IiwiQVNDSUkiLCJCSU5BUlkiLCJVSU5UOCIsIlVJTlQxNiIsIlVJTlQxNkxFIiwiVUlOVDE2QkUiLCJVSU5UMzIiLCJVSU5UMzJMRSIsIlVJTlQzMkJFIiwiRVNDQVBFRCIsIlNUUklORyIsImJvbTgiLCJzcmMiLCJ0eXBlIiwiYnVmIiwiZGF0YSIsImJvbSIsImxlbmd0aCIsImJvbTE2IiwiVHlwZUVycm9yIiwiYm9tMzIiLCJ2YWxpZGF0ZVNyYyIsImdldFR5cGUiLCJ0eXBlQXJnIiwicmV0IiwiYmFzZTY0IiwicngiLCJyZXN1bHQiLCJleGVjIiwidG9VcHBlckNhc2UiLCJpc0J1ZmZlciIsImRlY29kZSIsImZyb20iLCJ2YWxpZGF0ZURzdCIsImNoYXJzIiwiZml4IiwicmVtIiwiY3JsZiIsImxmIiwiVFJVRSIsInNsaWNlIiwic3BsaXQiLCJBcnJheSIsImlzQXJyYXkiLCJlbmNvZGUiLCJ1dGY4IiwidXRmMTZiZSIsInV0ZjE2bGUiLCJ1dGYzMmJlIiwidXRmMzJsZSIsInVpbnQ3IiwidWludDgiLCJ1aW50MTZiZSIsInVpbnQxNmxlIiwidWludDMyYmUiLCJ1aW50MzJsZSIsInN0cmluZyIsImVzY2FwZWQiLCJleHBvcnRzIiwiZXhwb3J0c0RlY29kZSIsImV4cG9ydHNFbmNvZGUiLCJjIiwiZHN0IiwibGluZUVuZHMiLCJjb252ZXJ0Iiwic3JjVHlwZSIsInNyY0RhdGEiLCJkc3RUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/converter.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/transformers.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/transformers.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* eslint-disable prefer-destructuring */ /* eslint-disable no-plusplus */ /* eslint-disable no-bitwise */ /*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module contains the actual encoding and decoding algorithms.\n// Throws \"RangeError\" exceptions on characters or bytes out of range for the given encoding.\n\"use strict;\";\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n/* decoding error codes */ const NON_SHORTEST = 0xfffffffc;\nconst TRAILING = 0xfffffffd;\nconst RANGE = 0xfffffffe;\nconst ILL_FORMED = 0xffffffff;\n/* mask[n] = 2**n - 1, ie. mask[n] = n bits on. e.g. mask[6] = %b111111 */ const mask = [\n    0,\n    1,\n    3,\n    7,\n    15,\n    31,\n    63,\n    127,\n    255,\n    511,\n    1023\n];\n/* ascii[n] = 'HH', where 0xHH = n, eg. ascii[254] = 'FE' */ const ascii = [\n    \"00\",\n    \"01\",\n    \"02\",\n    \"03\",\n    \"04\",\n    \"05\",\n    \"06\",\n    \"07\",\n    \"08\",\n    \"09\",\n    \"0A\",\n    \"0B\",\n    \"0C\",\n    \"0D\",\n    \"0E\",\n    \"0F\",\n    \"10\",\n    \"11\",\n    \"12\",\n    \"13\",\n    \"14\",\n    \"15\",\n    \"16\",\n    \"17\",\n    \"18\",\n    \"19\",\n    \"1A\",\n    \"1B\",\n    \"1C\",\n    \"1D\",\n    \"1E\",\n    \"1F\",\n    \"20\",\n    \"21\",\n    \"22\",\n    \"23\",\n    \"24\",\n    \"25\",\n    \"26\",\n    \"27\",\n    \"28\",\n    \"29\",\n    \"2A\",\n    \"2B\",\n    \"2C\",\n    \"2D\",\n    \"2E\",\n    \"2F\",\n    \"30\",\n    \"31\",\n    \"32\",\n    \"33\",\n    \"34\",\n    \"35\",\n    \"36\",\n    \"37\",\n    \"38\",\n    \"39\",\n    \"3A\",\n    \"3B\",\n    \"3C\",\n    \"3D\",\n    \"3E\",\n    \"3F\",\n    \"40\",\n    \"41\",\n    \"42\",\n    \"43\",\n    \"44\",\n    \"45\",\n    \"46\",\n    \"47\",\n    \"48\",\n    \"49\",\n    \"4A\",\n    \"4B\",\n    \"4C\",\n    \"4D\",\n    \"4E\",\n    \"4F\",\n    \"50\",\n    \"51\",\n    \"52\",\n    \"53\",\n    \"54\",\n    \"55\",\n    \"56\",\n    \"57\",\n    \"58\",\n    \"59\",\n    \"5A\",\n    \"5B\",\n    \"5C\",\n    \"5D\",\n    \"5E\",\n    \"5F\",\n    \"60\",\n    \"61\",\n    \"62\",\n    \"63\",\n    \"64\",\n    \"65\",\n    \"66\",\n    \"67\",\n    \"68\",\n    \"69\",\n    \"6A\",\n    \"6B\",\n    \"6C\",\n    \"6D\",\n    \"6E\",\n    \"6F\",\n    \"70\",\n    \"71\",\n    \"72\",\n    \"73\",\n    \"74\",\n    \"75\",\n    \"76\",\n    \"77\",\n    \"78\",\n    \"79\",\n    \"7A\",\n    \"7B\",\n    \"7C\",\n    \"7D\",\n    \"7E\",\n    \"7F\",\n    \"80\",\n    \"81\",\n    \"82\",\n    \"83\",\n    \"84\",\n    \"85\",\n    \"86\",\n    \"87\",\n    \"88\",\n    \"89\",\n    \"8A\",\n    \"8B\",\n    \"8C\",\n    \"8D\",\n    \"8E\",\n    \"8F\",\n    \"90\",\n    \"91\",\n    \"92\",\n    \"93\",\n    \"94\",\n    \"95\",\n    \"96\",\n    \"97\",\n    \"98\",\n    \"99\",\n    \"9A\",\n    \"9B\",\n    \"9C\",\n    \"9D\",\n    \"9E\",\n    \"9F\",\n    \"A0\",\n    \"A1\",\n    \"A2\",\n    \"A3\",\n    \"A4\",\n    \"A5\",\n    \"A6\",\n    \"A7\",\n    \"A8\",\n    \"A9\",\n    \"AA\",\n    \"AB\",\n    \"AC\",\n    \"AD\",\n    \"AE\",\n    \"AF\",\n    \"B0\",\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B9\",\n    \"BA\",\n    \"BB\",\n    \"BC\",\n    \"BD\",\n    \"BE\",\n    \"BF\",\n    \"C0\",\n    \"C1\",\n    \"C2\",\n    \"C3\",\n    \"C4\",\n    \"C5\",\n    \"C6\",\n    \"C7\",\n    \"C8\",\n    \"C9\",\n    \"CA\",\n    \"CB\",\n    \"CC\",\n    \"CD\",\n    \"CE\",\n    \"CF\",\n    \"D0\",\n    \"D1\",\n    \"D2\",\n    \"D3\",\n    \"D4\",\n    \"D5\",\n    \"D6\",\n    \"D7\",\n    \"D8\",\n    \"D9\",\n    \"DA\",\n    \"DB\",\n    \"DC\",\n    \"DD\",\n    \"DE\",\n    \"DF\",\n    \"E0\",\n    \"E1\",\n    \"E2\",\n    \"E3\",\n    \"E4\",\n    \"E5\",\n    \"E6\",\n    \"E7\",\n    \"E8\",\n    \"E9\",\n    \"EA\",\n    \"EB\",\n    \"EC\",\n    \"ED\",\n    \"EE\",\n    \"EF\",\n    \"F0\",\n    \"F1\",\n    \"F2\",\n    \"F3\",\n    \"F4\",\n    \"F5\",\n    \"F6\",\n    \"F7\",\n    \"F8\",\n    \"F9\",\n    \"FA\",\n    \"FB\",\n    \"FC\",\n    \"FD\",\n    \"FE\",\n    \"FF\"\n];\n/* vector of base 64 characters */ const base64chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".split(\"\");\n/* vector of base 64 character codes */ const base64codes = [];\nbase64chars.forEach((char)=>{\n    base64codes.push(char.charCodeAt(0));\n});\n// The UTF8 algorithms.\nexports.utf8 = {\n    encode (chars) {\n        const bytes = [];\n        chars.forEach((char)=>{\n            if (char >= 0 && char <= 0x7f) {\n                bytes.push(char);\n            } else if (char <= 0x7ff) {\n                bytes.push(0xc0 + (char >> 6 & mask[5]));\n                bytes.push(0x80 + (char & mask[6]));\n            } else if (char < 0xd800 || char > 0xdfff && char <= 0xffff) {\n                bytes.push(0xe0 + (char >> 12 & mask[4]));\n                bytes.push(0x80 + (char >> 6 & mask[6]));\n                bytes.push(0x80 + (char & mask[6]));\n            } else if (char >= 0x10000 && char <= 0x10ffff) {\n                const u = char >> 16 & mask[5];\n                bytes.push(0xf0 + (u >> 2));\n                bytes.push(0x80 + ((u & mask[2]) << 4) + (char >> 12 & mask[4]));\n                bytes.push(0x80 + (char >> 6 & mask[6]));\n                bytes.push(0x80 + (char & mask[6]));\n            } else {\n                throw new RangeError(`utf8.encode: character out of range: char: ${char}`);\n            }\n        });\n        return Buffer.from(bytes);\n    },\n    decode (buf, bom) {\n        /* bytes functions return error for non-shortest forms & values out of range */ function bytes2(b1, b2) {\n            /* U+0080..U+07FF */ /* 00000000 00000yyy yyxxxxxx | 110yyyyy 10xxxxxx */ if ((b2 & 0xc0) !== 0x80) {\n                return TRAILING;\n            }\n            const x = ((b1 & mask[5]) << 6) + (b2 & mask[6]);\n            if (x < 0x80) {\n                return NON_SHORTEST;\n            }\n            return x;\n        }\n        function bytes3(b1, b2, b3) {\n            /* U+0800..U+FFFF */ /* 00000000 zzzzyyyy yyxxxxxx | 1110zzzz 10yyyyyy 10xxxxxx */ if ((b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n                return TRAILING;\n            }\n            const x = ((b1 & mask[4]) << 12) + ((b2 & mask[6]) << 6) + (b3 & mask[6]);\n            if (x < 0x800) {\n                return NON_SHORTEST;\n            }\n            if (x >= 0xd800 && x <= 0xdfff) {\n                return RANGE;\n            }\n            return x;\n        }\n        function bytes4(b1, b2, b3, b4) {\n            /* U+10000..U+10FFFF */ /* 000uuuuu zzzzyyyy yyxxxxxx | 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx */ if ((b4 & 0xc0) !== 0x80 || (b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n                return TRAILING;\n            }\n            const x = (((b1 & mask[3]) << 2) + (b2 >> 4 & mask[2]) << 16) + ((b2 & mask[4]) << 12) + ((b3 & mask[6]) << 6) + (b4 & mask[6]);\n            if (x < 0x10000) {\n                return NON_SHORTEST;\n            }\n            if (x > 0x10ffff) {\n                return RANGE;\n            }\n            return x;\n        }\n        let c;\n        let b1;\n        let i1;\n        let i2;\n        let i3;\n        let inc;\n        const len = buf.length;\n        let i = bom ? 3 : 0;\n        const chars = [];\n        while(i < len){\n            b1 = buf[i];\n            c = ILL_FORMED;\n            const TRUE = true;\n            while(TRUE){\n                if (b1 >= 0 && b1 <= 0x7f) {\n                    /* U+0000..U+007F 00..7F */ c = b1;\n                    inc = 1;\n                    break;\n                }\n                i1 = i + 1;\n                if (i1 < len && b1 >= 0xc2 && b1 <= 0xdf) {\n                    /* U+0080..U+07FF C2..DF 80..BF */ c = bytes2(b1, buf[i1]);\n                    inc = 2;\n                    break;\n                }\n                i2 = i + 2;\n                if (i2 < len && b1 >= 0xe0 && b1 <= 0xef) {\n                    /* U+0800..U+FFFF */ c = bytes3(b1, buf[i1], buf[i2]);\n                    inc = 3;\n                    break;\n                }\n                i3 = i + 3;\n                if (i3 < len && b1 >= 0xf0 && b1 <= 0xf4) {\n                    /* U+10000..U+10FFFF */ c = bytes4(b1, buf[i1], buf[i2], buf[i3]);\n                    inc = 4;\n                    break;\n                }\n                break;\n            }\n            if (c > 0x10ffff) {\n                const at = `byte[${i}]`;\n                if (c === ILL_FORMED) {\n                    throw new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${at}`);\n                }\n                if (c === TRAILING) {\n                    throw new RangeError(`utf8.decode: illegal trailing byte found at: ${at}`);\n                }\n                if (c === RANGE) {\n                    throw new RangeError(`utf8.decode: code point out of range found at: ${at}`);\n                }\n                if (c === NON_SHORTEST) {\n                    throw new RangeError(`utf8.decode: non-shortest form found at: ${at}`);\n                }\n                throw new RangeError(`utf8.decode: unrecognized error found at: ${at}`);\n            }\n            chars.push(c);\n            i += inc;\n        }\n        return chars;\n    }\n};\n// The UTF16BE algorithms.\nexports.utf16be = {\n    encode (chars) {\n        const bytes = [];\n        let char;\n        let h;\n        let l;\n        for(let i = 0; i < chars.length; i += 1){\n            char = chars[i];\n            if (char >= 0 && char <= 0xd7ff || char >= 0xe000 && char <= 0xffff) {\n                bytes.push(char >> 8 & mask[8]);\n                bytes.push(char & mask[8]);\n            } else if (char >= 0x10000 && char <= 0x10ffff) {\n                l = char - 0x10000;\n                h = 0xd800 + (l >> 10);\n                l = 0xdc00 + (l & mask[10]);\n                bytes.push(h >> 8 & mask[8]);\n                bytes.push(h & mask[8]);\n                bytes.push(l >> 8 & mask[8]);\n                bytes.push(l & mask[8]);\n            } else {\n                throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${i}]: ${char}`);\n            }\n        }\n        return Buffer.from(bytes);\n    },\n    decode (buf, bom) {\n        /* assumes caller has insured that buf is a Buffer of bytes */ if (buf.length % 2 > 0) {\n            throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${buf.length}`);\n        }\n        const chars = [];\n        const len = buf.length;\n        let i = bom ? 2 : 0;\n        let j = 0;\n        let c;\n        let inc;\n        let i1;\n        let i3;\n        let high;\n        let low;\n        while(i < len){\n            const TRUE = true;\n            while(TRUE){\n                i1 = i + 1;\n                if (i1 < len) {\n                    high = (buf[i] << 8) + buf[i1];\n                    if (high < 0xd800 || high > 0xdfff) {\n                        c = high;\n                        inc = 2;\n                        break;\n                    }\n                    i3 = i + 3;\n                    if (i3 < len) {\n                        low = (buf[i + 2] << 8) + buf[i3];\n                        if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n                            c = 0x10000 + (high - 0xd800 << 10) + (low - 0xdc00);\n                            inc = 4;\n                            break;\n                        }\n                    }\n                }\n                /* if we fall through to here, it is an ill-formed sequence */ throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${i}]`);\n            }\n            chars[j++] = c;\n            i += inc;\n        }\n        return chars;\n    }\n};\n// The UTF16LE algorithms.\nexports.utf16le = {\n    encode (chars) {\n        const bytes = [];\n        let char;\n        let h;\n        let l;\n        for(let i = 0; i < chars.length; i += 1){\n            char = chars[i];\n            if (char >= 0 && char <= 0xd7ff || char >= 0xe000 && char <= 0xffff) {\n                bytes.push(char & mask[8]);\n                bytes.push(char >> 8 & mask[8]);\n            } else if (char >= 0x10000 && char <= 0x10ffff) {\n                l = char - 0x10000;\n                h = 0xd800 + (l >> 10);\n                l = 0xdc00 + (l & mask[10]);\n                bytes.push(h & mask[8]);\n                bytes.push(h >> 8 & mask[8]);\n                bytes.push(l & mask[8]);\n                bytes.push(l >> 8 & mask[8]);\n            } else {\n                throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${i}]: ${char}`);\n            }\n        }\n        return Buffer.from(bytes);\n    },\n    decode (buf, bom) {\n        /* assumes caller has insured that buf is a Buffer of bytes */ if (buf.length % 2 > 0) {\n            throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${buf.length}`);\n        }\n        const chars = [];\n        const len = buf.length;\n        let i = bom ? 2 : 0;\n        let j = 0;\n        let c;\n        let inc;\n        let i1;\n        let i3;\n        let high;\n        let low;\n        while(i < len){\n            const TRUE = true;\n            while(TRUE){\n                i1 = i + 1;\n                if (i1 < len) {\n                    high = (buf[i1] << 8) + buf[i];\n                    if (high < 0xd800 || high > 0xdfff) {\n                        c = high;\n                        inc = 2;\n                        break;\n                    }\n                    i3 = i + 3;\n                    if (i3 < len) {\n                        low = (buf[i3] << 8) + buf[i + 2];\n                        if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n                            c = 0x10000 + (high - 0xd800 << 10) + (low - 0xdc00);\n                            inc = 4;\n                            break;\n                        }\n                    }\n                }\n                /* if we fall through to here, it is an ill-formed sequence */ throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${i}]`);\n            }\n            chars[j++] = c;\n            i += inc;\n        }\n        return chars;\n    }\n};\n// The UTF32BE algorithms.\nexports.utf32be = {\n    encode (chars) {\n        const buf = Buffer.alloc(chars.length * 4);\n        let i = 0;\n        chars.forEach((char)=>{\n            if (char >= 0xd800 && char <= 0xdfff || char > 0x10ffff) {\n                throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n            }\n            buf[i++] = char >> 24 & mask[8];\n            buf[i++] = char >> 16 & mask[8];\n            buf[i++] = char >> 8 & mask[8];\n            buf[i++] = char & mask[8];\n        });\n        return buf;\n    },\n    decode (buf, bom) {\n        /* caller to insure buf is a Buffer of bytes */ if (buf.length % 4 > 0) {\n            throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${buf.length}`);\n        }\n        const chars = [];\n        let i = bom ? 4 : 0;\n        for(; i < buf.length; i += 4){\n            const char = (buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3];\n            if (char >= 0xd800 && char <= 0xdfff || char > 0x10ffff) {\n                throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n            }\n            chars.push(char);\n        }\n        return chars;\n    }\n};\n// The UTF32LE algorithms.\nexports.utf32le = {\n    encode (chars) {\n        const buf = Buffer.alloc(chars.length * 4);\n        let i = 0;\n        chars.forEach((char)=>{\n            if (char >= 0xd800 && char <= 0xdfff || char > 0x10ffff) {\n                throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n            }\n            buf[i++] = char & mask[8];\n            buf[i++] = char >> 8 & mask[8];\n            buf[i++] = char >> 16 & mask[8];\n            buf[i++] = char >> 24 & mask[8];\n        });\n        return buf;\n    },\n    decode (buf, bom) {\n        /* caller to insure buf is a Buffer of bytes */ if (buf.length % 4 > 0) {\n            throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${buf.length}`);\n        }\n        const chars = [];\n        let i = bom ? 4 : 0;\n        for(; i < buf.length; i += 4){\n            const char = (buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i];\n            if (char >= 0xd800 && char <= 0xdfff || char > 0x10ffff) {\n                throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n            }\n            chars.push(char);\n        }\n        return chars;\n    }\n};\n// The UINT7 algorithms. ASCII or 7-bit unsigned integers.\nexports.uint7 = {\n    encode (chars) {\n        const buf = Buffer.alloc(chars.length);\n        for(let i = 0; i < chars.length; i += 1){\n            if (chars[i] > 0x7f) {\n                throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${i}]: ${chars[i]}`);\n            }\n            buf[i] = chars[i];\n        }\n        return buf;\n    },\n    decode (buf) {\n        const chars = [];\n        for(let i = 0; i < buf.length; i += 1){\n            if (buf[i] > 0x7f) {\n                throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${i}]: ${buf[i]}`);\n            }\n            chars[i] = buf[i];\n        }\n        return chars;\n    }\n};\n// The UINT8 algorithms. BINARY, Latin 1 or 8-bit unsigned integers.\nexports.uint8 = {\n    encode (chars) {\n        const buf = Buffer.alloc(chars.length);\n        for(let i = 0; i < chars.length; i += 1){\n            if (chars[i] > 0xff) {\n                throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${i}]: ${chars[i]}`);\n            }\n            buf[i] = chars[i];\n        }\n        return buf;\n    },\n    decode (buf) {\n        const chars = [];\n        for(let i = 0; i < buf.length; i += 1){\n            chars[i] = buf[i];\n        }\n        return chars;\n    }\n};\n// The UINT16BE algorithms. Big-endian 16-bit unsigned integers.\nexports.uint16be = {\n    encode (chars) {\n        const buf = Buffer.alloc(chars.length * 2);\n        let i = 0;\n        chars.forEach((char)=>{\n            if (char > 0xffff) {\n                throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${i / 2}]: ${char}`);\n            }\n            buf[i++] = char >> 8 & mask[8];\n            buf[i++] = char & mask[8];\n        });\n        return buf;\n    },\n    decode (buf) {\n        if (buf.length % 2 > 0) {\n            throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${buf.length}`);\n        }\n        const chars = [];\n        for(let i = 0; i < buf.length; i += 2){\n            chars.push((buf[i] << 8) + buf[i + 1]);\n        }\n        return chars;\n    }\n};\n// The UINT16LE algorithms. Little-endian 16-bit unsigned integers.\nexports.uint16le = {\n    encode (chars) {\n        const buf = Buffer.alloc(chars.length * 2);\n        let i = 0;\n        chars.forEach((char)=>{\n            if (char > 0xffff) {\n                throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${i / 2}]: ${char}`);\n            }\n            buf[i++] = char & mask[8];\n            buf[i++] = char >> 8 & mask[8];\n        });\n        return buf;\n    },\n    decode (buf) {\n        if (buf.length % 2 > 0) {\n            throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${buf.length}`);\n        }\n        const chars = [];\n        for(let i = 0; i < buf.length; i += 2){\n            chars.push((buf[i + 1] << 8) + buf[i]);\n        }\n        return chars;\n    }\n};\n// The UINT32BE algorithms. Big-endian 32-bit unsigned integers.\nexports.uint32be = {\n    encode (chars) {\n        const buf = Buffer.alloc(chars.length * 4);\n        let i = 0;\n        chars.forEach((char)=>{\n            buf[i++] = char >> 24 & mask[8];\n            buf[i++] = char >> 16 & mask[8];\n            buf[i++] = char >> 8 & mask[8];\n            buf[i++] = char & mask[8];\n        });\n        return buf;\n    },\n    decode (buf) {\n        if (buf.length % 4 > 0) {\n            throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${buf.length}`);\n        }\n        const chars = [];\n        for(let i = 0; i < buf.length; i += 4){\n            chars.push((buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3]);\n        }\n        return chars;\n    }\n};\n// The UINT32LE algorithms. Little-endian 32-bit unsigned integers.\nexports.uint32le = {\n    encode (chars) {\n        const buf = Buffer.alloc(chars.length * 4);\n        let i = 0;\n        chars.forEach((char)=>{\n            buf[i++] = char & mask[8];\n            buf[i++] = char >> 8 & mask[8];\n            buf[i++] = char >> 16 & mask[8];\n            buf[i++] = char >> 24 & mask[8];\n        });\n        return buf;\n    },\n    decode (buf) {\n        /* caller to insure buf is a Buffer of bytes */ if (buf.length % 4 > 0) {\n            throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${buf.length}`);\n        }\n        const chars = [];\n        for(let i = 0; i < buf.length; i += 4){\n            chars.push((buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i]);\n        }\n        return chars;\n    }\n};\n// The STRING algorithms. Converts JavaScript strings to Array of 32-bit integers and vice versa.\n// Uses the node.js Buffer's native \"utf16le\" capabilites.\nexports.string = {\n    encode (chars) {\n        return exports.utf16le.encode(chars).toString(\"utf16le\");\n    },\n    decode (str) {\n        return exports.utf16le.decode(Buffer.from(str, \"utf16le\"), 0);\n    }\n};\n// The ESCAPED algorithms.\n// Note that ESCAPED format contains only ASCII characters.\n// The characters are always in the form of a Buffer of bytes.\nexports.escaped = {\n    // Encodes an Array of 32-bit integers into ESCAPED format.\n    encode (chars) {\n        const bytes = [];\n        for(let i = 0; i < chars.length; i += 1){\n            const char = chars[i];\n            if (char === 96) {\n                bytes.push(char);\n                bytes.push(char);\n            } else if (char === 10) {\n                bytes.push(char);\n            } else if (char >= 32 && char <= 126) {\n                bytes.push(char);\n            } else {\n                let str = \"\";\n                if (char >= 0 && char <= 31) {\n                    str += `\\`x${ascii[char]}`;\n                } else if (char >= 127 && char <= 255) {\n                    str += `\\`x${ascii[char]}`;\n                } else if (char >= 0x100 && char <= 0xffff) {\n                    str += `\\`u${ascii[char >> 8 & mask[8]]}${ascii[char & mask[8]]}`;\n                } else if (char >= 0x10000 && char <= 0xffffffff) {\n                    str += \"`u{\";\n                    const digit = char >> 24 & mask[8];\n                    if (digit > 0) {\n                        str += ascii[digit];\n                    }\n                    str += `${ascii[char >> 16 & mask[8]] + ascii[char >> 8 & mask[8]] + ascii[char & mask[8]]}}`;\n                } else {\n                    throw new Error(\"escape.encode(char): char > 0xffffffff not allowed\");\n                }\n                const buf = Buffer.from(str);\n                buf.forEach((b)=>{\n                    bytes.push(b);\n                });\n            }\n        }\n        return Buffer.from(bytes);\n    },\n    // Decodes ESCAPED format from a Buffer of bytes to an Array of 32-bit integers.\n    decode (buf) {\n        function isHex(hex) {\n            if (hex >= 48 && hex <= 57 || hex >= 65 && hex <= 70 || hex >= 97 && hex <= 102) {\n                return true;\n            }\n            return false;\n        }\n        function getx(i, len, bufArg) {\n            const ret = {\n                char: null,\n                nexti: i + 2,\n                error: true\n            };\n            if (i + 1 < len) {\n                if (isHex(bufArg[i]) && isHex(bufArg[i + 1])) {\n                    const str = String.fromCodePoint(bufArg[i], bufArg[i + 1]);\n                    ret.char = parseInt(str, 16);\n                    if (!Number.isNaN(ret.char)) {\n                        ret.error = false;\n                    }\n                }\n            }\n            return ret;\n        }\n        function getu(i, len, bufArg) {\n            const ret = {\n                char: null,\n                nexti: i + 4,\n                error: true\n            };\n            if (i + 3 < len) {\n                if (isHex(bufArg[i]) && isHex(bufArg[i + 1]) && isHex(bufArg[i + 2]) && isHex(bufArg[i + 3])) {\n                    const str = String.fromCodePoint(bufArg[i], bufArg[i + 1], bufArg[i + 2], bufArg[i + 3]);\n                    ret.char = parseInt(str, 16);\n                    if (!Number.isNaN(ret.char)) {\n                        ret.error = false;\n                    }\n                }\n            }\n            return ret;\n        }\n        function getU(i, len, bufArg) {\n            const ret = {\n                char: null,\n                nexti: i + 4,\n                error: true\n            };\n            let str = \"\";\n            while(i < len && isHex(bufArg[i])){\n                str += String.fromCodePoint(bufArg[i]);\n                // eslint-disable-next-line no-param-reassign\n                i += 1;\n            }\n            ret.char = parseInt(str, 16);\n            if (bufArg[i] === 125 && !Number.isNaN(ret.char)) {\n                ret.error = false;\n            }\n            ret.nexti = i + 1;\n            return ret;\n        }\n        const chars = [];\n        const len = buf.length;\n        let i1;\n        let ret;\n        let error;\n        let i = 0;\n        while(i < len){\n            const TRUE = true;\n            while(TRUE){\n                error = true;\n                if (buf[i] !== 96) {\n                    /* unescaped character */ chars.push(buf[i]);\n                    i += 1;\n                    error = false;\n                    break;\n                }\n                i1 = i + 1;\n                if (i1 >= len) {\n                    break;\n                }\n                if (buf[i1] === 96) {\n                    /* escaped grave accent */ chars.push(96);\n                    i += 2;\n                    error = false;\n                    break;\n                }\n                if (buf[i1] === 120) {\n                    ret = getx(i1 + 1, len, buf);\n                    if (ret.error) {\n                        break;\n                    }\n                    /* escaped hex */ chars.push(ret.char);\n                    i = ret.nexti;\n                    error = false;\n                    break;\n                }\n                if (buf[i1] === 117) {\n                    if (buf[i1 + 1] === 123) {\n                        ret = getU(i1 + 2, len, buf);\n                        if (ret.error) {\n                            break;\n                        }\n                        /* escaped utf-32 */ chars.push(ret.char);\n                        i = ret.nexti;\n                        error = false;\n                        break;\n                    }\n                    ret = getu(i1 + 1, len, buf);\n                    if (ret.error) {\n                        break;\n                    }\n                    /* escaped utf-16 */ chars.push(ret.char);\n                    i = ret.nexti;\n                    error = false;\n                    break;\n                }\n                break;\n            }\n            if (error) {\n                throw new Error(`escaped.decode: ill-formed escape sequence at buf[${i}]`);\n            }\n        }\n        return chars;\n    }\n};\n// The line end conversion algorigthms.\nconst CR = 13;\nconst LF = 10;\nexports.lineEnds = {\n    crlf (chars) {\n        const lfchars = [];\n        let i = 0;\n        while(i < chars.length){\n            switch(chars[i]){\n                case CR:\n                    if (i + 1 < chars.length && chars[i + 1] === LF) {\n                        i += 2;\n                    } else {\n                        i += 1;\n                    }\n                    lfchars.push(CR);\n                    lfchars.push(LF);\n                    break;\n                case LF:\n                    lfchars.push(CR);\n                    lfchars.push(LF);\n                    i += 1;\n                    break;\n                default:\n                    lfchars.push(chars[i]);\n                    i += 1;\n                    break;\n            }\n        }\n        if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n            lfchars.push(CR);\n            lfchars.push(LF);\n        }\n        return lfchars;\n    },\n    lf (chars) {\n        const lfchars = [];\n        let i = 0;\n        while(i < chars.length){\n            switch(chars[i]){\n                case CR:\n                    if (i + 1 < chars.length && chars[i + 1] === LF) {\n                        i += 2;\n                    } else {\n                        i += 1;\n                    }\n                    lfchars.push(LF);\n                    break;\n                case LF:\n                    lfchars.push(LF);\n                    i += 1;\n                    break;\n                default:\n                    lfchars.push(chars[i]);\n                    i += 1;\n                    break;\n            }\n        }\n        if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n            lfchars.push(LF);\n        }\n        return lfchars;\n    }\n};\n// The base 64 algorithms.\nexports.base64 = {\n    encode (buf) {\n        if (buf.length === 0) {\n            return Buffer.alloc(0);\n        }\n        let i;\n        let j;\n        let n;\n        let tail = buf.length % 3;\n        tail = tail > 0 ? 3 - tail : 0;\n        let units = (buf.length + tail) / 3;\n        const base64 = Buffer.alloc(units * 4);\n        if (tail > 0) {\n            units -= 1;\n        }\n        i = 0;\n        j = 0;\n        for(let u = 0; u < units; u += 1){\n            n = buf[i++] << 16;\n            n += buf[i++] << 8;\n            n += buf[i++];\n            base64[j++] = base64codes[n >> 18 & mask[6]];\n            base64[j++] = base64codes[n >> 12 & mask[6]];\n            base64[j++] = base64codes[n >> 6 & mask[6]];\n            base64[j++] = base64codes[n & mask[6]];\n        }\n        if (tail === 0) {\n            return base64;\n        }\n        if (tail === 1) {\n            n = buf[i++] << 16;\n            n += buf[i] << 8;\n            base64[j++] = base64codes[n >> 18 & mask[6]];\n            base64[j++] = base64codes[n >> 12 & mask[6]];\n            base64[j++] = base64codes[n >> 6 & mask[6]];\n            base64[j] = base64codes[64];\n            return base64;\n        }\n        if (tail === 2) {\n            n = buf[i] << 16;\n            base64[j++] = base64codes[n >> 18 & mask[6]];\n            base64[j++] = base64codes[n >> 12 & mask[6]];\n            base64[j++] = base64codes[64];\n            base64[j] = base64codes[64];\n            return base64;\n        }\n        return undefined;\n    },\n    decode (codes) {\n        /* remove white space and ctrl characters, validate & translate characters */ function validate(buf) {\n            const chars = [];\n            let tail = 0;\n            for(let i = 0; i < buf.length; i += 1){\n                const char = buf[i];\n                const TRUE = true;\n                while(TRUE){\n                    if (char === 32 || char === 9 || char === 10 || char === 13) {\n                        break;\n                    }\n                    if (char >= 65 && char <= 90) {\n                        chars.push(char - 65);\n                        break;\n                    }\n                    if (char >= 97 && char <= 122) {\n                        chars.push(char - 71);\n                        break;\n                    }\n                    if (char >= 48 && char <= 57) {\n                        chars.push(char + 4);\n                        break;\n                    }\n                    if (char === 43) {\n                        chars.push(62);\n                        break;\n                    }\n                    if (char === 47) {\n                        chars.push(63);\n                        break;\n                    }\n                    if (char === 61) {\n                        chars.push(64);\n                        tail += 1;\n                        break;\n                    }\n                    /* invalid character */ throw new RangeError(`base64.decode: invalid character buf[${i}]: ${char}`);\n                }\n            }\n            /* validate length */ if (chars.length % 4 > 0) {\n                throw new RangeError(`base64.decode: string length not integral multiple of 4: ${chars.length}`);\n            }\n            /* validate tail */ switch(tail){\n                case 0:\n                    break;\n                case 1:\n                    if (chars[chars.length - 1] !== 64) {\n                        throw new RangeError(\"base64.decode: one tail character found: not last character\");\n                    }\n                    break;\n                case 2:\n                    if (chars[chars.length - 1] !== 64 || chars[chars.length - 2] !== 64) {\n                        throw new RangeError(\"base64.decode: two tail characters found: not last characters\");\n                    }\n                    break;\n                default:\n                    throw new RangeError(`base64.decode: more than two tail characters found: ${tail}`);\n            }\n            return {\n                tail,\n                buf: Buffer.from(chars)\n            };\n        }\n        if (codes.length === 0) {\n            return Buffer.alloc(0);\n        }\n        const val = validate(codes);\n        const { tail } = val;\n        const base64 = val.buf;\n        let i;\n        let j;\n        let n;\n        let units = base64.length / 4;\n        const buf = Buffer.alloc(units * 3 - tail);\n        if (tail > 0) {\n            units -= 1;\n        }\n        j = 0;\n        i = 0;\n        for(let u = 0; u < units; u += 1){\n            n = base64[i++] << 18;\n            n += base64[i++] << 12;\n            n += base64[i++] << 6;\n            n += base64[i++];\n            buf[j++] = n >> 16 & mask[8];\n            buf[j++] = n >> 8 & mask[8];\n            buf[j++] = n & mask[8];\n        }\n        if (tail === 1) {\n            n = base64[i++] << 18;\n            n += base64[i++] << 12;\n            n += base64[i] << 6;\n            buf[j++] = n >> 16 & mask[8];\n            buf[j] = n >> 8 & mask[8];\n        }\n        if (tail === 2) {\n            n = base64[i++] << 18;\n            n += base64[i++] << 12;\n            buf[j] = n >> 16 & mask[8];\n        }\n        return buf;\n    },\n    // Converts a base 64 Buffer of bytes to a JavaScript string with line breaks.\n    toString (buf) {\n        if (buf.length % 4 > 0) {\n            throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${buf.length}`);\n        }\n        let str = \"\";\n        let lineLen = 0;\n        function buildLine(c1, c2, c3, c4) {\n            switch(lineLen){\n                case 76:\n                    str += `\\r\\n${c1}${c2}${c3}${c4}`;\n                    lineLen = 4;\n                    break;\n                case 75:\n                    str += `${c1}\\r\\n${c2}${c3}${c4}`;\n                    lineLen = 3;\n                    break;\n                case 74:\n                    str += `${c1 + c2}\\r\\n${c3}${c4}`;\n                    lineLen = 2;\n                    break;\n                case 73:\n                    str += `${c1 + c2 + c3}\\r\\n${c4}`;\n                    lineLen = 1;\n                    break;\n                default:\n                    str += c1 + c2 + c3 + c4;\n                    lineLen += 4;\n                    break;\n            }\n        }\n        function validate(c) {\n            if (c >= 65 && c <= 90) {\n                return true;\n            }\n            if (c >= 97 && c <= 122) {\n                return true;\n            }\n            if (c >= 48 && c <= 57) {\n                return true;\n            }\n            if (c === 43) {\n                return true;\n            }\n            if (c === 47) {\n                return true;\n            }\n            if (c === 61) {\n                return true;\n            }\n            return false;\n        }\n        for(let i = 0; i < buf.length; i += 4){\n            for(let j = i; j < i + 4; j += 1){\n                if (!validate(buf[j])) {\n                    throw new RangeError(`base64.toString: buf[${j}]: ${buf[j]} : not valid base64 character code`);\n                }\n            }\n            buildLine(String.fromCharCode(buf[i]), String.fromCharCode(buf[i + 1]), String.fromCharCode(buf[i + 2]), String.fromCharCode(buf[i + 3]));\n        }\n        return str;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvdHJhbnNmb3JtZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHVDQUF1QyxHQUN2Qyw4QkFBOEIsR0FDOUIsNkJBQTZCLEdBQzdCOzs7dUZBR3VGLEdBQ3ZGLG9FQUFvRTtBQUNwRSw2RkFBNkY7QUFFN0Y7QUFFQSxNQUFNLEVBQUVBLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUUzQix3QkFBd0IsR0FDeEIsTUFBTUMsZUFBZTtBQUNyQixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxhQUFhO0FBRW5CLHdFQUF3RSxHQUN4RSxNQUFNQyxPQUFPO0lBQUM7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQUs7SUFBSztDQUFLO0FBRTFELDBEQUEwRCxHQUMxRCxNQUFNQyxRQUFRO0lBQ1o7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVELGdDQUFnQyxHQUNoQyxNQUFNQyxjQUFjLG9FQUFvRUMsS0FBSyxDQUFDO0FBRTlGLHFD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LE1BQU0sRUFBRUMsS0FBSyxFQUFHO1lBQ3RDLElBQUssSUFBSU0sSUFBSU4sR0FBR00sSUFBSU4sSUFBSSxHQUFHTSxLQUFLLEVBQUc7Z0JBQ2pDLElBQUksQ0FBQzhDLFNBQVNyRSxHQUFHLENBQUN1QixFQUFFLEdBQUc7b0JBQ3JCLE1BQU0sSUFBSTFCLFdBQVcsQ0FBQyxxQkFBcUIsRUFBRTBCLEVBQUUsR0FBRyxFQUFFdkIsR0FBRyxDQUFDdUIsRUFBRSxDQUFDLGtDQUFrQyxDQUFDO2dCQUNoRztZQUNGO1lBQ0FpRCxVQUNFdEIsT0FBTzJCLFlBQVksQ0FBQzdFLEdBQUcsQ0FBQ2lCLEVBQUUsR0FDMUJpQyxPQUFPMkIsWUFBWSxDQUFDN0UsR0FBRyxDQUFDaUIsSUFBSSxFQUFFLEdBQzlCaUMsT0FBTzJCLFlBQVksQ0FBQzdFLEdBQUcsQ0FBQ2lCLElBQUksRUFBRSxHQUM5QmlDLE9BQU8yQixZQUFZLENBQUM3RSxHQUFHLENBQUNpQixJQUFJLEVBQUU7UUFFbEM7UUFDQSxPQUFPcUI7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1jb252LWFwaS90cmFuc2Zvcm1lcnMuanM/NmMzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGx1c3BsdXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGNvbnRhaW5zIHRoZSBhY3R1YWwgZW5jb2RpbmcgYW5kIGRlY29kaW5nIGFsZ29yaXRobXMuXG4vLyBUaHJvd3MgXCJSYW5nZUVycm9yXCIgZXhjZXB0aW9ucyBvbiBjaGFyYWN0ZXJzIG9yIGJ5dGVzIG91dCBvZiByYW5nZSBmb3IgdGhlIGdpdmVuIGVuY29kaW5nLlxuXG4ndXNlIHN0cmljdDsnO1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5cbi8qIGRlY29kaW5nIGVycm9yIGNvZGVzICovXG5jb25zdCBOT05fU0hPUlRFU1QgPSAweGZmZmZmZmZjO1xuY29uc3QgVFJBSUxJTkcgPSAweGZmZmZmZmZkO1xuY29uc3QgUkFOR0UgPSAweGZmZmZmZmZlO1xuY29uc3QgSUxMX0ZPUk1FRCA9IDB4ZmZmZmZmZmY7XG5cbi8qIG1hc2tbbl0gPSAyKipuIC0gMSwgaWUuIG1hc2tbbl0gPSBuIGJpdHMgb24uIGUuZy4gbWFza1s2XSA9ICViMTExMTExICovXG5jb25zdCBtYXNrID0gWzAsIDEsIDMsIDcsIDE1LCAzMSwgNjMsIDEyNywgMjU1LCA1MTEsIDEwMjNdO1xuXG4vKiBhc2NpaVtuXSA9ICdISCcsIHdoZXJlIDB4SEggPSBuLCBlZy4gYXNjaWlbMjU0XSA9ICdGRScgKi9cbmNvbnN0IGFzY2lpID0gW1xuICAnMDAnLFxuICAnMDEnLFxuICAnMDInLFxuICAnMDMnLFxuICAnMDQnLFxuICAnMDUnLFxuICAnMDYnLFxuICAnMDcnLFxuICAnMDgnLFxuICAnMDknLFxuICAnMEEnLFxuICAnMEInLFxuICAnMEMnLFxuICAnMEQnLFxuICAnMEUnLFxuICAnMEYnLFxuICAnMTAnLFxuICAnMTEnLFxuICAnMTInLFxuICAnMTMnLFxuICAnMTQnLFxuICAnMTUnLFxuICAnMTYnLFxuICAnMTcnLFxuICAnMTgnLFxuICAnMTknLFxuICAnMUEnLFxuICAnMUInLFxuICAnMUMnLFxuICAnMUQnLFxuICAnMUUnLFxuICAnMUYnLFxuICAnMjAnLFxuICAnMjEnLFxuICAnMjInLFxuICAnMjMnLFxuICAnMjQnLFxuICAnMjUnLFxuICAnMjYnLFxuICAnMjcnLFxuICAnMjgnLFxuICAnMjknLFxuICAnMkEnLFxuICAnMkInLFxuICAnMkMnLFxuICAnMkQnLFxuICAnMkUnLFxuICAnMkYnLFxuICAnMzAnLFxuICAnMzEnLFxuICAnMzInLFxuICAnMzMnLFxuICAnMzQnLFxuICAnMzUnLFxuICAnMzYnLFxuICAnMzcnLFxuICAnMzgnLFxuICAnMzknLFxuICAnM0EnLFxuICAnM0InLFxuICAnM0MnLFxuICAnM0QnLFxuICAnM0UnLFxuICAnM0YnLFxuICAnNDAnLFxuICAnNDEnLFxuICAnNDInLFxuICAnNDMnLFxuICAnNDQnLFxuICAnNDUnLFxuICAnNDYnLFxuICAnNDcnLFxuICAnNDgnLFxuICAnNDknLFxuICAnNEEnLFxuICAnNEInLFxuICAnNEMnLFxuICAnNEQnLFxuICAnNEUnLFxuICAnNEYnLFxuICAnNTAnLFxuICAnNTEnLFxuICAnNTInLFxuICAnNTMnLFxuICAnNTQnLFxuICAnNTUnLFxuICAnNTYnLFxuICAnNTcnLFxuICAnNTgnLFxuICAnNTknLFxuICAnNUEnLFxuICAnNUInLFxuICAnNUMnLFxuICAnNUQnLFxuICAnNUUnLFxuICAnNUYnLFxuICAnNjAnLFxuICAnNjEnLFxuICAnNjInLFxuICAnNjMnLFxuICAnNjQnLFxuICAnNjUnLFxuICAnNjYnLFxuICAnNjcnLFxuICAnNjgnLFxuICAnNjknLFxuICAnNkEnLFxuICAnNkInLFxuICAnNkMnLFxuICAnNkQnLFxuICAnNkUnLFxuICAnNkYnLFxuICAnNzAnLFxuICAnNzEnLFxuICAnNzInLFxuICAnNzMnLFxuICAnNzQnLFxuICAnNzUnLFxuICAnNzYnLFxuICAnNzcnLFxuICAnNzgnLFxuICAnNzknLFxuICAnN0EnLFxuICAnN0InLFxuICAnN0MnLFxuICAnN0QnLFxuICAnN0UnLFxuICAnN0YnLFxuICAnODAnLFxuICAnODEnLFxuICAnODInLFxuICAnODMnLFxuICAnODQnLFxuICAnODUnLFxuICAnODYnLFxuICAnODcnLFxuICAnODgnLFxuICAnODknLFxuICAnOEEnLFxuICAnOEInLFxuICAnOEMnLFxuICAnOEQnLFxuICAnOEUnLFxuICAnOEYnLFxuICAnOTAnLFxuICAnOTEnLFxuICAnOTInLFxuICAnOTMnLFxuICAnOTQnLFxuICAnOTUnLFxuICAnOTYnLFxuICAnOTcnLFxuICAnOTgnLFxuICAnOTknLFxuICAnOUEnLFxuICAnOUInLFxuICAnOUMnLFxuICAnOUQnLFxuICAnOUUnLFxuICAnOUYnLFxuICAnQTAnLFxuICAnQTEnLFxuICAnQTInLFxuICAnQTMnLFxuICAnQTQnLFxuICAnQTUnLFxuICAnQTYnLFxuICAnQTcnLFxuICAnQTgnLFxuICAnQTknLFxuICAnQUEnLFxuICAnQUInLFxuICAnQUMnLFxuICAnQUQnLFxuICAnQUUnLFxuICAnQUYnLFxuICAnQjAnLFxuICAnQjEnLFxuICAnQjInLFxuICAnQjMnLFxuICAnQjQnLFxuICAnQjUnLFxuICAnQjYnLFxuICAnQjcnLFxuICAnQjgnLFxuICAnQjknLFxuICAnQkEnLFxuICAnQkInLFxuICAnQkMnLFxuICAnQkQnLFxuICAnQkUnLFxuICAnQkYnLFxuICAnQzAnLFxuICAnQzEnLFxuICAnQzInLFxuICAnQzMnLFxuICAnQzQnLFxuICAnQzUnLFxuICAnQzYnLFxuICAnQzcnLFxuICAnQzgnLFxuICAnQzknLFxuICAnQ0EnLFxuICAnQ0InLFxuICAnQ0MnLFxuICAnQ0QnLFxuICAnQ0UnLFxuICAnQ0YnLFxuICAnRDAnLFxuICAnRDEnLFxuICAnRDInLFxuICAnRDMnLFxuICAnRDQnLFxuICAnRDUnLFxuICAnRDYnLFxuICAnRDcnLFxuICAnRDgnLFxuICAnRDknLFxuICAnREEnLFxuICAnREInLFxuICAnREMnLFxuICAnREQnLFxuICAnREUnLFxuICAnREYnLFxuICAnRTAnLFxuICAnRTEnLFxuICAnRTInLFxuICAnRTMnLFxuICAnRTQnLFxuICAnRTUnLFxuICAnRTYnLFxuICAnRTcnLFxuICAnRTgnLFxuICAnRTknLFxuICAnRUEnLFxuICAnRUInLFxuICAnRUMnLFxuICAnRUQnLFxuICAnRUUnLFxuICAnRUYnLFxuICAnRjAnLFxuICAnRjEnLFxuICAnRjInLFxuICAnRjMnLFxuICAnRjQnLFxuICAnRjUnLFxuICAnRjYnLFxuICAnRjcnLFxuICAnRjgnLFxuICAnRjknLFxuICAnRkEnLFxuICAnRkInLFxuICAnRkMnLFxuICAnRkQnLFxuICAnRkUnLFxuICAnRkYnLFxuXTtcblxuLyogdmVjdG9yIG9mIGJhc2UgNjQgY2hhcmFjdGVycyAqL1xuY29uc3QgYmFzZTY0Y2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nLnNwbGl0KCcnKTtcblxuLyogdmVjdG9yIG9mIGJhc2UgNjQgY2hhcmFjdGVyIGNvZGVzICovXG5jb25zdCBiYXNlNjRjb2RlcyA9IFtdO1xuYmFzZTY0Y2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICBiYXNlNjRjb2Rlcy5wdXNoKGNoYXIuY2hhckNvZGVBdCgwKSk7XG59KTtcblxuLy8gVGhlIFVURjggYWxnb3JpdGhtcy5cbmV4cG9ydHMudXRmOCA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBpZiAoY2hhciA+PSAwICYmIGNoYXIgPD0gMHg3Zikge1xuICAgICAgICBieXRlcy5wdXNoKGNoYXIpO1xuICAgICAgfSBlbHNlIGlmIChjaGFyIDw9IDB4N2ZmKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMHhjMCArICgoY2hhciA+PiA2KSAmIG1hc2tbNV0pKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwICsgKGNoYXIgJiBtYXNrWzZdKSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPCAweGQ4MDAgfHwgKGNoYXIgPiAweGRmZmYgJiYgY2hhciA8PSAweGZmZmYpKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMHhlMCArICgoY2hhciA+PiAxMikgJiBtYXNrWzRdKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCArICgoY2hhciA+PiA2KSAmIG1hc2tbNl0pKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwICsgKGNoYXIgJiBtYXNrWzZdKSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMHgxMDAwMCAmJiBjaGFyIDw9IDB4MTBmZmZmKSB7XG4gICAgICAgIGNvbnN0IHUgPSAoY2hhciA+PiAxNikgJiBtYXNrWzVdO1xuICAgICAgICBieXRlcy5wdXNoKDB4ZjAgKyAodSA+PiAyKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCArICgodSAmIG1hc2tbMl0pIDw8IDQpICsgKChjaGFyID4+IDEyKSAmIG1hc2tbNF0pKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwICsgKChjaGFyID4+IDYpICYgbWFza1s2XSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgKyAoY2hhciAmIG1hc2tbNl0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGY4LmVuY29kZTogY2hhcmFjdGVyIG91dCBvZiByYW5nZTogY2hhcjogJHtjaGFyfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0sXG4gIGRlY29kZShidWYsIGJvbSkge1xuICAgIC8qIGJ5dGVzIGZ1bmN0aW9ucyByZXR1cm4gZXJyb3IgZm9yIG5vbi1zaG9ydGVzdCBmb3JtcyAmIHZhbHVlcyBvdXQgb2YgcmFuZ2UgKi9cbiAgICBmdW5jdGlvbiBieXRlczIoYjEsIGIyKSB7XG4gICAgICAvKiBVKzAwODAuLlUrMDdGRiAqL1xuICAgICAgLyogMDAwMDAwMDAgMDAwMDB5eXkgeXl4eHh4eHggfCAxMTB5eXl5eSAxMHh4eHh4eCAqL1xuICAgICAgaWYgKChiMiAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgIHJldHVybiBUUkFJTElORztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSAoKGIxICYgbWFza1s1XSkgPDwgNikgKyAoYjIgJiBtYXNrWzZdKTtcbiAgICAgIGlmICh4IDwgMHg4MCkge1xuICAgICAgICByZXR1cm4gTk9OX1NIT1JURVNUO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ5dGVzMyhiMSwgYjIsIGIzKSB7XG4gICAgICAvKiBVKzA4MDAuLlUrRkZGRiAqL1xuICAgICAgLyogMDAwMDAwMDAgenp6enl5eXkgeXl4eHh4eHggfCAxMTEwenp6eiAxMHl5eXl5eSAxMHh4eHh4eCAqL1xuICAgICAgaWYgKChiMyAmIDB4YzApICE9PSAweDgwIHx8IChiMiAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgIHJldHVybiBUUkFJTElORztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSAoKGIxICYgbWFza1s0XSkgPDwgMTIpICsgKChiMiAmIG1hc2tbNl0pIDw8IDYpICsgKGIzICYgbWFza1s2XSk7XG4gICAgICBpZiAoeCA8IDB4ODAwKSB7XG4gICAgICAgIHJldHVybiBOT05fU0hPUlRFU1Q7XG4gICAgICB9XG4gICAgICBpZiAoeCA+PSAweGQ4MDAgJiYgeCA8PSAweGRmZmYpIHtcbiAgICAgICAgcmV0dXJuIFJBTkdFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ5dGVzNChiMSwgYjIsIGIzLCBiNCkge1xuICAgICAgLyogVSsxMDAwMC4uVSsxMEZGRkYgKi9cbiAgICAgIC8qIDAwMHV1dXV1IHp6enp5eXl5IHl5eHh4eHh4IHwgMTExMTB1dXUgMTB1dXp6enogMTB5eXl5eXkgMTB4eHh4eHggKi9cbiAgICAgIGlmICgoYjQgJiAweGMwKSAhPT0gMHg4MCB8fCAoYjMgJiAweGMwKSAhPT0gMHg4MCB8fCAoYjIgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICByZXR1cm4gVFJBSUxJTkc7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID1cbiAgICAgICAgKCgoKGIxICYgbWFza1szXSkgPDwgMikgKyAoKGIyID4+IDQpICYgbWFza1syXSkpIDw8IDE2KSArXG4gICAgICAgICgoYjIgJiBtYXNrWzRdKSA8PCAxMikgK1xuICAgICAgICAoKGIzICYgbWFza1s2XSkgPDwgNikgK1xuICAgICAgICAoYjQgJiBtYXNrWzZdKTtcbiAgICAgIGlmICh4IDwgMHgxMDAwMCkge1xuICAgICAgICByZXR1cm4gTk9OX1NIT1JURVNUO1xuICAgICAgfVxuICAgICAgaWYgKHggPiAweDEwZmZmZikge1xuICAgICAgICByZXR1cm4gUkFOR0U7XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgbGV0IGM7XG4gICAgbGV0IGIxO1xuICAgIGxldCBpMTtcbiAgICBsZXQgaTI7XG4gICAgbGV0IGkzO1xuICAgIGxldCBpbmM7XG4gICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgICBsZXQgaSA9IGJvbSA/IDMgOiAwO1xuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGIxID0gYnVmW2ldO1xuICAgICAgYyA9IElMTF9GT1JNRUQ7XG4gICAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgIGlmIChiMSA+PSAwICYmIGIxIDw9IDB4N2YpIHtcbiAgICAgICAgICAvKiBVKzAwMDAuLlUrMDA3RiAwMC4uN0YgKi9cbiAgICAgICAgICBjID0gYjE7XG4gICAgICAgICAgaW5jID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpMSA9IGkgKyAxO1xuICAgICAgICBpZiAoaTEgPCBsZW4gJiYgYjEgPj0gMHhjMiAmJiBiMSA8PSAweGRmKSB7XG4gICAgICAgICAgLyogVSswMDgwLi5VKzA3RkYgQzIuLkRGIDgwLi5CRiAqL1xuICAgICAgICAgIGMgPSBieXRlczIoYjEsIGJ1ZltpMV0pO1xuICAgICAgICAgIGluYyA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaTIgPSBpICsgMjtcbiAgICAgICAgaWYgKGkyIDwgbGVuICYmIGIxID49IDB4ZTAgJiYgYjEgPD0gMHhlZikge1xuICAgICAgICAgIC8qIFUrMDgwMC4uVStGRkZGICovXG4gICAgICAgICAgYyA9IGJ5dGVzMyhiMSwgYnVmW2kxXSwgYnVmW2kyXSk7XG4gICAgICAgICAgaW5jID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpMyA9IGkgKyAzO1xuICAgICAgICBpZiAoaTMgPCBsZW4gJiYgYjEgPj0gMHhmMCAmJiBiMSA8PSAweGY0KSB7XG4gICAgICAgICAgLyogVSsxMDAwMC4uVSsxMEZGRkYgKi9cbiAgICAgICAgICBjID0gYnl0ZXM0KGIxLCBidWZbaTFdLCBidWZbaTJdLCBidWZbaTNdKTtcbiAgICAgICAgICBpbmMgPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlmIHdlIGZhbGwgdGhyb3VnaCB0byBoZXJlLCBpdCBpcyBhbiBpbGwtZm9ybWVkIHNlcXVlbmNlICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGMgPiAweDEwZmZmZikge1xuICAgICAgICBjb25zdCBhdCA9IGBieXRlWyR7aX1dYDtcbiAgICAgICAgaWYgKGMgPT09IElMTF9GT1JNRUQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmOC5kZWNvZGU6IGlsbC1mb3JtZWQgVVRGOCBieXRlIHNlcXVlbmNlIGZvdW5kIGF0OiAke2F0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSBUUkFJTElORykge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGY4LmRlY29kZTogaWxsZWdhbCB0cmFpbGluZyBieXRlIGZvdW5kIGF0OiAke2F0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSBSQU5HRSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGY4LmRlY29kZTogY29kZSBwb2ludCBvdXQgb2YgcmFuZ2UgZm91bmQgYXQ6ICR7YXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IE5PTl9TSE9SVEVTVCkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGY4LmRlY29kZTogbm9uLXNob3J0ZXN0IGZvcm0gZm91bmQgYXQ6ICR7YXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjguZGVjb2RlOiB1bnJlY29nbml6ZWQgZXJyb3IgZm91bmQgYXQ6ICR7YXR9YCk7XG4gICAgICB9XG4gICAgICBjaGFycy5wdXNoKGMpO1xuICAgICAgaSArPSBpbmM7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVVEYxNkJFIGFsZ29yaXRobXMuXG5leHBvcnRzLnV0ZjE2YmUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgbGV0IGNoYXI7XG4gICAgbGV0IGg7XG4gICAgbGV0IGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgaWYgKChjaGFyID49IDAgJiYgY2hhciA8PSAweGQ3ZmYpIHx8IChjaGFyID49IDB4ZTAwMCAmJiBjaGFyIDw9IDB4ZmZmZikpIHtcbiAgICAgICAgYnl0ZXMucHVzaCgoY2hhciA+PiA4KSAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKGNoYXIgJiBtYXNrWzhdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA+PSAweDEwMDAwICYmIGNoYXIgPD0gMHgxMGZmZmYpIHtcbiAgICAgICAgbCA9IGNoYXIgLSAweDEwMDAwO1xuICAgICAgICBoID0gMHhkODAwICsgKGwgPj4gMTApO1xuICAgICAgICBsID0gMHhkYzAwICsgKGwgJiBtYXNrWzEwXSk7XG4gICAgICAgIGJ5dGVzLnB1c2goKGggPj4gOCkgJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaChoICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2goKGwgPj4gOCkgJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaChsICYgbWFza1s4XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMTZiZS5lbmNvZGU6IFVURjE2QkUgdmFsdWUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aX1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0sXG4gIGRlY29kZShidWYsIGJvbSkge1xuICAgIC8qIGFzc3VtZXMgY2FsbGVyIGhhcyBpbnN1cmVkIHRoYXQgYnVmIGlzIGEgQnVmZmVyIG9mIGJ5dGVzICovXG4gICAgaWYgKGJ1Zi5sZW5ndGggJSAyID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjE2YmUuZGVjb2RlOiBkYXRhIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgMjogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgICBsZXQgaSA9IGJvbSA/IDIgOiAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgYztcbiAgICBsZXQgaW5jO1xuICAgIGxldCBpMTtcbiAgICBsZXQgaTM7XG4gICAgbGV0IGhpZ2g7XG4gICAgbGV0IGxvdztcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgICBpMSA9IGkgKyAxO1xuICAgICAgICBpZiAoaTEgPCBsZW4pIHtcbiAgICAgICAgICBoaWdoID0gKGJ1ZltpXSA8PCA4KSArIGJ1ZltpMV07XG4gICAgICAgICAgaWYgKGhpZ2ggPCAweGQ4MDAgfHwgaGlnaCA+IDB4ZGZmZikge1xuICAgICAgICAgICAgYyA9IGhpZ2g7XG4gICAgICAgICAgICBpbmMgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkzID0gaSArIDM7XG4gICAgICAgICAgaWYgKGkzIDwgbGVuKSB7XG4gICAgICAgICAgICBsb3cgPSAoYnVmW2kgKyAyXSA8PCA4KSArIGJ1ZltpM107XG4gICAgICAgICAgICBpZiAoaGlnaCA8PSAweGRiZmYgJiYgbG93ID49IDB4ZGMwMCAmJiBsb3cgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChoaWdoIC0gMHhkODAwKSA8PCAxMCkgKyAobG93IC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgaW5jID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlmIHdlIGZhbGwgdGhyb3VnaCB0byBoZXJlLCBpdCBpcyBhbiBpbGwtZm9ybWVkIHNlcXVlbmNlICovXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYxNmJlLmRlY29kZTogaWxsLWZvcm1lZCBVVEYxNkJFIGJ5dGUgc2VxdWVuY2UgZm91bmQ6IGJ5dGVbJHtpfV1gKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzW2orK10gPSBjO1xuICAgICAgaSArPSBpbmM7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVVEYxNkxFIGFsZ29yaXRobXMuXG5leHBvcnRzLnV0ZjE2bGUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgbGV0IGNoYXI7XG4gICAgbGV0IGg7XG4gICAgbGV0IGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgaWYgKChjaGFyID49IDAgJiYgY2hhciA8PSAweGQ3ZmYpIHx8IChjaGFyID49IDB4ZTAwMCAmJiBjaGFyIDw9IDB4ZmZmZikpIHtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2goKGNoYXIgPj4gOCkgJiBtYXNrWzhdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA+PSAweDEwMDAwICYmIGNoYXIgPD0gMHgxMGZmZmYpIHtcbiAgICAgICAgbCA9IGNoYXIgLSAweDEwMDAwO1xuICAgICAgICBoID0gMHhkODAwICsgKGwgPj4gMTApO1xuICAgICAgICBsID0gMHhkYzAwICsgKGwgJiBtYXNrWzEwXSk7XG4gICAgICAgIGJ5dGVzLnB1c2goaCAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKChoID4+IDgpICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2gobCAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKChsID4+IDgpICYgbWFza1s4XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMTZsZS5lbmNvZGU6IFVURjE2TEUgdmFsdWUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aX1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0sXG4gIGRlY29kZShidWYsIGJvbSkge1xuICAgIC8qIGFzc3VtZXMgY2FsbGVyIGhhcyBpbnN1cmVkIHRoYXQgYnVmIGlzIGEgQnVmZmVyIG9mIGJ5dGVzICovXG4gICAgaWYgKGJ1Zi5sZW5ndGggJSAyID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjE2bGUuZGVjb2RlOiBkYXRhIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgMjogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgICBsZXQgaSA9IGJvbSA/IDIgOiAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgYztcbiAgICBsZXQgaW5jO1xuICAgIGxldCBpMTtcbiAgICBsZXQgaTM7XG4gICAgbGV0IGhpZ2g7XG4gICAgbGV0IGxvdztcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgICBpMSA9IGkgKyAxO1xuICAgICAgICBpZiAoaTEgPCBsZW4pIHtcbiAgICAgICAgICBoaWdoID0gKGJ1ZltpMV0gPDwgOCkgKyBidWZbaV07XG4gICAgICAgICAgaWYgKGhpZ2ggPCAweGQ4MDAgfHwgaGlnaCA+IDB4ZGZmZikge1xuICAgICAgICAgICAgYyA9IGhpZ2g7XG4gICAgICAgICAgICBpbmMgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkzID0gaSArIDM7XG4gICAgICAgICAgaWYgKGkzIDwgbGVuKSB7XG4gICAgICAgICAgICBsb3cgPSAoYnVmW2kzXSA8PCA4KSArIGJ1ZltpICsgMl07XG4gICAgICAgICAgICBpZiAoaGlnaCA8PSAweGRiZmYgJiYgbG93ID49IDB4ZGMwMCAmJiBsb3cgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChoaWdoIC0gMHhkODAwKSA8PCAxMCkgKyAobG93IC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgaW5jID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlmIHdlIGZhbGwgdGhyb3VnaCB0byBoZXJlLCBpdCBpcyBhbiBpbGwtZm9ybWVkIHNlcXVlbmNlICovXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYxNmxlLmRlY29kZTogaWxsLWZvcm1lZCBVVEYxNkxFIGJ5dGUgc2VxdWVuY2UgZm91bmQ6IGJ5dGVbJHtpfV1gKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzW2orK10gPSBjO1xuICAgICAgaSArPSBpbmM7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVVEYzMkJFIGFsZ29yaXRobXMuXG5leHBvcnRzLnV0ZjMyYmUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGggKiA0KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgaWYgKChjaGFyID49IDB4ZDgwMCAmJiBjaGFyIDw9IDB4ZGZmZikgfHwgY2hhciA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYzMmJlLmVuY29kZTogVVRGMzJCRSBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpIC8gNH1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDI0KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDE2KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDgpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gY2hhciAmIG1hc2tbOF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1ZiwgYm9tKSB7XG4gICAgLyogY2FsbGVyIHRvIGluc3VyZSBidWYgaXMgYSBCdWZmZXIgb2YgYnl0ZXMgKi9cbiAgICBpZiAoYnVmLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMzJiZS5kZWNvZGU6IFVURjMyQkUgYnl0ZSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDQ6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGxldCBpID0gYm9tID8gNCA6IDA7XG4gICAgZm9yICg7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGNvbnN0IGNoYXIgPSAoYnVmW2ldIDw8IDI0KSArIChidWZbaSArIDFdIDw8IDE2KSArIChidWZbaSArIDJdIDw8IDgpICsgYnVmW2kgKyAzXTtcbiAgICAgIGlmICgoY2hhciA+PSAweGQ4MDAgJiYgY2hhciA8PSAweGRmZmYpIHx8IGNoYXIgPiAweDEwZmZmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMzJiZS5kZWNvZGU6IFVURjMyQkUgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aSAvIDR9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgICAgY2hhcnMucHVzaChjaGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVURjMyTEUgYWxnb3JpdGhtcy5cbmV4cG9ydHMudXRmMzJsZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCAqIDQpO1xuICAgIGxldCBpID0gMDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBpZiAoKGNoYXIgPj0gMHhkODAwICYmIGNoYXIgPD0gMHhkZmZmKSB8fCBjaGFyID4gMHgxMGZmZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjMybGUuZW5jb2RlOiBVVEYzMkxFIGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2kgLyA0fV06ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICAgIGJ1ZltpKytdID0gY2hhciAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDgpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMTYpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMjQpICYgbWFza1s4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmLCBib20pIHtcbiAgICAvKiBjYWxsZXIgdG8gaW5zdXJlIGJ1ZiBpcyBhIEJ1ZmZlciBvZiBieXRlcyAqL1xuICAgIGlmIChidWYubGVuZ3RoICUgNCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYzMmJlLmRlY29kZTogVVRGMzJMRSBieXRlIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgNDogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgbGV0IGkgPSBib20gPyA0IDogMDtcbiAgICBmb3IgKDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgY29uc3QgY2hhciA9IChidWZbaSArIDNdIDw8IDI0KSArIChidWZbaSArIDJdIDw8IDE2KSArIChidWZbaSArIDFdIDw8IDgpICsgYnVmW2ldO1xuICAgICAgaWYgKChjaGFyID49IDB4ZDgwMCAmJiBjaGFyIDw9IDB4ZGZmZikgfHwgY2hhciA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYzMmxlLmVuY29kZTogVVRGMzJMRSBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpIC8gNH1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgICBjaGFycy5wdXNoKGNoYXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVUlOVDcgYWxnb3JpdGhtcy4gQVNDSUkgb3IgNy1iaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5leHBvcnRzLnVpbnQ3ID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoY2hhcnNbaV0gPiAweDdmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50Ny5lbmNvZGU6IFVJTlQ3IGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2l9XTogJHtjaGFyc1tpXX1gKTtcbiAgICAgIH1cbiAgICAgIGJ1ZltpXSA9IGNoYXJzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmKSB7XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGJ1ZltpXSA+IDB4N2YpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQ3LmRlY29kZTogVUlOVDcgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBieXRlWyR7aX1dOiAke2J1ZltpXX1gKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzW2ldID0gYnVmW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVUlOVDggYWxnb3JpdGhtcy4gQklOQVJZLCBMYXRpbiAxIG9yIDgtYml0IHVuc2lnbmVkIGludGVnZXJzLlxuZXhwb3J0cy51aW50OCA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGNoYXJzW2ldID4gMHhmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDguZW5jb2RlOiBVSU5UOCBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpfV06ICR7Y2hhcnNbaV19YCk7XG4gICAgICB9XG4gICAgICBidWZbaV0gPSBjaGFyc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNoYXJzW2ldID0gYnVmW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVUlOVDE2QkUgYWxnb3JpdGhtcy4gQmlnLWVuZGlhbiAxNi1iaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5leHBvcnRzLnVpbnQxNmJlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoICogMik7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIGlmIChjaGFyID4gMHhmZmZmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50MTZiZS5lbmNvZGU6IFVJTlQxNkJFIGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2kgLyAyfV06ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gOCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSBjaGFyICYgbWFza1s4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggJSAyID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQxNmJlLmRlY29kZTogVUlOVDE2QkUgYnl0ZSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDI6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjaGFycy5wdXNoKChidWZbaV0gPDwgOCkgKyBidWZbaSArIDFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVJTlQxNkxFIGFsZ29yaXRobXMuIExpdHRsZS1lbmRpYW4gMTYtYml0IHVuc2lnbmVkIGludGVnZXJzLlxuZXhwb3J0cy51aW50MTZsZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCAqIDIpO1xuICAgIGxldCBpID0gMDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBpZiAoY2hhciA+IDB4ZmZmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDE2bGUuZW5jb2RlOiBVSU5UMTZMRSBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpIC8gMn1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgICBidWZbaSsrXSA9IGNoYXIgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiA4KSAmIG1hc2tbOF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGlmIChidWYubGVuZ3RoICUgMiA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50MTZsZS5kZWNvZGU6IFVJTlQxNkxFIGJ5dGUgbGVuZ3RoIG11c3QgYmUgZXZlbiBtdWx0aXBsZSBvZiAyOiBsZW5ndGg6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY2hhcnMucHVzaCgoYnVmW2kgKyAxXSA8PCA4KSArIGJ1ZltpXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVSU5UMzJCRSBhbGdvcml0aG1zLiBCaWctZW5kaWFuIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cbmV4cG9ydHMudWludDMyYmUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGggKiA0KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAyNCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAxNikgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiA4KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IGNoYXIgJiBtYXNrWzhdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDMyYmUuZGVjb2RlOiBVSU5UMzJCRSBieXRlIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgNDogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGNoYXJzLnB1c2goKGJ1ZltpXSA8PCAyNCkgKyAoYnVmW2kgKyAxXSA8PCAxNikgKyAoYnVmW2kgKyAyXSA8PCA4KSArIGJ1ZltpICsgM10pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVUlOVDMyTEUgYWxnb3JpdGhtcy4gTGl0dGxlLWVuZGlhbiAzMi1iaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5leHBvcnRzLnVpbnQzMmxlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoICogNCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIGJ1ZltpKytdID0gY2hhciAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDgpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMTYpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMjQpICYgbWFza1s4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmKSB7XG4gICAgLyogY2FsbGVyIHRvIGluc3VyZSBidWYgaXMgYSBCdWZmZXIgb2YgYnl0ZXMgKi9cbiAgICBpZiAoYnVmLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDMybGUuZGVjb2RlOiBVSU5UMzJMRSBieXRlIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgNDogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGNoYXJzLnB1c2goKGJ1ZltpICsgM10gPDwgMjQpICsgKGJ1ZltpICsgMl0gPDwgMTYpICsgKGJ1ZltpICsgMV0gPDwgOCkgKyBidWZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgU1RSSU5HIGFsZ29yaXRobXMuIENvbnZlcnRzIEphdmFTY3JpcHQgc3RyaW5ncyB0byBBcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMgYW5kIHZpY2UgdmVyc2EuXG4vLyBVc2VzIHRoZSBub2RlLmpzIEJ1ZmZlcidzIG5hdGl2ZSBcInV0ZjE2bGVcIiBjYXBhYmlsaXRlcy5cbmV4cG9ydHMuc3RyaW5nID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICByZXR1cm4gZXhwb3J0cy51dGYxNmxlLmVuY29kZShjaGFycykudG9TdHJpbmcoJ3V0ZjE2bGUnKTtcbiAgfSxcbiAgZGVjb2RlKHN0cikge1xuICAgIHJldHVybiBleHBvcnRzLnV0ZjE2bGUuZGVjb2RlKEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjE2bGUnKSwgMCk7XG4gIH0sXG59O1xuXG4vLyBUaGUgRVNDQVBFRCBhbGdvcml0aG1zLlxuLy8gTm90ZSB0aGF0IEVTQ0FQRUQgZm9ybWF0IGNvbnRhaW5zIG9ubHkgQVNDSUkgY2hhcmFjdGVycy5cbi8vIFRoZSBjaGFyYWN0ZXJzIGFyZSBhbHdheXMgaW4gdGhlIGZvcm0gb2YgYSBCdWZmZXIgb2YgYnl0ZXMuXG5leHBvcnRzLmVzY2FwZWQgPSB7XG4gIC8vIEVuY29kZXMgYW4gQXJyYXkgb2YgMzItYml0IGludGVnZXJzIGludG8gRVNDQVBFRCBmb3JtYXQuXG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgaWYgKGNoYXIgPT09IDk2KSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhcik7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhcik7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IDEwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhcik7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMzIgJiYgY2hhciA8PSAxMjYpIHtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgICAgaWYgKGNoYXIgPj0gMCAmJiBjaGFyIDw9IDMxKSB7XG4gICAgICAgICAgc3RyICs9IGBcXGB4JHthc2NpaVtjaGFyXX1gO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMTI3ICYmIGNoYXIgPD0gMjU1KSB7XG4gICAgICAgICAgc3RyICs9IGBcXGB4JHthc2NpaVtjaGFyXX1gO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMHgxMDAgJiYgY2hhciA8PSAweGZmZmYpIHtcbiAgICAgICAgICBzdHIgKz0gYFxcYHUke2FzY2lpWyhjaGFyID4+IDgpICYgbWFza1s4XV19JHthc2NpaVtjaGFyICYgbWFza1s4XV19YDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID49IDB4MTAwMDAgJiYgY2hhciA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgc3RyICs9ICdgdXsnO1xuICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gKGNoYXIgPj4gMjQpICYgbWFza1s4XTtcbiAgICAgICAgICBpZiAoZGlnaXQgPiAwKSB7XG4gICAgICAgICAgICBzdHIgKz0gYXNjaWlbZGlnaXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gYCR7YXNjaWlbKGNoYXIgPj4gMTYpICYgbWFza1s4XV0gKyBhc2NpaVsoY2hhciA+PiA4KSAmIG1hc2tbOF1dICsgYXNjaWlbY2hhciAmIG1hc2tbOF1dfX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlLmVuY29kZShjaGFyKTogY2hhciA+IDB4ZmZmZmZmZmYgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShzdHIpO1xuICAgICAgICBidWYuZm9yRWFjaCgoYikgPT4ge1xuICAgICAgICAgIGJ5dGVzLnB1c2goYik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9LFxuICAvLyBEZWNvZGVzIEVTQ0FQRUQgZm9ybWF0IGZyb20gYSBCdWZmZXIgb2YgYnl0ZXMgdG8gYW4gQXJyYXkgb2YgMzItYml0IGludGVnZXJzLlxuICBkZWNvZGUoYnVmKSB7XG4gICAgZnVuY3Rpb24gaXNIZXgoaGV4KSB7XG4gICAgICBpZiAoKGhleCA+PSA0OCAmJiBoZXggPD0gNTcpIHx8IChoZXggPj0gNjUgJiYgaGV4IDw9IDcwKSB8fCAoaGV4ID49IDk3ICYmIGhleCA8PSAxMDIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXR4KGksIGxlbiwgYnVmQXJnKSB7XG4gICAgICBjb25zdCByZXQgPSB7IGNoYXI6IG51bGwsIG5leHRpOiBpICsgMiwgZXJyb3I6IHRydWUgfTtcbiAgICAgIGlmIChpICsgMSA8IGxlbikge1xuICAgICAgICBpZiAoaXNIZXgoYnVmQXJnW2ldKSAmJiBpc0hleChidWZBcmdbaSArIDFdKSkge1xuICAgICAgICAgIGNvbnN0IHN0ciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGJ1ZkFyZ1tpXSwgYnVmQXJnW2kgKyAxXSk7XG4gICAgICAgICAgcmV0LmNoYXIgPSBwYXJzZUludChzdHIsIDE2KTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihyZXQuY2hhcikpIHtcbiAgICAgICAgICAgIHJldC5lcnJvciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0dShpLCBsZW4sIGJ1ZkFyZykge1xuICAgICAgY29uc3QgcmV0ID0geyBjaGFyOiBudWxsLCBuZXh0aTogaSArIDQsIGVycm9yOiB0cnVlIH07XG4gICAgICBpZiAoaSArIDMgPCBsZW4pIHtcbiAgICAgICAgaWYgKGlzSGV4KGJ1ZkFyZ1tpXSkgJiYgaXNIZXgoYnVmQXJnW2kgKyAxXSkgJiYgaXNIZXgoYnVmQXJnW2kgKyAyXSkgJiYgaXNIZXgoYnVmQXJnW2kgKyAzXSkpIHtcbiAgICAgICAgICBjb25zdCBzdHIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChidWZBcmdbaV0sIGJ1ZkFyZ1tpICsgMV0sIGJ1ZkFyZ1tpICsgMl0sIGJ1ZkFyZ1tpICsgM10pO1xuICAgICAgICAgIHJldC5jaGFyID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocmV0LmNoYXIpKSB7XG4gICAgICAgICAgICByZXQuZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFUoaSwgbGVuLCBidWZBcmcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHsgY2hhcjogbnVsbCwgbmV4dGk6IGkgKyA0LCBlcnJvcjogdHJ1ZSB9O1xuICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgaXNIZXgoYnVmQXJnW2ldKSkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYnVmQXJnW2ldKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICAgIHJldC5jaGFyID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gICAgICBpZiAoYnVmQXJnW2ldID09PSAxMjUgJiYgIU51bWJlci5pc05hTihyZXQuY2hhcikpIHtcbiAgICAgICAgcmV0LmVycm9yID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXQubmV4dGkgPSBpICsgMTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgICBsZXQgaTE7XG4gICAgbGV0IHJldDtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGJ1ZltpXSAhPT0gOTYpIHtcbiAgICAgICAgICAvKiB1bmVzY2FwZWQgY2hhcmFjdGVyICovXG4gICAgICAgICAgY2hhcnMucHVzaChidWZbaV0pO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkxID0gaSArIDE7XG4gICAgICAgIGlmIChpMSA+PSBsZW4pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmW2kxXSA9PT0gOTYpIHtcbiAgICAgICAgICAvKiBlc2NhcGVkIGdyYXZlIGFjY2VudCAqL1xuICAgICAgICAgIGNoYXJzLnB1c2goOTYpO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZbaTFdID09PSAxMjApIHtcbiAgICAgICAgICByZXQgPSBnZXR4KGkxICsgMSwgbGVuLCBidWYpO1xuICAgICAgICAgIGlmIChyZXQuZXJyb3IpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBlc2NhcGVkIGhleCAqL1xuICAgICAgICAgIGNoYXJzLnB1c2gocmV0LmNoYXIpO1xuICAgICAgICAgIGkgPSByZXQubmV4dGk7XG4gICAgICAgICAgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmW2kxXSA9PT0gMTE3KSB7XG4gICAgICAgICAgaWYgKGJ1ZltpMSArIDFdID09PSAxMjMpIHtcbiAgICAgICAgICAgIHJldCA9IGdldFUoaTEgKyAyLCBsZW4sIGJ1Zik7XG4gICAgICAgICAgICBpZiAocmV0LmVycm9yKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZXNjYXBlZCB1dGYtMzIgKi9cbiAgICAgICAgICAgIGNoYXJzLnB1c2gocmV0LmNoYXIpO1xuICAgICAgICAgICAgaSA9IHJldC5uZXh0aTtcbiAgICAgICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0ID0gZ2V0dShpMSArIDEsIGxlbiwgYnVmKTtcbiAgICAgICAgICBpZiAocmV0LmVycm9yKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogZXNjYXBlZCB1dGYtMTYgKi9cbiAgICAgICAgICBjaGFycy5wdXNoKHJldC5jaGFyKTtcbiAgICAgICAgICBpID0gcmV0Lm5leHRpO1xuICAgICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlc2NhcGVkLmRlY29kZTogaWxsLWZvcm1lZCBlc2NhcGUgc2VxdWVuY2UgYXQgYnVmWyR7aX1dYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBsaW5lIGVuZCBjb252ZXJzaW9uIGFsZ29yaWd0aG1zLlxuY29uc3QgQ1IgPSAxMztcbmNvbnN0IExGID0gMTA7XG5leHBvcnRzLmxpbmVFbmRzID0ge1xuICBjcmxmKGNoYXJzKSB7XG4gICAgY29uc3QgbGZjaGFycyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNoYXJzLmxlbmd0aCkge1xuICAgICAgc3dpdGNoIChjaGFyc1tpXSkge1xuICAgICAgICBjYXNlIENSOlxuICAgICAgICAgIGlmIChpICsgMSA8IGNoYXJzLmxlbmd0aCAmJiBjaGFyc1tpICsgMV0gPT09IExGKSB7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGZjaGFycy5wdXNoKENSKTtcbiAgICAgICAgICBsZmNoYXJzLnB1c2goTEYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExGOlxuICAgICAgICAgIGxmY2hhcnMucHVzaChDUik7XG4gICAgICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGZjaGFycy5wdXNoKGNoYXJzW2ldKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZmNoYXJzLmxlbmd0aCA+IDAgJiYgbGZjaGFyc1tsZmNoYXJzLmxlbmd0aCAtIDFdICE9PSBMRikge1xuICAgICAgbGZjaGFycy5wdXNoKENSKTtcbiAgICAgIGxmY2hhcnMucHVzaChMRik7XG4gICAgfVxuICAgIHJldHVybiBsZmNoYXJzO1xuICB9LFxuICBsZihjaGFycykge1xuICAgIGNvbnN0IGxmY2hhcnMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFycy5sZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAoY2hhcnNbaV0pIHtcbiAgICAgICAgY2FzZSBDUjpcbiAgICAgICAgICBpZiAoaSArIDEgPCBjaGFycy5sZW5ndGggJiYgY2hhcnNbaSArIDFdID09PSBMRikge1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxmY2hhcnMucHVzaChMRik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTEY6XG4gICAgICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbGZjaGFycy5wdXNoKGNoYXJzW2ldKTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZmNoYXJzLmxlbmd0aCA+IDAgJiYgbGZjaGFyc1tsZmNoYXJzLmxlbmd0aCAtIDFdICE9PSBMRikge1xuICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICB9XG4gICAgcmV0dXJuIGxmY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgYmFzZSA2NCBhbGdvcml0aG1zLlxuZXhwb3J0cy5iYXNlNjQgPSB7XG4gIGVuY29kZShidWYpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IG47XG4gICAgbGV0IHRhaWwgPSBidWYubGVuZ3RoICUgMztcbiAgICB0YWlsID0gdGFpbCA+IDAgPyAzIC0gdGFpbCA6IDA7XG4gICAgbGV0IHVuaXRzID0gKGJ1Zi5sZW5ndGggKyB0YWlsKSAvIDM7XG4gICAgY29uc3QgYmFzZTY0ID0gQnVmZmVyLmFsbG9jKHVuaXRzICogNCk7XG4gICAgaWYgKHRhaWwgPiAwKSB7XG4gICAgICB1bml0cyAtPSAxO1xuICAgIH1cbiAgICBpID0gMDtcbiAgICBqID0gMDtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHVuaXRzOyB1ICs9IDEpIHtcbiAgICAgIG4gPSBidWZbaSsrXSA8PCAxNjtcbiAgICAgIG4gKz0gYnVmW2krK10gPDwgODtcbiAgICAgIG4gKz0gYnVmW2krK107XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDE4KSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxMikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gNikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbbiAmIG1hc2tbNl1dO1xuICAgIH1cbiAgICBpZiAodGFpbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICB9XG4gICAgaWYgKHRhaWwgPT09IDEpIHtcbiAgICAgIG4gPSBidWZbaSsrXSA8PCAxNjtcbiAgICAgIG4gKz0gYnVmW2ldIDw8IDg7XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDE4KSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxMikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gNikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqXSA9IGJhc2U2NGNvZGVzWzY0XTtcbiAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIGlmICh0YWlsID09PSAyKSB7XG4gICAgICBuID0gYnVmW2ldIDw8IDE2O1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxOCkgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gMTIpICYgbWFza1s2XV07XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWzY0XTtcbiAgICAgIGJhc2U2NFtqXSA9IGJhc2U2NGNvZGVzWzY0XTtcbiAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sXG4gIGRlY29kZShjb2Rlcykge1xuICAgIC8qIHJlbW92ZSB3aGl0ZSBzcGFjZSBhbmQgY3RybCBjaGFyYWN0ZXJzLCB2YWxpZGF0ZSAmIHRyYW5zbGF0ZSBjaGFyYWN0ZXJzICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoYnVmKSB7XG4gICAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgICAgbGV0IHRhaWwgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hhciA9IGJ1ZltpXTtcbiAgICAgICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgICAgaWYgKGNoYXIgPT09IDMyIHx8IGNoYXIgPT09IDkgfHwgY2hhciA9PT0gMTAgfHwgY2hhciA9PT0gMTMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA+PSA2NSAmJiBjaGFyIDw9IDkwKSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKGNoYXIgLSA2NSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPj0gOTcgJiYgY2hhciA8PSAxMjIpIHtcbiAgICAgICAgICAgIGNoYXJzLnB1c2goY2hhciAtIDcxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA+PSA0OCAmJiBjaGFyIDw9IDU3KSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKGNoYXIgKyA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA9PT0gNDMpIHtcbiAgICAgICAgICAgIGNoYXJzLnB1c2goNjIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyID09PSA0Nykge1xuICAgICAgICAgICAgY2hhcnMucHVzaCg2Myk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPT09IDYxKSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKDY0KTtcbiAgICAgICAgICAgIHRhaWwgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBpbnZhbGlkIGNoYXJhY3RlciAqL1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBiYXNlNjQuZGVjb2RlOiBpbnZhbGlkIGNoYXJhY3RlciBidWZbJHtpfV06ICR7Y2hhcn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogdmFsaWRhdGUgbGVuZ3RoICovXG4gICAgICBpZiAoY2hhcnMubGVuZ3RoICUgNCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGJhc2U2NC5kZWNvZGU6IHN0cmluZyBsZW5ndGggbm90IGludGVncmFsIG11bHRpcGxlIG9mIDQ6ICR7Y2hhcnMubGVuZ3RofWApO1xuICAgICAgfVxuICAgICAgLyogdmFsaWRhdGUgdGFpbCAqL1xuICAgICAgc3dpdGNoICh0YWlsKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChjaGFyc1tjaGFycy5sZW5ndGggLSAxXSAhPT0gNjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdiYXNlNjQuZGVjb2RlOiBvbmUgdGFpbCBjaGFyYWN0ZXIgZm91bmQ6IG5vdCBsYXN0IGNoYXJhY3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmIChjaGFyc1tjaGFycy5sZW5ndGggLSAxXSAhPT0gNjQgfHwgY2hhcnNbY2hhcnMubGVuZ3RoIC0gMl0gIT09IDY0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYmFzZTY0LmRlY29kZTogdHdvIHRhaWwgY2hhcmFjdGVycyBmb3VuZDogbm90IGxhc3QgY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgYmFzZTY0LmRlY29kZTogbW9yZSB0aGFuIHR3byB0YWlsIGNoYXJhY3RlcnMgZm91bmQ6ICR7dGFpbH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHRhaWwsIGJ1ZjogQnVmZmVyLmZyb20oY2hhcnMpIH07XG4gICAgfVxuXG4gICAgaWYgKGNvZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gdmFsaWRhdGUoY29kZXMpO1xuICAgIGNvbnN0IHsgdGFpbCB9ID0gdmFsO1xuICAgIGNvbnN0IGJhc2U2NCA9IHZhbC5idWY7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IG47XG4gICAgbGV0IHVuaXRzID0gYmFzZTY0Lmxlbmd0aCAvIDQ7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKHVuaXRzICogMyAtIHRhaWwpO1xuICAgIGlmICh0YWlsID4gMCkge1xuICAgICAgdW5pdHMgLT0gMTtcbiAgICB9XG4gICAgaiA9IDA7XG4gICAgaSA9IDA7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1bml0czsgdSArPSAxKSB7XG4gICAgICBuID0gYmFzZTY0W2krK10gPDwgMTg7XG4gICAgICBuICs9IGJhc2U2NFtpKytdIDw8IDEyO1xuICAgICAgbiArPSBiYXNlNjRbaSsrXSA8PCA2O1xuICAgICAgbiArPSBiYXNlNjRbaSsrXTtcbiAgICAgIGJ1ZltqKytdID0gKG4gPj4gMTYpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltqKytdID0gKG4gPj4gOCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2orK10gPSBuICYgbWFza1s4XTtcbiAgICB9XG4gICAgaWYgKHRhaWwgPT09IDEpIHtcbiAgICAgIG4gPSBiYXNlNjRbaSsrXSA8PCAxODtcbiAgICAgIG4gKz0gYmFzZTY0W2krK10gPDwgMTI7XG4gICAgICBuICs9IGJhc2U2NFtpXSA8PCA2O1xuICAgICAgYnVmW2orK10gPSAobiA+PiAxNikgJiBtYXNrWzhdO1xuICAgICAgYnVmW2pdID0gKG4gPj4gOCkgJiBtYXNrWzhdO1xuICAgIH1cbiAgICBpZiAodGFpbCA9PT0gMikge1xuICAgICAgbiA9IGJhc2U2NFtpKytdIDw8IDE4O1xuICAgICAgbiArPSBiYXNlNjRbaSsrXSA8PCAxMjtcbiAgICAgIGJ1ZltqXSA9IChuID4+IDE2KSAmIG1hc2tbOF07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIC8vIENvbnZlcnRzIGEgYmFzZSA2NCBCdWZmZXIgb2YgYnl0ZXMgdG8gYSBKYXZhU2NyaXB0IHN0cmluZyB3aXRoIGxpbmUgYnJlYWtzLlxuICB0b1N0cmluZyhidWYpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCAlIDQgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgYmFzZTY0LnRvU3RyaW5nOiBpbnB1dCBidWZmZXIgbGVuZ3RoIG5vdCBtdWx0aXBsZSBvZiA0OiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgbGluZUxlbiA9IDA7XG4gICAgZnVuY3Rpb24gYnVpbGRMaW5lKGMxLCBjMiwgYzMsIGM0KSB7XG4gICAgICBzd2l0Y2ggKGxpbmVMZW4pIHtcbiAgICAgICAgY2FzZSA3NjpcbiAgICAgICAgICBzdHIgKz0gYFxcclxcbiR7YzF9JHtjMn0ke2MzfSR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3NTpcbiAgICAgICAgICBzdHIgKz0gYCR7YzF9XFxyXFxuJHtjMn0ke2MzfSR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3NDpcbiAgICAgICAgICBzdHIgKz0gYCR7YzEgKyBjMn1cXHJcXG4ke2MzfSR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3MzpcbiAgICAgICAgICBzdHIgKz0gYCR7YzEgKyBjMiArIGMzfVxcclxcbiR7YzR9YDtcbiAgICAgICAgICBsaW5lTGVuID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdHIgKz0gYzEgKyBjMiArIGMzICsgYzQ7XG4gICAgICAgICAgbGluZUxlbiArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShjKSB7XG4gICAgICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDQzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDQ3KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDYxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBpICsgNDsgaiArPSAxKSB7XG4gICAgICAgIGlmICghdmFsaWRhdGUoYnVmW2pdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBiYXNlNjQudG9TdHJpbmc6IGJ1Zlske2p9XTogJHtidWZbal19IDogbm90IHZhbGlkIGJhc2U2NCBjaGFyYWN0ZXIgY29kZWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWlsZExpbmUoXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaSArIDFdKSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaSArIDJdKSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaSArIDNdKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSxcbn07XG4iXSwibmFtZXMiOlsiQnVmZmVyIiwicmVxdWlyZSIsIk5PTl9TSE9SVEVTVCIsIlRSQUlMSU5HIiwiUkFOR0UiLCJJTExfRk9STUVEIiwibWFzayIsImFzY2lpIiwiYmFzZTY0Y2hhcnMiLCJzcGxpdCIsImJhc2U2NGNvZGVzIiwiZm9yRWFjaCIsImNoYXIiLCJwdXNoIiwiY2hhckNvZGVBdCIsImV4cG9ydHMiLCJ1dGY4IiwiZW5jb2RlIiwiY2hhcnMiLCJieXRlcyIsInUiLCJSYW5nZUVycm9yIiwiZnJvbSIsImRlY29kZSIsImJ1ZiIsImJvbSIsImJ5dGVzMiIsImIxIiwiYjIiLCJ4IiwiYnl0ZXMzIiwiYjMiLCJieXRlczQiLCJiNCIsImMiLCJpMSIsImkyIiwiaTMiLCJpbmMiLCJsZW4iLCJsZW5ndGgiLCJpIiwiVFJVRSIsImF0IiwidXRmMTZiZSIsImgiLCJsIiwiaiIsImhpZ2giLCJsb3ciLCJ1dGYxNmxlIiwidXRmMzJiZSIsImFsbG9jIiwidXRmMzJsZSIsInVpbnQ3IiwidWludDgiLCJ1aW50MTZiZSIsInVpbnQxNmxlIiwidWludDMyYmUiLCJ1aW50MzJsZSIsInN0cmluZyIsInRvU3RyaW5nIiwic3RyIiwiZXNjYXBlZCIsImRpZ2l0IiwiRXJyb3IiLCJiIiwiaXNIZXgiLCJoZXgiLCJnZXR4IiwiYnVmQXJnIiwicmV0IiwibmV4dGkiLCJlcnJvciIsIlN0cmluZyIsImZyb21Db2RlUG9pbnQiLCJwYXJzZUludCIsIk51bWJlciIsImlzTmFOIiwiZ2V0dSIsImdldFUiLCJDUiIsIkxGIiwibGluZUVuZHMiLCJjcmxmIiwibGZjaGFycyIsImxmIiwiYmFzZTY0IiwibiIsInRhaWwiLCJ1bml0cyIsInVuZGVmaW5lZCIsImNvZGVzIiwidmFsaWRhdGUiLCJ2YWwiLCJsaW5lTGVuIiwiYnVpbGRMaW5lIiwiYzEiLCJjMiIsImMzIiwiYzQiLCJmcm9tQ2hhckNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/transformers.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/ast.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/ast.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint-disable guard-for-in */ /* eslint-disable no-restricted-syntax */ /*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module is used by the parser to build an [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST).\n// The AST can be thought of as a subset of the full parse tree.\n// Each node of the AST holds the phrase that was matched at the corresponding, named parse tree node.\n// It is built as the parser successfully matches phrases to the rule names\n// (`RNM` operators) and `UDT`s as it parses an input string.\n// The user controls which `RNM` or `UDT` names to keep on the AST.\n// The user can also associate callback functions with some or all of the retained\n// AST nodes to be used to translate the node phrases. That is, associate semantic\n// actions to the matched phrases.\n// Translating the AST rather that attempting to apply semantic actions during\n// the parsing process, has the advantage that there is no backtracking and that the phrases\n// are known while traversing down tree as will as up.\n//\n// Let `ast` be an `ast.js` object. To identify a node to be kept on the AST:\n// ```\n// ast.callbacks[\"rulename\"] = true; (all nodes default to false)\n// ```\n// To associate a callback function with a node:\n// ```\n// ast.callbacks[\"rulename\"] = fn\n// ```\n// `rulename` is any `RNM` or `UDT` name defined by the associated grammar\n// and `fn` is a user-written callback function.\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js2-examples/tree/master/ast) for examples of how to create an AST,\n// define the nodes and callback functions and attach it to a parser.)\n\nmodule.exports = function exportsAst() {\n    const id = __webpack_require__(/*! ./identifiers */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n    const utils = __webpack_require__(/*! ./utilities */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\");\n    const thisFileName = \"ast.js: \";\n    const that = this;\n    let rules = null;\n    let udts = null;\n    let chars = null;\n    let nodeCount = 0;\n    const nodesDefined = [];\n    const nodeCallbacks = [];\n    const stack = [];\n    const records = [];\n    this.callbacks = [];\n    this.astObject = \"astObject\";\n    /* called by the parser to initialize the AST with the rules, UDTs and the input characters */ this.init = function init(rulesIn, udtsIn, charsIn) {\n        stack.length = 0;\n        records.length = 0;\n        nodesDefined.length = 0;\n        nodeCount = 0;\n        rules = rulesIn;\n        udts = udtsIn;\n        chars = charsIn;\n        let i;\n        const list = [];\n        for(i = 0; i < rules.length; i += 1){\n            list.push(rules[i].lower);\n        }\n        for(i = 0; i < udts.length; i += 1){\n            list.push(udts[i].lower);\n        }\n        nodeCount = rules.length + udts.length;\n        for(i = 0; i < nodeCount; i += 1){\n            nodesDefined[i] = false;\n            nodeCallbacks[i] = null;\n        }\n        for(const index in that.callbacks){\n            const lower = index.toLowerCase();\n            i = list.indexOf(lower);\n            if (i < 0) {\n                throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);\n            }\n            if (typeof that.callbacks[index] === \"function\") {\n                nodesDefined[i] = true;\n                nodeCallbacks[i] = that.callbacks[index];\n            }\n            if (that.callbacks[index] === true) {\n                nodesDefined[i] = true;\n            }\n        }\n    };\n    /* AST node definitions - called by the parser's `RNM` operator */ this.ruleDefined = function ruleDefined(index) {\n        return nodesDefined[index] !== false;\n    };\n    /* AST node definitions - called by the parser's `UDT` operator */ this.udtDefined = function udtDefined(index) {\n        return nodesDefined[rules.length + index] !== false;\n    };\n    /* called by the parser's `RNM` & `UDT` operators */ /* builds a record for the downward traversal of the node */ this.down = function down(callbackIndex, name) {\n        const thisIndex = records.length;\n        stack.push(thisIndex);\n        records.push({\n            name,\n            thisIndex,\n            thatIndex: null,\n            state: id.SEM_PRE,\n            callbackIndex,\n            phraseIndex: null,\n            phraseLength: null,\n            stack: stack.length\n        });\n        return thisIndex;\n    };\n    /* called by the parser's `RNM` & `UDT` operators */ /* builds a record for the upward traversal of the node */ this.up = function up(callbackIndex, name, phraseIndex, phraseLength) {\n        const thisIndex = records.length;\n        const thatIndex = stack.pop();\n        records.push({\n            name,\n            thisIndex,\n            thatIndex,\n            state: id.SEM_POST,\n            callbackIndex,\n            phraseIndex,\n            phraseLength,\n            stack: stack.length\n        });\n        records[thatIndex].thatIndex = thisIndex;\n        records[thatIndex].phraseIndex = phraseIndex;\n        records[thatIndex].phraseLength = phraseLength;\n        return thisIndex;\n    };\n    // Called by the user to translate the AST.\n    // Translate means to associate or apply some semantic action to the\n    // phrases that were syntactically matched to the AST nodes according\n    // to the defining grammar.\n    // ```\n    // data - optional user-defined data\n    //        passed to the callback functions by the translator\n    // ```\n    this.translate = function translate(data) {\n        let ret;\n        let callback;\n        let record;\n        for(let i = 0; i < records.length; i += 1){\n            record = records[i];\n            callback = nodeCallbacks[record.callbackIndex];\n            if (record.state === id.SEM_PRE) {\n                if (callback !== null) {\n                    ret = callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);\n                    if (ret === id.SEM_SKIP) {\n                        i = record.thatIndex;\n                    }\n                }\n            } else if (callback !== null) {\n                callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);\n            }\n        }\n    };\n    /* called by the parser to reset the length of the records array */ /* necessary on backtracking */ this.setLength = function setLength(length) {\n        records.length = length;\n        if (length > 0) {\n            stack.length = records[length - 1].stack;\n        } else {\n            stack.length = 0;\n        }\n    };\n    /* called by the parser to get the length of the records array */ this.getLength = function getLength() {\n        return records.length;\n    };\n    /* helper for XML display */ function indent(n) {\n        let ret = \"\";\n        for(let i = 0; i < n; i += 1){\n            ret += \" \";\n        }\n        return ret;\n    }\n    // Generate an `XML` version of the AST.\n    // Useful if you want to use a special or favorite XML parser to translate the\n    // AST.\n    // ```\n    // mode - the display mode of the captured phrases\n    //      - default mode is \"ascii\"\n    //      - can be: \"ascii\"\n    //                \"decimal\"\n    //                \"hexadecimal\"\n    //                \"unicode\"\n    // ```\n    this.toXml = function toSml(modeArg) {\n        let display = utils.charsToDec;\n        let caption = \"decimal integer character codes\";\n        if (typeof modeArg === \"string\" && modeArg.length >= 3) {\n            const mode = modeArg.slice(0, 3).toLowerCase();\n            if (mode === \"asc\") {\n                display = utils.charsToAscii;\n                caption = \"ASCII for printing characters, hex for non-printing\";\n            } else if (mode === \"hex\") {\n                display = utils.charsToHex;\n                caption = \"hexadecimal integer character codes\";\n            } else if (mode === \"uni\") {\n                display = utils.charsToUnicode;\n                caption = \"Unicode UTF-32 integer character codes\";\n            }\n        }\n        let xml = \"\";\n        let depth = 0;\n        xml += '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n        xml += `<root nodes=\"${records.length / 2}\" characters=\"${chars.length}\">\\n`;\n        xml += `<!-- input string, ${caption} -->\\n`;\n        xml += indent(depth + 2);\n        xml += display(chars);\n        xml += \"\\n\";\n        records.forEach((rec)=>{\n            if (rec.state === id.SEM_PRE) {\n                depth += 1;\n                xml += indent(depth);\n                xml += `<node name=\"${rec.name}\" index=\"${rec.phraseIndex}\" length=\"${rec.phraseLength}\">\\n`;\n                xml += indent(depth + 2);\n                xml += display(chars, rec.phraseIndex, rec.phraseLength);\n                xml += \"\\n\";\n            } else {\n                xml += indent(depth);\n                xml += `</node><!-- name=\"${rec.name}\" -->\\n`;\n                depth -= 1;\n            }\n        });\n        xml += \"</root>\\n\";\n        return xml;\n    };\n    /* generate a JavaScript object version of the AST */ /* for the phrase-matching engine apg-exp */ this.phrases = function phrases() {\n        const obj = {};\n        let i;\n        let record;\n        for(i = 0; i < records.length; i += 1){\n            record = records[i];\n            if (record.state === id.SEM_PRE) {\n                if (!Array.isArray(obj[record.name])) {\n                    obj[record.name] = [];\n                }\n                obj[record.name].push({\n                    index: record.phraseIndex,\n                    length: record.phraseLength\n                });\n            }\n        }\n        return obj;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2FzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrQkFBK0IsR0FDL0IsdUNBQXVDLEdBQ3ZDOzs7dUZBR3VGLEdBQ3ZGLGtJQUFrSTtBQUNsSSxnRUFBZ0U7QUFDaEUsc0dBQXNHO0FBQ3RHLDJFQUEyRTtBQUMzRSw2REFBNkQ7QUFDN0QsbUVBQW1FO0FBQ25FLGtGQUFrRjtBQUNsRixrRkFBa0Y7QUFDbEYsa0NBQWtDO0FBQ2xDLDhFQUE4RTtBQUM5RSw0RkFBNEY7QUFDNUYsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiw2RUFBNkU7QUFDN0UsTUFBTTtBQUNOLGlFQUFpRTtBQUNqRSxNQUFNO0FBQ04sZ0RBQWdEO0FBQ2hELE1BQU07QUFDTixpQ0FBaUM7QUFDakMsTUFBTTtBQUNOLDBFQUEwRTtBQUMxRSxnREFBZ0Q7QUFDaEQsNEhBQTRIO0FBQzVILHNFQUFzRTs7QUFDdEVBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQztJQUN4QixNQUFNQyxLQUFLQyxtQkFBT0EsQ0FBQztJQUNuQixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQztJQUV0QixNQUFNRSxlQUFlO0lBQ3JCLE1BQU1DLE9BQU8sSUFBSTtJQUNqQixJQUFJQyxRQUFRO0lBQ1osSUFBSUMsT0FBTztJQUNYLElBQUlDLFFBQVE7SUFDWixJQUFJQyxZQUFZO0lBQ2hCLE1BQU1DLGVBQWUsRUFBRTtJQUN2QixNQUFNQyxnQkFBZ0IsRUFBRTtJQUN4QixNQUFNQyxRQUFRLEVBQUU7SUFDaEIsTUFBTUMsVUFBVSxFQUFFO0lBQ2xCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLEVBQUU7SUFDbkIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDakIsNEZBQTRGLEdBQzVGLElBQUksQ0FBQ0MsSUFBSSxHQUFHLFNBQVNBLEtBQUtDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxPQUFPO1FBQ2hEUCxNQUFN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Q3ZCO2dCQUNBb0MsR0FBRyxDQUFDdEIsT0FBT2QsSUFBSSxDQUFDLENBQUNWLElBQUksQ0FBQztvQkFDcEJFLE9BQU9zQixPQUFPVCxXQUFXO29CQUN6QmxCLFFBQVEyQixPQUFPUixZQUFZO2dCQUM3QjtZQUNGO1FBQ0Y7UUFDQSxPQUFPOEI7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvYXN0LmpzPzgzMDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgaXMgdXNlZCBieSB0aGUgcGFyc2VyIHRvIGJ1aWxkIGFuIFtBYnN0cmFjdCBTeW50YXggVHJlZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWJzdHJhY3Rfc3ludGF4X3RyZWUpIChBU1QpLlxuLy8gVGhlIEFTVCBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIHN1YnNldCBvZiB0aGUgZnVsbCBwYXJzZSB0cmVlLlxuLy8gRWFjaCBub2RlIG9mIHRoZSBBU1QgaG9sZHMgdGhlIHBocmFzZSB0aGF0IHdhcyBtYXRjaGVkIGF0IHRoZSBjb3JyZXNwb25kaW5nLCBuYW1lZCBwYXJzZSB0cmVlIG5vZGUuXG4vLyBJdCBpcyBidWlsdCBhcyB0aGUgcGFyc2VyIHN1Y2Nlc3NmdWxseSBtYXRjaGVzIHBocmFzZXMgdG8gdGhlIHJ1bGUgbmFtZXNcbi8vIChgUk5NYCBvcGVyYXRvcnMpIGFuZCBgVURUYHMgYXMgaXQgcGFyc2VzIGFuIGlucHV0IHN0cmluZy5cbi8vIFRoZSB1c2VyIGNvbnRyb2xzIHdoaWNoIGBSTk1gIG9yIGBVRFRgIG5hbWVzIHRvIGtlZXAgb24gdGhlIEFTVC5cbi8vIFRoZSB1c2VyIGNhbiBhbHNvIGFzc29jaWF0ZSBjYWxsYmFjayBmdW5jdGlvbnMgd2l0aCBzb21lIG9yIGFsbCBvZiB0aGUgcmV0YWluZWRcbi8vIEFTVCBub2RlcyB0byBiZSB1c2VkIHRvIHRyYW5zbGF0ZSB0aGUgbm9kZSBwaHJhc2VzLiBUaGF0IGlzLCBhc3NvY2lhdGUgc2VtYW50aWNcbi8vIGFjdGlvbnMgdG8gdGhlIG1hdGNoZWQgcGhyYXNlcy5cbi8vIFRyYW5zbGF0aW5nIHRoZSBBU1QgcmF0aGVyIHRoYXQgYXR0ZW1wdGluZyB0byBhcHBseSBzZW1hbnRpYyBhY3Rpb25zIGR1cmluZ1xuLy8gdGhlIHBhcnNpbmcgcHJvY2VzcywgaGFzIHRoZSBhZHZhbnRhZ2UgdGhhdCB0aGVyZSBpcyBubyBiYWNrdHJhY2tpbmcgYW5kIHRoYXQgdGhlIHBocmFzZXNcbi8vIGFyZSBrbm93biB3aGlsZSB0cmF2ZXJzaW5nIGRvd24gdHJlZSBhcyB3aWxsIGFzIHVwLlxuLy9cbi8vIExldCBgYXN0YCBiZSBhbiBgYXN0LmpzYCBvYmplY3QuIFRvIGlkZW50aWZ5IGEgbm9kZSB0byBiZSBrZXB0IG9uIHRoZSBBU1Q6XG4vLyBgYGBcbi8vIGFzdC5jYWxsYmFja3NbXCJydWxlbmFtZVwiXSA9IHRydWU7IChhbGwgbm9kZXMgZGVmYXVsdCB0byBmYWxzZSlcbi8vIGBgYFxuLy8gVG8gYXNzb2NpYXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIG5vZGU6XG4vLyBgYGBcbi8vIGFzdC5jYWxsYmFja3NbXCJydWxlbmFtZVwiXSA9IGZuXG4vLyBgYGBcbi8vIGBydWxlbmFtZWAgaXMgYW55IGBSTk1gIG9yIGBVRFRgIG5hbWUgZGVmaW5lZCBieSB0aGUgYXNzb2NpYXRlZCBncmFtbWFyXG4vLyBhbmQgYGZuYCBpcyBhIHVzZXItd3JpdHRlbiBjYWxsYmFjayBmdW5jdGlvbi5cbi8vIChTZWUgW2BhcGctZXhhbXBsZXNgXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzMi1leGFtcGxlcy90cmVlL21hc3Rlci9hc3QpIGZvciBleGFtcGxlcyBvZiBob3cgdG8gY3JlYXRlIGFuIEFTVCxcbi8vIGRlZmluZSB0aGUgbm9kZXMgYW5kIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgYXR0YWNoIGl0IHRvIGEgcGFyc2VyLilcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwb3J0c0FzdCgpIHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuL2lkZW50aWZpZXJzJyk7XG4gIGNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcblxuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnYXN0LmpzOiAnO1xuICBjb25zdCB0aGF0ID0gdGhpcztcbiAgbGV0IHJ1bGVzID0gbnVsbDtcbiAgbGV0IHVkdHMgPSBudWxsO1xuICBsZXQgY2hhcnMgPSBudWxsO1xuICBsZXQgbm9kZUNvdW50ID0gMDtcbiAgY29uc3Qgbm9kZXNEZWZpbmVkID0gW107XG4gIGNvbnN0IG5vZGVDYWxsYmFja3MgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgY29uc3QgcmVjb3JkcyA9IFtdO1xuICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICB0aGlzLmFzdE9iamVjdCA9ICdhc3RPYmplY3QnO1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlciB0byBpbml0aWFsaXplIHRoZSBBU1Qgd2l0aCB0aGUgcnVsZXMsIFVEVHMgYW5kIHRoZSBpbnB1dCBjaGFyYWN0ZXJzICovXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIGluaXQocnVsZXNJbiwgdWR0c0luLCBjaGFyc0luKSB7XG4gICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICByZWNvcmRzLmxlbmd0aCA9IDA7XG4gICAgbm9kZXNEZWZpbmVkLmxlbmd0aCA9IDA7XG4gICAgbm9kZUNvdW50ID0gMDtcbiAgICBydWxlcyA9IHJ1bGVzSW47XG4gICAgdWR0cyA9IHVkdHNJbjtcbiAgICBjaGFycyA9IGNoYXJzSW47XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGlzdC5wdXNoKHJ1bGVzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaCh1ZHRzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgbm9kZUNvdW50ID0gcnVsZXMubGVuZ3RoICsgdWR0cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vZGVDb3VudDsgaSArPSAxKSB7XG4gICAgICBub2Rlc0RlZmluZWRbaV0gPSBmYWxzZTtcbiAgICAgIG5vZGVDYWxsYmFja3NbaV0gPSBudWxsO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGluZGV4IGluIHRoYXQuY2FsbGJhY2tzKSB7XG4gICAgICBjb25zdCBsb3dlciA9IGluZGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpID0gbGlzdC5pbmRleE9mKGxvd2VyKTtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWluaXQ6IG5vZGUgJyR7aW5kZXh9JyBub3QgYSBydWxlIG9yIHVkdCBuYW1lYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoYXQuY2FsbGJhY2tzW2luZGV4XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBub2Rlc0RlZmluZWRbaV0gPSB0cnVlO1xuICAgICAgICBub2RlQ2FsbGJhY2tzW2ldID0gdGhhdC5jYWxsYmFja3NbaW5kZXhdO1xuICAgICAgfVxuICAgICAgaWYgKHRoYXQuY2FsbGJhY2tzW2luZGV4XSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2Rlc0RlZmluZWRbaV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogQVNUIG5vZGUgZGVmaW5pdGlvbnMgLSBjYWxsZWQgYnkgdGhlIHBhcnNlcidzIGBSTk1gIG9wZXJhdG9yICovXG4gIHRoaXMucnVsZURlZmluZWQgPSBmdW5jdGlvbiBydWxlRGVmaW5lZChpbmRleCkge1xuICAgIHJldHVybiBub2Rlc0RlZmluZWRbaW5kZXhdICE9PSBmYWxzZTtcbiAgfTtcbiAgLyogQVNUIG5vZGUgZGVmaW5pdGlvbnMgLSBjYWxsZWQgYnkgdGhlIHBhcnNlcidzIGBVRFRgIG9wZXJhdG9yICovXG4gIHRoaXMudWR0RGVmaW5lZCA9IGZ1bmN0aW9uIHVkdERlZmluZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gbm9kZXNEZWZpbmVkW3J1bGVzLmxlbmd0aCArIGluZGV4XSAhPT0gZmFsc2U7XG4gIH07XG4gIC8qIGNhbGxlZCBieSB0aGUgcGFyc2VyJ3MgYFJOTWAgJiBgVURUYCBvcGVyYXRvcnMgKi9cbiAgLyogYnVpbGRzIGEgcmVjb3JkIGZvciB0aGUgZG93bndhcmQgdHJhdmVyc2FsIG9mIHRoZSBub2RlICovXG4gIHRoaXMuZG93biA9IGZ1bmN0aW9uIGRvd24oY2FsbGJhY2tJbmRleCwgbmFtZSkge1xuICAgIGNvbnN0IHRoaXNJbmRleCA9IHJlY29yZHMubGVuZ3RoO1xuICAgIHN0YWNrLnB1c2godGhpc0luZGV4KTtcbiAgICByZWNvcmRzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHRoaXNJbmRleCxcbiAgICAgIHRoYXRJbmRleDogbnVsbCxcbiAgICAgIHN0YXRlOiBpZC5TRU1fUFJFLFxuICAgICAgY2FsbGJhY2tJbmRleCxcbiAgICAgIHBocmFzZUluZGV4OiBudWxsLFxuICAgICAgcGhyYXNlTGVuZ3RoOiBudWxsLFxuICAgICAgc3RhY2s6IHN0YWNrLmxlbmd0aCxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpc0luZGV4O1xuICB9O1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlcidzIGBSTk1gICYgYFVEVGAgb3BlcmF0b3JzICovXG4gIC8qIGJ1aWxkcyBhIHJlY29yZCBmb3IgdGhlIHVwd2FyZCB0cmF2ZXJzYWwgb2YgdGhlIG5vZGUgKi9cbiAgdGhpcy51cCA9IGZ1bmN0aW9uIHVwKGNhbGxiYWNrSW5kZXgsIG5hbWUsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgpIHtcbiAgICBjb25zdCB0aGlzSW5kZXggPSByZWNvcmRzLmxlbmd0aDtcbiAgICBjb25zdCB0aGF0SW5kZXggPSBzdGFjay5wb3AoKTtcbiAgICByZWNvcmRzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHRoaXNJbmRleCxcbiAgICAgIHRoYXRJbmRleCxcbiAgICAgIHN0YXRlOiBpZC5TRU1fUE9TVCxcbiAgICAgIGNhbGxiYWNrSW5kZXgsXG4gICAgICBwaHJhc2VJbmRleCxcbiAgICAgIHBocmFzZUxlbmd0aCxcbiAgICAgIHN0YWNrOiBzdGFjay5sZW5ndGgsXG4gICAgfSk7XG4gICAgcmVjb3Jkc1t0aGF0SW5kZXhdLnRoYXRJbmRleCA9IHRoaXNJbmRleDtcbiAgICByZWNvcmRzW3RoYXRJbmRleF0ucGhyYXNlSW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICByZWNvcmRzW3RoYXRJbmRleF0ucGhyYXNlTGVuZ3RoID0gcGhyYXNlTGVuZ3RoO1xuICAgIHJldHVybiB0aGlzSW5kZXg7XG4gIH07XG4gIC8vIENhbGxlZCBieSB0aGUgdXNlciB0byB0cmFuc2xhdGUgdGhlIEFTVC5cbiAgLy8gVHJhbnNsYXRlIG1lYW5zIHRvIGFzc29jaWF0ZSBvciBhcHBseSBzb21lIHNlbWFudGljIGFjdGlvbiB0byB0aGVcbiAgLy8gcGhyYXNlcyB0aGF0IHdlcmUgc3ludGFjdGljYWxseSBtYXRjaGVkIHRvIHRoZSBBU1Qgbm9kZXMgYWNjb3JkaW5nXG4gIC8vIHRvIHRoZSBkZWZpbmluZyBncmFtbWFyLlxuICAvLyBgYGBcbiAgLy8gZGF0YSAtIG9wdGlvbmFsIHVzZXItZGVmaW5lZCBkYXRhXG4gIC8vICAgICAgICBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucyBieSB0aGUgdHJhbnNsYXRvclxuICAvLyBgYGBcbiAgdGhpcy50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUoZGF0YSkge1xuICAgIGxldCByZXQ7XG4gICAgbGV0IGNhbGxiYWNrO1xuICAgIGxldCByZWNvcmQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvcmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgY2FsbGJhY2sgPSBub2RlQ2FsbGJhY2tzW3JlY29yZC5jYWxsYmFja0luZGV4XTtcbiAgICAgIGlmIChyZWNvcmQuc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0ID0gY2FsbGJhY2soaWQuU0VNX1BSRSwgY2hhcnMsIHJlY29yZC5waHJhc2VJbmRleCwgcmVjb3JkLnBocmFzZUxlbmd0aCwgZGF0YSk7XG4gICAgICAgICAgaWYgKHJldCA9PT0gaWQuU0VNX1NLSVApIHtcbiAgICAgICAgICAgIGkgPSByZWNvcmQudGhhdEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICBjYWxsYmFjayhpZC5TRU1fUE9TVCwgY2hhcnMsIHJlY29yZC5waHJhc2VJbmRleCwgcmVjb3JkLnBocmFzZUxlbmd0aCwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlciB0byByZXNldCB0aGUgbGVuZ3RoIG9mIHRoZSByZWNvcmRzIGFycmF5ICovXG4gIC8qIG5lY2Vzc2FyeSBvbiBiYWNrdHJhY2tpbmcgKi9cbiAgdGhpcy5zZXRMZW5ndGggPSBmdW5jdGlvbiBzZXRMZW5ndGgobGVuZ3RoKSB7XG4gICAgcmVjb3Jkcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHJlY29yZHNbbGVuZ3RoIC0gMV0uc3RhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9O1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlciB0byBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgcmVjb3JkcyBhcnJheSAqL1xuICB0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCgpIHtcbiAgICByZXR1cm4gcmVjb3Jkcy5sZW5ndGg7XG4gIH07XG4gIC8qIGhlbHBlciBmb3IgWE1MIGRpc3BsYXkgKi9cbiAgZnVuY3Rpb24gaW5kZW50KG4pIHtcbiAgICBsZXQgcmV0ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDEpIHtcbiAgICAgIHJldCArPSAnICc7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLy8gR2VuZXJhdGUgYW4gYFhNTGAgdmVyc2lvbiBvZiB0aGUgQVNULlxuICAvLyBVc2VmdWwgaWYgeW91IHdhbnQgdG8gdXNlIGEgc3BlY2lhbCBvciBmYXZvcml0ZSBYTUwgcGFyc2VyIHRvIHRyYW5zbGF0ZSB0aGVcbiAgLy8gQVNULlxuICAvLyBgYGBcbiAgLy8gbW9kZSAtIHRoZSBkaXNwbGF5IG1vZGUgb2YgdGhlIGNhcHR1cmVkIHBocmFzZXNcbiAgLy8gICAgICAtIGRlZmF1bHQgbW9kZSBpcyBcImFzY2lpXCJcbiAgLy8gICAgICAtIGNhbiBiZTogXCJhc2NpaVwiXG4gIC8vICAgICAgICAgICAgICAgIFwiZGVjaW1hbFwiXG4gIC8vICAgICAgICAgICAgICAgIFwiaGV4YWRlY2ltYWxcIlxuICAvLyAgICAgICAgICAgICAgICBcInVuaWNvZGVcIlxuICAvLyBgYGBcbiAgdGhpcy50b1htbCA9IGZ1bmN0aW9uIHRvU21sKG1vZGVBcmcpIHtcbiAgICBsZXQgZGlzcGxheSA9IHV0aWxzLmNoYXJzVG9EZWM7XG4gICAgbGV0IGNhcHRpb24gPSAnZGVjaW1hbCBpbnRlZ2VyIGNoYXJhY3RlciBjb2Rlcyc7XG4gICAgaWYgKHR5cGVvZiBtb2RlQXJnID09PSAnc3RyaW5nJyAmJiBtb2RlQXJnLmxlbmd0aCA+PSAzKSB7XG4gICAgICBjb25zdCBtb2RlID0gbW9kZUFyZy5zbGljZSgwLCAzKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKG1vZGUgPT09ICdhc2MnKSB7XG4gICAgICAgIGRpc3BsYXkgPSB1dGlscy5jaGFyc1RvQXNjaWk7XG4gICAgICAgIGNhcHRpb24gPSAnQVNDSUkgZm9yIHByaW50aW5nIGNoYXJhY3RlcnMsIGhleCBmb3Igbm9uLXByaW50aW5nJztcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2hleCcpIHtcbiAgICAgICAgZGlzcGxheSA9IHV0aWxzLmNoYXJzVG9IZXg7XG4gICAgICAgIGNhcHRpb24gPSAnaGV4YWRlY2ltYWwgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMnO1xuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAndW5pJykge1xuICAgICAgICBkaXNwbGF5ID0gdXRpbHMuY2hhcnNUb1VuaWNvZGU7XG4gICAgICAgIGNhcHRpb24gPSAnVW5pY29kZSBVVEYtMzIgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMnO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgeG1sID0gJyc7XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICB4bWwgKz0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cInV0Zi04XCI/Plxcbic7XG4gICAgeG1sICs9IGA8cm9vdCBub2Rlcz1cIiR7cmVjb3Jkcy5sZW5ndGggLyAyfVwiIGNoYXJhY3RlcnM9XCIke2NoYXJzLmxlbmd0aH1cIj5cXG5gO1xuICAgIHhtbCArPSBgPCEtLSBpbnB1dCBzdHJpbmcsICR7Y2FwdGlvbn0gLS0+XFxuYDtcbiAgICB4bWwgKz0gaW5kZW50KGRlcHRoICsgMik7XG4gICAgeG1sICs9IGRpc3BsYXkoY2hhcnMpO1xuICAgIHhtbCArPSAnXFxuJztcbiAgICByZWNvcmRzLmZvckVhY2goKHJlYykgPT4ge1xuICAgICAgaWYgKHJlYy5zdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICB4bWwgKz0gaW5kZW50KGRlcHRoKTtcbiAgICAgICAgeG1sICs9IGA8bm9kZSBuYW1lPVwiJHtyZWMubmFtZX1cIiBpbmRleD1cIiR7cmVjLnBocmFzZUluZGV4fVwiIGxlbmd0aD1cIiR7cmVjLnBocmFzZUxlbmd0aH1cIj5cXG5gO1xuICAgICAgICB4bWwgKz0gaW5kZW50KGRlcHRoICsgMik7XG4gICAgICAgIHhtbCArPSBkaXNwbGF5KGNoYXJzLCByZWMucGhyYXNlSW5kZXgsIHJlYy5waHJhc2VMZW5ndGgpO1xuICAgICAgICB4bWwgKz0gJ1xcbic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4bWwgKz0gaW5kZW50KGRlcHRoKTtcbiAgICAgICAgeG1sICs9IGA8L25vZGU+PCEtLSBuYW1lPVwiJHtyZWMubmFtZX1cIiAtLT5cXG5gO1xuICAgICAgICBkZXB0aCAtPSAxO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgeG1sICs9ICc8L3Jvb3Q+XFxuJztcbiAgICByZXR1cm4geG1sO1xuICB9O1xuICAvKiBnZW5lcmF0ZSBhIEphdmFTY3JpcHQgb2JqZWN0IHZlcnNpb24gb2YgdGhlIEFTVCAqL1xuICAvKiBmb3IgdGhlIHBocmFzZS1tYXRjaGluZyBlbmdpbmUgYXBnLWV4cCAqL1xuICB0aGlzLnBocmFzZXMgPSBmdW5jdGlvbiBwaHJhc2VzKCkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGxldCBpO1xuICAgIGxldCByZWNvcmQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHJlY29yZCA9IHJlY29yZHNbaV07XG4gICAgICBpZiAocmVjb3JkLnN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpbcmVjb3JkLm5hbWVdKSkge1xuICAgICAgICAgIG9ialtyZWNvcmQubmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBvYmpbcmVjb3JkLm5hbWVdLnB1c2goe1xuICAgICAgICAgIGluZGV4OiByZWNvcmQucGhyYXNlSW5kZXgsXG4gICAgICAgICAgbGVuZ3RoOiByZWNvcmQucGhyYXNlTGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImV4cG9ydHNBc3QiLCJpZCIsInJlcXVpcmUiLCJ1dGlscyIsInRoaXNGaWxlTmFtZSIsInRoYXQiLCJydWxlcyIsInVkdHMiLCJjaGFycyIsIm5vZGVDb3VudCIsIm5vZGVzRGVmaW5lZCIsIm5vZGVDYWxsYmFja3MiLCJzdGFjayIsInJlY29yZHMiLCJjYWxsYmFja3MiLCJhc3RPYmplY3QiLCJpbml0IiwicnVsZXNJbiIsInVkdHNJbiIsImNoYXJzSW4iLCJsZW5ndGgiLCJpIiwibGlzdCIsInB1c2giLCJsb3dlciIsImluZGV4IiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwiRXJyb3IiLCJydWxlRGVmaW5lZCIsInVkdERlZmluZWQiLCJkb3duIiwiY2FsbGJhY2tJbmRleCIsIm5hbWUiLCJ0aGlzSW5kZXgiLCJ0aGF0SW5kZXgiLCJzdGF0ZSIsIlNFTV9QUkUiLCJwaHJhc2VJbmRleCIsInBocmFzZUxlbmd0aCIsInVwIiwicG9wIiwiU0VNX1BPU1QiLCJ0cmFuc2xhdGUiLCJkYXRhIiwicmV0IiwiY2FsbGJhY2siLCJyZWNvcmQiLCJTRU1fU0tJUCIsInNldExlbmd0aCIsImdldExlbmd0aCIsImluZGVudCIsIm4iLCJ0b1htbCIsInRvU21sIiwibW9kZUFyZyIsImRpc3BsYXkiLCJjaGFyc1RvRGVjIiwiY2FwdGlvbiIsIm1vZGUiLCJzbGljZSIsImNoYXJzVG9Bc2NpaSIsImNoYXJzVG9IZXgiLCJjaGFyc1RvVW5pY29kZSIsInhtbCIsImRlcHRoIiwiZm9yRWFjaCIsInJlYyIsInBocmFzZXMiLCJvYmoiLCJBcnJheSIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/ast.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/circular-buffer.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/circular-buffer.js ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module acts as a \"circular buffer\". It is used to keep track\n// only the last N records in an array of records. If more than N records\n// are saved, each additional record overwrites the previously oldest record.\n// This module deals only with the record indexes and does not save\n// any actual records. It is used by [`trace.js`](./trace.html) for limiting the number of\n// trace records saved.\n\nmodule.exports = function exportsCircularBuffer() {\n    \"use strict;\";\n    const thisFileName = \"circular-buffer.js: \";\n    let itemIndex = -1;\n    let maxListSize = 0;\n    // Initialize buffer.<br>\n    // *size* is `maxListSize`, the maximum number of records saved before overwriting begins.\n    this.init = function init(size) {\n        if (typeof size !== \"number\" || size <= 0) {\n            throw new Error(`${thisFileName}init: circular buffer size must an integer > 0`);\n        }\n        maxListSize = Math.ceil(size);\n        itemIndex = -1;\n    };\n    // Call this to increment the number of records collected.<br>\n    // Returns the array index number to store the next record in.\n    this.increment = function increment() {\n        itemIndex += 1;\n        return (itemIndex + maxListSize) % maxListSize;\n    };\n    // Returns `maxListSize` - the maximum number of records to keep in the buffer.\n    this.maxSize = function maxSize() {\n        return maxListSize;\n    };\n    // Returns the highest number of items saved.<br>\n    // (The number of items is the actual number of records processed\n    // even though only `maxListSize` records are actually retained.)\n    this.items = function items() {\n        return itemIndex + 1;\n    };\n    // Returns the record number associated with this item index.\n    this.getListIndex = function getListIndex(item) {\n        if (itemIndex === -1) {\n            return -1;\n        }\n        if (item < 0 || item > itemIndex) {\n            return -1;\n        }\n        if (itemIndex - item >= maxListSize) {\n            return -1;\n        }\n        return (item + maxListSize) % maxListSize;\n    };\n    // The iterator over the circular buffer.\n    // The user's function, `fn`, will be called with arguments `fn(listIndex, itemIndex)`\n    // where `listIndex` is the saved record index and `itemIndex` is the actual item index.\n    this.forEach = function forEach(fn) {\n        if (itemIndex === -1) {\n            /* no records have been collected */ return;\n        }\n        if (itemIndex < maxListSize) {\n            /* fewer than maxListSize records have been collected - number of items = number of records */ for(let i = 0; i <= itemIndex; i += 1){\n                fn(i, i);\n            }\n            return;\n        }\n        /* start with the oldest record saved and finish with the most recent record saved */ for(let i = itemIndex - maxListSize + 1; i <= itemIndex; i += 1){\n            const listIndex = (i + maxListSize) % maxListSize;\n            fn(listIndex, i);\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2NpcmN1bGFyLWJ1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O3VGQUd1RixHQUN2RixvRUFBb0U7QUFDcEUseUVBQXlFO0FBQ3pFLDZFQUE2RTtBQUM3RSxtRUFBbUU7QUFDbkUsMEZBQTBGO0FBQzFGLHVCQUF1Qjs7QUFDdkJBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQztJQUN4QjtJQUVBLE1BQU1DLGVBQWU7SUFDckIsSUFBSUMsWUFBWSxDQUFDO0lBQ2pCLElBQUlDLGNBQWM7SUFDbEIseUJBQXlCO0lBQ3pCLDBGQUEwRjtJQUMxRixJQUFJLENBQUNDLElBQUksR0FBRyxTQUFTQSxLQUFLQyxJQUFJO1FBQzVCLElBQUksT0FBT0EsU0FBUyxZQUFZQSxRQUFRLEdBQUc7WUFDekMsTUFBTSxJQUFJQyxNQUFNLENBQUMsRUFBRUwsYUFBYSw4Q0FBOEMsQ0FBQztRQUNqRjtRQUNBRSxjQUFjSSxLQUFLQyxJQUFJLENBQUNIO1FBQ3hCSCxZQUFZLENBQUM7SUFDZjtJQUNBLDhEQUE4RDtJQUM5RCw4REFBOEQ7SUFDOUQsSUFBSSxDQUFDTyxTQUFTLEdBQUcsU0FBU0E7UUFDeEJQLGFBQWE7UUFDYixPQUFPLENBQUNBLFlBQVlDLFdBQVUsSUFBS0E7SUFDckM7SUFDQSwrRUFBK0U7SUFDL0UsSUFBSSxDQUFDTyxPQUFPLEdBQUcsU0FBU0E7UUFDdEIsT0FBT1A7SUFDVDtJQUNBLGlEQUFpRDtJQUNqRCxpRUFBaUU7SUFDakUsaUVBQWlFO0lBQ2pFLElBQUksQ0FBQ1EsS0FBSyxHQUFHLFNBQVNBO1FBQ3BCLE9BQU9ULFlBQVk7SUFDckI7SUFDQSw2REFBNkQ7SUFDN0QsSUFBSSxDQUFDVSxZQUFZLEdBQUcsU0FBU0EsYUFBYUMsSUFBSTtRQUM1QyxJQUFJWCxjQUFjLENBQUMsR0FBRztZQUNwQixPQUFPLENBQUM7UUFDVjtRQUNBLElBQUlXLE9BQU8sS0FBS0EsT0FBT1gsV0FBVztZQUNoQyxPQUFPLENBQUM7UUFDVjtRQUNBLElBQUlBLFlBQVlXLFFBQVFWLGFBQWE7WUFDbkMsT0FBTyxDQUFDO1FBQ1Y7UUFDQSxPQUFPLENBQUNVLE9BQU9WLFdBQVUsSUFBS0E7SUFDaEM7SUFDQSx5Q0FBeUM7SUFDekMsc0ZBQXNGO0lBQ3RGLHdGQUF3RjtJQUN4RixJQUFJLENBQUNXLE9BQU8sR0FBRyxTQUFTQSxRQUFRQyxFQUFFO1FBQ2hDLElBQUliLGNBQWMsQ0FBQyxHQUFHO1lBQ3BCLGtDQUFrQyxHQUNsQztRQUNGO1FBQ0EsSUFBSUEsWUFBWUMsYUFBYTtZQUMzQiw0RkFBNEYsR0FDNUYsSUFBSyxJQUFJYSxJQUFJLEdBQUdBLEtBQUtkLFdBQVdjLEtBQUssRUFBRztnQkFDdENELEdBQUdDLEdBQUdBO1lBQ1I7WUFDQTtRQUNGO1FBQ0EsbUZBQW1GLEdBQ25GLElBQUssSUFBSUEsSUFBSWQsWUFBWUMsY0FBYyxHQUFHYSxLQUFLZCxXQUFXYyxLQUFLLEVBQUc7WUFDaEUsTUFBTUMsWUFBWSxDQUFDRCxJQUFJYixXQUFVLElBQUtBO1lBQ3RDWSxHQUFHRSxXQUFXRDtRQUNoQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9jaXJjdWxhci1idWZmZXIuanM/M2ViNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBhY3RzIGFzIGEgXCJjaXJjdWxhciBidWZmZXJcIi4gSXQgaXMgdXNlZCB0byBrZWVwIHRyYWNrXG4vLyBvbmx5IHRoZSBsYXN0IE4gcmVjb3JkcyBpbiBhbiBhcnJheSBvZiByZWNvcmRzLiBJZiBtb3JlIHRoYW4gTiByZWNvcmRzXG4vLyBhcmUgc2F2ZWQsIGVhY2ggYWRkaXRpb25hbCByZWNvcmQgb3ZlcndyaXRlcyB0aGUgcHJldmlvdXNseSBvbGRlc3QgcmVjb3JkLlxuLy8gVGhpcyBtb2R1bGUgZGVhbHMgb25seSB3aXRoIHRoZSByZWNvcmQgaW5kZXhlcyBhbmQgZG9lcyBub3Qgc2F2ZVxuLy8gYW55IGFjdHVhbCByZWNvcmRzLiBJdCBpcyB1c2VkIGJ5IFtgdHJhY2UuanNgXSguL3RyYWNlLmh0bWwpIGZvciBsaW1pdGluZyB0aGUgbnVtYmVyIG9mXG4vLyB0cmFjZSByZWNvcmRzIHNhdmVkLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHBvcnRzQ2lyY3VsYXJCdWZmZXIoKSB7XG4gICd1c2Ugc3RyaWN0Oyc7XG5cbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ2NpcmN1bGFyLWJ1ZmZlci5qczogJztcbiAgbGV0IGl0ZW1JbmRleCA9IC0xO1xuICBsZXQgbWF4TGlzdFNpemUgPSAwO1xuICAvLyBJbml0aWFsaXplIGJ1ZmZlci48YnI+XG4gIC8vICpzaXplKiBpcyBgbWF4TGlzdFNpemVgLCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyBzYXZlZCBiZWZvcmUgb3ZlcndyaXRpbmcgYmVnaW5zLlxuICB0aGlzLmluaXQgPSBmdW5jdGlvbiBpbml0KHNpemUpIHtcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInIHx8IHNpemUgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1pbml0OiBjaXJjdWxhciBidWZmZXIgc2l6ZSBtdXN0IGFuIGludGVnZXIgPiAwYCk7XG4gICAgfVxuICAgIG1heExpc3RTaXplID0gTWF0aC5jZWlsKHNpemUpO1xuICAgIGl0ZW1JbmRleCA9IC0xO1xuICB9O1xuICAvLyBDYWxsIHRoaXMgdG8gaW5jcmVtZW50IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBjb2xsZWN0ZWQuPGJyPlxuICAvLyBSZXR1cm5zIHRoZSBhcnJheSBpbmRleCBudW1iZXIgdG8gc3RvcmUgdGhlIG5leHQgcmVjb3JkIGluLlxuICB0aGlzLmluY3JlbWVudCA9IGZ1bmN0aW9uIGluY3JlbWVudCgpIHtcbiAgICBpdGVtSW5kZXggKz0gMTtcbiAgICByZXR1cm4gKGl0ZW1JbmRleCArIG1heExpc3RTaXplKSAlIG1heExpc3RTaXplO1xuICB9O1xuICAvLyBSZXR1cm5zIGBtYXhMaXN0U2l6ZWAgLSB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyB0byBrZWVwIGluIHRoZSBidWZmZXIuXG4gIHRoaXMubWF4U2l6ZSA9IGZ1bmN0aW9uIG1heFNpemUoKSB7XG4gICAgcmV0dXJuIG1heExpc3RTaXplO1xuICB9O1xuICAvLyBSZXR1cm5zIHRoZSBoaWdoZXN0IG51bWJlciBvZiBpdGVtcyBzYXZlZC48YnI+XG4gIC8vIChUaGUgbnVtYmVyIG9mIGl0ZW1zIGlzIHRoZSBhY3R1YWwgbnVtYmVyIG9mIHJlY29yZHMgcHJvY2Vzc2VkXG4gIC8vIGV2ZW4gdGhvdWdoIG9ubHkgYG1heExpc3RTaXplYCByZWNvcmRzIGFyZSBhY3R1YWxseSByZXRhaW5lZC4pXG4gIHRoaXMuaXRlbXMgPSBmdW5jdGlvbiBpdGVtcygpIHtcbiAgICByZXR1cm4gaXRlbUluZGV4ICsgMTtcbiAgfTtcbiAgLy8gUmV0dXJucyB0aGUgcmVjb3JkIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBpdGVtIGluZGV4LlxuICB0aGlzLmdldExpc3RJbmRleCA9IGZ1bmN0aW9uIGdldExpc3RJbmRleChpdGVtKSB7XG4gICAgaWYgKGl0ZW1JbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGl0ZW0gPCAwIHx8IGl0ZW0gPiBpdGVtSW5kZXgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGl0ZW1JbmRleCAtIGl0ZW0gPj0gbWF4TGlzdFNpemUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIChpdGVtICsgbWF4TGlzdFNpemUpICUgbWF4TGlzdFNpemU7XG4gIH07XG4gIC8vIFRoZSBpdGVyYXRvciBvdmVyIHRoZSBjaXJjdWxhciBidWZmZXIuXG4gIC8vIFRoZSB1c2VyJ3MgZnVuY3Rpb24sIGBmbmAsIHdpbGwgYmUgY2FsbGVkIHdpdGggYXJndW1lbnRzIGBmbihsaXN0SW5kZXgsIGl0ZW1JbmRleClgXG4gIC8vIHdoZXJlIGBsaXN0SW5kZXhgIGlzIHRoZSBzYXZlZCByZWNvcmQgaW5kZXggYW5kIGBpdGVtSW5kZXhgIGlzIHRoZSBhY3R1YWwgaXRlbSBpbmRleC5cbiAgdGhpcy5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgIGlmIChpdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAvKiBubyByZWNvcmRzIGhhdmUgYmVlbiBjb2xsZWN0ZWQgKi9cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGl0ZW1JbmRleCA8IG1heExpc3RTaXplKSB7XG4gICAgICAvKiBmZXdlciB0aGFuIG1heExpc3RTaXplIHJlY29yZHMgaGF2ZSBiZWVuIGNvbGxlY3RlZCAtIG51bWJlciBvZiBpdGVtcyA9IG51bWJlciBvZiByZWNvcmRzICovXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpdGVtSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICBmbihpLCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyogc3RhcnQgd2l0aCB0aGUgb2xkZXN0IHJlY29yZCBzYXZlZCBhbmQgZmluaXNoIHdpdGggdGhlIG1vc3QgcmVjZW50IHJlY29yZCBzYXZlZCAqL1xuICAgIGZvciAobGV0IGkgPSBpdGVtSW5kZXggLSBtYXhMaXN0U2l6ZSArIDE7IGkgPD0gaXRlbUluZGV4OyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGxpc3RJbmRleCA9IChpICsgbWF4TGlzdFNpemUpICUgbWF4TGlzdFNpemU7XG4gICAgICBmbihsaXN0SW5kZXgsIGkpO1xuICAgIH1cbiAgfTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImV4cG9ydHNDaXJjdWxhckJ1ZmZlciIsInRoaXNGaWxlTmFtZSIsIml0ZW1JbmRleCIsIm1heExpc3RTaXplIiwiaW5pdCIsInNpemUiLCJFcnJvciIsIk1hdGgiLCJjZWlsIiwiaW5jcmVtZW50IiwibWF4U2l6ZSIsIml0ZW1zIiwiZ2V0TGlzdEluZGV4IiwiaXRlbSIsImZvckVhY2giLCJmbiIsImkiLCJsaXN0SW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/circular-buffer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/emitcss.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/emitcss.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("// This module has been developed programmatically in the `apg-lib` build process.\n// It is used to build web pages programatically on the fly without the need for <script> or <style> tags.\n\nmodule.exports = function emittcss() {\n    return \"/* This file automatically generated by jsonToless() and LESS. */\\n.apg-mono {\\n  font-family: monospace;\\n}\\n.apg-active {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-match {\\n  font-weight: bold;\\n  color: #264BFF;\\n}\\n.apg-empty {\\n  font-weight: bold;\\n  color: #0fbd0f;\\n}\\n.apg-nomatch {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-lh-match {\\n  font-weight: bold;\\n  color: #1A97BA;\\n}\\n.apg-lb-match {\\n  font-weight: bold;\\n  color: #5F1687;\\n}\\n.apg-remainder {\\n  font-weight: bold;\\n  color: #999999;\\n}\\n.apg-ctrl-char {\\n  font-weight: bolder;\\n  font-style: italic;\\n  font-size: 0.6em;\\n}\\n.apg-line-end {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-error {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-phrase {\\n  color: #000000;\\n  background-color: #8caae6;\\n}\\n.apg-empty-phrase {\\n  color: #0fbd0f;\\n}\\ntable.apg-state {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th,\\ntable.apg-state td {\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th:nth-last-child(2),\\ntable.apg-state td:nth-last-child(2) {\\n  text-align: right;\\n}\\ntable.apg-state caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-stats {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats th,\\ntable.apg-stats td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace th,\\ntable.apg-trace td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace th:last-child,\\ntable.apg-trace th:nth-last-child(2),\\ntable.apg-trace td:last-child,\\ntable.apg-trace td:nth-last-child(2) {\\n  text-align: left;\\n}\\ntable.apg-grammar {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-grammar th,\\ntable.apg-grammar td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar th:last-child,\\ntable.apg-grammar td:last-child {\\n  text-align: left;\\n}\\ntable.apg-rules {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-rules th,\\ntable.apg-rules td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules a {\\n  color: #003399 !important;\\n}\\ntable.apg-rules a:hover {\\n  color: #8caae6 !important;\\n}\\ntable.apg-attrs {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-attrs th,\\ntable.apg-attrs td {\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs th:nth-child(1),\\ntable.apg-attrs th:nth-child(2),\\ntable.apg-attrs th:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs td:nth-child(1),\\ntable.apg-attrs td:nth-child(2),\\ntable.apg-attrs td:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs a {\\n  color: #003399 !important;\\n}\\ntable.apg-attrs a:hover {\\n  color: #8caae6 !important;\\n}\\n\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2VtaXRjc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsa0ZBQWtGO0FBQ2xGLDBHQUEwRzs7QUFFMUdBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQztJQUMxQixPQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9lbWl0Y3NzLmpzP2QxODgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBtb2R1bGUgaGFzIGJlZW4gZGV2ZWxvcGVkIHByb2dyYW1tYXRpY2FsbHkgaW4gdGhlIGBhcGctbGliYCBidWlsZCBwcm9jZXNzLlxuLy8gSXQgaXMgdXNlZCB0byBidWlsZCB3ZWIgcGFnZXMgcHJvZ3JhbWF0aWNhbGx5IG9uIHRoZSBmbHkgd2l0aG91dCB0aGUgbmVlZCBmb3IgPHNjcmlwdD4gb3IgPHN0eWxlPiB0YWdzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVtaXR0Y3NzKCl7XG5yZXR1cm4gJy8qIFRoaXMgZmlsZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBqc29uVG9sZXNzKCkgYW5kIExFU1MuICovXFxuLmFwZy1tb25vIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxufVxcbi5hcGctYWN0aXZlIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICMwMDAwMDA7XFxufVxcbi5hcGctbWF0Y2gge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzI2NEJGRjtcXG59XFxuLmFwZy1lbXB0eSB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjMGZiZDBmO1xcbn1cXG4uYXBnLW5vbWF0Y2gge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogI0ZGNDAwMDtcXG59XFxuLmFwZy1saC1tYXRjaCB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjMUE5N0JBO1xcbn1cXG4uYXBnLWxiLW1hdGNoIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICM1RjE2ODc7XFxufVxcbi5hcGctcmVtYWluZGVyIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICM5OTk5OTk7XFxufVxcbi5hcGctY3RybC1jaGFyIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxuICBmb250LXNpemU6IDAuNmVtO1xcbn1cXG4uYXBnLWxpbmUtZW5kIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICMwMDAwMDA7XFxufVxcbi5hcGctZXJyb3Ige1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogI0ZGNDAwMDtcXG59XFxuLmFwZy1waHJhc2Uge1xcbiAgY29sb3I6ICMwMDAwMDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjOGNhYWU2O1xcbn1cXG4uYXBnLWVtcHR5LXBocmFzZSB7XFxuICBjb2xvcjogIzBmYmQwZjtcXG59XFxudGFibGUuYXBnLXN0YXRlIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1zdGF0ZSB0aCxcXG50YWJsZS5hcGctc3RhdGUgdGQge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXN0YXRlIHRoOm50aC1sYXN0LWNoaWxkKDIpLFxcbnRhYmxlLmFwZy1zdGF0ZSB0ZDpudGgtbGFzdC1jaGlsZCgyKSB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxudGFibGUuYXBnLXN0YXRlIGNhcHRpb24ge1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy1zdGF0cyB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLXRvcDogNXB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXN0YXRzIHRoLFxcbnRhYmxlLmFwZy1zdGF0cyB0ZCB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXN0YXRzIGNhcHRpb24ge1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy10cmFjZSB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLXRvcDogNXB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXRyYWNlIGNhcHRpb24ge1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy10cmFjZSB0aCxcXG50YWJsZS5hcGctdHJhY2UgdGQge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy10cmFjZSB0aDpsYXN0LWNoaWxkLFxcbnRhYmxlLmFwZy10cmFjZSB0aDpudGgtbGFzdC1jaGlsZCgyKSxcXG50YWJsZS5hcGctdHJhY2UgdGQ6bGFzdC1jaGlsZCxcXG50YWJsZS5hcGctdHJhY2UgdGQ6bnRoLWxhc3QtY2hpbGQoMikge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLWdyYW1tYXIge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1ncmFtbWFyIGNhcHRpb24ge1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy1ncmFtbWFyIHRoLFxcbnRhYmxlLmFwZy1ncmFtbWFyIHRkIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctZ3JhbW1hciB0aDpsYXN0LWNoaWxkLFxcbnRhYmxlLmFwZy1ncmFtbWFyIHRkOmxhc3QtY2hpbGQge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLXJ1bGVzIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctcnVsZXMgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLXJ1bGVzIHRoLFxcbnRhYmxlLmFwZy1ydWxlcyB0ZCB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXJ1bGVzIGEge1xcbiAgY29sb3I6ICMwMDMzOTkgIWltcG9ydGFudDtcXG59XFxudGFibGUuYXBnLXJ1bGVzIGE6aG92ZXIge1xcbiAgY29sb3I6ICM4Y2FhZTYgIWltcG9ydGFudDtcXG59XFxudGFibGUuYXBnLWF0dHJzIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLWF0dHJzIGNhcHRpb24ge1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy1hdHRycyB0aCxcXG50YWJsZS5hcGctYXR0cnMgdGQge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctYXR0cnMgdGg6bnRoLWNoaWxkKDEpLFxcbnRhYmxlLmFwZy1hdHRycyB0aDpudGgtY2hpbGQoMiksXFxudGFibGUuYXBnLWF0dHJzIHRoOm50aC1jaGlsZCgzKSB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxudGFibGUuYXBnLWF0dHJzIHRkOm50aC1jaGlsZCgxKSxcXG50YWJsZS5hcGctYXR0cnMgdGQ6bnRoLWNoaWxkKDIpLFxcbnRhYmxlLmFwZy1hdHRycyB0ZDpudGgtY2hpbGQoMykge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxufVxcbnRhYmxlLmFwZy1hdHRycyBhIHtcXG4gIGNvbG9yOiAjMDAzMzk5ICFpbXBvcnRhbnQ7XFxufVxcbnRhYmxlLmFwZy1hdHRycyBhOmhvdmVyIHtcXG4gIGNvbG9yOiAjOGNhYWU2ICFpbXBvcnRhbnQ7XFxufVxcbic7XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImVtaXR0Y3NzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/emitcss.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module exposes a list of named identifiers, shared across the parser generator\n// and the parsers that are generated.\n\nmodule.exports = {\n    // Identifies the operator type. Used by the generator\n    // to indicate operator types in the grammar object.\n    // Used by the [parser](./parser.html) when interpreting the grammar object.\n    /* the original ABNF operators */ ALT: 1 /* alternation */ ,\n    CAT: 2 /* concatenation */ ,\n    REP: 3 /* repetition */ ,\n    RNM: 4 /* rule name */ ,\n    TRG: 5 /* terminal range */ ,\n    TBS: 6 /* terminal binary string, case sensitive */ ,\n    TLS: 7 /* terminal literal string, case insensitive */ ,\n    /* the super set, SABNF operators */ UDT: 11 /* user-defined terminal */ ,\n    AND: 12 /* positive look ahead */ ,\n    NOT: 13 /* negative look ahead */ ,\n    BKR: 14 /* back reference to a previously matched rule name */ ,\n    BKA: 15 /* positive look behind */ ,\n    BKN: 16 /* negative look behind */ ,\n    ABG: 17 /* anchor - begin of string */ ,\n    AEN: 18 /* anchor - end of string */ ,\n    // Used by the parser and the user's `RNM` and `UDT` callback functions.\n    // Identifies the parser state as it traverses the parse tree nodes.\n    // - *ACTIVE* - indicates the downward direction through the parse tree node.\n    // - *MATCH* - indicates the upward direction and a phrase, of length \\> 0, has been successfully matched\n    // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched\n    // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all\n    ACTIVE: 100,\n    MATCH: 101,\n    EMPTY: 102,\n    NOMATCH: 103,\n    // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions\n    // to indicate the direction of flow through the `AST` nodes.\n    // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.\n    // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.\n    SEM_PRE: 200,\n    SEM_POST: 201,\n    // Used by the user's callback functions to indicate to the `AST` translator (semantic analysis) how to proceed.\n    // - *SEM_OK* - normal return value\n    // - *SEM_SKIP* - if a callback function returns this value from the SEM_PRE state,\n    // the translator will skip processing all `AST` nodes in the branch below the current node.\n    // Ignored if returned from the SEM_POST state.\n    SEM_OK: 300,\n    SEM_SKIP: 301,\n    // Used in attribute generation to distinguish the necessary attribute categories.\n    // - *ATTR_N* - non-recursive\n    // - *ATTR_R* - recursive\n    // - *ATTR_MR* - belongs to a mutually-recursive set\n    ATTR_N: 400,\n    ATTR_R: 401,\n    ATTR_MR: 402,\n    // Look around values indicate whether the parser is in look ahead or look behind mode.\n    // Used by the tracing facility to indicate the look around mode in the trace records display.\n    // - *LOOKAROUND_NONE* - the parser is in normal parsing mode\n    // - *LOOKAROUND_AHEAD* - the parse is in look-ahead mode, phrase matching for operator `AND(&)` or `NOT(!)`\n    // - *LOOKAROUND_BEHIND* - the parse is in look-behind mode, phrase matching for operator `BKA(&&)` or `BKN(!!)`\n    LOOKAROUND_NONE: 500,\n    LOOKAROUND_AHEAD: 501,\n    LOOKAROUND_BEHIND: 502,\n    // Back reference rule mode indicators\n    // - *BKR_MODE_UM* - the back reference is using universal mode\n    // - *BKR_MODE_PM* - the back reference is using parent frame mode\n    // - *BKR_MODE_CS* - the back reference is using case-sensitive phrase matching\n    // - *BKR_MODE_CI* - the back reference is using case-insensitive phrase matching\n    BKR_MODE_UM: 601,\n    BKR_MODE_PM: 602,\n    BKR_MODE_CS: 603,\n    BKR_MODE_CI: 604\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2lkZW50aWZpZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7dUZBR3VGLEdBQ3ZGLHNGQUFzRjtBQUN0RixzQ0FBc0M7O0FBRXRDQSxPQUFPQyxPQUFPLEdBQUc7SUFDZixzREFBc0Q7SUFDdEQsb0RBQW9EO0lBQ3BELDRFQUE0RTtJQUM1RSwrQkFBK0IsR0FDL0JDLEtBQUssRUFBRSxlQUFlO0lBQ3RCQyxLQUFLLEVBQUUsaUJBQWlCO0lBQ3hCQyxLQUFLLEVBQUUsY0FBYztJQUNyQkMsS0FBSyxFQUFFLGFBQWE7SUFDcEJDLEtBQUssRUFBRSxrQkFBa0I7SUFDekJDLEtBQUssRUFBRSwwQ0FBMEM7SUFDakRDLEtBQUssRUFBRSw2Q0FBNkM7SUFDcEQsa0NBQWtDLEdBQ2xDQyxLQUFLLEdBQUcseUJBQXlCO0lBQ2pDQyxLQUFLLEdBQUcsdUJBQXVCO0lBQy9CQyxLQUFLLEdBQUcsdUJBQXVCO0lBQy9CQyxLQUFLLEdBQUcsb0RBQW9EO0lBQzVEQyxLQUFLLEdBQUcsd0JBQXdCO0lBQ2hDQyxLQUFLLEdBQUcsd0JBQXdCO0lBQ2hDQyxLQUFLLEdBQUcsNEJBQTRCO0lBQ3BDQyxLQUFLLEdBQUcsMEJBQTBCO0lBQ2xDLHdFQUF3RTtJQUN4RSxvRUFBb0U7SUFDcEUsNkVBQTZFO0lBQzdFLHlHQUF5RztJQUN6Ryx3R0FBd0c7SUFDeEcsZ0dBQWdHO0lBQ2hHQyxRQUFRO0lBQ1JDLE9BQU87SUFDUEMsT0FBTztJQUNQQyxTQUFTO0lBQ1QsK0ZBQStGO0lBQy9GLDZEQUE2RDtJQUM3RCxzRkFBc0Y7SUFDdEYsc0ZBQXNGO0lBQ3RGQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVixnSEFBZ0g7SUFDaEgsbUNBQW1DO0lBQ25DLG1GQUFtRjtJQUNuRiw0RkFBNEY7SUFDNUYsK0NBQStDO0lBQy9DQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVixrRkFBa0Y7SUFDbEYsNkJBQTZCO0lBQzdCLHlCQUF5QjtJQUN6QixvREFBb0Q7SUFDcERDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxTQUFTO0lBQ1QsdUZBQXVGO0lBQ3ZGLDhGQUE4RjtJQUM5Riw2REFBNkQ7SUFDN0QsNEdBQTRHO0lBQzVHLGdIQUFnSDtJQUNoSEMsaUJBQWlCO0lBQ2pCQyxrQkFBa0I7SUFDbEJDLG1CQUFtQjtJQUNuQixzQ0FBc0M7SUFDdEMsK0RBQStEO0lBQy9ELGtFQUFrRTtJQUNsRSwrRUFBK0U7SUFDL0UsaUZBQWlGO0lBQ2pGQyxhQUFhO0lBQ2JDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxhQUFhO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9pZGVudGlmaWVycy5qcz9jNDhkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGV4cG9zZXMgYSBsaXN0IG9mIG5hbWVkIGlkZW50aWZpZXJzLCBzaGFyZWQgYWNyb3NzIHRoZSBwYXJzZXIgZ2VuZXJhdG9yXG4vLyBhbmQgdGhlIHBhcnNlcnMgdGhhdCBhcmUgZ2VuZXJhdGVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gSWRlbnRpZmllcyB0aGUgb3BlcmF0b3IgdHlwZS4gVXNlZCBieSB0aGUgZ2VuZXJhdG9yXG4gIC8vIHRvIGluZGljYXRlIG9wZXJhdG9yIHR5cGVzIGluIHRoZSBncmFtbWFyIG9iamVjdC5cbiAgLy8gVXNlZCBieSB0aGUgW3BhcnNlcl0oLi9wYXJzZXIuaHRtbCkgd2hlbiBpbnRlcnByZXRpbmcgdGhlIGdyYW1tYXIgb2JqZWN0LlxuICAvKiB0aGUgb3JpZ2luYWwgQUJORiBvcGVyYXRvcnMgKi9cbiAgQUxUOiAxIC8qIGFsdGVybmF0aW9uICovLFxuICBDQVQ6IDIgLyogY29uY2F0ZW5hdGlvbiAqLyxcbiAgUkVQOiAzIC8qIHJlcGV0aXRpb24gKi8sXG4gIFJOTTogNCAvKiBydWxlIG5hbWUgKi8sXG4gIFRSRzogNSAvKiB0ZXJtaW5hbCByYW5nZSAqLyxcbiAgVEJTOiA2IC8qIHRlcm1pbmFsIGJpbmFyeSBzdHJpbmcsIGNhc2Ugc2Vuc2l0aXZlICovLFxuICBUTFM6IDcgLyogdGVybWluYWwgbGl0ZXJhbCBzdHJpbmcsIGNhc2UgaW5zZW5zaXRpdmUgKi8sXG4gIC8qIHRoZSBzdXBlciBzZXQsIFNBQk5GIG9wZXJhdG9ycyAqL1xuICBVRFQ6IDExIC8qIHVzZXItZGVmaW5lZCB0ZXJtaW5hbCAqLyxcbiAgQU5EOiAxMiAvKiBwb3NpdGl2ZSBsb29rIGFoZWFkICovLFxuICBOT1Q6IDEzIC8qIG5lZ2F0aXZlIGxvb2sgYWhlYWQgKi8sXG4gIEJLUjogMTQgLyogYmFjayByZWZlcmVuY2UgdG8gYSBwcmV2aW91c2x5IG1hdGNoZWQgcnVsZSBuYW1lICovLFxuICBCS0E6IDE1IC8qIHBvc2l0aXZlIGxvb2sgYmVoaW5kICovLFxuICBCS046IDE2IC8qIG5lZ2F0aXZlIGxvb2sgYmVoaW5kICovLFxuICBBQkc6IDE3IC8qIGFuY2hvciAtIGJlZ2luIG9mIHN0cmluZyAqLyxcbiAgQUVOOiAxOCAvKiBhbmNob3IgLSBlbmQgb2Ygc3RyaW5nICovLFxuICAvLyBVc2VkIGJ5IHRoZSBwYXJzZXIgYW5kIHRoZSB1c2VyJ3MgYFJOTWAgYW5kIGBVRFRgIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgLy8gSWRlbnRpZmllcyB0aGUgcGFyc2VyIHN0YXRlIGFzIGl0IHRyYXZlcnNlcyB0aGUgcGFyc2UgdHJlZSBub2Rlcy5cbiAgLy8gLSAqQUNUSVZFKiAtIGluZGljYXRlcyB0aGUgZG93bndhcmQgZGlyZWN0aW9uIHRocm91Z2ggdGhlIHBhcnNlIHRyZWUgbm9kZS5cbiAgLy8gLSAqTUFUQ0gqIC0gaW5kaWNhdGVzIHRoZSB1cHdhcmQgZGlyZWN0aW9uIGFuZCBhIHBocmFzZSwgb2YgbGVuZ3RoIFxcPiAwLCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbWF0Y2hlZFxuICAvLyAtICpFTVBUWSogLSBpbmRpY2F0ZXMgdGhlIHVwd2FyZCBkaXJlY3Rpb24gYW5kIGEgcGhyYXNlLCBvZiBsZW5ndGggPSAwLCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbWF0Y2hlZFxuICAvLyAtICpOT01BVENIKiAtIGluZGljYXRlcyB0aGUgdXB3YXJkIGRpcmVjdGlvbiBhbmQgdGhlIHBhcnNlciBmYWlsZWQgdG8gbWF0Y2ggYW55IHBocmFzZSBhdCBhbGxcbiAgQUNUSVZFOiAxMDAsXG4gIE1BVENIOiAxMDEsXG4gIEVNUFRZOiAxMDIsXG4gIE5PTUFUQ0g6IDEwMyxcbiAgLy8gVXNlZCBieSBbYEFTVGAgdHJhbnNsYXRvcl0oLi9hc3QuaHRtbCkgKHNlbWFudGljIGFuYWx5c2lzKSBhbmQgdGhlIHVzZXIncyBjYWxsYmFjayBmdW5jdGlvbnNcbiAgLy8gdG8gaW5kaWNhdGUgdGhlIGRpcmVjdGlvbiBvZiBmbG93IHRocm91Z2ggdGhlIGBBU1RgIG5vZGVzLlxuICAvLyAtICpTRU1fUFJFKiAtIGluZGljYXRlcyB0aGUgZG93bndhcmQgKHByZS1icmFuY2gpIGRpcmVjdGlvbiB0aHJvdWdoIHRoZSBgQVNUYCBub2RlLlxuICAvLyAtICpTRU1fUE9TVCogLSBpbmRpY2F0ZXMgdGhlIHVwd2FyZCAocG9zdC1icmFuY2gpIGRpcmVjdGlvbiB0aHJvdWdoIHRoZSBgQVNUYCBub2RlLlxuICBTRU1fUFJFOiAyMDAsXG4gIFNFTV9QT1NUOiAyMDEsXG4gIC8vIFVzZWQgYnkgdGhlIHVzZXIncyBjYWxsYmFjayBmdW5jdGlvbnMgdG8gaW5kaWNhdGUgdG8gdGhlIGBBU1RgIHRyYW5zbGF0b3IgKHNlbWFudGljIGFuYWx5c2lzKSBob3cgdG8gcHJvY2VlZC5cbiAgLy8gLSAqU0VNX09LKiAtIG5vcm1hbCByZXR1cm4gdmFsdWVcbiAgLy8gLSAqU0VNX1NLSVAqIC0gaWYgYSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRoaXMgdmFsdWUgZnJvbSB0aGUgU0VNX1BSRSBzdGF0ZSxcbiAgLy8gdGhlIHRyYW5zbGF0b3Igd2lsbCBza2lwIHByb2Nlc3NpbmcgYWxsIGBBU1RgIG5vZGVzIGluIHRoZSBicmFuY2ggYmVsb3cgdGhlIGN1cnJlbnQgbm9kZS5cbiAgLy8gSWdub3JlZCBpZiByZXR1cm5lZCBmcm9tIHRoZSBTRU1fUE9TVCBzdGF0ZS5cbiAgU0VNX09LOiAzMDAsXG4gIFNFTV9TS0lQOiAzMDEsXG4gIC8vIFVzZWQgaW4gYXR0cmlidXRlIGdlbmVyYXRpb24gdG8gZGlzdGluZ3Vpc2ggdGhlIG5lY2Vzc2FyeSBhdHRyaWJ1dGUgY2F0ZWdvcmllcy5cbiAgLy8gLSAqQVRUUl9OKiAtIG5vbi1yZWN1cnNpdmVcbiAgLy8gLSAqQVRUUl9SKiAtIHJlY3Vyc2l2ZVxuICAvLyAtICpBVFRSX01SKiAtIGJlbG9uZ3MgdG8gYSBtdXR1YWxseS1yZWN1cnNpdmUgc2V0XG4gIEFUVFJfTjogNDAwLFxuICBBVFRSX1I6IDQwMSxcbiAgQVRUUl9NUjogNDAyLFxuICAvLyBMb29rIGFyb3VuZCB2YWx1ZXMgaW5kaWNhdGUgd2hldGhlciB0aGUgcGFyc2VyIGlzIGluIGxvb2sgYWhlYWQgb3IgbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gVXNlZCBieSB0aGUgdHJhY2luZyBmYWNpbGl0eSB0byBpbmRpY2F0ZSB0aGUgbG9vayBhcm91bmQgbW9kZSBpbiB0aGUgdHJhY2UgcmVjb3JkcyBkaXNwbGF5LlxuICAvLyAtICpMT09LQVJPVU5EX05PTkUqIC0gdGhlIHBhcnNlciBpcyBpbiBub3JtYWwgcGFyc2luZyBtb2RlXG4gIC8vIC0gKkxPT0tBUk9VTkRfQUhFQUQqIC0gdGhlIHBhcnNlIGlzIGluIGxvb2stYWhlYWQgbW9kZSwgcGhyYXNlIG1hdGNoaW5nIGZvciBvcGVyYXRvciBgQU5EKCYpYCBvciBgTk9UKCEpYFxuICAvLyAtICpMT09LQVJPVU5EX0JFSElORCogLSB0aGUgcGFyc2UgaXMgaW4gbG9vay1iZWhpbmQgbW9kZSwgcGhyYXNlIG1hdGNoaW5nIGZvciBvcGVyYXRvciBgQktBKCYmKWAgb3IgYEJLTighISlgXG4gIExPT0tBUk9VTkRfTk9ORTogNTAwLFxuICBMT09LQVJPVU5EX0FIRUFEOiA1MDEsXG4gIExPT0tBUk9VTkRfQkVISU5EOiA1MDIsXG4gIC8vIEJhY2sgcmVmZXJlbmNlIHJ1bGUgbW9kZSBpbmRpY2F0b3JzXG4gIC8vIC0gKkJLUl9NT0RFX1VNKiAtIHRoZSBiYWNrIHJlZmVyZW5jZSBpcyB1c2luZyB1bml2ZXJzYWwgbW9kZVxuICAvLyAtICpCS1JfTU9ERV9QTSogLSB0aGUgYmFjayByZWZlcmVuY2UgaXMgdXNpbmcgcGFyZW50IGZyYW1lIG1vZGVcbiAgLy8gLSAqQktSX01PREVfQ1MqIC0gdGhlIGJhY2sgcmVmZXJlbmNlIGlzIHVzaW5nIGNhc2Utc2Vuc2l0aXZlIHBocmFzZSBtYXRjaGluZ1xuICAvLyAtICpCS1JfTU9ERV9DSSogLSB0aGUgYmFjayByZWZlcmVuY2UgaXMgdXNpbmcgY2FzZS1pbnNlbnNpdGl2ZSBwaHJhc2UgbWF0Y2hpbmdcbiAgQktSX01PREVfVU06IDYwMSxcbiAgQktSX01PREVfUE06IDYwMixcbiAgQktSX01PREVfQ1M6IDYwMyxcbiAgQktSX01PREVfQ0k6IDYwNCxcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkFMVCIsIkNBVCIsIlJFUCIsIlJOTSIsIlRSRyIsIlRCUyIsIlRMUyIsIlVEVCIsIkFORCIsIk5PVCIsIkJLUiIsIkJLQSIsIkJLTiIsIkFCRyIsIkFFTiIsIkFDVElWRSIsIk1BVENIIiwiRU1QVFkiLCJOT01BVENIIiwiU0VNX1BSRSIsIlNFTV9QT1NUIiwiU0VNX09LIiwiU0VNX1NLSVAiLCJBVFRSX04iLCJBVFRSX1IiLCJBVFRSX01SIiwiTE9PS0FST1VORF9OT05FIiwiTE9PS0FST1VORF9BSEVBRCIsIkxPT0tBUk9VTkRfQkVISU5EIiwiQktSX01PREVfVU0iLCJCS1JfTU9ERV9QTSIsIkJLUl9NT0RFX0NTIiwiQktSX01PREVfQ0kiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module serves to export all library objects and object constructors with the `require(\"apg-lib\")` statement.\n// For example, to create a new parser in your program,\n// ````\n// let apglib = require(\"../apg-lib/node-exports\");\n// let my-parser = new apglib.parser();\n// ````\n\nmodule.exports = {\n    ast: __webpack_require__(/*! ./ast */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/ast.js\"),\n    circular: __webpack_require__(/*! ./circular-buffer */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/circular-buffer.js\"),\n    ids: __webpack_require__(/*! ./identifiers */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\"),\n    parser: __webpack_require__(/*! ./parser */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/parser.js\"),\n    stats: __webpack_require__(/*! ./stats */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/stats.js\"),\n    trace: __webpack_require__(/*! ./trace */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/trace.js\"),\n    utils: __webpack_require__(/*! ./utilities */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\"),\n    emitcss: __webpack_require__(/*! ./emitcss */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/emitcss.js\"),\n    style: __webpack_require__(/*! ./style */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL25vZGUtZXhwb3J0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O3VGQUd1RixHQUN2RixvSEFBb0g7QUFDcEgsdURBQXVEO0FBQ3ZELE9BQU87QUFDUCxtREFBbUQ7QUFDbkQsdUNBQXVDO0FBQ3ZDLE9BQU87O0FBQ1BBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxLQUFLQyxtQkFBT0EsQ0FBQztJQUNiQyxVQUFVRCxtQkFBT0EsQ0FBQztJQUNsQkUsS0FBS0YsbUJBQU9BLENBQUM7SUFDYkcsUUFBUUgsbUJBQU9BLENBQUM7SUFDaEJJLE9BQU9KLG1CQUFPQSxDQUFDO0lBQ2ZLLE9BQU9MLG1CQUFPQSxDQUFDO0lBQ2ZNLE9BQU9OLG1CQUFPQSxDQUFDO0lBQ2ZPLFNBQVNQLG1CQUFPQSxDQUFDO0lBQ2pCUSxPQUFPUixtQkFBT0EsQ0FBQztBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL25vZGUtZXhwb3J0cy5qcz9iY2FmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIHNlcnZlcyB0byBleHBvcnQgYWxsIGxpYnJhcnkgb2JqZWN0cyBhbmQgb2JqZWN0IGNvbnN0cnVjdG9ycyB3aXRoIHRoZSBgcmVxdWlyZShcImFwZy1saWJcIilgIHN0YXRlbWVudC5cbi8vIEZvciBleGFtcGxlLCB0byBjcmVhdGUgYSBuZXcgcGFyc2VyIGluIHlvdXIgcHJvZ3JhbSxcbi8vIGBgYGBcbi8vIGxldCBhcGdsaWIgPSByZXF1aXJlKFwiLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHNcIik7XG4vLyBsZXQgbXktcGFyc2VyID0gbmV3IGFwZ2xpYi5wYXJzZXIoKTtcbi8vIGBgYGBcbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3Q6IHJlcXVpcmUoJy4vYXN0JyksXG4gIGNpcmN1bGFyOiByZXF1aXJlKCcuL2NpcmN1bGFyLWJ1ZmZlcicpLFxuICBpZHM6IHJlcXVpcmUoJy4vaWRlbnRpZmllcnMnKSxcbiAgcGFyc2VyOiByZXF1aXJlKCcuL3BhcnNlcicpLFxuICBzdGF0czogcmVxdWlyZSgnLi9zdGF0cycpLFxuICB0cmFjZTogcmVxdWlyZSgnLi90cmFjZScpLFxuICB1dGlsczogcmVxdWlyZSgnLi91dGlsaXRpZXMnKSxcbiAgZW1pdGNzczogcmVxdWlyZSgnLi9lbWl0Y3NzJyksXG4gIHN0eWxlOiByZXF1aXJlKCcuL3N0eWxlJyksXG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJhc3QiLCJyZXF1aXJlIiwiY2lyY3VsYXIiLCJpZHMiLCJwYXJzZXIiLCJzdGF0cyIsInRyYWNlIiwidXRpbHMiLCJlbWl0Y3NzIiwic3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/node-exports.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/parser.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/parser.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint-disable func-names */ /* eslint-disable no-restricted-syntax */ /* eslint-disable new-cap */ /* eslint-disable guard-for-in */ /*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This is the primary object of `apg-lib`. Calling its `parse()` member function\n// walks the parse tree of opcodes, matching phrases from the input string as it goes.\n// The working code for all of the operators, `ALT`, `CAT`, etc. is in this module.\n\nmodule.exports = function parser() {\n    const id = __webpack_require__(/*! ./identifiers */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n    const utils = __webpack_require__(/*! ./utilities */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\");\n    const thisFileName = \"parser.js: \";\n    const thisThis = this;\n    let opExecute;\n    this.ast = null;\n    this.stats = null;\n    this.trace = null;\n    this.callbacks = [];\n    let opcodes = null;\n    let chars = null;\n    let charsBegin;\n    let charsLength;\n    let charsEnd;\n    let lookAround;\n    let treeDepth = 0;\n    let maxTreeDepth = 0;\n    let nodeHits = 0;\n    let ruleCallbacks = null;\n    let udtCallbacks = null;\n    let rules = null;\n    let udts = null;\n    let syntaxData = null;\n    let maxMatched = 0;\n    let limitTreeDepth = Infinity;\n    let limitNodeHits = Infinity;\n    // Evaluates any given rule. This can be called from the syntax callback\n    // functions to evaluate any rule in the grammar's rule list. Great caution\n    // should be used. Use of this function will alter the language that the\n    // parser accepts.\n    const evaluateRule = function evaluateRule(ruleIndex, phraseIndex, sysData) {\n        const functionName = `${thisFileName}evaluateRule(): `;\n        if (ruleIndex >= rules.length) {\n            throw new Error(`${functionName}rule index: ${ruleIndex} out of range`);\n        }\n        if (phraseIndex >= charsEnd) {\n            throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n        }\n        const { length } = opcodes;\n        opcodes.push({\n            type: id.RNM,\n            index: ruleIndex\n        });\n        opExecute(length, phraseIndex, sysData);\n        opcodes.pop();\n    };\n    // Evaluates any given UDT. This can be called from the syntax callback\n    // functions to evaluate any UDT in the grammar's UDT list. Great caution\n    // should be used. Use of this function will alter the language that the\n    // parser accepts.\n    const evaluateUdt = function(udtIndex, phraseIndex, sysData) {\n        const functionName = `${thisFileName}evaluateUdt(): `;\n        if (udtIndex >= udts.length) {\n            throw new Error(`${functionName}udt index: ${udtIndex} out of range`);\n        }\n        if (phraseIndex >= charsEnd) {\n            throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n        }\n        const { length } = opcodes;\n        opcodes.push({\n            type: id.UDT,\n            empty: udts[udtIndex].empty,\n            index: udtIndex\n        });\n        opExecute(length, phraseIndex, sysData);\n        opcodes.pop();\n    };\n    /* Clears this object of any/all data that has been initialized or added to it. */ /* Called by parse() on initialization, allowing this object to be re-used for multiple parsing calls. */ const clear = function() {\n        treeDepth = 0;\n        maxTreeDepth = 0;\n        nodeHits = 0;\n        maxMatched = 0;\n        lookAround = [\n            {\n                lookAround: id.LOOKAROUND_NONE,\n                anchor: 0,\n                charsEnd: 0,\n                charsLength: 0\n            }\n        ];\n        rules = null;\n        udts = null;\n        chars = null;\n        charsBegin = 0;\n        charsLength = 0;\n        charsEnd = 0;\n        ruleCallbacks = null;\n        udtCallbacks = null;\n        syntaxData = null;\n        opcodes = null;\n    };\n    /* object for maintaining a stack of back reference frames */ const backRef = function() {\n        const stack = [];\n        const init = function() {\n            const obj = {};\n            rules.forEach((rule)=>{\n                if (rule.isBkr) {\n                    obj[rule.lower] = null;\n                }\n            });\n            if (udts.length > 0) {\n                udts.forEach((udt)=>{\n                    if (udt.isBkr) {\n                        obj[udt.lower] = null;\n                    }\n                });\n            }\n            stack.push(obj);\n        };\n        const copy = function() {\n            const top = stack[stack.length - 1];\n            const obj = {};\n            /* // eslint-disable-next-line no-restricted-syntax */ for(const name in top){\n                obj[name] = top[name];\n            }\n            return obj;\n        };\n        this.push = function push() {\n            stack.push(copy());\n        };\n        this.pop = function pop(lengthArg) {\n            let length = lengthArg;\n            if (!length) {\n                length = stack.length - 1;\n            }\n            if (length < 1 || length > stack.length) {\n                throw new Error(`${thisFileName}backRef.pop(): bad length: ${length}`);\n            }\n            stack.length = length;\n            return stack[stack.length - 1];\n        };\n        this.length = function length() {\n            return stack.length;\n        };\n        this.savePhrase = function savePhrase(name, index, length) {\n            stack[stack.length - 1][name] = {\n                phraseIndex: index,\n                phraseLength: length\n            };\n        };\n        this.getPhrase = function(name) {\n            return stack[stack.length - 1][name];\n        };\n        /* constructor */ init();\n    };\n    // The system data structure that relays system information to and from the rule and UDT callback functions.\n    // - *state* - the state of the parser, ACTIVE, MATCH, EMPTY or NOMATCH (see the `identifiers` object in\n    // [`apg-lib`](https://github.com/ldthomas/apg-js2-lib))\n    // - *phraseLength* - the number of characters matched if the state is MATCHED or EMPTY\n    // - *lookaround* - the top of the stack holds the current look around state,\n    // LOOKAROUND_NONE, LOOKAROUND_AHEAD or LOOKAROUND_BEHIND,\n    // - *uFrame* - the \"universal\" back reference frame.\n    // Holds the last matched phrase for each of the back referenced rules and UDTs.\n    // - *pFrame* - the stack of \"parent\" back reference frames.\n    // Holds the matched phrase from the parent frame of each back referenced rules and UDTs.\n    // - *evaluateRule* - a reference to this object's `evaluateRule()` function.\n    // Can be called from a callback function (use with extreme caution!)\n    // - *evaluateUdt* - a reference to this object's `evaluateUdt()` function.\n    // Can be called from a callback function (use with extreme caution!)\n    const systemData = function systemData() {\n        const thisData = this;\n        this.state = id.ACTIVE;\n        this.phraseLength = 0;\n        this.ruleIndex = 0;\n        this.udtIndex = 0;\n        this.lookAround = lookAround[lookAround.length - 1];\n        this.uFrame = new backRef();\n        this.pFrame = new backRef();\n        this.evaluateRule = evaluateRule;\n        this.evaluateUdt = evaluateUdt;\n        /* refresh the parser state for the next operation */ this.refresh = function refresh() {\n            thisData.state = id.ACTIVE;\n            thisData.phraseLength = 0;\n            thisData.lookAround = lookAround[lookAround.length - 1];\n        };\n    };\n    /* some look around helper functions */ const lookAroundValue = function lookAroundValue() {\n        return lookAround[lookAround.length - 1];\n    };\n    /* return true if parser is in look around (ahead or behind) state */ const inLookAround = function inLookAround() {\n        return lookAround.length > 1;\n    };\n    /* return true if parser is in look behind state */ const inLookBehind = function() {\n        return lookAround[lookAround.length - 1].lookAround === id.LOOKAROUND_BEHIND;\n    };\n    /* called by parse() to initialize the AST object, if one has been defined */ const initializeAst = function() {\n        const functionName = `${thisFileName}initializeAst(): `;\n        const TRUE = true;\n        while(TRUE){\n            if (thisThis.ast === undefined) {\n                thisThis.ast = null;\n                break;\n            }\n            if (thisThis.ast === null) {\n                break;\n            }\n            if (thisThis.ast.astObject !== \"astObject\") {\n                throw new Error(`${functionName}ast object not recognized`);\n            }\n            break;\n        }\n        if (thisThis.ast !== null) {\n            thisThis.ast.init(rules, udts, chars);\n        }\n    };\n    /* called by parse() to initialize the trace object, if one has been defined */ const initializeTrace = function() {\n        const functionName = `${thisFileName}initializeTrace(): `;\n        const TRUE = true;\n        while(TRUE){\n            if (thisThis.trace === undefined) {\n                thisThis.trace = null;\n                break;\n            }\n            if (thisThis.trace === null) {\n                break;\n            }\n            if (thisThis.trace.traceObject !== \"traceObject\") {\n                throw new Error(`${functionName}trace object not recognized`);\n            }\n            break;\n        }\n        if (thisThis.trace !== null) {\n            thisThis.trace.init(rules, udts, chars);\n        }\n    };\n    /* called by parse() to initialize the statistics object, if one has been defined */ const initializeStats = function() {\n        const functionName = `${thisFileName}initializeStats(): `;\n        const TRUE = true;\n        while(TRUE){\n            if (thisThis.stats === undefined) {\n                thisThis.stats = null;\n                break;\n            }\n            if (thisThis.stats === null) {\n                break;\n            }\n            if (thisThis.stats.statsObject !== \"statsObject\") {\n                throw new Error(`${functionName}stats object not recognized`);\n            }\n            break;\n        }\n        if (thisThis.stats !== null) {\n            thisThis.stats.init(rules, udts);\n        }\n    };\n    /* called by parse() to initialize the rules & udts from the grammar object */ /* (the grammar object generated previously by apg) */ const initializeGrammar = function(grammar) {\n        const functionName = `${thisFileName}initializeGrammar(): `;\n        if (!grammar) {\n            throw new Error(`${functionName}grammar object undefined`);\n        }\n        if (grammar.grammarObject !== \"grammarObject\") {\n            throw new Error(`${functionName}bad grammar object`);\n        }\n        rules = grammar.rules;\n        udts = grammar.udts;\n    };\n    /* called by parse() to initialize the start rule */ const initializeStartRule = function(startRule) {\n        const functionName = `${thisFileName}initializeStartRule(): `;\n        let start = null;\n        if (typeof startRule === \"number\") {\n            if (startRule >= rules.length) {\n                throw new Error(`${functionName}start rule index too large: max: ${rules.length}: index: ${startRule}`);\n            }\n            start = startRule;\n        } else if (typeof startRule === \"string\") {\n            const lower = startRule.toLowerCase();\n            for(let i = 0; i < rules.length; i += 1){\n                if (lower === rules[i].lower) {\n                    start = rules[i].index;\n                    break;\n                }\n            }\n            if (start === null) {\n                throw new Error(`${functionName}start rule name '${startRule}' not recognized`);\n            }\n        } else {\n            throw new Error(`${functionName}type of start rule '${typeof startRule}' not recognized`);\n        }\n        return start;\n    };\n    /* called by parse() to initialize the array of characters codes representing the input string */ const initializeInputChars = function initializeInputChars(inputArg, begArg, lenArg) {\n        const functionName = `${thisFileName}initializeInputChars(): `;\n        /* varify and normalize input */ let input = inputArg;\n        let beg = begArg;\n        let len = lenArg;\n        if (input === undefined) {\n            throw new Error(`${functionName}input string is undefined`);\n        }\n        if (input === null) {\n            throw new Error(`${functionName}input string is null`);\n        }\n        if (typeof input === \"string\") {\n            input = utils.stringToChars(input);\n        } else if (!Array.isArray(input)) {\n            throw new Error(`${functionName}input string is not a string or array`);\n        }\n        if (input.length > 0) {\n            if (typeof input[0] !== \"number\") {\n                throw new Error(`${functionName}input string not an array of integers`);\n            }\n        }\n        /* verify and normalize beginning index */ if (typeof beg !== \"number\") {\n            beg = 0;\n        } else {\n            beg = Math.floor(beg);\n            if (beg < 0 || beg > input.length) {\n                throw new Error(`${functionName}input beginning index out of range: ${beg}`);\n            }\n        }\n        /* verify and normalize input length */ if (typeof len !== \"number\") {\n            len = input.length - beg;\n        } else {\n            len = Math.floor(len);\n            if (len < 0 || len > input.length - beg) {\n                throw new Error(`${functionName}input length out of range: ${len}`);\n            }\n        }\n        chars = input;\n        charsBegin = beg;\n        charsLength = len;\n        charsEnd = charsBegin + charsLength;\n    };\n    /* called by parse() to initialize the user-written, syntax callback functions, if any */ const initializeCallbacks = function() {\n        const functionName = `${thisFileName}initializeCallbacks(): `;\n        let i;\n        ruleCallbacks = [];\n        udtCallbacks = [];\n        for(i = 0; i < rules.length; i += 1){\n            ruleCallbacks[i] = null;\n        }\n        for(i = 0; i < udts.length; i += 1){\n            udtCallbacks[i] = null;\n        }\n        let func;\n        const list = [];\n        for(i = 0; i < rules.length; i += 1){\n            list.push(rules[i].lower);\n        }\n        for(i = 0; i < udts.length; i += 1){\n            list.push(udts[i].lower);\n        }\n        for(const index in thisThis.callbacks){\n            i = list.indexOf(index.toLowerCase());\n            if (i < 0) {\n                throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);\n            }\n            func = thisThis.callbacks[index];\n            if (!func) {\n                func = null;\n            }\n            if (typeof func === \"function\" || func === null) {\n                if (i < rules.length) {\n                    ruleCallbacks[i] = func;\n                } else {\n                    udtCallbacks[i - rules.length] = func;\n                }\n            } else {\n                throw new Error(`${functionName}syntax callback[${index}] must be function reference or 'false' (false/null/undefined/etc.)`);\n            }\n        }\n        /* make sure all udts have been defined - the parser can't work without them */ for(i = 0; i < udts.length; i += 1){\n            if (udtCallbacks[i] === null) {\n                throw new Error(`${functionName}all UDT callbacks must be defined. UDT callback[${udts[i].lower}] not a function reference`);\n            }\n        }\n    };\n    // Set the maximum parse tree depth allowed. The default is `Infinity`.\n    // A limit is not normally needed, but can be used to protect against an\n    // exponentual or \"catastrophically backtracking\" grammar.\n    // <ul>\n    // <li>\n    // depth - max allowed parse tree depth. An exception is thrown if exceeded.\n    // </li>\n    // </ul>\n    this.setMaxTreeDepth = function(depth) {\n        if (typeof depth !== \"number\") {\n            throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n        }\n        limitTreeDepth = Math.floor(depth);\n        if (limitTreeDepth <= 0) {\n            throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n        }\n    };\n    // Set the maximum number of node hits (parser unit steps or opcode function calls) allowed.\n    // The default is `Infinity`.\n    // A limit is not normally needed, but can be used to protect against an\n    // exponentual or \"catastrophically backtracking\" grammar.\n    // <ul>\n    // <li>\n    // hits - maximum number of node hits or parser unit steps allowed.\n    // An exception thrown if exceeded.\n    // </li>\n    // </ul>\n    this.setMaxNodeHits = function(hits) {\n        if (typeof hits !== \"number\") {\n            throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n        }\n        limitNodeHits = Math.floor(hits);\n        if (limitNodeHits <= 0) {\n            throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n        }\n    };\n    /* the main parser function */ const privateParse = function(grammar, startRuleArg, callbackData) {\n        let success;\n        const functionName = `${thisFileName}parse(): `;\n        initializeGrammar(grammar);\n        const startRule = initializeStartRule(startRuleArg);\n        initializeCallbacks();\n        initializeTrace();\n        initializeStats();\n        initializeAst();\n        const sysData = new systemData();\n        if (!(callbackData === undefined || callbackData === null)) {\n            syntaxData = callbackData;\n        }\n        /* create a dummy opcode for the start rule */ opcodes = [\n            {\n                type: id.RNM,\n                index: startRule\n            }\n        ];\n        /* execute the start rule */ opExecute(0, charsBegin, sysData);\n        opcodes = null;\n        /* test and return the sysData */ switch(sysData.state){\n            case id.ACTIVE:\n                throw new Error(`${functionName}final state should never be 'ACTIVE'`);\n            case id.NOMATCH:\n                success = false;\n                break;\n            case id.EMPTY:\n            case id.MATCH:\n                if (sysData.phraseLength === charsLength) {\n                    success = true;\n                } else {\n                    success = false;\n                }\n                break;\n            default:\n                throw new Error(\"unrecognized state\");\n        }\n        return {\n            success,\n            state: sysData.state,\n            length: charsLength,\n            matched: sysData.phraseLength,\n            maxMatched,\n            maxTreeDepth,\n            nodeHits,\n            inputLength: chars.length,\n            subBegin: charsBegin,\n            subEnd: charsEnd,\n            subLength: charsLength\n        };\n    };\n    // This form allows parsing of a sub-string of the full input string.\n    // <ul>\n    // <li>*inputIndex* - index of the first character in the sub-string</li>\n    // <li>*inputLength* - length of the sub-string</li>\n    // </ul>\n    // All other parameters as for the above function `parse()`.\n    this.parseSubstring = function parseSubstring(grammar, startRule, inputChars, inputIndex, inputLength, callbackData) {\n        clear();\n        initializeInputChars(inputChars, inputIndex, inputLength);\n        return privateParse(grammar, startRule, callbackData);\n    };\n    // This is the main function, called to parse an input string.\n    // <ul>\n    // <li>*grammar* - an instantiated grammar object - the output of `apg` for a\n    // specific SABNF grammar</li>\n    // <li>*startRule* - the rule name or rule index to be used as the root of the\n    // parse tree. This is usually the first rule, index = 0, of the grammar\n    // but can be any rule defined in the above grammar object.</li>\n    // <li>*inputChars* - the input string. Can be a string or an array of integer character codes representing the\n    // string.</li>\n    // <li>*callbackData* - user-defined data object to be passed to the user's\n    // callback functions.\n    // This is not used by the parser in any way, merely passed on to the user.\n    // May be `null` or omitted.</li>\n    // </ul>\n    this.parse = function parse(grammar, startRule, inputChars, callbackData) {\n        clear();\n        initializeInputChars(inputChars, 0, inputChars.length);\n        return privateParse(grammar, startRule, callbackData);\n    };\n    // The `ALT` operator.<br>\n    // Executes its child nodes, from left to right, until it finds a match.\n    // Fails if *all* of its child nodes fail.\n    const opALT = function(opIndex, phraseIndex, sysData) {\n        const op = opcodes[opIndex];\n        for(let i = 0; i < op.children.length; i += 1){\n            opExecute(op.children[i], phraseIndex, sysData);\n            if (sysData.state !== id.NOMATCH) {\n                break;\n            }\n        }\n    };\n    // The `CAT` operator.<br>\n    // Executes all of its child nodes, from left to right,\n    // concatenating the matched phrases.\n    // Fails if *any* child nodes fail.\n    const opCAT = function(opIndex, phraseIndex, sysData) {\n        let success;\n        let astLength;\n        let catCharIndex;\n        let catPhrase;\n        const op = opcodes[opIndex];\n        const ulen = sysData.uFrame.length();\n        const plen = sysData.pFrame.length();\n        if (thisThis.ast) {\n            astLength = thisThis.ast.getLength();\n        }\n        success = true;\n        catCharIndex = phraseIndex;\n        catPhrase = 0;\n        for(let i = 0; i < op.children.length; i += 1){\n            opExecute(op.children[i], catCharIndex, sysData);\n            if (sysData.state === id.NOMATCH) {\n                success = false;\n                break;\n            } else {\n                catCharIndex += sysData.phraseLength;\n                catPhrase += sysData.phraseLength;\n            }\n        }\n        if (success) {\n            sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;\n            sysData.phraseLength = catPhrase;\n        } else {\n            sysData.state = id.NOMATCH;\n            sysData.phraseLength = 0;\n            /* reset the back referencing frames on failure */ sysData.uFrame.pop(ulen);\n            sysData.pFrame.pop(plen);\n            if (thisThis.ast) {\n                thisThis.ast.setLength(astLength);\n            }\n        }\n    };\n    // The `REP` operator.<br>\n    // Repeatedly executes its single child node,\n    // concatenating each of the matched phrases found.\n    // The number of repetitions executed and its final sysData depends\n    // on its `min` & `max` repetition values.\n    const opREP = function(opIndex, phraseIndex, sysData) {\n        let astLength;\n        let repCharIndex;\n        let repPhrase;\n        let repCount;\n        const op = opcodes[opIndex];\n        if (op.max === 0) {\n            // this is an empty-string acceptor\n            // deprecated: use the TLS empty string operator, \"\", instead\n            sysData.state = id.EMPTY;\n            sysData.phraseLength = 0;\n            return;\n        }\n        repCharIndex = phraseIndex;\n        repPhrase = 0;\n        repCount = 0;\n        const ulen = sysData.uFrame.length();\n        const plen = sysData.pFrame.length();\n        if (thisThis.ast) {\n            astLength = thisThis.ast.getLength();\n        }\n        const TRUE = true;\n        while(TRUE){\n            if (repCharIndex >= charsEnd) {\n                break;\n            }\n            opExecute(opIndex + 1, repCharIndex, sysData);\n            if (sysData.state === id.NOMATCH) {\n                break;\n            }\n            if (sysData.state === id.EMPTY) {\n                break;\n            }\n            repCount += 1;\n            repPhrase += sysData.phraseLength;\n            repCharIndex += sysData.phraseLength;\n            if (repCount === op.max) {\n                break;\n            }\n        }\n        /* evaluate the match count according to the min, max values */ if (sysData.state === id.EMPTY) {\n            sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n            sysData.phraseLength = repPhrase;\n        } else if (repCount >= op.min) {\n            sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n            sysData.phraseLength = repPhrase;\n        } else {\n            sysData.state = id.NOMATCH;\n            sysData.phraseLength = 0;\n            /* reset the back referencing frames on failure */ sysData.uFrame.pop(ulen);\n            sysData.pFrame.pop(plen);\n            if (thisThis.ast) {\n                thisThis.ast.setLength(astLength);\n            }\n        }\n    };\n    // Validate the callback function's returned sysData values.\n    // It's the user's responsibility to get them right\n    // but `RNM` fails if not.\n    const validateRnmCallbackResult = function(rule, sysData, charsLeft, down) {\n        if (sysData.phraseLength > charsLeft) {\n            let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;\n            str += `sysData.phraseLength: ${sysData.phraseLength}`;\n            str += ` must be <= remaining chars: ${charsLeft}`;\n            throw new Error(str);\n        }\n        switch(sysData.state){\n            case id.ACTIVE:\n                if (down !== true) {\n                    throw new Error(`${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`);\n                }\n                break;\n            case id.EMPTY:\n                sysData.phraseLength = 0;\n                break;\n            case id.MATCH:\n                if (sysData.phraseLength === 0) {\n                    sysData.state = id.EMPTY;\n                }\n                break;\n            case id.NOMATCH:\n                sysData.phraseLength = 0;\n                break;\n            default:\n                throw new Error(`${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`);\n        }\n    };\n    // The `RNM` operator.<br>\n    // This operator will acts as a root node for a parse tree branch below and\n    // returns the matched phrase to its parent.\n    // However, its larger responsibility is handling user-defined callback functions, back references and `AST` nodes.\n    // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.\n    // See [`ast.js`](./ast.html) for usage.\n    const opRNM = function(opIndex, phraseIndex, sysData) {\n        let astLength;\n        let astDefined;\n        let savedOpcodes;\n        let ulen;\n        let plen;\n        let saveFrame;\n        const op = opcodes[opIndex];\n        const rule = rules[op.index];\n        const callback = ruleCallbacks[rule.index];\n        const notLookAround = !inLookAround();\n        /* ignore AST and back references in lookaround */ if (notLookAround) {\n            /* begin AST and back references */ astDefined = thisThis.ast && thisThis.ast.ruleDefined(op.index);\n            if (astDefined) {\n                astLength = thisThis.ast.getLength();\n                thisThis.ast.down(op.index, rules[op.index].name);\n            }\n            ulen = sysData.uFrame.length();\n            plen = sysData.pFrame.length();\n            sysData.uFrame.push();\n            sysData.pFrame.push();\n            saveFrame = sysData.pFrame;\n            sysData.pFrame = new backRef();\n        }\n        if (callback === null) {\n            /* no callback - just execute the rule */ savedOpcodes = opcodes;\n            opcodes = rule.opcodes;\n            opExecute(0, phraseIndex, sysData);\n            opcodes = savedOpcodes;\n        } else {\n            /* call user's callback */ const charsLeft = charsEnd - phraseIndex;\n            sysData.ruleIndex = rule.index;\n            callback(sysData, chars, phraseIndex, syntaxData);\n            validateRnmCallbackResult(rule, sysData, charsLeft, true);\n            if (sysData.state === id.ACTIVE) {\n                savedOpcodes = opcodes;\n                opcodes = rule.opcodes;\n                opExecute(0, phraseIndex, sysData);\n                opcodes = savedOpcodes;\n                sysData.ruleIndex = rule.index;\n                callback(sysData, chars, phraseIndex, syntaxData);\n                validateRnmCallbackResult(rule, sysData, charsLeft, false);\n            } /* implied else clause: just accept the callback sysData - RNM acting as UDT */ \n        }\n        if (notLookAround) {\n            /* end AST */ if (astDefined) {\n                if (sysData.state === id.NOMATCH) {\n                    thisThis.ast.setLength(astLength);\n                } else {\n                    thisThis.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);\n                }\n            }\n            /* end back reference */ sysData.pFrame = saveFrame;\n            if (sysData.state === id.NOMATCH) {\n                sysData.uFrame.pop(ulen);\n                sysData.pFrame.pop(plen);\n            } else if (rule.isBkr) {\n                /* save phrase on both the parent and universal frames */ /* BKR operator will decide which to use later */ sysData.pFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n                sysData.uFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n            }\n        }\n    };\n    // Validate the callback function's returned sysData values.\n    // It's the user's responsibility to get it right but `UDT` fails if not.\n    const validateUdtCallbackResult = function(udt, sysData, charsLeft) {\n        if (sysData.phraseLength > charsLeft) {\n            let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;\n            str += `sysData.phraseLength: ${sysData.phraseLength}`;\n            str += ` must be <= remaining chars: ${charsLeft}`;\n            throw new Error(str);\n        }\n        switch(sysData.state){\n            case id.ACTIVE:\n                throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. ACTIVE state not allowed.`);\n            case id.EMPTY:\n                if (udt.empty === false) {\n                    throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n                } else {\n                    sysData.phraseLength = 0;\n                }\n                break;\n            case id.MATCH:\n                if (sysData.phraseLength === 0) {\n                    if (udt.empty === false) {\n                        throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n                    } else {\n                        sysData.state = id.EMPTY;\n                    }\n                }\n                break;\n            case id.NOMATCH:\n                sysData.phraseLength = 0;\n                break;\n            default:\n                throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`);\n        }\n    };\n    // The `UDT` operator.<br>\n    // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`\n    // and back referencing.\n    // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules\n    // for `AST` nodes and back referencing.\n    // See [`ast.js`](./ast.html) for usage.\n    const opUDT = function(opIndex, phraseIndex, sysData) {\n        let astLength;\n        let astIndex;\n        let astDefined;\n        let ulen;\n        let plen;\n        let saveFrame;\n        const op = opcodes[opIndex];\n        const udt = udts[op.index];\n        sysData.UdtIndex = udt.index;\n        const notLookAround = !inLookAround();\n        /* ignore AST and back references in lookaround */ if (notLookAround) {\n            /* begin AST and back reference */ astDefined = thisThis.ast && thisThis.ast.udtDefined(op.index);\n            if (astDefined) {\n                astIndex = rules.length + op.index;\n                astLength = thisThis.ast.getLength();\n                thisThis.ast.down(astIndex, udt.name);\n            }\n            /* NOTE: push and pop of the back reference frame is normally not necessary */ /* only in the case that the UDT calls evaluateRule() or evaluateUdt() */ ulen = sysData.uFrame.length();\n            plen = sysData.pFrame.length();\n            sysData.uFrame.push();\n            sysData.pFrame.push();\n            saveFrame = sysData.pFrame;\n            sysData.pFrame = new backRef();\n        }\n        /* call the UDT */ const charsLeft = charsEnd - phraseIndex;\n        udtCallbacks[op.index](sysData, chars, phraseIndex, syntaxData);\n        validateUdtCallbackResult(udt, sysData, charsLeft);\n        if (notLookAround) {\n            /* end AST */ if (astDefined) {\n                if (sysData.state === id.NOMATCH) {\n                    thisThis.ast.setLength(astLength);\n                } else {\n                    thisThis.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);\n                }\n            }\n            /* end back reference */ sysData.pFrame = saveFrame;\n            if (sysData.state === id.NOMATCH) {\n                sysData.uFrame.pop(ulen);\n                sysData.pFrame.pop(plen);\n            } else if (udt.isBkr) {\n                /* save phrase on both the parent and universal frames */ /* BKR operator will decide which to use later */ sysData.pFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n                sysData.uFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n            }\n        }\n    };\n    // The `AND` operator.<br>\n    // This is the positive `look ahead` operator.\n    // Executes its single child node, returning the EMPTY state\n    // if it succeedsand NOMATCH if it fails.\n    // *Always* backtracks on any matched phrase and returns EMPTY on success.\n    const opAND = function(opIndex, phraseIndex, sysData) {\n        lookAround.push({\n            lookAround: id.LOOKAROUND_AHEAD,\n            anchor: phraseIndex,\n            charsEnd,\n            charsLength\n        });\n        charsEnd = chars.length;\n        charsLength = chars.length - charsBegin;\n        opExecute(opIndex + 1, phraseIndex, sysData);\n        const pop = lookAround.pop();\n        charsEnd = pop.charsEnd;\n        charsLength = pop.charsLength;\n        sysData.phraseLength = 0;\n        switch(sysData.state){\n            case id.EMPTY:\n                sysData.state = id.EMPTY;\n                break;\n            case id.MATCH:\n                sysData.state = id.EMPTY;\n                break;\n            case id.NOMATCH:\n                sysData.state = id.NOMATCH;\n                break;\n            default:\n                throw new Error(`opAND: invalid state ${sysData.state}`);\n        }\n    };\n    // The `NOT` operator.<br>\n    // This is the negative `look ahead` operator.\n    // Executes its single child node, returning the EMPTY state\n    // if it *fails* and NOMATCH if it succeeds.\n    // *Always* backtracks on any matched phrase and returns EMPTY\n    // on success (failure of its child node).\n    const opNOT = function(opIndex, phraseIndex, sysData) {\n        lookAround.push({\n            lookAround: id.LOOKAROUND_AHEAD,\n            anchor: phraseIndex,\n            charsEnd,\n            charsLength\n        });\n        charsEnd = chars.length;\n        charsLength = chars.length - charsBegin;\n        opExecute(opIndex + 1, phraseIndex, sysData);\n        const pop = lookAround.pop();\n        charsEnd = pop.charsEnd;\n        charsLength = pop.charsLength;\n        sysData.phraseLength = 0;\n        switch(sysData.state){\n            case id.EMPTY:\n            case id.MATCH:\n                sysData.state = id.NOMATCH;\n                break;\n            case id.NOMATCH:\n                sysData.state = id.EMPTY;\n                break;\n            default:\n                throw new Error(`opNOT: invalid state ${sysData.state}`);\n        }\n    };\n    // The `TRG` operator.<br>\n    // Succeeds if the single first character of the phrase is\n    // within the `min - max` range.\n    const opTRG = function(opIndex, phraseIndex, sysData) {\n        const op = opcodes[opIndex];\n        sysData.state = id.NOMATCH;\n        if (phraseIndex < charsEnd) {\n            if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {\n                sysData.state = id.MATCH;\n                sysData.phraseLength = 1;\n            }\n        }\n    };\n    // The `TBS` operator.<br>\n    // Matches its pre-defined phrase against the input string.\n    // All characters must match exactly.\n    // Case-sensitive literal strings (`'string'` & `%s\"string\"`) are translated to `TBS`\n    // operators by `apg`.\n    // Phrase length of zero is not allowed.\n    // Empty phrases can only be defined with `TLS` operators.\n    const opTBS = function(opIndex, phraseIndex, sysData) {\n        let i;\n        const op = opcodes[opIndex];\n        const len = op.string.length;\n        sysData.state = id.NOMATCH;\n        if (phraseIndex + len <= charsEnd) {\n            for(i = 0; i < len; i += 1){\n                if (chars[phraseIndex + i] !== op.string[i]) {\n                    return;\n                }\n            }\n            sysData.state = id.MATCH;\n            sysData.phraseLength = len;\n        } /* implied else NOMATCH */ \n    };\n    // The `TLS` operator.<br>\n    // Matches its pre-defined phrase against the input string.\n    // A case-insensitive match is attempted for ASCII alphbetical characters.\n    // `TLS` is the only operator that explicitly allows empty phrases.\n    // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or\n    // zero repetitions (`0*0RuleName` or `0RuleName`).\n    const opTLS = function(opIndex, phraseIndex, sysData) {\n        let i;\n        let code;\n        const op = opcodes[opIndex];\n        sysData.state = id.NOMATCH;\n        const len = op.string.length;\n        if (len === 0) {\n            /* EMPTY match allowed for TLS */ sysData.state = id.EMPTY;\n            return;\n        }\n        if (phraseIndex + len <= charsEnd) {\n            for(i = 0; i < len; i += 1){\n                code = chars[phraseIndex + i];\n                if (code >= 65 && code <= 90) {\n                    code += 32;\n                }\n                if (code !== op.string[i]) {\n                    return;\n                }\n            }\n            sysData.state = id.MATCH;\n            sysData.phraseLength = len;\n        } /* implied else NOMATCH */ \n    };\n    // The `ABG` operator.<br>\n    // This is an \"anchor\" for the beginning of the string, similar to the familiar regex `^` anchor.\n    // An anchor matches a position rather than a phrase.\n    // Returns EMPTY if `phraseIndex` is 0, NOMATCH otherwise.\n    const opABG = function(opIndex, phraseIndex, sysData) {\n        sysData.state = id.NOMATCH;\n        sysData.phraseLength = 0;\n        sysData.state = phraseIndex === 0 ? id.EMPTY : id.NOMATCH;\n    };\n    // The `AEN` operator.<br>\n    // This is an \"anchor\" for the end of the string, similar to the familiar regex `$` anchor.\n    // An anchor matches a position rather than a phrase.\n    // Returns EMPTY if `phraseIndex` equals the input string length, NOMATCH otherwise.\n    const opAEN = function(opIndex, phraseIndex, sysData) {\n        sysData.state = id.NOMATCH;\n        sysData.phraseLength = 0;\n        sysData.state = phraseIndex === chars.length ? id.EMPTY : id.NOMATCH;\n    };\n    // The `BKR` operator.<br>\n    // The back reference operator.\n    // Matches the last matched phrase of the named rule or UDT against the input string.\n    // For ASCII alphbetical characters the match may be case sensitive (`%s`) or insensitive (`%i`),\n    // depending on the back reference definition.\n    // For `universal` mode (`%u`) matches the last phrase found anywhere in the grammar.\n    // For `parent frame` mode (`%p`) matches the last phrase found in the parent rule only.\n    const opBKR = function(opIndex, phraseIndex, sysData) {\n        let i;\n        let code;\n        let lmcode;\n        let lower;\n        const op = opcodes[opIndex];\n        sysData.state = id.NOMATCH;\n        if (op.index < rules.length) {\n            lower = rules[op.index].lower;\n        } else {\n            lower = udts[op.index - rules.length].lower;\n        }\n        const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n        const insensitive = op.bkrCase === id.BKR_MODE_CI;\n        if (frame === null) {\n            return;\n        }\n        const lmIndex = frame.phraseIndex;\n        const len = frame.phraseLength;\n        if (len === 0) {\n            sysData.state = id.EMPTY;\n            return;\n        }\n        if (phraseIndex + len <= charsEnd) {\n            if (insensitive) {\n                /* case-insensitive match */ for(i = 0; i < len; i += 1){\n                    code = chars[phraseIndex + i];\n                    lmcode = chars[lmIndex + i];\n                    if (code >= 65 && code <= 90) {\n                        code += 32;\n                    }\n                    if (lmcode >= 65 && lmcode <= 90) {\n                        lmcode += 32;\n                    }\n                    if (code !== lmcode) {\n                        return;\n                    }\n                }\n                sysData.state = id.MATCH;\n                sysData.phraseLength = len;\n            } else {\n                /* case-sensitive match */ for(i = 0; i < len; i += 1){\n                    code = chars[phraseIndex + i];\n                    lmcode = chars[lmIndex + i];\n                    if (code !== lmcode) {\n                        return;\n                    }\n                }\n            }\n            sysData.state = id.MATCH;\n            sysData.phraseLength = len;\n        }\n    };\n    // The `BKA` operator.<br>\n    // This is the positive `look behind` operator.\n    // It's child node is parsed right-to-left.\n    // Returns the EMPTY state if a match is found, NOMATCH otherwise.\n    // Like the look ahead operators, it always backtracks to `phraseIndex`.\n    const opBKA = function(opIndex, phraseIndex, sysData) {\n        lookAround.push({\n            lookAround: id.LOOKAROUND_BEHIND,\n            anchor: phraseIndex\n        });\n        opExecute(opIndex + 1, phraseIndex, sysData);\n        lookAround.pop();\n        sysData.phraseLength = 0;\n        switch(sysData.state){\n            case id.EMPTY:\n                sysData.state = id.EMPTY;\n                break;\n            case id.MATCH:\n                sysData.state = id.EMPTY;\n                break;\n            case id.NOMATCH:\n                sysData.state = id.NOMATCH;\n                break;\n            default:\n                throw new Error(`opBKA: invalid state ${sysData.state}`);\n        }\n    };\n    // The `BKN` operator.<br>\n    // This is the negative `look behind` operator.\n    // It's child node is parsed right-to-left.\n    // Returns the EMPTY state if a match is *not* found, NOMATCH otherwise.\n    // Like the look ahead operators, it always backtracks to `phraseIndex`.\n    const opBKN = function(opIndex, phraseIndex, sysData) {\n        // let op;\n        // op = opcodes[opIndex];\n        lookAround.push({\n            lookAround: id.LOOKAROUND_BEHIND,\n            anchor: phraseIndex\n        });\n        opExecute(opIndex + 1, phraseIndex, sysData);\n        lookAround.pop();\n        sysData.phraseLength = 0;\n        switch(sysData.state){\n            case id.EMPTY:\n            case id.MATCH:\n                sysData.state = id.NOMATCH;\n                break;\n            case id.NOMATCH:\n                sysData.state = id.EMPTY;\n                break;\n            default:\n                throw new Error(`opBKN: invalid state ${sysData.state}`);\n        }\n    };\n    // The right-to-left `CAT` operator.<br>\n    // Called for `CAT` operators when in look behind mode.\n    // Calls its child nodes from right to left concatenating matched phrases right to left.\n    const opCATBehind = function(opIndex, phraseIndex, sysData) {\n        let success;\n        let astLength;\n        let catCharIndex;\n        let catMatched;\n        const op = opcodes[opIndex];\n        const ulen = sysData.uFrame.length();\n        const plen = sysData.pFrame.length();\n        if (thisThis.ast) {\n            astLength = thisThis.ast.getLength();\n        }\n        success = true;\n        catCharIndex = phraseIndex;\n        catMatched = 0;\n        // catPhrase = 0;\n        for(let i = op.children.length - 1; i >= 0; i -= 1){\n            opExecute(op.children[i], catCharIndex, sysData);\n            catCharIndex -= sysData.phraseLength;\n            catMatched += sysData.phraseLength;\n            // catPhrase += sysData.phraseLength;\n            if (sysData.state === id.NOMATCH) {\n                success = false;\n                break;\n            }\n        }\n        if (success) {\n            sysData.state = catMatched === 0 ? id.EMPTY : id.MATCH;\n            sysData.phraseLength = catMatched;\n        } else {\n            sysData.state = id.NOMATCH;\n            sysData.phraseLength = 0;\n            sysData.uFrame.pop(ulen);\n            sysData.pFrame.pop(plen);\n            if (thisThis.ast) {\n                thisThis.ast.setLength(astLength);\n            }\n        }\n    };\n    // The right-to-left `REP` operator.<br>\n    // Called for `REP` operators in look behind mode.\n    // Makes repeated calls to its child node, concatenating matched phrases right to left.\n    const opREPBehind = function(opIndex, phraseIndex, sysData) {\n        let astLength;\n        let repCharIndex;\n        let repPhrase;\n        let repCount;\n        const op = opcodes[opIndex];\n        repCharIndex = phraseIndex;\n        repPhrase = 0;\n        repCount = 0;\n        const ulen = sysData.uFrame.length();\n        const plen = sysData.pFrame.length();\n        if (thisThis.ast) {\n            astLength = thisThis.ast.getLength();\n        }\n        const TRUE = true;\n        while(TRUE){\n            if (repCharIndex <= 0) {\n                break;\n            }\n            opExecute(opIndex + 1, repCharIndex, sysData);\n            if (sysData.state === id.NOMATCH) {\n                break;\n            }\n            if (sysData.state === id.EMPTY) {\n                break;\n            }\n            repCount += 1;\n            repPhrase += sysData.phraseLength;\n            repCharIndex -= sysData.phraseLength;\n            if (repCount === op.max) {\n                break;\n            }\n        }\n        /* evaluate the match count according to the min, max values */ if (sysData.state === id.EMPTY) {\n            sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n            sysData.phraseLength = repPhrase;\n        } else if (repCount >= op.min) {\n            sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n            sysData.phraseLength = repPhrase;\n        } else {\n            sysData.state = id.NOMATCH;\n            sysData.phraseLength = 0;\n            sysData.uFrame.pop(ulen);\n            sysData.pFrame.pop(plen);\n            if (thisThis.ast) {\n                thisThis.ast.setLength(astLength);\n            }\n        }\n    };\n    // The right-to-left `TRG` operator.<br>\n    // Called for `TRG` operators in look behind mode.\n    // Matches a single character at `phraseIndex - 1` to the `min` - `max` range.\n    const opTRGBehind = function(opIndex, phraseIndex, sysData) {\n        const op = opcodes[opIndex];\n        sysData.state = id.NOMATCH;\n        sysData.phraseLength = 0;\n        if (phraseIndex > 0) {\n            const char = chars[phraseIndex - 1];\n            if (op.min <= char && char <= op.max) {\n                sysData.state = id.MATCH;\n                sysData.phraseLength = 1;\n            }\n        }\n    };\n    // The right-to-left `TBS` operator.<br>\n    // Called for `TBS` operators in look behind mode.\n    // Matches the `TBS` phrase to the left of `phraseIndex`.\n    const opTBSBehind = function(opIndex, phraseIndex, sysData) {\n        let i;\n        const op = opcodes[opIndex];\n        sysData.state = id.NOMATCH;\n        const len = op.string.length;\n        const beg = phraseIndex - len;\n        if (beg >= 0) {\n            for(i = 0; i < len; i += 1){\n                if (chars[beg + i] !== op.string[i]) {\n                    return;\n                }\n            }\n            sysData.state = id.MATCH;\n            sysData.phraseLength = len;\n        }\n    };\n    // The right-to-left `TLS` operator.<br>\n    // Called for `TLS` operators in look behind mode.\n    // Matches the `TLS` phrase to the left of `phraseIndex`.\n    const opTLSBehind = function(opIndex, phraseIndex, sysData) {\n        let char;\n        const op = opcodes[opIndex];\n        sysData.state = id.NOMATCH;\n        const len = op.string.length;\n        if (len === 0) {\n            /* EMPTY match allowed for TLS */ sysData.state = id.EMPTY;\n            return;\n        }\n        const beg = phraseIndex - len;\n        if (beg >= 0) {\n            for(let i = 0; i < len; i += 1){\n                char = chars[beg + i];\n                if (char >= 65 && char <= 90) {\n                    char += 32;\n                }\n                if (char !== op.string[i]) {\n                    return;\n                }\n            }\n            sysData.state = id.MATCH;\n            sysData.phraseLength = len;\n        }\n    };\n    // The right-to-left back reference operator.<br>\n    // Matches the back referenced phrase to the left of `phraseIndex`.\n    const opBKRBehind = function(opIndex, phraseIndex, sysData) {\n        let i;\n        let code;\n        let lmcode;\n        let lower;\n        const op = opcodes[opIndex];\n        /* NOMATCH default */ sysData.state = id.NOMATCH;\n        sysData.phraseLength = 0;\n        if (op.index < rules.length) {\n            lower = rules[op.index].lower;\n        } else {\n            lower = udts[op.index - rules.length].lower;\n        }\n        const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n        const insensitive = op.bkrCase === id.BKR_MODE_CI;\n        if (frame === null) {\n            return;\n        }\n        const lmIndex = frame.phraseIndex;\n        const len = frame.phraseLength;\n        if (len === 0) {\n            sysData.state = id.EMPTY;\n            sysData.phraseLength = 0;\n            return;\n        }\n        const beg = phraseIndex - len;\n        if (beg >= 0) {\n            if (insensitive) {\n                /* case-insensitive match */ for(i = 0; i < len; i += 1){\n                    code = chars[beg + i];\n                    lmcode = chars[lmIndex + i];\n                    if (code >= 65 && code <= 90) {\n                        code += 32;\n                    }\n                    if (lmcode >= 65 && lmcode <= 90) {\n                        lmcode += 32;\n                    }\n                    if (code !== lmcode) {\n                        return;\n                    }\n                }\n                sysData.state = id.MATCH;\n                sysData.phraseLength = len;\n            } else {\n                /* case-sensitive match */ for(i = 0; i < len; i += 1){\n                    code = chars[beg + i];\n                    lmcode = chars[lmIndex + i];\n                    if (code !== lmcode) {\n                        return;\n                    }\n                }\n            }\n            sysData.state = id.MATCH;\n            sysData.phraseLength = len;\n        }\n    };\n    // Generalized execution function.<br>\n    // Having a single, generalized function, allows a single location\n    // for tracing and statistics gathering functions to be called.\n    // Tracing and statistics are handled in separate objects.\n    // However, the parser calls their API to build the object data records.\n    // See [`trace.js`](./trace.html) and [`stats.js`](./stats.html) for their\n    // usage.\n    opExecute = function opExecuteFunc(opIndex, phraseIndex, sysData) {\n        let ret = true;\n        const op = opcodes[opIndex];\n        nodeHits += 1;\n        if (nodeHits > limitNodeHits) {\n            throw new Error(`parser: maximum number of node hits exceeded: ${limitNodeHits}`);\n        }\n        treeDepth += 1;\n        if (treeDepth > maxTreeDepth) {\n            maxTreeDepth = treeDepth;\n            if (maxTreeDepth > limitTreeDepth) {\n                throw new Error(`parser: maximum parse tree depth exceeded: ${limitTreeDepth}`);\n            }\n        }\n        sysData.refresh();\n        if (thisThis.trace !== null) {\n            /* collect the trace record for down the parse tree */ const lk = lookAroundValue();\n            thisThis.trace.down(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n        }\n        if (inLookBehind()) {\n            switch(op.type){\n                case id.ALT:\n                    opALT(opIndex, phraseIndex, sysData);\n                    break;\n                case id.CAT:\n                    opCATBehind(opIndex, phraseIndex, sysData);\n                    break;\n                case id.REP:\n                    opREPBehind(opIndex, phraseIndex, sysData);\n                    break;\n                case id.RNM:\n                    opRNM(opIndex, phraseIndex, sysData);\n                    break;\n                case id.UDT:\n                    opUDT(opIndex, phraseIndex, sysData);\n                    break;\n                case id.AND:\n                    opAND(opIndex, phraseIndex, sysData);\n                    break;\n                case id.NOT:\n                    opNOT(opIndex, phraseIndex, sysData);\n                    break;\n                case id.TRG:\n                    opTRGBehind(opIndex, phraseIndex, sysData);\n                    break;\n                case id.TBS:\n                    opTBSBehind(opIndex, phraseIndex, sysData);\n                    break;\n                case id.TLS:\n                    opTLSBehind(opIndex, phraseIndex, sysData);\n                    break;\n                case id.BKR:\n                    opBKRBehind(opIndex, phraseIndex, sysData);\n                    break;\n                case id.BKA:\n                    opBKA(opIndex, phraseIndex, sysData);\n                    break;\n                case id.BKN:\n                    opBKN(opIndex, phraseIndex, sysData);\n                    break;\n                case id.ABG:\n                    opABG(opIndex, phraseIndex, sysData);\n                    break;\n                case id.AEN:\n                    opAEN(opIndex, phraseIndex, sysData);\n                    break;\n                default:\n                    ret = false;\n                    break;\n            }\n        } else {\n            switch(op.type){\n                case id.ALT:\n                    opALT(opIndex, phraseIndex, sysData);\n                    break;\n                case id.CAT:\n                    opCAT(opIndex, phraseIndex, sysData);\n                    break;\n                case id.REP:\n                    opREP(opIndex, phraseIndex, sysData);\n                    break;\n                case id.RNM:\n                    opRNM(opIndex, phraseIndex, sysData);\n                    break;\n                case id.UDT:\n                    opUDT(opIndex, phraseIndex, sysData);\n                    break;\n                case id.AND:\n                    opAND(opIndex, phraseIndex, sysData);\n                    break;\n                case id.NOT:\n                    opNOT(opIndex, phraseIndex, sysData);\n                    break;\n                case id.TRG:\n                    opTRG(opIndex, phraseIndex, sysData);\n                    break;\n                case id.TBS:\n                    opTBS(opIndex, phraseIndex, sysData);\n                    break;\n                case id.TLS:\n                    opTLS(opIndex, phraseIndex, sysData);\n                    break;\n                case id.BKR:\n                    opBKR(opIndex, phraseIndex, sysData);\n                    break;\n                case id.BKA:\n                    opBKA(opIndex, phraseIndex, sysData);\n                    break;\n                case id.BKN:\n                    opBKN(opIndex, phraseIndex, sysData);\n                    break;\n                case id.ABG:\n                    opABG(opIndex, phraseIndex, sysData);\n                    break;\n                case id.AEN:\n                    opAEN(opIndex, phraseIndex, sysData);\n                    break;\n                default:\n                    ret = false;\n                    break;\n            }\n        }\n        if (!inLookAround() && phraseIndex + sysData.phraseLength > maxMatched) {\n            maxMatched = phraseIndex + sysData.phraseLength;\n        }\n        if (thisThis.stats !== null) {\n            /* collect the statistics */ thisThis.stats.collect(op, sysData);\n        }\n        if (thisThis.trace !== null) {\n            /* collect the trace record for up the parse tree */ const lk = lookAroundValue();\n            thisThis.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n        }\n        treeDepth -= 1;\n        return ret;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2QkFBNkIsR0FDN0IsdUNBQXVDLEdBQ3ZDLDBCQUEwQixHQUMxQiwrQkFBK0IsR0FDL0I7Ozt1RkFHdUYsR0FDdkYsaUZBQWlGO0FBQ2pGLHNGQUFzRjtBQUN0RixtRkFBbUY7O0FBQ25GQSxPQUFPQyxPQUFPLEdBQUcsU0FBU0M7SUFDeEIsTUFBTUMsS0FBS0MsbUJBQU9BLENBQUM7SUFDbkIsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7SUFFdEIsTUFBTUUsZUFBZTtJQUNyQixNQUFNQyxXQUFXLElBQUk7SUFDckIsSUFBSUM7SUFDSixJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLFNBQVMsR0FBRyxFQUFFO0lBQ25CLElBQUlDLFVBQVU7SUFDZCxJQUFJQyxRQUFRO0lBQ1osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQyxZQUFZO0lBQ2hCLElBQUlDLGVBQWU7SUFDbkIsSUFBSUMsV0FBVztJQUNmLElBQUlDLGdCQUFnQjtJQUNwQixJQUFJQyxlQUFlO0lBQ25CLElBQUlDLFFBQVE7SUFDWixJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsYUFBYTtJQUNqQixJQUFJQyxhQUFhO0lBQ2pCLElBQUlDLGlCQUFpQkM7SUFDckIsSUFBSUMsZ0JBQWdCRDtJQUNwQix3RUFBd0U7SUFDeEUsMkVBQTJFO0lBQzNFLHdFQUF3RTtJQUN4RSxrQkFBa0I7SUFDbEIsTUFBTUUsZUFBZSxTQUFTQSxhQUFhQyxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsT0FBTztRQUN4RSxNQUFNQyxlQUFlLENBQUMsRUFBRTdCLGFBQWEsZ0JBQWdCLENBQUM7UUFDdEQsSUFBSTBCLGFBQWFSLE1BQU1ZLE1BQU0sRUFBRTtZQUM3QixNQUFNLElBQUlDLE1BQU0sQ0FBQyxFQUFFRixhQUFhLFlBQVksRUFBRUgsVUFBVSxhQUFhLENBQUM7UUFDeEU7UUFDQSxJQUFJQyxlQUFlaEIsVUFBVTtZQUMzQixNQUFNLElBQUlvQixNQUFNLENBQUMsRUFBRUYsYUFBYSxjQUFjLEVBQUVGLFlBQVksYUFBYSxDQUFDO1FBQzVFO1FBQ0EsTUFBTSxFQUFFRyxNQUFNLEVBQUUsR0FBR3ZCO1FBQ25CQSxRQUFReUIsSUFBSSxDQUFDO1lBQ1hDLE1BQU1wQyxHQUFHcUMsR0FBRztZQUNaQyxPQUFPVDtRQUNUO1FBQ0F4QixVQUFVNEIsUUFBUUgsYUFBYUM7UUFDL0JyQixRQUFRNkIsR0FBRztJQUNiO0lBQ0EsdUVBQXVFO0lBQ3ZFLHlFQUF5RTtJQUN6RSx3RUFBd0U7SUFDeEUsa0JBQWtCO0lBQ2xCLE1BQU1DLGNBQWMsU0FBVUMsUUFBUSxFQUFFWCxXQUFXLEVBQUVDLE9BQU87UUFDMUQsTUFBTUMsZUFBZSxDQUFDLEVBQUU3QixhQUFhLGVBQWUsQ0FBQztRQUNyRCxJQUFJc0MsWUFBWW5CLEtBQUtXLE1BQU0sRUFBRTtZQUMzQixNQUFNLElBQUlDLE1BQU0sQ0FBQyxFQUFFRixhQUFhLFdBQVcsRUFBRVMsU0FBUyxhQUFhLENBQUM7UUFDdEU7UUFDQSxJQUFJWCxlQUFlaEIsVUFBVTtZQUMzQixNQUFNLElBQUlvQixNQUFNLENBQUMsRUFBRUYsYUFBYSxjQUFjLEVBQUVGLFlBQVksYUFBYSxDQUFDO1FBQzVFO1FBQ0EsTUFBTSxFQUFFRyxNQUFNLEVBQUUsR0FBR3ZCO1FBQ25CQSxRQUFReUIsSUFBSSxDQUFDO1lBQ1hDLE1BQU1wQyxHQUFHMEMsR0FBRztZQUNaQyxPQUFPckIsSUFBSSxDQUFDbUIsU0FBUyxDQUFDRSxLQUFLO1lBQzNCTCxPQUFPRztRQUNUO1FBQ0FwQyxVQUFVNEIsUUFBUUgsYUFBYUM7UUFDL0JyQixRQUFRNkIsR0FBRztJQUNiO0lBQ0EsZ0ZBQWdGLEdBQ2hGLHVHQUF1RyxHQUN2RyxNQUFNSyxRQUFRO1FBQ1o1QixZQUFZO1FBQ1pDLGVBQWU7UUFDZkMsV0FBVztRQUNYTSxhQUFhO1FBQ2JULGFBQWE7WUFDWDtnQkFDRUEsWUFBWWYsR0FBRzZDLGVBQWU7Z0JBQzlCQyxRQUFRO2dCQUNSaEMsVUFBVTtnQkFDVkQsYUFBYTtZQUNmO1NBQ0Q7UUFDRFEsUUFBUTtRQUNSQyxPQUFPO1FBQ1BYLFFBQVE7UUFDUkMsYUFBYTtRQUNiQyxjQUFjO1FBQ2RDLFdBQVc7UUFDWEssZ0JBQWdCO1FBQ2hCQyxlQUFlO1FBQ2ZHLGFBQWE7UUFDYmIsVUFBVTtJQUNaO0lBQ0EsMkRBQTJELEdBQzNELE1BQU1xQyxVQUFVO1FBQ2QsTUFBTUMsUUFBUSxFQUFFO1FBQ2hCLE1BQU1DLE9BQU87WUFDWCxNQUFNQyxNQUFNLENBQUM7WUFDYjdCLE1BQU04QixPQUFPLENBQUMsQ0FBQ0M7Z0JBQ2IsSUFBSUEsS0FBS0MsS0FBSyxFQUFFO29CQUNkSCxHQUFHLENBQUNFLEtBQUtFLEtBQUssQ0FBQyxHQUFHO2dCQUNwQjtZQUNGO1lBQ0EsSUFBSWhDLEtBQUtXLE1BQU0sR0FBRyxHQUFHO2dCQUNuQlgsS0FBSzZCLE9BQU8sQ0FBQyxDQUFDSTtvQkFDWixJQUFJQSxJQUFJRixLQUFLLEVBQUU7d0JBQ2JILEdBQUcsQ0FBQ0ssSUFBSUQsS0FBSyxDQUFDLEdBQUc7b0JBQ25CO2dCQUNGO1lBQ0Y7WUFDQU4sTUFBTWIsSUFBSSxDQUFDZTtRQUNiO1FBQ0EsTUFBTU0sT0FBTztZQUNYLE1BQU1DLE1BQU1ULEtBQUssQ0FBQ0EsTUFBTWYsTUFBTSxHQUFHLEVBQUU7WUFDbkMsTUFBTWlCLE1BQU0sQ0FBQztZQUNiLG9EQUFvRCxHQUNwRCxJQUFLLE1BQU1RLFFBQVFELElBQUs7Z0JBQ3RCUCxHQUFHLENBQUNRLEtBQUssR0FBR0QsR0FBRyxDQUFDQyxLQUFLO1lBQ3ZCO1lBQ0EsT0FBT1I7UUFDVDtRQUNBLElBQUksQ0FBQ2YsSUFBSSxHQUFHLFNBQVNBO1lBQ25CYSxNQUFNYixJQUFJLENBQUNxQjtRQUNiO1FBQ0EsSUFBSSxDQUFDakIsR0FBRyxHQUFHLFNBQVNBLElBQUlvQixTQUFTO1lBQy9CLElBQUkxQixTQUFTMEI7WUFDYixJQUFJLENBQUMxQixRQUFRO2dCQUNYQSxTQUFTZSxNQUFNZixNQUFNLEdBQUc7WUFDMUI7WUFDQSxJQUFJQSxTQUFTLEtBQUtBLFNBQVNlLE1BQU1mLE1BQU0sRUFBRTtnQkFDdkMsTUFBTSxJQUFJQyxNQUFNLENBQUMsRUFBRS9CLGFBQWEsMkJBQTJCLEVBQUU4QixPQUFPLENBQUM7WUFDdkU7WUFDQWUsTUFBTWYsTUFBTSxHQUFHQTtZQUNmLE9BQU9lLEtBQUssQ0FBQ0EsTUFBTWYsTUFBTSxHQUFHLEVBQUU7UUFDaEM7UUFDQSxJQUFJLENBQUNBLE1BQU0sR0FBRyxTQUFTQTtZQUNyQixPQUFPZSxNQUFNZixNQUFNO1FBQ3JCO1FBQ0EsSUFBSSxDQUFDMkIsVUFBVSxHQUFHLFNBQVNBLFdBQVdGLElBQUksRUFBRXBCLEtBQUssRUFBRUwsTUFBTTtZQUN2RGUsS0FBSyxDQUFDQSxNQUFNZixNQUFNLEdBQUcsRUFBRSxDQUFDeUIsS0FBSyxHQUFHO2dCQUM5QjVCLGFBQWFRO2dCQUNidUIsY0FBYzVCO1lBQ2hCO1FBQ0Y7UUFDQSxJQUFJLENBQUM2QixTQUFTLEdBQUcsU0FBVUosSUFBSTtZQUM3QixPQUFPVixLQUFLLENBQUNBLE1BQU1mLE1BQU0sR0FBRyxFQUFFLENBQUN5QixLQUFLO1FBQ3RDO1FBQ0EsZUFBZSxHQUNmVDtJQUNGO0lBQ0EsNEdBQTRHO0lBQzVHLHdHQUF3RztJQUN4Ryx3REFBd0Q7SUFDeEQsdUZBQXVGO0lBQ3ZGLDZFQUE2RTtJQUM3RSwwREFBMEQ7SUFDMUQscURBQXFEO0lBQ3JELGdGQUFnRjtJQUNoRiw0REFBNEQ7SUFDNUQseUZBQXlGO0lBQ3pGLDZFQUE2RTtJQUM3RSxxRUFBcUU7SUFDckUsMkVBQTJFO0lBQzNFLHFFQUFxRTtJQUNyRSxNQUFNYyxhQUFhLFNBQVNBO1FBQzFCLE1BQU1DLFdBQVcsSUFBSTtRQUNyQixJQUFJLENBQUNDLEtBQUssR0FBR2pFLEdBQUdrRSxNQUFNO1FBQ3RCLElBQUksQ0FBQ0wsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ2hDLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNZLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUMxQixVQUFVLEdBQUdBLFVBQVUsQ0FBQ0EsV0FBV2tCLE1BQU0sR0FBRyxFQUFFO1FBQ25ELElBQUksQ0FBQ2tDLE1BQU0sR0FBRyxJQUFJcEI7UUFDbEIsSUFBSSxDQUFDcUIsTUFBTSxHQUFHLElBQUlyQjtRQUNsQixJQUFJLENBQUNuQixZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ1ksV0FBVyxHQUFHQTtRQUNuQixtREFBbUQsR0FDbkQsSUFBSSxDQUFDNkIsT0FBTyxHQUFHLFNBQVNBO1lBQ3RCTCxTQUFTQyxLQUFLLEdBQUdqRSxHQUFHa0UsTUFBTTtZQUMxQkYsU0FBU0gsWUFBWSxHQUFHO1lBQ3hCRyxTQUFTakQsVUFBVSxHQUFHQSxVQUFVLENBQUNBLFdBQVdrQixNQUFNLEdBQUcsRUFBRTtRQUN6RDtJQUNGO0lBQ0EscUNBQXFDLEdBQ3JDLE1BQU1xQyxrQkFBa0IsU0FBU0E7UUFDL0IsT0FBT3ZELFVBQVUsQ0FBQ0EsV0FBV2tCLE1BQU0sR0FBRyxFQUFFO0lBQzFDO0lBQ0EsbUVBQW1FLEdBQ25FLE1BQU1zQyxlQUFlLFNBQVNBO1FBQzVCLE9BQU94RCxXQUFXa0IsTUFBTSxHQUFHO0lBQzdCO0lBQ0EsaURBQWlELEdBQ2pELE1BQU11QyxlQUFlO1FBQ25CLE9BQU96RCxVQUFVLENBQUNBLFdBQVdrQixNQUFNLEdBQUcsRUFBRSxDQUFDbEIsVUFBVSxLQUFLZixHQUFHeUUsaUJBQWlCO0lBQzlFO0lBQ0EsMkVBQTJFLEdBQzNFLE1BQU1DLGdCQUFnQjtRQUNwQixNQUFNMUMsZUFBZSxDQUFDLEVBQUU3QixhQUFhLGlCQUFpQixDQUFDO1FBQ3ZELE1BQU13RSxPQUFPO1FBQ2IsTUFBT0EsS0FBTTtZQUNYLElBQUl2RSxTQUFTRSxHQUFHLEtBQUtzRSxXQUFXO2dCQUM5QnhFLFNBQVNFLEdBQUcsR0FBRztnQkFDZjtZQUNGO1lBQ0EsSUFBSUYsU0FBU0UsR0FBRyxLQUFLLE1BQU07Z0JBQ3pCO1lBQ0Y7WUFDQSxJQUFJRixTQUFTRSxHQUFHLENBQUN1RSxTQUFTLEtBQUssYUFBYTtnQkFDMUMsTUFBTSxJQUFJM0MsTUFBTSxDQUFDLEVBQUVGLGFBQWEseUJBQXlCLENBQUM7WUFDNUQ7WUFDQTtRQUNGO1FBQ0EsSUFBSTVCLFNBQVNFLEdBQUcsS0FBSyxNQUFNO1lBQ3pCRixTQUFTRSxHQUFHLENBQUMyQyxJQUFJLENBQUM1QixPQUFPQyxNQUFNWDtRQUNqQztJQUNGO0lBQ0EsNkVBQTZFLEdBQzdFLE1BQU1tRSxrQkFBa0I7UUFDdEIsTUFBTTlDLGVBQWUsQ0FBQyxFQUFFN0IsYUFBYSxtQkFBbUIsQ0FBQztRQUN6RCxNQUFNd0UsT0FBTztRQUNiLE1BQU9BLEtBQU07WUFDWCxJQUFJdkUsU0FBU0ksS0FBSyxLQUFLb0UsV0FBVztnQkFDaEN4RSxTQUFTSSxLQUFLLEdBQUc7Z0JBQ2pCO1lBQ0Y7WUFDQSxJQUFJSixTQUFTSSxLQUFLLEtBQUssTUFBTTtnQkFDM0I7WUFDRjtZQUNBLElBQUlKLFNBQVNJLEtBQUssQ0FBQ3VFLFdBQVcsS0FBSyxlQUFlO2dCQUNoRCxNQUFNLElBQUk3QyxNQUFNLENBQUMsRUFBRUYsYUFBYSwyQkFBMkIsQ0FBQztZQUM5RDtZQUNBO1FBQ0Y7UUFDQSxJQUFJNUIsU0FBU0ksS0FBSyxLQUFLLE1BQU07WUFDM0JKLFNBQVNJLEtBQUssQ0FBQ3lDLElBQUksQ0FBQzVCLE9BQU9DLE1BQU1YO1FBQ25DO0lBQ0Y7SUFDQSxrRkFBa0YsR0FDbEYsTUFBTXFFLGtCQUFrQjtRQUN0QixNQUFNaEQsZUFBZSxDQUFDLEVBQUU3QixhQUFhLG1CQUFtQixDQUFDO1FBQ3pELE1BQU13RSxPQUFPO1FBQ2IsTUFBT0EsS0FBTTtZQUNYLElBQUl2RSxTQUFTRyxLQUFLLEtBQUtxRSxXQUFXO2dCQUNoQ3hFLFNBQVNHLEtBQUssR0FBRztnQkFDakI7WUFDRjtZQUNBLElBQUlILFNBQVNHLEtBQUssS0FBSyxNQUFNO2dCQUMzQjtZQUNGO1lBQ0EsSUFBSUgsU0FBU0csS0FBSyxDQUFDMEUsV0FBVyxLQUFLLGVBQWU7Z0JBQ2hELE1BQU0sSUFBSS9DLE1BQU0sQ0FBQyxFQUFFRixhQUFhLDJCQUEyQixDQUFDO1lBQzlEO1lBQ0E7UUFDRjtRQUNBLElBQUk1QixTQUFTRyxLQUFLLEtBQUssTUFBTTtZQUMzQkgsU0FBU0csS0FBSyxDQUFDMEMsSUFBSSxDQUFDNUIsT0FBT0M7UUFDN0I7SUFDRjtJQUNBLDRFQUE0RSxHQUM1RSxvREFBb0QsR0FDcEQsTUFBTTRELG9CQUFvQixTQUFVQyxPQUFPO1FBQ3pDLE1BQU1uRCxlQUFlLENBQUMsRUFBRTdCLGFBQWEscUJBQXFCLENBQUM7UUFDM0QsSUFBSSxDQUFDZ0YsU0FBUztZQUNaLE1BQU0sSUFBSWpELE1BQU0sQ0FBQyxFQUFFRixhQUFhLHdCQUF3QixDQUFDO1FBQzNEO1FBQ0EsSUFBSW1ELFFBQVFDLGFBQWEsS0FBSyxpQkFBaUI7WUFDN0MsTUFBTSxJQUFJbEQsTUFBTSxDQUFDLEVBQUVGLGFBQWEsa0JBQWtCLENBQUM7UUFDckQ7UUFDQVgsUUFBUThELFFBQVE5RCxLQUFLO1FBQ3JCQyxPQUFPNkQsUUFBUTdELElBQUk7SUFDckI7SUFDQSxrREFBa0QsR0FDbEQsTUFBTStELHNCQUFzQixTQUFVQyxTQUFTO1FBQzdDLE1BQU10RCxlQUFlLENBQUMsRUFBRTdCLGFBQWEsdUJBQXVCLENBQUM7UUFDN0QsSUFBSW9GLFFBQVE7UUFDWixJQUFJLE9BQU9ELGNBQWMsVUFBVTtZQUNqQyxJQUFJQSxhQUFhakUsTUFBTVksTUFBTSxFQUFFO2dCQUM3QixNQUFNLElBQUlDLE1BQU0sQ0FBQyxFQUFFRixhQUFhLGlDQUFpQyxFQUFFWCxNQUFNWSxNQUFNLENBQUMsU0FBUyxFQUFFcUQsVUFBVSxDQUFDO1lBQ3hHO1lBQ0FDLFFBQVFEO1FBQ1YsT0FBTyxJQUFJLE9BQU9BLGNBQWMsVUFBVTtZQUN4QyxNQUFNaEMsUUFBUWdDLFVBQVVFLFdBQVc7WUFDbkMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlwRSxNQUFNWSxNQUFNLEVBQUV3RCxLQUFLLEVBQUc7Z0JBQ3hDLElBQUluQyxVQUFVakMsS0FBSyxDQUFDb0UsRUFBRSxDQUFDbkMsS0FBSyxFQUFFO29CQUM1QmlDLFFBQVFsRSxLQUFLLENBQUNvRSxFQUFFLENBQUNuRCxLQUFLO29CQUN0QjtnQkFDRjtZQUNGO1lBQ0EsSUFBSWlELFVBQVUsTUFBTTtnQkFDbEIsTUFBTSxJQUFJckQsTUFBTSxDQUFDLEVBQUVGLGFBQWEsaUJBQWlCLEVBQUVzRCxVQUFVLGdCQUFnQixDQUFDO1lBQ2hGO1FBQ0YsT0FBTztZQUNMLE1BQU0sSUFBSXBELE1BQU0sQ0FBQyxFQUFFRixhQUFhLG9CQUFvQixFQUFFLE9BQU9zRCxVQUFVLGdCQUFnQixDQUFDO1FBQzFGO1FBQ0EsT0FBT0M7SUFDVDtJQUNBLCtGQUErRixHQUMvRixNQUFNRyx1QkFBdUIsU0FBU0EscUJBQXFCQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsTUFBTTtRQUNqRixNQUFNN0QsZUFBZSxDQUFDLEVBQUU3QixhQUFhLHdCQUF3QixDQUFDO1FBQzlELDhCQUE4QixHQUM5QixJQUFJMkYsUUFBUUg7UUFDWixJQUFJSSxNQUFNSDtRQUNWLElBQUlJLE1BQU1IO1FBQ1YsSUFBSUMsVUFBVWxCLFdBQVc7WUFDdkIsTUFBTSxJQUFJMUMsTUFBTSxDQUFDLEVBQUVGLGFBQWEseUJBQXlCLENBQUM7UUFDNUQ7UUFDQSxJQUFJOEQsVUFBVSxNQUFNO1lBQ2xCLE1BQU0sSUFBSTVELE1BQU0sQ0FBQyxFQUFFRixhQUFhLG9CQUFvQixDQUFDO1FBQ3ZEO1FBQ0EsSUFBSSxPQUFPOEQsVUFBVSxVQUFVO1lBQzdCQSxRQUFRNUYsTUFBTStGLGFBQWEsQ0FBQ0g7UUFDOUIsT0FBTyxJQUFJLENBQUNJLE1BQU1DLE9BQU8sQ0FBQ0wsUUFBUTtZQUNoQyxNQUFNLElBQUk1RCxNQUFNLENBQUMsRUFBRUYsYUFBYSxxQ0FBcUMsQ0FBQztRQUN4RTtRQUNBLElBQUk4RCxNQUFNN0QsTUFBTSxHQUFHLEdBQUc7WUFDcEIsSUFBSSxPQUFPNkQsS0FBSyxDQUFDLEVBQUUsS0FBSyxVQUFVO2dCQUNoQyxNQUFNLElBQUk1RCxNQUFNLENBQUMsRUFBRUYsYUFBYSxxQ0FBcUMsQ0FBQztZQUN4RTtRQUNGO1FBQ0Esd0NBQXdDLEdBQ3hDLElBQUksT0FBTytELFFBQVEsVUFBVTtZQUMzQkEsTUFBTTtRQUNSLE9BQU87WUFDTEEsTUFBTUssS0FBS0MsS0FBSyxDQUFDTjtZQUNqQixJQUFJQSxNQUFNLEtBQUtBLE1BQU1ELE1BQU03RCxNQUFNLEVBQUU7Z0JBQ2pDLE1BQU0sSUFBSUMsTUFBTSxDQUFDLEVBQUVGLGFBQWEsb0NBQW9DLEVBQUUrRCxJQUFJLENBQUM7WUFDN0U7UUFDRjtRQUNBLHFDQUFxQyxHQUNyQyxJQUFJLE9BQU9DLFFBQVEsVUFBVTtZQUMzQkEsTUFBTUYsTUFBTTdELE1BQU0sR0FBRzhEO1FBQ3ZCLE9BQU87WUFDTEMsTUFBTUksS0FBS0MsS0FBSyxDQUFDTDtZQUNqQixJQUFJQSxNQUFNLEtBQUtBLE1BQU1GLE1BQU03RCxNQUFNLEdBQUc4RCxLQUFLO2dCQUN2QyxNQUFNLElBQUk3RCxNQUFNLENBQUMsRUFBRUYsYUFBYSwyQkFBMkIsRUFBRWdFLElBQUksQ0FBQztZQUNwRTtRQUNGO1FBQ0FyRixRQUFRbUY7UUFDUmxGLGFBQWFtRjtRQUNibEYsY0FBY21GO1FBQ2RsRixXQUFXRixhQUFhQztJQUMxQjtJQUNBLHVGQUF1RixHQUN2RixNQUFNeUYsc0JBQXNCO1FBQzFCLE1BQU10RSxlQUFlLENBQUMsRUFBRTdCLGFBQWEsdUJBQXVCLENBQUM7UUFDN0QsSUFBSXNGO1FBQ0p0RSxnQkFBZ0IsRUFBRTtRQUNsQkMsZUFBZSxFQUFFO1FBQ2pCLElBQUtxRSxJQUFJLEdBQUdBLElBQUlwRSxNQUFNWSxNQUFNLEVBQUV3RCxLQUFLLEVBQUc7WUFDcEN0RSxhQUFhLENBQUNzRSxFQUFFLEdBQUc7UUFDckI7UUFDQSxJQUFLQSxJQUFJLEdBQUdBLElBQUluRSxLQUFLVyxNQUFNLEVBQUV3RCxLQUFLLEVBQUc7WUFDbkNyRSxZQUFZLENBQUNxRSxFQUFFLEdBQUc7UUFDcEI7UUFDQSxJQUFJYztRQUNKLE1BQU1DLE9BQU8sRUFBRTtRQUNmLElBQUtmLElBQUksR0FBR0EsSUFBSXBFLE1BQU1ZLE1BQU0sRUFBRXdELEtBQUssRUFBRztZQUNwQ2UsS0FBS3JFLElBQUksQ0FBQ2QsS0FBSyxDQUFDb0UsRUFBRSxDQUFDbkMsS0FBSztRQUMxQjtRQUNBLElBQUttQyxJQUFJLEdBQUdBLElBQUluRSxLQUFLVyxNQUFNLEVBQUV3RCxLQUFLLEVBQUc7WUFDbkNlLEtBQUtyRSxJQUFJLENBQUNiLElBQUksQ0FBQ21FLEVBQUUsQ0FBQ25DLEtBQUs7UUFDekI7UUFDQSxJQUFLLE1BQU1oQixTQUFTbEMsU0FBU0ssU0FBUyxDQUFFO1lBQ3RDZ0YsSUFBSWUsS0FBS0MsT0FBTyxDQUFDbkUsTUFBTWtELFdBQVc7WUFDbEMsSUFBSUMsSUFBSSxHQUFHO2dCQUNULE1BQU0sSUFBSXZELE1BQU0sQ0FBQyxFQUFFRixhQUFhLGlCQUFpQixFQUFFTSxNQUFNLHdCQUF3QixDQUFDO1lBQ3BGO1lBQ0FpRSxPQUFPbkcsU0FBU0ssU0FBUyxDQUFDNkIsTUFBTTtZQUNoQyxJQUFJLENBQUNpRSxNQUFNO2dCQUNUQSxPQUFPO1lBQ1Q7WUFDQSxJQUFJLE9BQU9BLFNBQVMsY0FBY0EsU0FBUyxNQUFNO2dCQUMvQyxJQUFJZCxJQUFJcEUsTUFBTVksTUFBTSxFQUFFO29CQUNwQmQsYUFBYSxDQUFDc0UsRUFBRSxHQUFHYztnQkFDckIsT0FBTztvQkFDTG5GLFlBQVksQ0FBQ3FFLElBQUlwRSxNQUFNWSxNQUFNLENBQUMsR0FBR3NFO2dCQUNuQztZQUNGLE9BQU87Z0JBQ0wsTUFBTSxJQUFJckUsTUFDUixDQUFDLEVBQUVGLGFBQWEsZ0JBQWdCLEVBQUVNLE1BQU0sbUVBQW1FLENBQUM7WUFFaEg7UUFDRjtRQUNBLDZFQUE2RSxHQUM3RSxJQUFLbUQsSUFBSSxHQUFHQSxJQUFJbkUsS0FBS1csTUFBTSxFQUFFd0QsS0FBSyxFQUFHO1lBQ25DLElBQUlyRSxZQUFZLENBQUNxRSxFQUFFLEtBQUssTUFBTTtnQkFDNUIsTUFBTSxJQUFJdkQsTUFDUixDQUFDLEVBQUVGLGFBQWEsZ0RBQWdELEVBQUVWLElBQUksQ0FBQ21FLEVBQUUsQ0FBQ25DLEtBQUssQ0FBQywwQkFBMEIsQ0FBQztZQUUvRztRQUNGO0lBQ0Y7SUFDQSx1RUFBdUU7SUFDdkUsd0VBQXdFO0lBQ3hFLDBEQUEwRDtJQUMxRCxPQUFPO0lBQ1AsT0FBTztJQUNQLDRFQUE0RTtJQUM1RSxRQUFRO0lBQ1IsUUFBUTtJQUNSLElBQUksQ0FBQ29ELGVBQWUsR0FBRyxTQUFVQyxLQUFLO1FBQ3BDLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSXpFLE1BQU0sQ0FBQyw0Q0FBNEMsRUFBRXlFLE1BQU0sQ0FBQztRQUN4RTtRQUNBbEYsaUJBQWlCMkUsS0FBS0MsS0FBSyxDQUFDTTtRQUM1QixJQUFJbEYsa0JBQWtCLEdBQUc7WUFDdkIsTUFBTSxJQUFJUyxNQUFNLENBQUMsNENBQTRDLEVBQUV5RSxNQUFNLENBQUM7UUFDeEU7SUFDRjtJQUNBLDRGQUE0RjtJQUM1Riw2QkFBNkI7SUFDN0Isd0VBQXdFO0lBQ3hFLDBEQUEwRDtJQUMxRCxPQUFPO0lBQ1AsT0FBTztJQUNQLG1FQUFtRTtJQUNuRSxtQ0FBbUM7SUFDbkMsUUFBUTtJQUNSLFFBQVE7SUFDUixJQUFJLENBQUNDLGNBQWMsR0FBRyxTQUFVQyxJQUFJO1FBQ2xDLElBQUksT0FBT0EsU0FBUyxVQUFVO1lBQzVCLE1BQU0sSUFBSTNFLE1BQU0sQ0FBQywyQ0FBMkMsRUFBRTJFLEtBQUssQ0FBQztRQUN0RTtRQUNBbEYsZ0JBQWdCeUUsS0FBS0MsS0FBSyxDQUFDUTtRQUMzQixJQUFJbEYsaUJBQWlCLEdBQUc7WUFDdEIsTUFBTSxJQUFJTyxNQUFNLENBQUMsMkNBQTJDLEVBQUUyRSxLQUFLLENBQUM7UUFDdEU7SUFDRjtJQUNBLDRCQUE0QixHQUM1QixNQUFNQyxlQUFlLFNBQVUzQixPQUFPLEVBQUU0QixZQUFZLEVBQUVDLFlBQVk7UUFDaEUsSUFBSUM7UUFDSixNQUFNakYsZUFBZSxDQUFDLEVBQUU3QixhQUFhLFNBQVMsQ0FBQztRQUMvQytFLGtCQUFrQkM7UUFDbEIsTUFBTUcsWUFBWUQsb0JBQW9CMEI7UUFDdENUO1FBQ0F4QjtRQUNBRTtRQUNBTjtRQUNBLE1BQU0zQyxVQUFVLElBQUlnQztRQUNwQixJQUFJLENBQUVpRCxDQUFBQSxpQkFBaUJwQyxhQUFhb0MsaUJBQWlCLElBQUcsR0FBSTtZQUMxRHpGLGFBQWF5RjtRQUNmO1FBQ0EsNENBQTRDLEdBQzVDdEcsVUFBVTtZQUNSO2dCQUNFMEIsTUFBTXBDLEdBQUdxQyxHQUFHO2dCQUNaQyxPQUFPZ0Q7WUFDVDtTQUNEO1FBQ0QsMEJBQTBCLEdBQzFCakYsVUFBVSxHQUFHTyxZQUFZbUI7UUFDekJyQixVQUFVO1FBQ1YsK0JBQStCLEdBQy9CLE9BQVFxQixRQUFRa0MsS0FBSztZQUNuQixLQUFLakUsR0FBR2tFLE1BQU07Z0JBQ1osTUFBTSxJQUFJaEMsTUFBTSxDQUFDLEVBQUVGLGFBQWEsb0NBQW9DLENBQUM7WUFDdkUsS0FBS2hDLEdBQUdrSCxPQUFPO2dCQUNiRCxVQUFVO2dCQUNWO1lBQ0YsS0FBS2pILEdBQUdtSCxLQUFLO1lBQ2IsS0FBS25ILEdBQUdvSCxLQUFLO2dCQUNYLElBQUlyRixRQUFROEIsWUFBWSxLQUFLaEQsYUFBYTtvQkFDeENvRyxVQUFVO2dCQUNaLE9BQU87b0JBQ0xBLFVBQVU7Z0JBQ1o7Z0JBQ0E7WUFDRjtnQkFDRSxNQUFNLElBQUkvRSxNQUFNO1FBQ3BCO1FBQ0EsT0FBTztZQUNMK0U7WUFDQWhELE9BQU9sQyxRQUFRa0MsS0FBSztZQUNwQmhDLFFBQVFwQjtZQUNSd0csU0FBU3RGLFFBQVE4QixZQUFZO1lBQzdCckM7WUFDQVA7WUFDQUM7WUFDQW9HLGFBQWEzRyxNQUFNc0IsTUFBTTtZQUN6QnNGLFVBQVUzRztZQUNWNEcsUUFBUTFHO1lBQ1IyRyxXQUFXNUc7UUFDYjtJQUNGO0lBRUEscUVBQXFFO0lBQ3JFLE9BQU87SUFDUCx5RUFBeUU7SUFDekUsb0RBQW9EO0lBQ3BELFFBQVE7SUFDUiw0REFBNEQ7SUFDNUQsSUFBSSxDQUFDNkcsY0FBYyxHQUFHLFNBQVNBLGVBQWV2QyxPQUFPLEVBQUVHLFNBQVMsRUFBRXFDLFVBQVUsRUFBRUMsVUFBVSxFQUFFTixXQUFXLEVBQUVOLFlBQVk7UUFDakhwRTtRQUNBOEMscUJBQXFCaUMsWUFBWUMsWUFBWU47UUFDN0MsT0FBT1IsYUFBYTNCLFNBQVNHLFdBQVcwQjtJQUMxQztJQUNBLDhEQUE4RDtJQUM5RCxPQUFPO0lBQ1AsNkVBQTZFO0lBQzdFLDhCQUE4QjtJQUM5Qiw4RUFBOEU7SUFDOUUsd0VBQXdFO0lBQ3hFLGdFQUFnRTtJQUNoRSwrR0FBK0c7SUFDL0csZUFBZTtJQUNmLDJFQUEyRTtJQUMzRSxzQkFBc0I7SUFDdEIsMkVBQTJFO0lBQzNFLGlDQUFpQztJQUNqQyxRQUFRO0lBQ1IsSUFBSSxDQUFDYSxLQUFLLEdBQUcsU0FBU0EsTUFBTTFDLE9BQU8sRUFBRUcsU0FBUyxFQUFFcUMsVUFBVSxFQUFFWCxZQUFZO1FBQ3RFcEU7UUFDQThDLHFCQUFxQmlDLFlBQVksR0FBR0EsV0FBVzFGLE1BQU07UUFDckQsT0FBTzZFLGFBQWEzQixTQUFTRyxXQUFXMEI7SUFDMUM7SUFDQSwwQkFBMEI7SUFDMUIsd0VBQXdFO0lBQ3hFLDBDQUEwQztJQUMxQyxNQUFNYyxRQUFRLFNBQVVDLE9BQU8sRUFBRWpHLFdBQVcsRUFBRUMsT0FBTztRQUNuRCxNQUFNaUcsS0FBS3RILE9BQU8sQ0FBQ3FILFFBQVE7UUFDM0IsSUFBSyxJQUFJdEMsSUFBSSxHQUFHQSxJQUFJdUMsR0FBR0MsUUFBUSxDQUFDaEcsTUFBTSxFQUFFd0QsS0FBSyxFQUFHO1lBQzlDcEYsVUFBVTJILEdBQUdDLFFBQVEsQ0FBQ3hDLEVBQUUsRUFBRTNELGFBQWFDO1lBQ3ZDLElBQUlBLFFBQVFrQyxLQUFLLEtBQUtqRSxHQUFHa0gsT0FBTyxFQUFFO2dCQUNoQztZQUNGO1FBQ0Y7SUFDRjtJQUNBLDBCQUEwQjtJQUMxQix1REFBdUQ7SUFDdkQscUNBQXFDO0lBQ3JDLG1DQUFtQztJQUNuQyxNQUFNZ0IsUUFBUSxTQUFVSCxPQUFPLEVBQUVqRyxXQUFXLEVBQUVDLE9BQU87UUFDbkQsSUFBSWtGO1FBQ0osSUFBSWtCO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLE1BQU1MLEtBQUt0SCxPQUFPLENBQUNxSCxRQUFRO1FBQzNCLE1BQU1PLE9BQU92RyxRQUFRb0MsTUFBTSxDQUFDbEMsTUFBTTtRQUNsQyxNQUFNc0csT0FBT3hHLFFBQVFxQyxNQUFNLENBQUNuQyxNQUFNO1FBQ2xDLElBQUk3QixTQUFTRSxHQUFHLEVBQUU7WUFDaEI2SCxZQUFZL0gsU0FBU0UsR0FBRyxDQUFDa0ksU0FBUztRQUNwQztRQUNBdkIsVUFBVTtRQUNWbUIsZUFBZXRHO1FBQ2Z1RyxZQUFZO1FBQ1osSUFBSyxJQUFJNUMsSUFBSSxHQUFHQSxJQUFJdUMsR0FBR0MsUUFBUSxDQUFDaEcsTUFBTSxFQUFFd0QsS0FBSyxFQUFHO1lBQzlDcEYsVUFBVTJILEdBQUdDLFFBQVEsQ0FBQ3hDLEVBQUUsRUFBRTJDLGNBQWNyRztZQUN4QyxJQUFJQSxRQUFRa0MsS0FBSyxLQUFLakUsR0FBR2tILE9BQU8sRUFBRTtnQkFDaENELFVBQVU7Z0JBQ1Y7WUFDRixPQUFPO2dCQUNMbUIsZ0JBQWdCckcsUUFBUThCLFlBQVk7Z0JBQ3BDd0UsYUFBYXRHLFFBQVE4QixZQUFZO1lBQ25DO1FBQ0Y7UUFDQSxJQUFJb0QsU0FBUztZQUNYbEYsUUFBUWtDLEtBQUssR0FBR29FLGNBQWMsSUFBSXJJLEdBQUdtSCxLQUFLLEdBQUduSCxHQUFHb0gsS0FBSztZQUNyRHJGLFFBQVE4QixZQUFZLEdBQUd3RTtRQUN6QixPQUFPO1lBQ0x0RyxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR2tILE9BQU87WUFDMUJuRixRQUFROEIsWUFBWSxHQUFHO1lBQ3ZCLGdEQUFnRCxHQUNoRDlCLFFBQVFvQyxNQUFNLENBQUM1QixHQUFHLENBQUMrRjtZQUNuQnZHLFFBQVFxQyxNQUFNLENBQUM3QixHQUFHLENBQUNnRztZQUNuQixJQUFJbkksU0FBU0UsR0FBRyxFQUFFO2dCQUNoQkYsU0FBU0UsR0FBRyxDQUFDbUksU0FBUyxDQUFDTjtZQUN6QjtRQUNGO0lBQ0Y7SUFDQSwwQkFBMEI7SUFDMUIsNkNBQTZDO0lBQzdDLG1EQUFtRDtJQUNuRCxtRUFBbUU7SUFDbkUsMENBQTBDO0lBQzFDLE1BQU1PLFFBQVEsU0FBVVgsT0FBTyxFQUFFakcsV0FBVyxFQUFFQyxPQUFPO1FBQ25ELElBQUlvRztRQUNKLElBQUlRO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLE1BQU1iLEtBQUt0SCxPQUFPLENBQUNxSCxRQUFRO1FBQzNCLElBQUlDLEdBQUdjLEdBQUcsS0FBSyxHQUFHO1lBQ2hCLG1DQUFtQztZQUNuQyw2REFBNkQ7WUFDN0QvRyxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR21ILEtBQUs7WUFDeEJwRixRQUFROEIsWUFBWSxHQUFHO1lBQ3ZCO1FBQ0Y7UUFDQThFLGVBQWU3RztRQUNmOEcsWUFBWTtRQUNaQyxXQUFXO1FBQ1gsTUFBTVAsT0FBT3ZHLFFBQVFvQyxNQUFNLENBQUNsQyxNQUFNO1FBQ2xDLE1BQU1zRyxPQUFPeEcsUUFBUXFDLE1BQU0sQ0FBQ25DLE1BQU07UUFDbEMsSUFBSTdCLFNBQVNFLEdBQUcsRUFBRTtZQUNoQjZILFlBQVkvSCxTQUFTRSxHQUFHLENBQUNrSSxTQUFTO1FBQ3BDO1FBQ0EsTUFBTTdELE9BQU87UUFDYixNQUFPQSxLQUFNO1lBQ1gsSUFBSWdFLGdCQUFnQjdILFVBQVU7Z0JBRTVCO1lBQ0Y7WUFDQVQsVUFBVTBILFVBQVUsR0FBR1ksY0FBYzVHO1lBQ3JDLElBQUlBLFFBQVFrQyxLQUFLLEtBQUtqRSxHQUFHa0gsT0FBTyxFQUFFO2dCQUVoQztZQUNGO1lBQ0EsSUFBSW5GLFFBQVFrQyxLQUFLLEtBQUtqRSxHQUFHbUgsS0FBSyxFQUFFO2dCQUc5QjtZQUNGO1lBQ0EwQixZQUFZO1lBQ1pELGFBQWE3RyxRQUFROEIsWUFBWTtZQUNqQzhFLGdCQUFnQjVHLFFBQVE4QixZQUFZO1lBQ3BDLElBQUlnRixhQUFhYixHQUFHYyxHQUFHLEVBQUU7Z0JBRXZCO1lBQ0Y7UUFDRjtRQUNBLDZEQUE2RCxHQUM3RCxJQUFJL0csUUFBUWtDLEtBQUssS0FBS2pFLEdBQUdtSCxLQUFLLEVBQUU7WUFDOUJwRixRQUFRa0MsS0FBSyxHQUFHMkUsY0FBYyxJQUFJNUksR0FBR21ILEtBQUssR0FBR25ILEdBQUdvSCxLQUFLO1lBQ3JEckYsUUFBUThCLFlBQVksR0FBRytFO1FBQ3pCLE9BQU8sSUFBSUMsWUFBWWIsR0FBR2UsR0FBRyxFQUFFO1lBQzdCaEgsUUFBUWtDLEtBQUssR0FBRzJFLGNBQWMsSUFBSTVJLEdBQUdtSCxLQUFLLEdBQUduSCxHQUFHb0gsS0FBSztZQUNyRHJGLFFBQVE4QixZQUFZLEdBQUcrRTtRQUN6QixPQUFPO1lBQ0w3RyxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR2tILE9BQU87WUFDMUJuRixRQUFROEIsWUFBWSxHQUFHO1lBQ3ZCLGdEQUFnRCxHQUNoRDlCLFFBQVFvQyxNQUFNLENBQUM1QixHQUFHLENBQUMrRjtZQUNuQnZHLFFBQVFxQyxNQUFNLENBQUM3QixHQUFHLENBQUNnRztZQUNuQixJQUFJbkksU0FBU0UsR0FBRyxFQUFFO2dCQUNoQkYsU0FBU0UsR0FBRyxDQUFDbUksU0FBUyxDQUFDTjtZQUN6QjtRQUNGO0lBQ0Y7SUFDQSw0REFBNEQ7SUFDNUQsbURBQW1EO0lBQ25ELDBCQUEwQjtJQUMxQixNQUFNYSw0QkFBNEIsU0FBVTVGLElBQUksRUFBRXJCLE9BQU8sRUFBRWtILFNBQVMsRUFBRUMsSUFBSTtRQUN4RSxJQUFJbkgsUUFBUThCLFlBQVksR0FBR29GLFdBQVc7WUFDcEMsSUFBSUUsTUFBTSxDQUFDLEVBQUVoSixhQUFhLE1BQU0sRUFBRWlELEtBQUtNLElBQUksQ0FBQyw0QkFBNEIsQ0FBQztZQUN6RXlGLE9BQU8sQ0FBQyxzQkFBc0IsRUFBRXBILFFBQVE4QixZQUFZLENBQUMsQ0FBQztZQUN0RHNGLE9BQU8sQ0FBQyw2QkFBNkIsRUFBRUYsVUFBVSxDQUFDO1lBQ2xELE1BQU0sSUFBSS9HLE1BQU1pSDtRQUNsQjtRQUNBLE9BQVFwSCxRQUFRa0MsS0FBSztZQUNuQixLQUFLakUsR0FBR2tFLE1BQU07Z0JBQ1osSUFBSWdGLFNBQVMsTUFBTTtvQkFDakIsTUFBTSxJQUFJaEgsTUFDUixDQUFDLEVBQUUvQixhQUFhLE1BQU0sRUFBRWlELEtBQUtNLElBQUksQ0FBQyw0REFBNEQsQ0FBQztnQkFFbkc7Z0JBQ0E7WUFDRixLQUFLMUQsR0FBR21ILEtBQUs7Z0JBQ1hwRixRQUFROEIsWUFBWSxHQUFHO2dCQUN2QjtZQUNGLEtBQUs3RCxHQUFHb0gsS0FBSztnQkFDWCxJQUFJckYsUUFBUThCLFlBQVksS0FBSyxHQUFHO29CQUM5QjlCLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHbUgsS0FBSztnQkFDMUI7Z0JBQ0E7WUFDRixLQUFLbkgsR0FBR2tILE9BQU87Z0JBQ2JuRixRQUFROEIsWUFBWSxHQUFHO2dCQUN2QjtZQUNGO2dCQUNFLE1BQU0sSUFBSTNCLE1BQ1IsQ0FBQyxFQUFFL0IsYUFBYSxNQUFNLEVBQUVpRCxLQUFLTSxJQUFJLENBQUMsOERBQThELEVBQUUzQixRQUFRa0MsS0FBSyxDQUFDLENBQUM7UUFFdkg7SUFDRjtJQUNBLDBCQUEwQjtJQUMxQiwyRUFBMkU7SUFDM0UsNENBQTRDO0lBQzVDLG1IQUFtSDtJQUNuSCwrRkFBK0Y7SUFDL0Ysd0NBQXdDO0lBQ3hDLE1BQU1tRixRQUFRLFNBQVVyQixPQUFPLEVBQUVqRyxXQUFXLEVBQUVDLE9BQU87UUFDbkQsSUFBSW9HO1FBQ0osSUFBSWtCO1FBQ0osSUFBSUM7UUFDSixJQUFJaEI7UUFDSixJQUFJQztRQUNKLElBQUlnQjtRQUNKLE1BQU12QixLQUFLdEgsT0FBTyxDQUFDcUgsUUFBUTtRQUMzQixNQUFNM0UsT0FBTy9CLEtBQUssQ0FBQzJHLEdBQUcxRixLQUFLLENBQUM7UUFDNUIsTUFBTWtILFdBQVdySSxhQUFhLENBQUNpQyxLQUFLZCxLQUFLLENBQUM7UUFDMUMsTUFBTW1ILGdCQUFnQixDQUFDbEY7UUFDdkIsZ0RBQWdELEdBQ2hELElBQUlrRixlQUFlO1lBQ2pCLGlDQUFpQyxHQUNqQ0osYUFBYWpKLFNBQVNFLEdBQUcsSUFBSUYsU0FBU0UsR0FBRyxDQUFDb0osV0FBVyxDQUFDMUIsR0FBRzFGLEtBQUs7WUFDOUQsSUFBSStHLFlBQVk7Z0JBQ2RsQixZQUFZL0gsU0FBU0UsR0FBRyxDQUFDa0ksU0FBUztnQkFDbENwSSxTQUFTRSxHQUFHLENBQUM0SSxJQUFJLENBQUNsQixHQUFHMUYsS0FBSyxFQUFFakIsS0FBSyxDQUFDMkcsR0FBRzFGLEtBQUssQ0FBQyxDQUFDb0IsSUFBSTtZQUNsRDtZQUNBNEUsT0FBT3ZHLFFBQVFvQyxNQUFNLENBQUNsQyxNQUFNO1lBQzVCc0csT0FBT3hHLFFBQVFxQyxNQUFNLENBQUNuQyxNQUFNO1lBQzVCRixRQUFRb0MsTUFBTSxDQUFDaEMsSUFBSTtZQUNuQkosUUFBUXFDLE1BQU0sQ0FBQ2pDLElBQUk7WUFDbkJvSCxZQUFZeEgsUUFBUXFDLE1BQU07WUFDMUJyQyxRQUFRcUMsTUFBTSxHQUFHLElBQUlyQjtRQUN2QjtRQUNBLElBQUl5RyxhQUFhLE1BQU07WUFDckIsdUNBQXVDLEdBQ3ZDRixlQUFlNUk7WUFDZkEsVUFBVTBDLEtBQUsxQyxPQUFPO1lBQ3RCTCxVQUFVLEdBQUd5QixhQUFhQztZQUMxQnJCLFVBQVU0STtRQUNaLE9BQU87WUFDTCx3QkFBd0IsR0FDeEIsTUFBTUwsWUFBWW5JLFdBQVdnQjtZQUM3QkMsUUFBUUYsU0FBUyxHQUFHdUIsS0FBS2QsS0FBSztZQUM5QmtILFNBQVN6SCxTQUFTcEIsT0FBT21CLGFBQWFQO1lBQ3RDeUgsMEJBQTBCNUYsTUFBTXJCLFNBQVNrSCxXQUFXO1lBQ3BELElBQUlsSCxRQUFRa0MsS0FBSyxLQUFLakUsR0FBR2tFLE1BQU0sRUFBRTtnQkFDL0JvRixlQUFlNUk7Z0JBQ2ZBLFVBQVUwQyxLQUFLMUMsT0FBTztnQkFDdEJMLFVBQVUsR0FBR3lCLGFBQWFDO2dCQUMxQnJCLFVBQVU0STtnQkFDVnZILFFBQVFGLFNBQVMsR0FBR3VCLEtBQUtkLEtBQUs7Z0JBQzlCa0gsU0FBU3pILFNBQVNwQixPQUFPbUIsYUFBYVA7Z0JBQ3RDeUgsMEJBQTBCNUYsTUFBTXJCLFNBQVNrSCxXQUFXO1lBQ3RELEVBQUUsNkVBQTZFO1FBQ2pGO1FBQ0EsSUFBSVEsZUFBZTtZQUNqQixXQUFXLEdBQ1gsSUFBSUosWUFBWTtnQkFDZCxJQUFJdEgsUUFBUWtDLEtBQUssS0FBS2pFLEdBQUdrSCxPQUFPLEVBQUU7b0JBQ2hDOUcsU0FBU0UsR0FBRyxDQUFDbUksU0FBUyxDQUFDTjtnQkFDekIsT0FBTztvQkFDTC9ILFNBQVNFLEdBQUcsQ0FBQ3FKLEVBQUUsQ0FBQzNCLEdBQUcxRixLQUFLLEVBQUVjLEtBQUtNLElBQUksRUFBRTVCLGFBQWFDLFFBQVE4QixZQUFZO2dCQUN4RTtZQUNGO1lBQ0Esc0JBQXNCLEdBQ3RCOUIsUUFBUXFDLE1BQU0sR0FBR21GO1lBQ2pCLElBQUl4SCxRQUFRa0MsS0FBSyxLQUFLakUsR0FBR2tILE9BQU8sRUFBRTtnQkFDaENuRixRQUFRb0MsTUFBTSxDQUFDNUIsR0FBRyxDQUFDK0Y7Z0JBQ25CdkcsUUFBUXFDLE1BQU0sQ0FBQzdCLEdBQUcsQ0FBQ2dHO1lBQ3JCLE9BQU8sSUFBSW5GLEtBQUtDLEtBQUssRUFBRTtnQkFDckIsdURBQXVELEdBQ3ZELCtDQUErQyxHQUMvQ3RCLFFBQVFxQyxNQUFNLENBQUNSLFVBQVUsQ0FBQ1IsS0FBS0UsS0FBSyxFQUFFeEIsYUFBYUMsUUFBUThCLFlBQVk7Z0JBQ3ZFOUIsUUFBUW9DLE1BQU0sQ0FBQ1AsVUFBVSxDQUFDUixLQUFLRSxLQUFLLEVBQUV4QixhQUFhQyxRQUFROEIsWUFBWTtZQUN6RTtRQUNGO0lBQ0Y7SUFDQSw0REFBNEQ7SUFDNUQseUVBQXlFO0lBQ3pFLE1BQU0rRiw0QkFBNEIsU0FBVXJHLEdBQUcsRUFBRXhCLE9BQU8sRUFBRWtILFNBQVM7UUFDakUsSUFBSWxILFFBQVE4QixZQUFZLEdBQUdvRixXQUFXO1lBQ3BDLElBQUlFLE1BQU0sQ0FBQyxFQUFFaEosYUFBYSxNQUFNLEVBQUVvRCxJQUFJRyxJQUFJLENBQUMsNEJBQTRCLENBQUM7WUFDeEV5RixPQUFPLENBQUMsc0JBQXNCLEVBQUVwSCxRQUFROEIsWUFBWSxDQUFDLENBQUM7WUFDdERzRixPQUFPLENBQUMsNkJBQTZCLEVBQUVGLFVBQVUsQ0FBQztZQUNsRCxNQUFNLElBQUkvRyxNQUFNaUg7UUFDbEI7UUFDQSxPQUFRcEgsUUFBUWtDLEtBQUs7WUFDbkIsS0FBS2pFLEdBQUdrRSxNQUFNO2dCQUNaLE1BQU0sSUFBSWhDLE1BQU0sQ0FBQyxFQUFFL0IsYUFBYSxNQUFNLEVBQUVvRCxJQUFJRyxJQUFJLENBQUMsNERBQTRELENBQUM7WUFDaEgsS0FBSzFELEdBQUdtSCxLQUFLO2dCQUNYLElBQUk1RCxJQUFJWixLQUFLLEtBQUssT0FBTztvQkFDdkIsTUFBTSxJQUFJVCxNQUFNLENBQUMsRUFBRS9CLGFBQWEsTUFBTSxFQUFFb0QsSUFBSUcsSUFBSSxDQUFDLHdEQUF3RCxDQUFDO2dCQUM1RyxPQUFPO29CQUNMM0IsUUFBUThCLFlBQVksR0FBRztnQkFDekI7Z0JBQ0E7WUFDRixLQUFLN0QsR0FBR29ILEtBQUs7Z0JBQ1gsSUFBSXJGLFFBQVE4QixZQUFZLEtBQUssR0FBRztvQkFDOUIsSUFBSU4sSUFBSVosS0FBSyxLQUFLLE9BQU87d0JBQ3ZCLE1BQU0sSUFBSVQsTUFBTSxDQUFDLEVBQUUvQixhQUFhLE1BQU0sRUFBRW9ELElBQUlHLElBQUksQ0FBQyx3REFBd0QsQ0FBQztvQkFDNUcsT0FBTzt3QkFDTDNCLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHbUgsS0FBSztvQkFDMUI7Z0JBQ0Y7Z0JBQ0E7WUFDRixLQUFLbkgsR0FBR2tILE9BQU87Z0JBQ2JuRixRQUFROEIsWUFBWSxHQUFHO2dCQUN2QjtZQUNGO2dCQUNFLE1BQU0sSUFBSTNCLE1BQ1IsQ0FBQyxFQUFFL0IsYUFBYSxNQUFNLEVBQUVvRCxJQUFJRyxJQUFJLENBQUMsOERBQThELEVBQUUzQixRQUFRa0MsS0FBSyxDQUFDLENBQUM7UUFFdEg7SUFDRjtJQUNBLDBCQUEwQjtJQUMxQiw4RkFBOEY7SUFDOUYsd0JBQXdCO0lBQ3hCLGtHQUFrRztJQUNsRyx3Q0FBd0M7SUFDeEMsd0NBQXdDO0lBQ3hDLE1BQU00RixRQUFRLFNBQVU5QixPQUFPLEVBQUVqRyxXQUFXLEVBQUVDLE9BQU87UUFDbkQsSUFBSW9HO1FBQ0osSUFBSTJCO1FBQ0osSUFBSVQ7UUFDSixJQUFJZjtRQUNKLElBQUlDO1FBQ0osSUFBSWdCO1FBQ0osTUFBTXZCLEtBQUt0SCxPQUFPLENBQUNxSCxRQUFRO1FBQzNCLE1BQU14RSxNQUFNakMsSUFBSSxDQUFDMEcsR0FBRzFGLEtBQUssQ0FBQztRQUMxQlAsUUFBUWdJLFFBQVEsR0FBR3hHLElBQUlqQixLQUFLO1FBRTVCLE1BQU1tSCxnQkFBZ0IsQ0FBQ2xGO1FBQ3ZCLGdEQUFnRCxHQUNoRCxJQUFJa0YsZUFBZTtZQUNqQixnQ0FBZ0MsR0FDaENKLGFBQWFqSixTQUFTRSxHQUFHLElBQUlGLFNBQVNFLEdBQUcsQ0FBQzBKLFVBQVUsQ0FBQ2hDLEdBQUcxRixLQUFLO1lBQzdELElBQUkrRyxZQUFZO2dCQUNkUyxXQUFXekksTUFBTVksTUFBTSxHQUFHK0YsR0FBRzFGLEtBQUs7Z0JBQ2xDNkYsWUFBWS9ILFNBQVNFLEdBQUcsQ0FBQ2tJLFNBQVM7Z0JBQ2xDcEksU0FBU0UsR0FBRyxDQUFDNEksSUFBSSxDQUFDWSxVQUFVdkcsSUFBSUcsSUFBSTtZQUN0QztZQUNBLDRFQUE0RSxHQUM1RSx1RUFBdUUsR0FDdkU0RSxPQUFPdkcsUUFBUW9DLE1BQU0sQ0FBQ2xDLE1BQU07WUFDNUJzRyxPQUFPeEcsUUFBUXFDLE1BQU0sQ0FBQ25DLE1BQU07WUFDNUJGLFFBQVFvQyxNQUFNLENBQUNoQyxJQUFJO1lBQ25CSixRQUFRcUMsTUFBTSxDQUFDakMsSUFBSTtZQUNuQm9ILFlBQVl4SCxRQUFRcUMsTUFBTTtZQUMxQnJDLFFBQVFxQyxNQUFNLEdBQUcsSUFBSXJCO1FBQ3ZCO1FBQ0EsZ0JBQWdCLEdBQ2hCLE1BQU1rRyxZQUFZbkksV0FBV2dCO1FBQzdCVixZQUFZLENBQUM0RyxHQUFHMUYsS0FBSyxDQUFDLENBQUNQLFNBQVNwQixPQUFPbUIsYUFBYVA7UUFDcERxSSwwQkFBMEJyRyxLQUFLeEIsU0FBU2tIO1FBQ3hDLElBQUlRLGVBQWU7WUFDakIsV0FBVyxHQUNYLElBQUlKLFlBQVk7Z0JBQ2QsSUFBSXRILFFBQVFrQyxLQUFLLEtBQUtqRSxHQUFHa0gsT0FBTyxFQUFFO29CQUNoQzlHLFNBQVNFLEdBQUcsQ0FBQ21JLFNBQVMsQ0FBQ047Z0JBQ3pCLE9BQU87b0JBQ0wvSCxTQUFTRSxHQUFHLENBQUNxSixFQUFFLENBQUNHLFVBQVV2RyxJQUFJRyxJQUFJLEVBQUU1QixhQUFhQyxRQUFROEIsWUFBWTtnQkFDdkU7WUFDRjtZQUNBLHNCQUFzQixHQUN0QjlCLFFBQVFxQyxNQUFNLEdBQUdtRjtZQUNqQixJQUFJeEgsUUFBUWtDLEtBQUssS0FBS2pFLEdBQUdrSCxPQUFPLEVBQUU7Z0JBQ2hDbkYsUUFBUW9DLE1BQU0sQ0FBQzVCLEdBQUcsQ0FBQytGO2dCQUNuQnZHLFFBQVFxQyxNQUFNLENBQUM3QixHQUFHLENBQUNnRztZQUNyQixPQUFPLElBQUloRixJQUFJRixLQUFLLEVBQUU7Z0JBQ3BCLHVEQUF1RCxHQUN2RCwrQ0FBK0MsR0FDL0N0QixRQUFRcUMsTUFBTSxDQUFDUixVQUFVLENBQUNMLElBQUlELEtBQUssRUFBRXhCLGFBQWFDLFFBQVE4QixZQUFZO2dCQUN0RTlCLFFBQVFvQyxNQUFNLENBQUNQLFVBQVUsQ0FBQ0wsSUFBSUQsS0FBSyxFQUFFeEIsYUFBYUMsUUFBUThCLFlBQVk7WUFDeEU7UUFDRjtJQUNGO0lBQ0EsMEJBQTBCO0lBQzFCLDhDQUE4QztJQUM5Qyw0REFBNEQ7SUFDNUQseUNBQXlDO0lBQ3pDLDBFQUEwRTtJQUMxRSxNQUFNb0csUUFBUSxTQUFVbEMsT0FBTyxFQUFFakcsV0FBVyxFQUFFQyxPQUFPO1FBQ25EaEIsV0FBV29CLElBQUksQ0FBQztZQUNkcEIsWUFBWWYsR0FBR2tLLGdCQUFnQjtZQUMvQnBILFFBQVFoQjtZQUNSaEI7WUFDQUQ7UUFDRjtRQUNBQyxXQUFXSCxNQUFNc0IsTUFBTTtRQUN2QnBCLGNBQWNGLE1BQU1zQixNQUFNLEdBQUdyQjtRQUM3QlAsVUFBVTBILFVBQVUsR0FBR2pHLGFBQWFDO1FBQ3BDLE1BQU1RLE1BQU14QixXQUFXd0IsR0FBRztRQUMxQnpCLFdBQVd5QixJQUFJekIsUUFBUTtRQUN2QkQsY0FBYzBCLElBQUkxQixXQUFXO1FBQzdCa0IsUUFBUThCLFlBQVksR0FBRztRQUN2QixPQUFROUIsUUFBUWtDLEtBQUs7WUFDbkIsS0FBS2pFLEdBQUdtSCxLQUFLO2dCQUNYcEYsUUFBUWtDLEtBQUssR0FBR2pFLEdBQUdtSCxLQUFLO2dCQUN4QjtZQUNGLEtBQUtuSCxHQUFHb0gsS0FBSztnQkFDWHJGLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHbUgsS0FBSztnQkFDeEI7WUFDRixLQUFLbkgsR0FBR2tILE9BQU87Z0JBQ2JuRixRQUFRa0MsS0FBSyxHQUFHakUsR0FBR2tILE9BQU87Z0JBQzFCO1lBQ0Y7Z0JBQ0UsTUFBTSxJQUFJaEYsTUFBTSxDQUFDLHFCQUFxQixFQUFFSCxRQUFRa0MsS0FBSyxDQUFDLENBQUM7UUFDM0Q7SUFDRjtJQUNBLDBCQUEwQjtJQUMxQiw4Q0FBOEM7SUFDOUMsNERBQTREO0lBQzVELDRDQUE0QztJQUM1Qyw4REFBOEQ7SUFDOUQsMENBQTBDO0lBQzFDLE1BQU1rRyxRQUFRLFNBQVVwQyxPQUFPLEVBQUVqRyxXQUFXLEVBQUVDLE9BQU87UUFDbkRoQixXQUFXb0IsSUFBSSxDQUFDO1lBQ2RwQixZQUFZZixHQUFHa0ssZ0JBQWdCO1lBQy9CcEgsUUFBUWhCO1lBQ1JoQjtZQUNBRDtRQUNGO1FBQ0FDLFdBQVdILE1BQU1zQixNQUFNO1FBQ3ZCcEIsY0FBY0YsTUFBTXNCLE1BQU0sR0FBR3JCO1FBQzdCUCxVQUFVMEgsVUFBVSxHQUFHakcsYUFBYUM7UUFDcEMsTUFBTVEsTUFBTXhCLFdBQVd3QixHQUFHO1FBQzFCekIsV0FBV3lCLElBQUl6QixRQUFRO1FBQ3ZCRCxjQUFjMEIsSUFBSTFCLFdBQVc7UUFDN0JrQixRQUFROEIsWUFBWSxHQUFHO1FBQ3ZCLE9BQVE5QixRQUFRa0MsS0FBSztZQUNuQixLQUFLakUsR0FBR21ILEtBQUs7WUFDYixLQUFLbkgsR0FBR29ILEtBQUs7Z0JBQ1hyRixRQUFRa0MsS0FBSyxHQUFHakUsR0FBR2tILE9BQU87Z0JBQzFCO1lBQ0YsS0FBS2xILEdBQUdrSCxPQUFPO2dCQUNibkYsUUFBUWtDLEtBQUssR0FBR2pFLEdBQUdtSCxLQUFLO2dCQUN4QjtZQUNGO2dCQUNFLE1BQU0sSUFBSWpGLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRUgsUUFBUWtDLEtBQUssQ0FBQyxDQUFDO1FBQzNEO0lBQ0Y7SUFDQSwwQkFBMEI7SUFDMUIsMERBQTBEO0lBQzFELGdDQUFnQztJQUNoQyxNQUFNbUcsUUFBUSxTQUFVckMsT0FBTyxFQUFFakcsV0FBVyxFQUFFQyxPQUFPO1FBQ25ELE1BQU1pRyxLQUFLdEgsT0FBTyxDQUFDcUgsUUFBUTtRQUMzQmhHLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHa0gsT0FBTztRQUMxQixJQUFJcEYsY0FBY2hCLFVBQVU7WUFDMUIsSUFBSWtILEdBQUdlLEdBQUcsSUFBSXBJLEtBQUssQ0FBQ21CLFlBQVksSUFBSW5CLEtBQUssQ0FBQ21CLFlBQVksSUFBSWtHLEdBQUdjLEdBQUcsRUFBRTtnQkFDaEUvRyxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR29ILEtBQUs7Z0JBQ3hCckYsUUFBUThCLFlBQVksR0FBRztZQUN6QjtRQUNGO0lBQ0Y7SUFDQSwwQkFBMEI7SUFDMUIsMkRBQTJEO0lBQzNELHFDQUFxQztJQUNyQyxxRkFBcUY7SUFDckYsc0JBQXNCO0lBQ3RCLHdDQUF3QztJQUN4QywwREFBMEQ7SUFDMUQsTUFBTXdHLFFBQVEsU0FBVXRDLE9BQU8sRUFBRWpHLFdBQVcsRUFBRUMsT0FBTztRQUNuRCxJQUFJMEQ7UUFDSixNQUFNdUMsS0FBS3RILE9BQU8sQ0FBQ3FILFFBQVE7UUFDM0IsTUFBTS9CLE1BQU1nQyxHQUFHc0MsTUFBTSxDQUFDckksTUFBTTtRQUM1QkYsUUFBUWtDLEtBQUssR0FBR2pFLEdBQUdrSCxPQUFPO1FBQzFCLElBQUlwRixjQUFja0UsT0FBT2xGLFVBQVU7WUFDakMsSUFBSzJFLElBQUksR0FBR0EsSUFBSU8sS0FBS1AsS0FBSyxFQUFHO2dCQUMzQixJQUFJOUUsS0FBSyxDQUFDbUIsY0FBYzJELEVBQUUsS0FBS3VDLEdBQUdzQyxNQUFNLENBQUM3RSxFQUFFLEVBQUU7b0JBQzNDO2dCQUNGO1lBQ0Y7WUFDQTFELFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHb0gsS0FBSztZQUN4QnJGLFFBQVE4QixZQUFZLEdBQUdtQztRQUN6QixFQUFFLHdCQUF3QjtJQUM1QjtJQUNBLDBCQUEwQjtJQUMxQiwyREFBMkQ7SUFDM0QsMEVBQTBFO0lBQzFFLG1FQUFtRTtJQUNuRSxvRUFBb0U7SUFDcEUsbURBQW1EO0lBQ25ELE1BQU11RSxRQUFRLFNBQVV4QyxPQUFPLEVBQUVqRyxXQUFXLEVBQUVDLE9BQU87UUFDbkQsSUFBSTBEO1FBQ0osSUFBSStFO1FBQ0osTUFBTXhDLEtBQUt0SCxPQUFPLENBQUNxSCxRQUFRO1FBQzNCaEcsUUFBUWtDLEtBQUssR0FBR2pFLEdBQUdrSCxPQUFPO1FBQzFCLE1BQU1sQixNQUFNZ0MsR0FBR3NDLE1BQU0sQ0FBQ3JJLE1BQU07UUFDNUIsSUFBSStELFFBQVEsR0FBRztZQUNiLCtCQUErQixHQUMvQmpFLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHbUgsS0FBSztZQUN4QjtRQUNGO1FBQ0EsSUFBSXJGLGNBQWNrRSxPQUFPbEYsVUFBVTtZQUNqQyxJQUFLMkUsSUFBSSxHQUFHQSxJQUFJTyxLQUFLUCxLQUFLLEVBQUc7Z0JBQzNCK0UsT0FBTzdKLEtBQUssQ0FBQ21CLGNBQWMyRCxFQUFFO2dCQUM3QixJQUFJK0UsUUFBUSxNQUFNQSxRQUFRLElBQUk7b0JBQzVCQSxRQUFRO2dCQUNWO2dCQUNBLElBQUlBLFNBQVN4QyxHQUFHc0MsTUFBTSxDQUFDN0UsRUFBRSxFQUFFO29CQUN6QjtnQkFDRjtZQUNGO1lBQ0ExRCxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR29ILEtBQUs7WUFDeEJyRixRQUFROEIsWUFBWSxHQUFHbUM7UUFDekIsRUFBRSx3QkFBd0I7SUFDNUI7SUFDQSwwQkFBMEI7SUFDMUIsaUdBQWlHO0lBQ2pHLHFEQUFxRDtJQUNyRCwwREFBMEQ7SUFDMUQsTUFBTXlFLFFBQVEsU0FBVTFDLE9BQU8sRUFBRWpHLFdBQVcsRUFBRUMsT0FBTztRQUNuREEsUUFBUWtDLEtBQUssR0FBR2pFLEdBQUdrSCxPQUFPO1FBQzFCbkYsUUFBUThCLFlBQVksR0FBRztRQUN2QjlCLFFBQVFrQyxLQUFLLEdBQUduQyxnQkFBZ0IsSUFBSTlCLEdBQUdtSCxLQUFLLEdBQUduSCxHQUFHa0gsT0FBTztJQUMzRDtJQUNBLDBCQUEwQjtJQUMxQiwyRkFBMkY7SUFDM0YscURBQXFEO0lBQ3JELG9GQUFvRjtJQUNwRixNQUFNd0QsUUFBUSxTQUFVM0MsT0FBTyxFQUFFakcsV0FBVyxFQUFFQyxPQUFPO1FBQ25EQSxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR2tILE9BQU87UUFDMUJuRixRQUFROEIsWUFBWSxHQUFHO1FBQ3ZCOUIsUUFBUWtDLEtBQUssR0FBR25DLGdCQUFnQm5CLE1BQU1zQixNQUFNLEdBQUdqQyxHQUFHbUgsS0FBSyxHQUFHbkgsR0FBR2tILE9BQU87SUFDdEU7SUFDQSwwQkFBMEI7SUFDMUIsK0JBQStCO0lBQy9CLHFGQUFxRjtJQUNyRixpR0FBaUc7SUFDakcsOENBQThDO0lBQzlDLHFGQUFxRjtJQUNyRix3RkFBd0Y7SUFDeEYsTUFBTXlELFFBQVEsU0FBVTVDLE9BQU8sRUFBRWpHLFdBQVcsRUFBRUMsT0FBTztRQUNuRCxJQUFJMEQ7UUFDSixJQUFJK0U7UUFDSixJQUFJSTtRQUNKLElBQUl0SDtRQUNKLE1BQU0wRSxLQUFLdEgsT0FBTyxDQUFDcUgsUUFBUTtRQUMzQmhHLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHa0gsT0FBTztRQUMxQixJQUFJYyxHQUFHMUYsS0FBSyxHQUFHakIsTUFBTVksTUFBTSxFQUFFO1lBQzNCcUIsUUFBUWpDLEtBQUssQ0FBQzJHLEdBQUcxRixLQUFLLENBQUMsQ0FBQ2dCLEtBQUs7UUFDL0IsT0FBTztZQUNMQSxRQUFRaEMsSUFBSSxDQUFDMEcsR0FBRzFGLEtBQUssR0FBR2pCLE1BQU1ZLE1BQU0sQ0FBQyxDQUFDcUIsS0FBSztRQUM3QztRQUNBLE1BQU11SCxRQUFRN0MsR0FBRzhDLE9BQU8sS0FBSzlLLEdBQUcrSyxXQUFXLEdBQUdoSixRQUFRcUMsTUFBTSxDQUFDTixTQUFTLENBQUNSLFNBQVN2QixRQUFRb0MsTUFBTSxDQUFDTCxTQUFTLENBQUNSO1FBQ3pHLE1BQU0wSCxjQUFjaEQsR0FBR2lELE9BQU8sS0FBS2pMLEdBQUdrTCxXQUFXO1FBQ2pELElBQUlMLFVBQVUsTUFBTTtZQUNsQjtRQUNGO1FBQ0EsTUFBTU0sVUFBVU4sTUFBTS9JLFdBQVc7UUFDakMsTUFBTWtFLE1BQU02RSxNQUFNaEgsWUFBWTtRQUM5QixJQUFJbUMsUUFBUSxHQUFHO1lBQ2JqRSxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR21ILEtBQUs7WUFDeEI7UUFDRjtRQUNBLElBQUlyRixjQUFja0UsT0FBT2xGLFVBQVU7WUFDakMsSUFBSWtLLGFBQWE7Z0JBQ2YsMEJBQTBCLEdBQzFCLElBQUt2RixJQUFJLEdBQUdBLElBQUlPLEtBQUtQLEtBQUssRUFBRztvQkFDM0IrRSxPQUFPN0osS0FBSyxDQUFDbUIsY0FBYzJELEVBQUU7b0JBQzdCbUYsU0FBU2pLLEtBQUssQ0FBQ3dLLFVBQVUxRixFQUFFO29CQUMzQixJQUFJK0UsUUFBUSxNQUFNQSxRQUFRLElBQUk7d0JBQzVCQSxRQUFRO29CQUNWO29CQUNBLElBQUlJLFVBQVUsTUFBTUEsVUFBVSxJQUFJO3dCQUNoQ0EsVUFBVTtvQkFDWjtvQkFDQSxJQUFJSixTQUFTSSxRQUFRO3dCQUNuQjtvQkFDRjtnQkFDRjtnQkFDQTdJLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHb0gsS0FBSztnQkFDeEJyRixRQUFROEIsWUFBWSxHQUFHbUM7WUFDekIsT0FBTztnQkFDTCx3QkFBd0IsR0FDeEIsSUFBS1AsSUFBSSxHQUFHQSxJQUFJTyxLQUFLUCxLQUFLLEVBQUc7b0JBQzNCK0UsT0FBTzdKLEtBQUssQ0FBQ21CLGNBQWMyRCxFQUFFO29CQUM3Qm1GLFNBQVNqSyxLQUFLLENBQUN3SyxVQUFVMUYsRUFBRTtvQkFDM0IsSUFBSStFLFNBQVNJLFFBQVE7d0JBQ25CO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQTdJLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHb0gsS0FBSztZQUN4QnJGLFFBQVE4QixZQUFZLEdBQUdtQztRQUN6QjtJQUNGO0lBQ0EsMEJBQTBCO0lBQzFCLCtDQUErQztJQUMvQywyQ0FBMkM7SUFDM0Msa0VBQWtFO0lBQ2xFLHdFQUF3RTtJQUN4RSxNQUFNb0YsUUFBUSxTQUFVckQsT0FBTyxFQUFFakcsV0FBVyxFQUFFQyxPQUFPO1FBQ25EaEIsV0FBV29CLElBQUksQ0FBQztZQUNkcEIsWUFBWWYsR0FBR3lFLGlCQUFpQjtZQUNoQzNCLFFBQVFoQjtRQUNWO1FBQ0F6QixVQUFVMEgsVUFBVSxHQUFHakcsYUFBYUM7UUFDcENoQixXQUFXd0IsR0FBRztRQUNkUixRQUFROEIsWUFBWSxHQUFHO1FBQ3ZCLE9BQVE5QixRQUFRa0MsS0FBSztZQUNuQixLQUFLakUsR0FBR21ILEtBQUs7Z0JBQ1hwRixRQUFRa0MsS0FBSyxHQUFHakUsR0FBR21ILEtBQUs7Z0JBQ3hCO1lBQ0YsS0FBS25ILEdBQUdvSCxLQUFLO2dCQUNYckYsUUFBUWtDLEtBQUssR0FBR2pFLEdBQUdtSCxLQUFLO2dCQUN4QjtZQUNGLEtBQUtuSCxHQUFHa0gsT0FBTztnQkFDYm5GLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHa0gsT0FBTztnQkFDMUI7WUFDRjtnQkFDRSxNQUFNLElBQUloRixNQUFNLENBQUMscUJBQXFCLEVBQUVILFFBQVFrQyxLQUFLLENBQUMsQ0FBQztRQUMzRDtJQUNGO0lBQ0EsMEJBQTBCO0lBQzFCLCtDQUErQztJQUMvQywyQ0FBMkM7SUFDM0Msd0VBQXdFO0lBQ3hFLHdFQUF3RTtJQUN4RSxNQUFNb0gsUUFBUSxTQUFVdEQsT0FBTyxFQUFFakcsV0FBVyxFQUFFQyxPQUFPO1FBQ25ELFVBQVU7UUFDVix5QkFBeUI7UUFDekJoQixXQUFXb0IsSUFBSSxDQUFDO1lBQ2RwQixZQUFZZixHQUFHeUUsaUJBQWlCO1lBQ2hDM0IsUUFBUWhCO1FBQ1Y7UUFDQXpCLFVBQVUwSCxVQUFVLEdBQUdqRyxhQUFhQztRQUNwQ2hCLFdBQVd3QixHQUFHO1FBQ2RSLFFBQVE4QixZQUFZLEdBQUc7UUFDdkIsT0FBUTlCLFFBQVFrQyxLQUFLO1lBQ25CLEtBQUtqRSxHQUFHbUgsS0FBSztZQUNiLEtBQUtuSCxHQUFHb0gsS0FBSztnQkFDWHJGLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHa0gsT0FBTztnQkFDMUI7WUFDRixLQUFLbEgsR0FBR2tILE9BQU87Z0JBQ2JuRixRQUFRa0MsS0FBSyxHQUFHakUsR0FBR21ILEtBQUs7Z0JBQ3hCO1lBQ0Y7Z0JBQ0UsTUFBTSxJQUFJakYsTUFBTSxDQUFDLHFCQUFxQixFQUFFSCxRQUFRa0MsS0FBSyxDQUFDLENBQUM7UUFDM0Q7SUFDRjtJQUNBLHdDQUF3QztJQUN4Qyx1REFBdUQ7SUFDdkQsd0ZBQXdGO0lBQ3hGLE1BQU1xSCxjQUFjLFNBQVV2RCxPQUFPLEVBQUVqRyxXQUFXLEVBQUVDLE9BQU87UUFDekQsSUFBSWtGO1FBQ0osSUFBSWtCO1FBQ0osSUFBSUM7UUFDSixJQUFJbUQ7UUFDSixNQUFNdkQsS0FBS3RILE9BQU8sQ0FBQ3FILFFBQVE7UUFDM0IsTUFBTU8sT0FBT3ZHLFFBQVFvQyxNQUFNLENBQUNsQyxNQUFNO1FBQ2xDLE1BQU1zRyxPQUFPeEcsUUFBUXFDLE1BQU0sQ0FBQ25DLE1BQU07UUFDbEMsSUFBSTdCLFNBQVNFLEdBQUcsRUFBRTtZQUNoQjZILFlBQVkvSCxTQUFTRSxHQUFHLENBQUNrSSxTQUFTO1FBQ3BDO1FBQ0F2QixVQUFVO1FBQ1ZtQixlQUFldEc7UUFDZnlKLGFBQWE7UUFDYixpQkFBaUI7UUFDakIsSUFBSyxJQUFJOUYsSUFBSXVDLEdBQUdDLFFBQVEsQ0FBQ2hHLE1BQU0sR0FBRyxHQUFHd0QsS0FBSyxHQUFHQSxLQUFLLEVBQUc7WUFDbkRwRixVQUFVMkgsR0FBR0MsUUFBUSxDQUFDeEMsRUFBRSxFQUFFMkMsY0FBY3JHO1lBQ3hDcUcsZ0JBQWdCckcsUUFBUThCLFlBQVk7WUFDcEMwSCxjQUFjeEosUUFBUThCLFlBQVk7WUFDbEMscUNBQXFDO1lBQ3JDLElBQUk5QixRQUFRa0MsS0FBSyxLQUFLakUsR0FBR2tILE9BQU8sRUFBRTtnQkFDaENELFVBQVU7Z0JBQ1Y7WUFDRjtRQUNGO1FBQ0EsSUFBSUEsU0FBUztZQUNYbEYsUUFBUWtDLEtBQUssR0FBR3NILGVBQWUsSUFBSXZMLEdBQUdtSCxLQUFLLEdBQUduSCxHQUFHb0gsS0FBSztZQUN0RHJGLFFBQVE4QixZQUFZLEdBQUcwSDtRQUN6QixPQUFPO1lBQ0x4SixRQUFRa0MsS0FBSyxHQUFHakUsR0FBR2tILE9BQU87WUFDMUJuRixRQUFROEIsWUFBWSxHQUFHO1lBQ3ZCOUIsUUFBUW9DLE1BQU0sQ0FBQzVCLEdBQUcsQ0FBQytGO1lBQ25CdkcsUUFBUXFDLE1BQU0sQ0FBQzdCLEdBQUcsQ0FBQ2dHO1lBQ25CLElBQUluSSxTQUFTRSxHQUFHLEVBQUU7Z0JBQ2hCRixTQUFTRSxHQUFHLENBQUNtSSxTQUFTLENBQUNOO1lBQ3pCO1FBQ0Y7SUFDRjtJQUNBLHdDQUF3QztJQUN4QyxrREFBa0Q7SUFDbEQsdUZBQXVGO0lBQ3ZGLE1BQU1xRCxjQUFjLFNBQVV6RCxPQUFPLEVBQUVqRyxXQUFXLEVBQUVDLE9BQU87UUFDekQsSUFBSW9HO1FBQ0osSUFBSVE7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osTUFBTWIsS0FBS3RILE9BQU8sQ0FBQ3FILFFBQVE7UUFDM0JZLGVBQWU3RztRQUNmOEcsWUFBWTtRQUNaQyxXQUFXO1FBQ1gsTUFBTVAsT0FBT3ZHLFFBQVFvQyxNQUFNLENBQUNsQyxNQUFNO1FBQ2xDLE1BQU1zRyxPQUFPeEcsUUFBUXFDLE1BQU0sQ0FBQ25DLE1BQU07UUFDbEMsSUFBSTdCLFNBQVNFLEdBQUcsRUFBRTtZQUNoQjZILFlBQVkvSCxTQUFTRSxHQUFHLENBQUNrSSxTQUFTO1FBQ3BDO1FBQ0EsTUFBTTdELE9BQU87UUFDYixNQUFPQSxLQUFNO1lBQ1gsSUFBSWdFLGdCQUFnQixHQUFHO2dCQUVyQjtZQUNGO1lBQ0F0SSxVQUFVMEgsVUFBVSxHQUFHWSxjQUFjNUc7WUFDckMsSUFBSUEsUUFBUWtDLEtBQUssS0FBS2pFLEdBQUdrSCxPQUFPLEVBQUU7Z0JBRWhDO1lBQ0Y7WUFDQSxJQUFJbkYsUUFBUWtDLEtBQUssS0FBS2pFLEdBQUdtSCxLQUFLLEVBQUU7Z0JBRzlCO1lBQ0Y7WUFDQTBCLFlBQVk7WUFDWkQsYUFBYTdHLFFBQVE4QixZQUFZO1lBQ2pDOEUsZ0JBQWdCNUcsUUFBUThCLFlBQVk7WUFDcEMsSUFBSWdGLGFBQWFiLEdBQUdjLEdBQUcsRUFBRTtnQkFFdkI7WUFDRjtRQUNGO1FBQ0EsNkRBQTZELEdBQzdELElBQUkvRyxRQUFRa0MsS0FBSyxLQUFLakUsR0FBR21ILEtBQUssRUFBRTtZQUM5QnBGLFFBQVFrQyxLQUFLLEdBQUcyRSxjQUFjLElBQUk1SSxHQUFHbUgsS0FBSyxHQUFHbkgsR0FBR29ILEtBQUs7WUFDckRyRixRQUFROEIsWUFBWSxHQUFHK0U7UUFDekIsT0FBTyxJQUFJQyxZQUFZYixHQUFHZSxHQUFHLEVBQUU7WUFDN0JoSCxRQUFRa0MsS0FBSyxHQUFHMkUsY0FBYyxJQUFJNUksR0FBR21ILEtBQUssR0FBR25ILEdBQUdvSCxLQUFLO1lBQ3JEckYsUUFBUThCLFlBQVksR0FBRytFO1FBQ3pCLE9BQU87WUFDTDdHLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHa0gsT0FBTztZQUMxQm5GLFFBQVE4QixZQUFZLEdBQUc7WUFDdkI5QixRQUFRb0MsTUFBTSxDQUFDNUIsR0FBRyxDQUFDK0Y7WUFDbkJ2RyxRQUFRcUMsTUFBTSxDQUFDN0IsR0FBRyxDQUFDZ0c7WUFDbkIsSUFBSW5JLFNBQVNFLEdBQUcsRUFBRTtnQkFDaEJGLFNBQVNFLEdBQUcsQ0FBQ21JLFNBQVMsQ0FBQ047WUFDekI7UUFDRjtJQUNGO0lBQ0Esd0NBQXdDO0lBQ3hDLGtEQUFrRDtJQUNsRCw4RUFBOEU7SUFDOUUsTUFBTXNELGNBQWMsU0FBVTFELE9BQU8sRUFBRWpHLFdBQVcsRUFBRUMsT0FBTztRQUN6RCxNQUFNaUcsS0FBS3RILE9BQU8sQ0FBQ3FILFFBQVE7UUFDM0JoRyxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR2tILE9BQU87UUFDMUJuRixRQUFROEIsWUFBWSxHQUFHO1FBQ3ZCLElBQUkvQixjQUFjLEdBQUc7WUFDbkIsTUFBTTRKLE9BQU8vSyxLQUFLLENBQUNtQixjQUFjLEVBQUU7WUFDbkMsSUFBSWtHLEdBQUdlLEdBQUcsSUFBSTJDLFFBQVFBLFFBQVExRCxHQUFHYyxHQUFHLEVBQUU7Z0JBQ3BDL0csUUFBUWtDLEtBQUssR0FBR2pFLEdBQUdvSCxLQUFLO2dCQUN4QnJGLFFBQVE4QixZQUFZLEdBQUc7WUFDekI7UUFDRjtJQUNGO0lBQ0Esd0NBQXdDO0lBQ3hDLGtEQUFrRDtJQUNsRCx5REFBeUQ7SUFDekQsTUFBTThILGNBQWMsU0FBVTVELE9BQU8sRUFBRWpHLFdBQVcsRUFBRUMsT0FBTztRQUN6RCxJQUFJMEQ7UUFDSixNQUFNdUMsS0FBS3RILE9BQU8sQ0FBQ3FILFFBQVE7UUFDM0JoRyxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR2tILE9BQU87UUFDMUIsTUFBTWxCLE1BQU1nQyxHQUFHc0MsTUFBTSxDQUFDckksTUFBTTtRQUM1QixNQUFNOEQsTUFBTWpFLGNBQWNrRTtRQUMxQixJQUFJRCxPQUFPLEdBQUc7WUFDWixJQUFLTixJQUFJLEdBQUdBLElBQUlPLEtBQUtQLEtBQUssRUFBRztnQkFDM0IsSUFBSTlFLEtBQUssQ0FBQ29GLE1BQU1OLEVBQUUsS0FBS3VDLEdBQUdzQyxNQUFNLENBQUM3RSxFQUFFLEVBQUU7b0JBQ25DO2dCQUNGO1lBQ0Y7WUFDQTFELFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHb0gsS0FBSztZQUN4QnJGLFFBQVE4QixZQUFZLEdBQUdtQztRQUN6QjtJQUNGO0lBQ0Esd0NBQXdDO0lBQ3hDLGtEQUFrRDtJQUNsRCx5REFBeUQ7SUFDekQsTUFBTTRGLGNBQWMsU0FBVTdELE9BQU8sRUFBRWpHLFdBQVcsRUFBRUMsT0FBTztRQUN6RCxJQUFJMko7UUFDSixNQUFNMUQsS0FBS3RILE9BQU8sQ0FBQ3FILFFBQVE7UUFDM0JoRyxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR2tILE9BQU87UUFDMUIsTUFBTWxCLE1BQU1nQyxHQUFHc0MsTUFBTSxDQUFDckksTUFBTTtRQUM1QixJQUFJK0QsUUFBUSxHQUFHO1lBQ2IsK0JBQStCLEdBQy9CakUsUUFBUWtDLEtBQUssR0FBR2pFLEdBQUdtSCxLQUFLO1lBQ3hCO1FBQ0Y7UUFDQSxNQUFNcEIsTUFBTWpFLGNBQWNrRTtRQUMxQixJQUFJRCxPQUFPLEdBQUc7WUFDWixJQUFLLElBQUlOLElBQUksR0FBR0EsSUFBSU8sS0FBS1AsS0FBSyxFQUFHO2dCQUMvQmlHLE9BQU8vSyxLQUFLLENBQUNvRixNQUFNTixFQUFFO2dCQUNyQixJQUFJaUcsUUFBUSxNQUFNQSxRQUFRLElBQUk7b0JBQzVCQSxRQUFRO2dCQUNWO2dCQUNBLElBQUlBLFNBQVMxRCxHQUFHc0MsTUFBTSxDQUFDN0UsRUFBRSxFQUFFO29CQUN6QjtnQkFDRjtZQUNGO1lBQ0ExRCxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR29ILEtBQUs7WUFDeEJyRixRQUFROEIsWUFBWSxHQUFHbUM7UUFDekI7SUFDRjtJQUNBLGlEQUFpRDtJQUNqRCxtRUFBbUU7SUFDbkUsTUFBTTZGLGNBQWMsU0FBVTlELE9BQU8sRUFBRWpHLFdBQVcsRUFBRUMsT0FBTztRQUN6RCxJQUFJMEQ7UUFDSixJQUFJK0U7UUFDSixJQUFJSTtRQUNKLElBQUl0SDtRQUNKLE1BQU0wRSxLQUFLdEgsT0FBTyxDQUFDcUgsUUFBUTtRQUMzQixtQkFBbUIsR0FDbkJoRyxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR2tILE9BQU87UUFDMUJuRixRQUFROEIsWUFBWSxHQUFHO1FBQ3ZCLElBQUltRSxHQUFHMUYsS0FBSyxHQUFHakIsTUFBTVksTUFBTSxFQUFFO1lBQzNCcUIsUUFBUWpDLEtBQUssQ0FBQzJHLEdBQUcxRixLQUFLLENBQUMsQ0FBQ2dCLEtBQUs7UUFDL0IsT0FBTztZQUNMQSxRQUFRaEMsSUFBSSxDQUFDMEcsR0FBRzFGLEtBQUssR0FBR2pCLE1BQU1ZLE1BQU0sQ0FBQyxDQUFDcUIsS0FBSztRQUM3QztRQUNBLE1BQU11SCxRQUFRN0MsR0FBRzhDLE9BQU8sS0FBSzlLLEdBQUcrSyxXQUFXLEdBQUdoSixRQUFRcUMsTUFBTSxDQUFDTixTQUFTLENBQUNSLFNBQVN2QixRQUFRb0MsTUFBTSxDQUFDTCxTQUFTLENBQUNSO1FBQ3pHLE1BQU0wSCxjQUFjaEQsR0FBR2lELE9BQU8sS0FBS2pMLEdBQUdrTCxXQUFXO1FBQ2pELElBQUlMLFVBQVUsTUFBTTtZQUNsQjtRQUNGO1FBQ0EsTUFBTU0sVUFBVU4sTUFBTS9JLFdBQVc7UUFDakMsTUFBTWtFLE1BQU02RSxNQUFNaEgsWUFBWTtRQUM5QixJQUFJbUMsUUFBUSxHQUFHO1lBQ2JqRSxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR21ILEtBQUs7WUFDeEJwRixRQUFROEIsWUFBWSxHQUFHO1lBQ3ZCO1FBQ0Y7UUFDQSxNQUFNa0MsTUFBTWpFLGNBQWNrRTtRQUMxQixJQUFJRCxPQUFPLEdBQUc7WUFDWixJQUFJaUYsYUFBYTtnQkFDZiwwQkFBMEIsR0FDMUIsSUFBS3ZGLElBQUksR0FBR0EsSUFBSU8sS0FBS1AsS0FBSyxFQUFHO29CQUMzQitFLE9BQU83SixLQUFLLENBQUNvRixNQUFNTixFQUFFO29CQUNyQm1GLFNBQVNqSyxLQUFLLENBQUN3SyxVQUFVMUYsRUFBRTtvQkFDM0IsSUFBSStFLFFBQVEsTUFBTUEsUUFBUSxJQUFJO3dCQUM1QkEsUUFBUTtvQkFDVjtvQkFDQSxJQUFJSSxVQUFVLE1BQU1BLFVBQVUsSUFBSTt3QkFDaENBLFVBQVU7b0JBQ1o7b0JBQ0EsSUFBSUosU0FBU0ksUUFBUTt3QkFDbkI7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0E3SSxRQUFRa0MsS0FBSyxHQUFHakUsR0FBR29ILEtBQUs7Z0JBQ3hCckYsUUFBUThCLFlBQVksR0FBR21DO1lBQ3pCLE9BQU87Z0JBQ0wsd0JBQXdCLEdBQ3hCLElBQUtQLElBQUksR0FBR0EsSUFBSU8sS0FBS1AsS0FBSyxFQUFHO29CQUMzQitFLE9BQU83SixLQUFLLENBQUNvRixNQUFNTixFQUFFO29CQUNyQm1GLFNBQVNqSyxLQUFLLENBQUN3SyxVQUFVMUYsRUFBRTtvQkFDM0IsSUFBSStFLFNBQVNJLFFBQVE7d0JBQ25CO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQTdJLFFBQVFrQyxLQUFLLEdBQUdqRSxHQUFHb0gsS0FBSztZQUN4QnJGLFFBQVE4QixZQUFZLEdBQUdtQztRQUN6QjtJQUNGO0lBQ0Esc0NBQXNDO0lBQ3RDLGtFQUFrRTtJQUNsRSwrREFBK0Q7SUFDL0QsMERBQTBEO0lBQzFELHdFQUF3RTtJQUN4RSwwRUFBMEU7SUFDMUUsU0FBUztJQUNUM0YsWUFBWSxTQUFTeUwsY0FBYy9ELE9BQU8sRUFBRWpHLFdBQVcsRUFBRUMsT0FBTztRQUM5RCxJQUFJZ0ssTUFBTTtRQUNWLE1BQU0vRCxLQUFLdEgsT0FBTyxDQUFDcUgsUUFBUTtRQUMzQjdHLFlBQVk7UUFDWixJQUFJQSxXQUFXUyxlQUFlO1lBQzVCLE1BQU0sSUFBSU8sTUFBTSxDQUFDLDhDQUE4QyxFQUFFUCxjQUFjLENBQUM7UUFDbEY7UUFDQVgsYUFBYTtRQUNiLElBQUlBLFlBQVlDLGNBQWM7WUFDNUJBLGVBQWVEO1lBQ2YsSUFBSUMsZUFBZVEsZ0JBQWdCO2dCQUNqQyxNQUFNLElBQUlTLE1BQU0sQ0FBQywyQ0FBMkMsRUFBRVQsZUFBZSxDQUFDO1lBQ2hGO1FBQ0Y7UUFDQU0sUUFBUXNDLE9BQU87UUFDZixJQUFJakUsU0FBU0ksS0FBSyxLQUFLLE1BQU07WUFDM0Isb0RBQW9ELEdBQ3BELE1BQU13TCxLQUFLMUg7WUFDWGxFLFNBQVNJLEtBQUssQ0FBQzBJLElBQUksQ0FBQ2xCLElBQUlqRyxRQUFRa0MsS0FBSyxFQUFFbkMsYUFBYUMsUUFBUThCLFlBQVksRUFBRW1JLEdBQUdsSixNQUFNLEVBQUVrSixHQUFHakwsVUFBVTtRQUNwRztRQUNBLElBQUl5RCxnQkFBZ0I7WUFDbEIsT0FBUXdELEdBQUc1RixJQUFJO2dCQUNiLEtBQUtwQyxHQUFHaU0sR0FBRztvQkFDVG5FLE1BQU1DLFNBQVNqRyxhQUFhQztvQkFDNUI7Z0JBQ0YsS0FBSy9CLEdBQUdrTSxHQUFHO29CQUNUWixZQUFZdkQsU0FBU2pHLGFBQWFDO29CQUNsQztnQkFDRixLQUFLL0IsR0FBR21NLEdBQUc7b0JBQ1RYLFlBQVl6RCxTQUFTakcsYUFBYUM7b0JBQ2xDO2dCQUNGLEtBQUsvQixHQUFHcUMsR0FBRztvQkFDVCtHLE1BQU1yQixTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHMEMsR0FBRztvQkFDVG1ILE1BQU05QixTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHb00sR0FBRztvQkFDVG5DLE1BQU1sQyxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHcU0sR0FBRztvQkFDVGxDLE1BQU1wQyxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHc00sR0FBRztvQkFDVGIsWUFBWTFELFNBQVNqRyxhQUFhQztvQkFDbEM7Z0JBQ0YsS0FBSy9CLEdBQUd1TSxHQUFHO29CQUNUWixZQUFZNUQsU0FBU2pHLGFBQWFDO29CQUNsQztnQkFDRixLQUFLL0IsR0FBR3dNLEdBQUc7b0JBQ1RaLFlBQVk3RCxTQUFTakcsYUFBYUM7b0JBQ2xDO2dCQUNGLEtBQUsvQixHQUFHeU0sR0FBRztvQkFDVFosWUFBWTlELFNBQVNqRyxhQUFhQztvQkFDbEM7Z0JBQ0YsS0FBSy9CLEdBQUcwTSxHQUFHO29CQUNUdEIsTUFBTXJELFNBQVNqRyxhQUFhQztvQkFDNUI7Z0JBQ0YsS0FBSy9CLEdBQUcyTSxHQUFHO29CQUNUdEIsTUFBTXRELFNBQVNqRyxhQUFhQztvQkFDNUI7Z0JBQ0YsS0FBSy9CLEdBQUc0TSxHQUFHO29CQUNUbkMsTUFBTTFDLFNBQVNqRyxhQUFhQztvQkFDNUI7Z0JBQ0YsS0FBSy9CLEdBQUc2TSxHQUFHO29CQUNUbkMsTUFBTTNDLFNBQVNqRyxhQUFhQztvQkFDNUI7Z0JBQ0Y7b0JBQ0VnSyxNQUFNO29CQUNOO1lBQ0o7UUFDRixPQUFPO1lBQ0wsT0FBUS9ELEdBQUc1RixJQUFJO2dCQUNiLEtBQUtwQyxHQUFHaU0sR0FBRztvQkFDVG5FLE1BQU1DLFNBQVNqRyxhQUFhQztvQkFDNUI7Z0JBQ0YsS0FBSy9CLEdBQUdrTSxHQUFHO29CQUNUaEUsTUFBTUgsU0FBU2pHLGFBQWFDO29CQUM1QjtnQkFDRixLQUFLL0IsR0FBR21NLEdBQUc7b0JBQ1R6RCxNQUFNWCxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHcUMsR0FBRztvQkFDVCtHLE1BQU1yQixTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHMEMsR0FBRztvQkFDVG1ILE1BQU05QixTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHb00sR0FBRztvQkFDVG5DLE1BQU1sQyxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHcU0sR0FBRztvQkFDVGxDLE1BQU1wQyxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHc00sR0FBRztvQkFDVGxDLE1BQU1yQyxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHdU0sR0FBRztvQkFDVGxDLE1BQU10QyxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHd00sR0FBRztvQkFDVGpDLE1BQU14QyxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHeU0sR0FBRztvQkFDVDlCLE1BQU01QyxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHME0sR0FBRztvQkFDVHRCLE1BQU1yRCxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHMk0sR0FBRztvQkFDVHRCLE1BQU10RCxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHNE0sR0FBRztvQkFDVG5DLE1BQU0xQyxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGLEtBQUsvQixHQUFHNk0sR0FBRztvQkFDVG5DLE1BQU0zQyxTQUFTakcsYUFBYUM7b0JBQzVCO2dCQUNGO29CQUNFZ0ssTUFBTTtvQkFDTjtZQUNKO1FBQ0Y7UUFDQSxJQUFJLENBQUN4SCxrQkFBa0J6QyxjQUFjQyxRQUFROEIsWUFBWSxHQUFHckMsWUFBWTtZQUN0RUEsYUFBYU0sY0FBY0MsUUFBUThCLFlBQVk7UUFDakQ7UUFDQSxJQUFJekQsU0FBU0csS0FBSyxLQUFLLE1BQU07WUFDM0IsMEJBQTBCLEdBQzFCSCxTQUFTRyxLQUFLLENBQUN1TSxPQUFPLENBQUM5RSxJQUFJakc7UUFDN0I7UUFDQSxJQUFJM0IsU0FBU0ksS0FBSyxLQUFLLE1BQU07WUFDM0Isa0RBQWtELEdBQ2xELE1BQU13TCxLQUFLMUg7WUFDWGxFLFNBQVNJLEtBQUssQ0FBQ21KLEVBQUUsQ0FBQzNCLElBQUlqRyxRQUFRa0MsS0FBSyxFQUFFbkMsYUFBYUMsUUFBUThCLFlBQVksRUFBRW1JLEdBQUdsSixNQUFNLEVBQUVrSixHQUFHakwsVUFBVTtRQUNsRztRQUNBQyxhQUFhO1FBQ2IsT0FBTytLO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3BhcnNlci5qcz9iZTFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtbmFtZXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgaXMgdGhlIHByaW1hcnkgb2JqZWN0IG9mIGBhcGctbGliYC4gQ2FsbGluZyBpdHMgYHBhcnNlKClgIG1lbWJlciBmdW5jdGlvblxuLy8gd2Fsa3MgdGhlIHBhcnNlIHRyZWUgb2Ygb3Bjb2RlcywgbWF0Y2hpbmcgcGhyYXNlcyBmcm9tIHRoZSBpbnB1dCBzdHJpbmcgYXMgaXQgZ29lcy5cbi8vIFRoZSB3b3JraW5nIGNvZGUgZm9yIGFsbCBvZiB0aGUgb3BlcmF0b3JzLCBgQUxUYCwgYENBVGAsIGV0Yy4gaXMgaW4gdGhpcyBtb2R1bGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlcigpIHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuL2lkZW50aWZpZXJzJyk7XG4gIGNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcblxuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAncGFyc2VyLmpzOiAnO1xuICBjb25zdCB0aGlzVGhpcyA9IHRoaXM7XG4gIGxldCBvcEV4ZWN1dGU7XG4gIHRoaXMuYXN0ID0gbnVsbDtcbiAgdGhpcy5zdGF0cyA9IG51bGw7XG4gIHRoaXMudHJhY2UgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICBsZXQgb3Bjb2RlcyA9IG51bGw7XG4gIGxldCBjaGFycyA9IG51bGw7XG4gIGxldCBjaGFyc0JlZ2luO1xuICBsZXQgY2hhcnNMZW5ndGg7XG4gIGxldCBjaGFyc0VuZDtcbiAgbGV0IGxvb2tBcm91bmQ7XG4gIGxldCB0cmVlRGVwdGggPSAwO1xuICBsZXQgbWF4VHJlZURlcHRoID0gMDtcbiAgbGV0IG5vZGVIaXRzID0gMDtcbiAgbGV0IHJ1bGVDYWxsYmFja3MgPSBudWxsO1xuICBsZXQgdWR0Q2FsbGJhY2tzID0gbnVsbDtcbiAgbGV0IHJ1bGVzID0gbnVsbDtcbiAgbGV0IHVkdHMgPSBudWxsO1xuICBsZXQgc3ludGF4RGF0YSA9IG51bGw7XG4gIGxldCBtYXhNYXRjaGVkID0gMDtcbiAgbGV0IGxpbWl0VHJlZURlcHRoID0gSW5maW5pdHk7XG4gIGxldCBsaW1pdE5vZGVIaXRzID0gSW5maW5pdHk7XG4gIC8vIEV2YWx1YXRlcyBhbnkgZ2l2ZW4gcnVsZS4gVGhpcyBjYW4gYmUgY2FsbGVkIGZyb20gdGhlIHN5bnRheCBjYWxsYmFja1xuICAvLyBmdW5jdGlvbnMgdG8gZXZhbHVhdGUgYW55IHJ1bGUgaW4gdGhlIGdyYW1tYXIncyBydWxlIGxpc3QuIEdyZWF0IGNhdXRpb25cbiAgLy8gc2hvdWxkIGJlIHVzZWQuIFVzZSBvZiB0aGlzIGZ1bmN0aW9uIHdpbGwgYWx0ZXIgdGhlIGxhbmd1YWdlIHRoYXQgdGhlXG4gIC8vIHBhcnNlciBhY2NlcHRzLlxuICBjb25zdCBldmFsdWF0ZVJ1bGUgPSBmdW5jdGlvbiBldmFsdWF0ZVJ1bGUocnVsZUluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1ldmFsdWF0ZVJ1bGUoKTogYDtcbiAgICBpZiAocnVsZUluZGV4ID49IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1ydWxlIGluZGV4OiAke3J1bGVJbmRleH0gb3V0IG9mIHJhbmdlYCk7XG4gICAgfVxuICAgIGlmIChwaHJhc2VJbmRleCA+PSBjaGFyc0VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1waHJhc2UgaW5kZXg6ICR7cGhyYXNlSW5kZXh9IG91dCBvZiByYW5nZWApO1xuICAgIH1cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gb3Bjb2RlcztcbiAgICBvcGNvZGVzLnB1c2goe1xuICAgICAgdHlwZTogaWQuUk5NLFxuICAgICAgaW5kZXg6IHJ1bGVJbmRleCxcbiAgICB9KTtcbiAgICBvcEV4ZWN1dGUobGVuZ3RoLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgb3Bjb2Rlcy5wb3AoKTtcbiAgfTtcbiAgLy8gRXZhbHVhdGVzIGFueSBnaXZlbiBVRFQuIFRoaXMgY2FuIGJlIGNhbGxlZCBmcm9tIHRoZSBzeW50YXggY2FsbGJhY2tcbiAgLy8gZnVuY3Rpb25zIHRvIGV2YWx1YXRlIGFueSBVRFQgaW4gdGhlIGdyYW1tYXIncyBVRFQgbGlzdC4gR3JlYXQgY2F1dGlvblxuICAvLyBzaG91bGQgYmUgdXNlZC4gVXNlIG9mIHRoaXMgZnVuY3Rpb24gd2lsbCBhbHRlciB0aGUgbGFuZ3VhZ2UgdGhhdCB0aGVcbiAgLy8gcGFyc2VyIGFjY2VwdHMuXG4gIGNvbnN0IGV2YWx1YXRlVWR0ID0gZnVuY3Rpb24gKHVkdEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1ldmFsdWF0ZVVkdCgpOiBgO1xuICAgIGlmICh1ZHRJbmRleCA+PSB1ZHRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX11ZHQgaW5kZXg6ICR7dWR0SW5kZXh9IG91dCBvZiByYW5nZWApO1xuICAgIH1cbiAgICBpZiAocGhyYXNlSW5kZXggPj0gY2hhcnNFbmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9cGhyYXNlIGluZGV4OiAke3BocmFzZUluZGV4fSBvdXQgb2YgcmFuZ2VgKTtcbiAgICB9XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IG9wY29kZXM7XG4gICAgb3Bjb2Rlcy5wdXNoKHtcbiAgICAgIHR5cGU6IGlkLlVEVCxcbiAgICAgIGVtcHR5OiB1ZHRzW3VkdEluZGV4XS5lbXB0eSxcbiAgICAgIGluZGV4OiB1ZHRJbmRleCxcbiAgICB9KTtcbiAgICBvcEV4ZWN1dGUobGVuZ3RoLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgb3Bjb2Rlcy5wb3AoKTtcbiAgfTtcbiAgLyogQ2xlYXJzIHRoaXMgb2JqZWN0IG9mIGFueS9hbGwgZGF0YSB0aGF0IGhhcyBiZWVuIGluaXRpYWxpemVkIG9yIGFkZGVkIHRvIGl0LiAqL1xuICAvKiBDYWxsZWQgYnkgcGFyc2UoKSBvbiBpbml0aWFsaXphdGlvbiwgYWxsb3dpbmcgdGhpcyBvYmplY3QgdG8gYmUgcmUtdXNlZCBmb3IgbXVsdGlwbGUgcGFyc2luZyBjYWxscy4gKi9cbiAgY29uc3QgY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJlZURlcHRoID0gMDtcbiAgICBtYXhUcmVlRGVwdGggPSAwO1xuICAgIG5vZGVIaXRzID0gMDtcbiAgICBtYXhNYXRjaGVkID0gMDtcbiAgICBsb29rQXJvdW5kID0gW1xuICAgICAge1xuICAgICAgICBsb29rQXJvdW5kOiBpZC5MT09LQVJPVU5EX05PTkUsXG4gICAgICAgIGFuY2hvcjogMCxcbiAgICAgICAgY2hhcnNFbmQ6IDAsXG4gICAgICAgIGNoYXJzTGVuZ3RoOiAwLFxuICAgICAgfSxcbiAgICBdO1xuICAgIHJ1bGVzID0gbnVsbDtcbiAgICB1ZHRzID0gbnVsbDtcbiAgICBjaGFycyA9IG51bGw7XG4gICAgY2hhcnNCZWdpbiA9IDA7XG4gICAgY2hhcnNMZW5ndGggPSAwO1xuICAgIGNoYXJzRW5kID0gMDtcbiAgICBydWxlQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB1ZHRDYWxsYmFja3MgPSBudWxsO1xuICAgIHN5bnRheERhdGEgPSBudWxsO1xuICAgIG9wY29kZXMgPSBudWxsO1xuICB9O1xuICAvKiBvYmplY3QgZm9yIG1haW50YWluaW5nIGEgc3RhY2sgb2YgYmFjayByZWZlcmVuY2UgZnJhbWVzICovXG4gIGNvbnN0IGJhY2tSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBjb25zdCBpbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICAgIGlmIChydWxlLmlzQmtyKSB7XG4gICAgICAgICAgb2JqW3J1bGUubG93ZXJdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAodWR0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVkdHMuZm9yRWFjaCgodWR0KSA9PiB7XG4gICAgICAgICAgaWYgKHVkdC5pc0Jrcikge1xuICAgICAgICAgICAgb2JqW3VkdC5sb3dlcl0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgfTtcbiAgICBjb25zdCBjb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdG9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgIC8qIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRvcCkge1xuICAgICAgICBvYmpbbmFtZV0gPSB0b3BbbmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgdGhpcy5wdXNoID0gZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgIHN0YWNrLnB1c2goY29weSgpKTtcbiAgICB9O1xuICAgIHRoaXMucG9wID0gZnVuY3Rpb24gcG9wKGxlbmd0aEFyZykge1xuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aEFyZztcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoIDwgMSB8fCBsZW5ndGggPiBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1iYWNrUmVmLnBvcCgpOiBiYWQgbGVuZ3RoOiAke2xlbmd0aH1gKTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIHRoaXMubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHN0YWNrLmxlbmd0aDtcbiAgICB9O1xuICAgIHRoaXMuc2F2ZVBocmFzZSA9IGZ1bmN0aW9uIHNhdmVQaHJhc2UobmFtZSwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1bbmFtZV0gPSB7XG4gICAgICAgIHBocmFzZUluZGV4OiBpbmRleCxcbiAgICAgICAgcGhyYXNlTGVuZ3RoOiBsZW5ndGgsXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5nZXRQaHJhc2UgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdW25hbWVdO1xuICAgIH07XG4gICAgLyogY29uc3RydWN0b3IgKi9cbiAgICBpbml0KCk7XG4gIH07XG4gIC8vIFRoZSBzeXN0ZW0gZGF0YSBzdHJ1Y3R1cmUgdGhhdCByZWxheXMgc3lzdGVtIGluZm9ybWF0aW9uIHRvIGFuZCBmcm9tIHRoZSBydWxlIGFuZCBVRFQgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAvLyAtICpzdGF0ZSogLSB0aGUgc3RhdGUgb2YgdGhlIHBhcnNlciwgQUNUSVZFLCBNQVRDSCwgRU1QVFkgb3IgTk9NQVRDSCAoc2VlIHRoZSBgaWRlbnRpZmllcnNgIG9iamVjdCBpblxuICAvLyBbYGFwZy1saWJgXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzMi1saWIpKVxuICAvLyAtICpwaHJhc2VMZW5ndGgqIC0gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1hdGNoZWQgaWYgdGhlIHN0YXRlIGlzIE1BVENIRUQgb3IgRU1QVFlcbiAgLy8gLSAqbG9va2Fyb3VuZCogLSB0aGUgdG9wIG9mIHRoZSBzdGFjayBob2xkcyB0aGUgY3VycmVudCBsb29rIGFyb3VuZCBzdGF0ZSxcbiAgLy8gTE9PS0FST1VORF9OT05FLCBMT09LQVJPVU5EX0FIRUFEIG9yIExPT0tBUk9VTkRfQkVISU5ELFxuICAvLyAtICp1RnJhbWUqIC0gdGhlIFwidW5pdmVyc2FsXCIgYmFjayByZWZlcmVuY2UgZnJhbWUuXG4gIC8vIEhvbGRzIHRoZSBsYXN0IG1hdGNoZWQgcGhyYXNlIGZvciBlYWNoIG9mIHRoZSBiYWNrIHJlZmVyZW5jZWQgcnVsZXMgYW5kIFVEVHMuXG4gIC8vIC0gKnBGcmFtZSogLSB0aGUgc3RhY2sgb2YgXCJwYXJlbnRcIiBiYWNrIHJlZmVyZW5jZSBmcmFtZXMuXG4gIC8vIEhvbGRzIHRoZSBtYXRjaGVkIHBocmFzZSBmcm9tIHRoZSBwYXJlbnQgZnJhbWUgb2YgZWFjaCBiYWNrIHJlZmVyZW5jZWQgcnVsZXMgYW5kIFVEVHMuXG4gIC8vIC0gKmV2YWx1YXRlUnVsZSogLSBhIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdCdzIGBldmFsdWF0ZVJ1bGUoKWAgZnVuY3Rpb24uXG4gIC8vIENhbiBiZSBjYWxsZWQgZnJvbSBhIGNhbGxiYWNrIGZ1bmN0aW9uICh1c2Ugd2l0aCBleHRyZW1lIGNhdXRpb24hKVxuICAvLyAtICpldmFsdWF0ZVVkdCogLSBhIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdCdzIGBldmFsdWF0ZVVkdCgpYCBmdW5jdGlvbi5cbiAgLy8gQ2FuIGJlIGNhbGxlZCBmcm9tIGEgY2FsbGJhY2sgZnVuY3Rpb24gKHVzZSB3aXRoIGV4dHJlbWUgY2F1dGlvbiEpXG4gIGNvbnN0IHN5c3RlbURhdGEgPSBmdW5jdGlvbiBzeXN0ZW1EYXRhKCkge1xuICAgIGNvbnN0IHRoaXNEYXRhID0gdGhpcztcbiAgICB0aGlzLnN0YXRlID0gaWQuQUNUSVZFO1xuICAgIHRoaXMucGhyYXNlTGVuZ3RoID0gMDtcbiAgICB0aGlzLnJ1bGVJbmRleCA9IDA7XG4gICAgdGhpcy51ZHRJbmRleCA9IDA7XG4gICAgdGhpcy5sb29rQXJvdW5kID0gbG9va0Fyb3VuZFtsb29rQXJvdW5kLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMudUZyYW1lID0gbmV3IGJhY2tSZWYoKTtcbiAgICB0aGlzLnBGcmFtZSA9IG5ldyBiYWNrUmVmKCk7XG4gICAgdGhpcy5ldmFsdWF0ZVJ1bGUgPSBldmFsdWF0ZVJ1bGU7XG4gICAgdGhpcy5ldmFsdWF0ZVVkdCA9IGV2YWx1YXRlVWR0O1xuICAgIC8qIHJlZnJlc2ggdGhlIHBhcnNlciBzdGF0ZSBmb3IgdGhlIG5leHQgb3BlcmF0aW9uICovXG4gICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHRoaXNEYXRhLnN0YXRlID0gaWQuQUNUSVZFO1xuICAgICAgdGhpc0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgIHRoaXNEYXRhLmxvb2tBcm91bmQgPSBsb29rQXJvdW5kW2xvb2tBcm91bmQubGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgfTtcbiAgLyogc29tZSBsb29rIGFyb3VuZCBoZWxwZXIgZnVuY3Rpb25zICovXG4gIGNvbnN0IGxvb2tBcm91bmRWYWx1ZSA9IGZ1bmN0aW9uIGxvb2tBcm91bmRWYWx1ZSgpIHtcbiAgICByZXR1cm4gbG9va0Fyb3VuZFtsb29rQXJvdW5kLmxlbmd0aCAtIDFdO1xuICB9O1xuICAvKiByZXR1cm4gdHJ1ZSBpZiBwYXJzZXIgaXMgaW4gbG9vayBhcm91bmQgKGFoZWFkIG9yIGJlaGluZCkgc3RhdGUgKi9cbiAgY29uc3QgaW5Mb29rQXJvdW5kID0gZnVuY3Rpb24gaW5Mb29rQXJvdW5kKCkge1xuICAgIHJldHVybiBsb29rQXJvdW5kLmxlbmd0aCA+IDE7XG4gIH07XG4gIC8qIHJldHVybiB0cnVlIGlmIHBhcnNlciBpcyBpbiBsb29rIGJlaGluZCBzdGF0ZSAqL1xuICBjb25zdCBpbkxvb2tCZWhpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvb2tBcm91bmRbbG9va0Fyb3VuZC5sZW5ndGggLSAxXS5sb29rQXJvdW5kID09PSBpZC5MT09LQVJPVU5EX0JFSElORDtcbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHBhcnNlKCkgdG8gaW5pdGlhbGl6ZSB0aGUgQVNUIG9iamVjdCwgaWYgb25lIGhhcyBiZWVuIGRlZmluZWQgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZUFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZUFzdCgpOiBgO1xuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAodGhpc1RoaXMuYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpc1RoaXMuYXN0ID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMuYXN0ID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLmFzdC5hc3RPYmplY3QgIT09ICdhc3RPYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9YXN0IG9iamVjdCBub3QgcmVjb2duaXplZGApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzVGhpcy5hc3QgIT09IG51bGwpIHtcbiAgICAgIHRoaXNUaGlzLmFzdC5pbml0KHJ1bGVzLCB1ZHRzLCBjaGFycyk7XG4gICAgfVxuICB9O1xuICAvKiBjYWxsZWQgYnkgcGFyc2UoKSB0byBpbml0aWFsaXplIHRoZSB0cmFjZSBvYmplY3QsIGlmIG9uZSBoYXMgYmVlbiBkZWZpbmVkICovXG4gIGNvbnN0IGluaXRpYWxpemVUcmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZVRyYWNlKCk6IGA7XG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIGlmICh0aGlzVGhpcy50cmFjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXNUaGlzLnRyYWNlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMudHJhY2UgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMudHJhY2UudHJhY2VPYmplY3QgIT09ICd0cmFjZU9iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX10cmFjZSBvYmplY3Qgbm90IHJlY29nbml6ZWRgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpc1RoaXMudHJhY2UgIT09IG51bGwpIHtcbiAgICAgIHRoaXNUaGlzLnRyYWNlLmluaXQocnVsZXMsIHVkdHMsIGNoYXJzKTtcbiAgICB9XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIHN0YXRpc3RpY3Mgb2JqZWN0LCBpZiBvbmUgaGFzIGJlZW4gZGVmaW5lZCAqL1xuICBjb25zdCBpbml0aWFsaXplU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWluaXRpYWxpemVTdGF0cygpOiBgO1xuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAodGhpc1RoaXMuc3RhdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzVGhpcy5zdGF0cyA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLnN0YXRzID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLnN0YXRzLnN0YXRzT2JqZWN0ICE9PSAnc3RhdHNPYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3RhdHMgb2JqZWN0IG5vdCByZWNvZ25pemVkYCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXNUaGlzLnN0YXRzICE9PSBudWxsKSB7XG4gICAgICB0aGlzVGhpcy5zdGF0cy5pbml0KHJ1bGVzLCB1ZHRzKTtcbiAgICB9XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIHJ1bGVzICYgdWR0cyBmcm9tIHRoZSBncmFtbWFyIG9iamVjdCAqL1xuICAvKiAodGhlIGdyYW1tYXIgb2JqZWN0IGdlbmVyYXRlZCBwcmV2aW91c2x5IGJ5IGFwZykgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZUdyYW1tYXIgPSBmdW5jdGlvbiAoZ3JhbW1hcikge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1pbml0aWFsaXplR3JhbW1hcigpOiBgO1xuICAgIGlmICghZ3JhbW1hcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1ncmFtbWFyIG9iamVjdCB1bmRlZmluZWRgKTtcbiAgICB9XG4gICAgaWYgKGdyYW1tYXIuZ3JhbW1hck9iamVjdCAhPT0gJ2dyYW1tYXJPYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWJhZCBncmFtbWFyIG9iamVjdGApO1xuICAgIH1cbiAgICBydWxlcyA9IGdyYW1tYXIucnVsZXM7XG4gICAgdWR0cyA9IGdyYW1tYXIudWR0cztcbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHBhcnNlKCkgdG8gaW5pdGlhbGl6ZSB0aGUgc3RhcnQgcnVsZSAqL1xuICBjb25zdCBpbml0aWFsaXplU3RhcnRSdWxlID0gZnVuY3Rpb24gKHN0YXJ0UnVsZSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1pbml0aWFsaXplU3RhcnRSdWxlKCk6IGA7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIHN0YXJ0UnVsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChzdGFydFJ1bGUgPj0gcnVsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3RhcnQgcnVsZSBpbmRleCB0b28gbGFyZ2U6IG1heDogJHtydWxlcy5sZW5ndGh9OiBpbmRleDogJHtzdGFydFJ1bGV9YCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0UnVsZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFydFJ1bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsb3dlciA9IHN0YXJ0UnVsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAobG93ZXIgPT09IHJ1bGVzW2ldLmxvd2VyKSB7XG4gICAgICAgICAgc3RhcnQgPSBydWxlc1tpXS5pbmRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3RhcnQgcnVsZSBuYW1lICcke3N0YXJ0UnVsZX0nIG5vdCByZWNvZ25pemVkYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9dHlwZSBvZiBzdGFydCBydWxlICcke3R5cGVvZiBzdGFydFJ1bGV9JyBub3QgcmVjb2duaXplZGApO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnQ7XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIGFycmF5IG9mIGNoYXJhY3RlcnMgY29kZXMgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBzdHJpbmcgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZUlucHV0Q2hhcnMgPSBmdW5jdGlvbiBpbml0aWFsaXplSW5wdXRDaGFycyhpbnB1dEFyZywgYmVnQXJnLCBsZW5BcmcpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZUlucHV0Q2hhcnMoKTogYDtcbiAgICAvKiB2YXJpZnkgYW5kIG5vcm1hbGl6ZSBpbnB1dCAqL1xuICAgIGxldCBpbnB1dCA9IGlucHV0QXJnO1xuICAgIGxldCBiZWcgPSBiZWdBcmc7XG4gICAgbGV0IGxlbiA9IGxlbkFyZztcbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBzdHJpbmcgaXMgdW5kZWZpbmVkYCk7XG4gICAgfVxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBzdHJpbmcgaXMgbnVsbGApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgaW5wdXQgPSB1dGlscy5zdHJpbmdUb0NoYXJzKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBzdHJpbmcgaXMgbm90IGEgc3RyaW5nIG9yIGFycmF5YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0WzBdICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWlucHV0IHN0cmluZyBub3QgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogdmVyaWZ5IGFuZCBub3JtYWxpemUgYmVnaW5uaW5nIGluZGV4ICovXG4gICAgaWYgKHR5cGVvZiBiZWcgIT09ICdudW1iZXInKSB7XG4gICAgICBiZWcgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBiZWcgPSBNYXRoLmZsb29yKGJlZyk7XG4gICAgICBpZiAoYmVnIDwgMCB8fCBiZWcgPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBiZWdpbm5pbmcgaW5kZXggb3V0IG9mIHJhbmdlOiAke2JlZ31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogdmVyaWZ5IGFuZCBub3JtYWxpemUgaW5wdXQgbGVuZ3RoICovXG4gICAgaWYgKHR5cGVvZiBsZW4gIT09ICdudW1iZXInKSB7XG4gICAgICBsZW4gPSBpbnB1dC5sZW5ndGggLSBiZWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbiA9IE1hdGguZmxvb3IobGVuKTtcbiAgICAgIGlmIChsZW4gPCAwIHx8IGxlbiA+IGlucHV0Lmxlbmd0aCAtIGJlZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWlucHV0IGxlbmd0aCBvdXQgb2YgcmFuZ2U6ICR7bGVufWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGFycyA9IGlucHV0O1xuICAgIGNoYXJzQmVnaW4gPSBiZWc7XG4gICAgY2hhcnNMZW5ndGggPSBsZW47XG4gICAgY2hhcnNFbmQgPSBjaGFyc0JlZ2luICsgY2hhcnNMZW5ndGg7XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIHVzZXItd3JpdHRlbiwgc3ludGF4IGNhbGxiYWNrIGZ1bmN0aW9ucywgaWYgYW55ICovXG4gIGNvbnN0IGluaXRpYWxpemVDYWxsYmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWluaXRpYWxpemVDYWxsYmFja3MoKTogYDtcbiAgICBsZXQgaTtcbiAgICBydWxlQ2FsbGJhY2tzID0gW107XG4gICAgdWR0Q2FsbGJhY2tzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBydWxlQ2FsbGJhY2tzW2ldID0gbnVsbDtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHVkdENhbGxiYWNrc1tpXSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBmdW5jO1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaChydWxlc1tpXS5sb3dlcik7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsaXN0LnB1c2godWR0c1tpXS5sb3dlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaW5kZXggaW4gdGhpc1RoaXMuY2FsbGJhY2tzKSB7XG4gICAgICBpID0gbGlzdC5pbmRleE9mKGluZGV4LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3ludGF4IGNhbGxiYWNrICcke2luZGV4fScgbm90IGEgcnVsZSBvciB1ZHQgbmFtZWApO1xuICAgICAgfVxuICAgICAgZnVuYyA9IHRoaXNUaGlzLmNhbGxiYWNrc1tpbmRleF07XG4gICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgfHwgZnVuYyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoaSA8IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJ1bGVDYWxsYmFja3NbaV0gPSBmdW5jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVkdENhbGxiYWNrc1tpIC0gcnVsZXMubGVuZ3RoXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtmdW5jdGlvbk5hbWV9c3ludGF4IGNhbGxiYWNrWyR7aW5kZXh9XSBtdXN0IGJlIGZ1bmN0aW9uIHJlZmVyZW5jZSBvciAnZmFsc2UnIChmYWxzZS9udWxsL3VuZGVmaW5lZC9ldGMuKWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogbWFrZSBzdXJlIGFsbCB1ZHRzIGhhdmUgYmVlbiBkZWZpbmVkIC0gdGhlIHBhcnNlciBjYW4ndCB3b3JrIHdpdGhvdXQgdGhlbSAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodWR0Q2FsbGJhY2tzW2ldID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtmdW5jdGlvbk5hbWV9YWxsIFVEVCBjYWxsYmFja3MgbXVzdCBiZSBkZWZpbmVkLiBVRFQgY2FsbGJhY2tbJHt1ZHRzW2ldLmxvd2VyfV0gbm90IGEgZnVuY3Rpb24gcmVmZXJlbmNlYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gU2V0IHRoZSBtYXhpbXVtIHBhcnNlIHRyZWUgZGVwdGggYWxsb3dlZC4gVGhlIGRlZmF1bHQgaXMgYEluZmluaXR5YC5cbiAgLy8gQSBsaW1pdCBpcyBub3Qgbm9ybWFsbHkgbmVlZGVkLCBidXQgY2FuIGJlIHVzZWQgdG8gcHJvdGVjdCBhZ2FpbnN0IGFuXG4gIC8vIGV4cG9uZW50dWFsIG9yIFwiY2F0YXN0cm9waGljYWxseSBiYWNrdHJhY2tpbmdcIiBncmFtbWFyLlxuICAvLyA8dWw+XG4gIC8vIDxsaT5cbiAgLy8gZGVwdGggLSBtYXggYWxsb3dlZCBwYXJzZSB0cmVlIGRlcHRoLiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIGV4Y2VlZGVkLlxuICAvLyA8L2xpPlxuICAvLyA8L3VsPlxuICB0aGlzLnNldE1heFRyZWVEZXB0aCA9IGZ1bmN0aW9uIChkZXB0aCkge1xuICAgIGlmICh0eXBlb2YgZGVwdGggIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlcjogbWF4IHRyZWUgZGVwdGggbXVzdCBiZSBpbnRlZ2VyID4gMDogJHtkZXB0aH1gKTtcbiAgICB9XG4gICAgbGltaXRUcmVlRGVwdGggPSBNYXRoLmZsb29yKGRlcHRoKTtcbiAgICBpZiAobGltaXRUcmVlRGVwdGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heCB0cmVlIGRlcHRoIG11c3QgYmUgaW50ZWdlciA+IDA6ICR7ZGVwdGh9YCk7XG4gICAgfVxuICB9O1xuICAvLyBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIG5vZGUgaGl0cyAocGFyc2VyIHVuaXQgc3RlcHMgb3Igb3Bjb2RlIGZ1bmN0aW9uIGNhbGxzKSBhbGxvd2VkLlxuICAvLyBUaGUgZGVmYXVsdCBpcyBgSW5maW5pdHlgLlxuICAvLyBBIGxpbWl0IGlzIG5vdCBub3JtYWxseSBuZWVkZWQsIGJ1dCBjYW4gYmUgdXNlZCB0byBwcm90ZWN0IGFnYWluc3QgYW5cbiAgLy8gZXhwb25lbnR1YWwgb3IgXCJjYXRhc3Ryb3BoaWNhbGx5IGJhY2t0cmFja2luZ1wiIGdyYW1tYXIuXG4gIC8vIDx1bD5cbiAgLy8gPGxpPlxuICAvLyBoaXRzIC0gbWF4aW11bSBudW1iZXIgb2Ygbm9kZSBoaXRzIG9yIHBhcnNlciB1bml0IHN0ZXBzIGFsbG93ZWQuXG4gIC8vIEFuIGV4Y2VwdGlvbiB0aHJvd24gaWYgZXhjZWVkZWQuXG4gIC8vIDwvbGk+XG4gIC8vIDwvdWw+XG4gIHRoaXMuc2V0TWF4Tm9kZUhpdHMgPSBmdW5jdGlvbiAoaGl0cykge1xuICAgIGlmICh0eXBlb2YgaGl0cyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyc2VyOiBtYXggbm9kZSBoaXRzIG11c3QgYmUgaW50ZWdlciA+IDA6ICR7aGl0c31gKTtcbiAgICB9XG4gICAgbGltaXROb2RlSGl0cyA9IE1hdGguZmxvb3IoaGl0cyk7XG4gICAgaWYgKGxpbWl0Tm9kZUhpdHMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heCBub2RlIGhpdHMgbXVzdCBiZSBpbnRlZ2VyID4gMDogJHtoaXRzfWApO1xuICAgIH1cbiAgfTtcbiAgLyogdGhlIG1haW4gcGFyc2VyIGZ1bmN0aW9uICovXG4gIGNvbnN0IHByaXZhdGVQYXJzZSA9IGZ1bmN0aW9uIChncmFtbWFyLCBzdGFydFJ1bGVBcmcsIGNhbGxiYWNrRGF0YSkge1xuICAgIGxldCBzdWNjZXNzO1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1wYXJzZSgpOiBgO1xuICAgIGluaXRpYWxpemVHcmFtbWFyKGdyYW1tYXIpO1xuICAgIGNvbnN0IHN0YXJ0UnVsZSA9IGluaXRpYWxpemVTdGFydFJ1bGUoc3RhcnRSdWxlQXJnKTtcbiAgICBpbml0aWFsaXplQ2FsbGJhY2tzKCk7XG4gICAgaW5pdGlhbGl6ZVRyYWNlKCk7XG4gICAgaW5pdGlhbGl6ZVN0YXRzKCk7XG4gICAgaW5pdGlhbGl6ZUFzdCgpO1xuICAgIGNvbnN0IHN5c0RhdGEgPSBuZXcgc3lzdGVtRGF0YSgpO1xuICAgIGlmICghKGNhbGxiYWNrRGF0YSA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrRGF0YSA9PT0gbnVsbCkpIHtcbiAgICAgIHN5bnRheERhdGEgPSBjYWxsYmFja0RhdGE7XG4gICAgfVxuICAgIC8qIGNyZWF0ZSBhIGR1bW15IG9wY29kZSBmb3IgdGhlIHN0YXJ0IHJ1bGUgKi9cbiAgICBvcGNvZGVzID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBpZC5STk0sXG4gICAgICAgIGluZGV4OiBzdGFydFJ1bGUsXG4gICAgICB9LFxuICAgIF07XG4gICAgLyogZXhlY3V0ZSB0aGUgc3RhcnQgcnVsZSAqL1xuICAgIG9wRXhlY3V0ZSgwLCBjaGFyc0JlZ2luLCBzeXNEYXRhKTtcbiAgICBvcGNvZGVzID0gbnVsbDtcbiAgICAvKiB0ZXN0IGFuZCByZXR1cm4gdGhlIHN5c0RhdGEgKi9cbiAgICBzd2l0Y2ggKHN5c0RhdGEuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWZpbmFsIHN0YXRlIHNob3VsZCBuZXZlciBiZSAnQUNUSVZFJ2ApO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChzeXNEYXRhLnBocmFzZUxlbmd0aCA9PT0gY2hhcnNMZW5ndGgpIHtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBzdGF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzcyxcbiAgICAgIHN0YXRlOiBzeXNEYXRhLnN0YXRlLFxuICAgICAgbGVuZ3RoOiBjaGFyc0xlbmd0aCxcbiAgICAgIG1hdGNoZWQ6IHN5c0RhdGEucGhyYXNlTGVuZ3RoLFxuICAgICAgbWF4TWF0Y2hlZCxcbiAgICAgIG1heFRyZWVEZXB0aCxcbiAgICAgIG5vZGVIaXRzLFxuICAgICAgaW5wdXRMZW5ndGg6IGNoYXJzLmxlbmd0aCxcbiAgICAgIHN1YkJlZ2luOiBjaGFyc0JlZ2luLFxuICAgICAgc3ViRW5kOiBjaGFyc0VuZCxcbiAgICAgIHN1Ykxlbmd0aDogY2hhcnNMZW5ndGgsXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGZvcm0gYWxsb3dzIHBhcnNpbmcgb2YgYSBzdWItc3RyaW5nIG9mIHRoZSBmdWxsIGlucHV0IHN0cmluZy5cbiAgLy8gPHVsPlxuICAvLyA8bGk+KmlucHV0SW5kZXgqIC0gaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3ViLXN0cmluZzwvbGk+XG4gIC8vIDxsaT4qaW5wdXRMZW5ndGgqIC0gbGVuZ3RoIG9mIHRoZSBzdWItc3RyaW5nPC9saT5cbiAgLy8gPC91bD5cbiAgLy8gQWxsIG90aGVyIHBhcmFtZXRlcnMgYXMgZm9yIHRoZSBhYm92ZSBmdW5jdGlvbiBgcGFyc2UoKWAuXG4gIHRoaXMucGFyc2VTdWJzdHJpbmcgPSBmdW5jdGlvbiBwYXJzZVN1YnN0cmluZyhncmFtbWFyLCBzdGFydFJ1bGUsIGlucHV0Q2hhcnMsIGlucHV0SW5kZXgsIGlucHV0TGVuZ3RoLCBjYWxsYmFja0RhdGEpIHtcbiAgICBjbGVhcigpO1xuICAgIGluaXRpYWxpemVJbnB1dENoYXJzKGlucHV0Q2hhcnMsIGlucHV0SW5kZXgsIGlucHV0TGVuZ3RoKTtcbiAgICByZXR1cm4gcHJpdmF0ZVBhcnNlKGdyYW1tYXIsIHN0YXJ0UnVsZSwgY2FsbGJhY2tEYXRhKTtcbiAgfTtcbiAgLy8gVGhpcyBpcyB0aGUgbWFpbiBmdW5jdGlvbiwgY2FsbGVkIHRvIHBhcnNlIGFuIGlucHV0IHN0cmluZy5cbiAgLy8gPHVsPlxuICAvLyA8bGk+KmdyYW1tYXIqIC0gYW4gaW5zdGFudGlhdGVkIGdyYW1tYXIgb2JqZWN0IC0gdGhlIG91dHB1dCBvZiBgYXBnYCBmb3IgYVxuICAvLyBzcGVjaWZpYyBTQUJORiBncmFtbWFyPC9saT5cbiAgLy8gPGxpPipzdGFydFJ1bGUqIC0gdGhlIHJ1bGUgbmFtZSBvciBydWxlIGluZGV4IHRvIGJlIHVzZWQgYXMgdGhlIHJvb3Qgb2YgdGhlXG4gIC8vIHBhcnNlIHRyZWUuIFRoaXMgaXMgdXN1YWxseSB0aGUgZmlyc3QgcnVsZSwgaW5kZXggPSAwLCBvZiB0aGUgZ3JhbW1hclxuICAvLyBidXQgY2FuIGJlIGFueSBydWxlIGRlZmluZWQgaW4gdGhlIGFib3ZlIGdyYW1tYXIgb2JqZWN0LjwvbGk+XG4gIC8vIDxsaT4qaW5wdXRDaGFycyogLSB0aGUgaW5wdXQgc3RyaW5nLiBDYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMgcmVwcmVzZW50aW5nIHRoZVxuICAvLyBzdHJpbmcuPC9saT5cbiAgLy8gPGxpPipjYWxsYmFja0RhdGEqIC0gdXNlci1kZWZpbmVkIGRhdGEgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byB0aGUgdXNlcidzXG4gIC8vIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgLy8gVGhpcyBpcyBub3QgdXNlZCBieSB0aGUgcGFyc2VyIGluIGFueSB3YXksIG1lcmVseSBwYXNzZWQgb24gdG8gdGhlIHVzZXIuXG4gIC8vIE1heSBiZSBgbnVsbGAgb3Igb21pdHRlZC48L2xpPlxuICAvLyA8L3VsPlxuICB0aGlzLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZ3JhbW1hciwgc3RhcnRSdWxlLCBpbnB1dENoYXJzLCBjYWxsYmFja0RhdGEpIHtcbiAgICBjbGVhcigpO1xuICAgIGluaXRpYWxpemVJbnB1dENoYXJzKGlucHV0Q2hhcnMsIDAsIGlucHV0Q2hhcnMubGVuZ3RoKTtcbiAgICByZXR1cm4gcHJpdmF0ZVBhcnNlKGdyYW1tYXIsIHN0YXJ0UnVsZSwgY2FsbGJhY2tEYXRhKTtcbiAgfTtcbiAgLy8gVGhlIGBBTFRgIG9wZXJhdG9yLjxicj5cbiAgLy8gRXhlY3V0ZXMgaXRzIGNoaWxkIG5vZGVzLCBmcm9tIGxlZnQgdG8gcmlnaHQsIHVudGlsIGl0IGZpbmRzIGEgbWF0Y2guXG4gIC8vIEZhaWxzIGlmICphbGwqIG9mIGl0cyBjaGlsZCBub2RlcyBmYWlsLlxuICBjb25zdCBvcEFMVCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvcEV4ZWN1dGUob3AuY2hpbGRyZW5baV0sIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlICE9PSBpZC5OT01BVENIKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBDQVRgIG9wZXJhdG9yLjxicj5cbiAgLy8gRXhlY3V0ZXMgYWxsIG9mIGl0cyBjaGlsZCBub2RlcywgZnJvbSBsZWZ0IHRvIHJpZ2h0LFxuICAvLyBjb25jYXRlbmF0aW5nIHRoZSBtYXRjaGVkIHBocmFzZXMuXG4gIC8vIEZhaWxzIGlmICphbnkqIGNoaWxkIG5vZGVzIGZhaWwuXG4gIGNvbnN0IG9wQ0FUID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG4gICAgbGV0IGFzdExlbmd0aDtcbiAgICBsZXQgY2F0Q2hhckluZGV4O1xuICAgIGxldCBjYXRQaHJhc2U7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IHVsZW4gPSBzeXNEYXRhLnVGcmFtZS5sZW5ndGgoKTtcbiAgICBjb25zdCBwbGVuID0gc3lzRGF0YS5wRnJhbWUubGVuZ3RoKCk7XG4gICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgYXN0TGVuZ3RoID0gdGhpc1RoaXMuYXN0LmdldExlbmd0aCgpO1xuICAgIH1cbiAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICBjYXRDaGFySW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICBjYXRQaHJhc2UgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3AuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG9wRXhlY3V0ZShvcC5jaGlsZHJlbltpXSwgY2F0Q2hhckluZGV4LCBzeXNEYXRhKTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXRDaGFySW5kZXggKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICAgIGNhdFBocmFzZSArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBjYXRQaHJhc2UgPT09IDAgPyBpZC5FTVBUWSA6IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBjYXRQaHJhc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgLyogcmVzZXQgdGhlIGJhY2sgcmVmZXJlbmNpbmcgZnJhbWVzIG9uIGZhaWx1cmUgKi9cbiAgICAgIHN5c0RhdGEudUZyYW1lLnBvcCh1bGVuKTtcbiAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBSRVBgIG9wZXJhdG9yLjxicj5cbiAgLy8gUmVwZWF0ZWRseSBleGVjdXRlcyBpdHMgc2luZ2xlIGNoaWxkIG5vZGUsXG4gIC8vIGNvbmNhdGVuYXRpbmcgZWFjaCBvZiB0aGUgbWF0Y2hlZCBwaHJhc2VzIGZvdW5kLlxuICAvLyBUaGUgbnVtYmVyIG9mIHJlcGV0aXRpb25zIGV4ZWN1dGVkIGFuZCBpdHMgZmluYWwgc3lzRGF0YSBkZXBlbmRzXG4gIC8vIG9uIGl0cyBgbWluYCAmIGBtYXhgIHJlcGV0aXRpb24gdmFsdWVzLlxuICBjb25zdCBvcFJFUCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IHJlcENoYXJJbmRleDtcbiAgICBsZXQgcmVwUGhyYXNlO1xuICAgIGxldCByZXBDb3VudDtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgaWYgKG9wLm1heCA9PT0gMCkge1xuICAgICAgLy8gdGhpcyBpcyBhbiBlbXB0eS1zdHJpbmcgYWNjZXB0b3JcbiAgICAgIC8vIGRlcHJlY2F0ZWQ6IHVzZSB0aGUgVExTIGVtcHR5IHN0cmluZyBvcGVyYXRvciwgXCJcIiwgaW5zdGVhZFxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXBDaGFySW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICByZXBQaHJhc2UgPSAwO1xuICAgIHJlcENvdW50ID0gMDtcbiAgICBjb25zdCB1bGVuID0gc3lzRGF0YS51RnJhbWUubGVuZ3RoKCk7XG4gICAgY29uc3QgcGxlbiA9IHN5c0RhdGEucEZyYW1lLmxlbmd0aCgpO1xuICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgIGFzdExlbmd0aCA9IHRoaXNUaGlzLmFzdC5nZXRMZW5ndGgoKTtcbiAgICB9XG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIGlmIChyZXBDaGFySW5kZXggPj0gY2hhcnNFbmQpIHtcbiAgICAgICAgLyogZXhpdCBvbiBlbmQgb2YgaW5wdXQgc3RyaW5nICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCByZXBDaGFySW5kZXgsIHN5c0RhdGEpO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgLyogYWx3YXlzIGVuZCBpZiB0aGUgY2hpbGQgbm9kZSBmYWlscyAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5FTVBUWSkge1xuICAgICAgICAvKiBSRVAgYWx3YXlzIHN1Y2NlZWRzIHdoZW4gdGhlIGNoaWxkIG5vZGUgcmV0dXJucyBhbiBlbXB0eSBwaHJhc2UgKi9cbiAgICAgICAgLyogdGhpcyBtYXkgbm90IHNlZW0gb2J2aW91cywgYnV0IHRoYXQncyB0aGUgd2F5IGl0IHdvcmtzIG91dCAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlcENvdW50ICs9IDE7XG4gICAgICByZXBQaHJhc2UgKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICByZXBDaGFySW5kZXggKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICBpZiAocmVwQ291bnQgPT09IG9wLm1heCkge1xuICAgICAgICAvKiBlbmQgb24gbWF4ZWQgb3V0IHJlcHMgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGV2YWx1YXRlIHRoZSBtYXRjaCBjb3VudCBhY2NvcmRpbmcgdG8gdGhlIG1pbiwgbWF4IHZhbHVlcyAqL1xuICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5FTVBUWSkge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IHJlcFBocmFzZSA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IHJlcFBocmFzZTtcbiAgICB9IGVsc2UgaWYgKHJlcENvdW50ID49IG9wLm1pbikge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IHJlcFBocmFzZSA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IHJlcFBocmFzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICAvKiByZXNldCB0aGUgYmFjayByZWZlcmVuY2luZyBmcmFtZXMgb24gZmFpbHVyZSAqL1xuICAgICAgc3lzRGF0YS51RnJhbWUucG9wKHVsZW4pO1xuICAgICAgc3lzRGF0YS5wRnJhbWUucG9wKHBsZW4pO1xuICAgICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgICB0aGlzVGhpcy5hc3Quc2V0TGVuZ3RoKGFzdExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBWYWxpZGF0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24ncyByZXR1cm5lZCBzeXNEYXRhIHZhbHVlcy5cbiAgLy8gSXQncyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGdldCB0aGVtIHJpZ2h0XG4gIC8vIGJ1dCBgUk5NYCBmYWlscyBpZiBub3QuXG4gIGNvbnN0IHZhbGlkYXRlUm5tQ2FsbGJhY2tSZXN1bHQgPSBmdW5jdGlvbiAocnVsZSwgc3lzRGF0YSwgY2hhcnNMZWZ0LCBkb3duKSB7XG4gICAgaWYgKHN5c0RhdGEucGhyYXNlTGVuZ3RoID4gY2hhcnNMZWZ0KSB7XG4gICAgICBsZXQgc3RyID0gYCR7dGhpc0ZpbGVOYW1lfW9wUk5NKCR7cnVsZS5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIGVycm9yOiBgO1xuICAgICAgc3RyICs9IGBzeXNEYXRhLnBocmFzZUxlbmd0aDogJHtzeXNEYXRhLnBocmFzZUxlbmd0aH1gO1xuICAgICAgc3RyICs9IGAgbXVzdCBiZSA8PSByZW1haW5pbmcgY2hhcnM6ICR7Y2hhcnNMZWZ0fWA7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICB9XG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgaWYgKGRvd24gIT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgJHt0aGlzRmlsZU5hbWV9b3BSTk0oJHtydWxlLm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJuIGVycm9yLiBBQ1RJVkUgc3RhdGUgbm90IGFsbG93ZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKHN5c0RhdGEucGhyYXNlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke3RoaXNGaWxlTmFtZX1vcFJOTSgke3J1bGUubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm4gZXJyb3IuIFVucmVjb2duaXplZCByZXR1cm4gc3RhdGU6ICR7c3lzRGF0YS5zdGF0ZX1gXG4gICAgICAgICk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYFJOTWAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIG9wZXJhdG9yIHdpbGwgYWN0cyBhcyBhIHJvb3Qgbm9kZSBmb3IgYSBwYXJzZSB0cmVlIGJyYW5jaCBiZWxvdyBhbmRcbiAgLy8gcmV0dXJucyB0aGUgbWF0Y2hlZCBwaHJhc2UgdG8gaXRzIHBhcmVudC5cbiAgLy8gSG93ZXZlciwgaXRzIGxhcmdlciByZXNwb25zaWJpbGl0eSBpcyBoYW5kbGluZyB1c2VyLWRlZmluZWQgY2FsbGJhY2sgZnVuY3Rpb25zLCBiYWNrIHJlZmVyZW5jZXMgYW5kIGBBU1RgIG5vZGVzLlxuICAvLyBOb3RlIHRoYXQgdGhlIGBBU1RgIGlzIGEgc2VwYXJhdGUgb2JqZWN0LCBidXQgYFJOTWAgY2FsbHMgaXRzIGZ1bmN0aW9ucyB0byBjcmVhdGUgaXRzIG5vZGVzLlxuICAvLyBTZWUgW2Bhc3QuanNgXSguL2FzdC5odG1sKSBmb3IgdXNhZ2UuXG4gIGNvbnN0IG9wUk5NID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGFzdExlbmd0aDtcbiAgICBsZXQgYXN0RGVmaW5lZDtcbiAgICBsZXQgc2F2ZWRPcGNvZGVzO1xuICAgIGxldCB1bGVuO1xuICAgIGxldCBwbGVuO1xuICAgIGxldCBzYXZlRnJhbWU7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlc1tvcC5pbmRleF07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBydWxlQ2FsbGJhY2tzW3J1bGUuaW5kZXhdO1xuICAgIGNvbnN0IG5vdExvb2tBcm91bmQgPSAhaW5Mb29rQXJvdW5kKCk7XG4gICAgLyogaWdub3JlIEFTVCBhbmQgYmFjayByZWZlcmVuY2VzIGluIGxvb2thcm91bmQgKi9cbiAgICBpZiAobm90TG9va0Fyb3VuZCkge1xuICAgICAgLyogYmVnaW4gQVNUIGFuZCBiYWNrIHJlZmVyZW5jZXMgKi9cbiAgICAgIGFzdERlZmluZWQgPSB0aGlzVGhpcy5hc3QgJiYgdGhpc1RoaXMuYXN0LnJ1bGVEZWZpbmVkKG9wLmluZGV4KTtcbiAgICAgIGlmIChhc3REZWZpbmVkKSB7XG4gICAgICAgIGFzdExlbmd0aCA9IHRoaXNUaGlzLmFzdC5nZXRMZW5ndGgoKTtcbiAgICAgICAgdGhpc1RoaXMuYXN0LmRvd24ob3AuaW5kZXgsIHJ1bGVzW29wLmluZGV4XS5uYW1lKTtcbiAgICAgIH1cbiAgICAgIHVsZW4gPSBzeXNEYXRhLnVGcmFtZS5sZW5ndGgoKTtcbiAgICAgIHBsZW4gPSBzeXNEYXRhLnBGcmFtZS5sZW5ndGgoKTtcbiAgICAgIHN5c0RhdGEudUZyYW1lLnB1c2goKTtcbiAgICAgIHN5c0RhdGEucEZyYW1lLnB1c2goKTtcbiAgICAgIHNhdmVGcmFtZSA9IHN5c0RhdGEucEZyYW1lO1xuICAgICAgc3lzRGF0YS5wRnJhbWUgPSBuZXcgYmFja1JlZigpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwpIHtcbiAgICAgIC8qIG5vIGNhbGxiYWNrIC0ganVzdCBleGVjdXRlIHRoZSBydWxlICovXG4gICAgICBzYXZlZE9wY29kZXMgPSBvcGNvZGVzO1xuICAgICAgb3Bjb2RlcyA9IHJ1bGUub3Bjb2RlcztcbiAgICAgIG9wRXhlY3V0ZSgwLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICBvcGNvZGVzID0gc2F2ZWRPcGNvZGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBjYWxsIHVzZXIncyBjYWxsYmFjayAqL1xuICAgICAgY29uc3QgY2hhcnNMZWZ0ID0gY2hhcnNFbmQgLSBwaHJhc2VJbmRleDtcbiAgICAgIHN5c0RhdGEucnVsZUluZGV4ID0gcnVsZS5pbmRleDtcbiAgICAgIGNhbGxiYWNrKHN5c0RhdGEsIGNoYXJzLCBwaHJhc2VJbmRleCwgc3ludGF4RGF0YSk7XG4gICAgICB2YWxpZGF0ZVJubUNhbGxiYWNrUmVzdWx0KHJ1bGUsIHN5c0RhdGEsIGNoYXJzTGVmdCwgdHJ1ZSk7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuQUNUSVZFKSB7XG4gICAgICAgIHNhdmVkT3Bjb2RlcyA9IG9wY29kZXM7XG4gICAgICAgIG9wY29kZXMgPSBydWxlLm9wY29kZXM7XG4gICAgICAgIG9wRXhlY3V0ZSgwLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgIG9wY29kZXMgPSBzYXZlZE9wY29kZXM7XG4gICAgICAgIHN5c0RhdGEucnVsZUluZGV4ID0gcnVsZS5pbmRleDtcbiAgICAgICAgY2FsbGJhY2soc3lzRGF0YSwgY2hhcnMsIHBocmFzZUluZGV4LCBzeW50YXhEYXRhKTtcbiAgICAgICAgdmFsaWRhdGVSbm1DYWxsYmFja1Jlc3VsdChydWxlLCBzeXNEYXRhLCBjaGFyc0xlZnQsIGZhbHNlKTtcbiAgICAgIH0gLyogaW1wbGllZCBlbHNlIGNsYXVzZToganVzdCBhY2NlcHQgdGhlIGNhbGxiYWNrIHN5c0RhdGEgLSBSTk0gYWN0aW5nIGFzIFVEVCAqL1xuICAgIH1cbiAgICBpZiAobm90TG9va0Fyb3VuZCkge1xuICAgICAgLyogZW5kIEFTVCAqL1xuICAgICAgaWYgKGFzdERlZmluZWQpIHtcbiAgICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgICB0aGlzVGhpcy5hc3Quc2V0TGVuZ3RoKGFzdExlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1RoaXMuYXN0LnVwKG9wLmluZGV4LCBydWxlLm5hbWUsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIGVuZCBiYWNrIHJlZmVyZW5jZSAqL1xuICAgICAgc3lzRGF0YS5wRnJhbWUgPSBzYXZlRnJhbWU7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICBzeXNEYXRhLnVGcmFtZS5wb3AodWxlbik7XG4gICAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIH0gZWxzZSBpZiAocnVsZS5pc0Jrcikge1xuICAgICAgICAvKiBzYXZlIHBocmFzZSBvbiBib3RoIHRoZSBwYXJlbnQgYW5kIHVuaXZlcnNhbCBmcmFtZXMgKi9cbiAgICAgICAgLyogQktSIG9wZXJhdG9yIHdpbGwgZGVjaWRlIHdoaWNoIHRvIHVzZSBsYXRlciAqL1xuICAgICAgICBzeXNEYXRhLnBGcmFtZS5zYXZlUGhyYXNlKHJ1bGUubG93ZXIsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCk7XG4gICAgICAgIHN5c0RhdGEudUZyYW1lLnNhdmVQaHJhc2UocnVsZS5sb3dlciwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFZhbGlkYXRlIHRoZSBjYWxsYmFjayBmdW5jdGlvbidzIHJldHVybmVkIHN5c0RhdGEgdmFsdWVzLlxuICAvLyBJdCdzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gZ2V0IGl0IHJpZ2h0IGJ1dCBgVURUYCBmYWlscyBpZiBub3QuXG4gIGNvbnN0IHZhbGlkYXRlVWR0Q2FsbGJhY2tSZXN1bHQgPSBmdW5jdGlvbiAodWR0LCBzeXNEYXRhLCBjaGFyc0xlZnQpIHtcbiAgICBpZiAoc3lzRGF0YS5waHJhc2VMZW5ndGggPiBjaGFyc0xlZnQpIHtcbiAgICAgIGxldCBzdHIgPSBgJHt0aGlzRmlsZU5hbWV9b3BVRFQoJHt1ZHQubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiBlcnJvcjogYDtcbiAgICAgIHN0ciArPSBgc3lzRGF0YS5waHJhc2VMZW5ndGg6ICR7c3lzRGF0YS5waHJhc2VMZW5ndGh9YDtcbiAgICAgIHN0ciArPSBgIG11c3QgYmUgPD0gcmVtYWluaW5nIGNoYXJzOiAke2NoYXJzTGVmdH1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgfVxuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9b3BVRFQoJHt1ZHQubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm4gZXJyb3IuIEFDVElWRSBzdGF0ZSBub3QgYWxsb3dlZC5gKTtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGlmICh1ZHQuZW1wdHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1vcFVEVCgke3VkdC5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybiBlcnJvci4gTWF5IG5vdCByZXR1cm4gRU1QVFkuYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKHN5c0RhdGEucGhyYXNlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHVkdC5lbXB0eSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9b3BVRFQoJHt1ZHQubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm4gZXJyb3IuIE1heSBub3QgcmV0dXJuIEVNUFRZLmApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke3RoaXNGaWxlTmFtZX1vcFVEVCgke3VkdC5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybiBlcnJvci4gVW5yZWNvZ25pemVkIHJldHVybiBzdGF0ZTogJHtzeXNEYXRhLnN0YXRlfWBcbiAgICAgICAgKTtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgVURUYCBvcGVyYXRvci48YnI+XG4gIC8vIFNpbXBseSBjYWxscyB0aGUgdXNlcidzIGNhbGxiYWNrIGZ1bmN0aW9uLCBidXQgb3BlcmF0ZXMgbGlrZSBgUk5NYCB3aXRoIHJlZ2FyZCB0byB0aGUgYEFTVGBcbiAgLy8gYW5kIGJhY2sgcmVmZXJlbmNpbmcuXG4gIC8vIFRoZXJlIGlzIHNvbWUgYW1iaWd1aXR5IGhlcmUuIGBVRFRgcyBhY3QgYXMgdGVybWluYWxzIGZvciBwaHJhc2UgcmVjb2duaXRpb24gYnV0IGFzIG5hbWVkIHJ1bGVzXG4gIC8vIGZvciBgQVNUYCBub2RlcyBhbmQgYmFjayByZWZlcmVuY2luZy5cbiAgLy8gU2VlIFtgYXN0LmpzYF0oLi9hc3QuaHRtbCkgZm9yIHVzYWdlLlxuICBjb25zdCBvcFVEVCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IGFzdEluZGV4O1xuICAgIGxldCBhc3REZWZpbmVkO1xuICAgIGxldCB1bGVuO1xuICAgIGxldCBwbGVuO1xuICAgIGxldCBzYXZlRnJhbWU7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IHVkdCA9IHVkdHNbb3AuaW5kZXhdO1xuICAgIHN5c0RhdGEuVWR0SW5kZXggPSB1ZHQuaW5kZXg7XG5cbiAgICBjb25zdCBub3RMb29rQXJvdW5kID0gIWluTG9va0Fyb3VuZCgpO1xuICAgIC8qIGlnbm9yZSBBU1QgYW5kIGJhY2sgcmVmZXJlbmNlcyBpbiBsb29rYXJvdW5kICovXG4gICAgaWYgKG5vdExvb2tBcm91bmQpIHtcbiAgICAgIC8qIGJlZ2luIEFTVCBhbmQgYmFjayByZWZlcmVuY2UgKi9cbiAgICAgIGFzdERlZmluZWQgPSB0aGlzVGhpcy5hc3QgJiYgdGhpc1RoaXMuYXN0LnVkdERlZmluZWQob3AuaW5kZXgpO1xuICAgICAgaWYgKGFzdERlZmluZWQpIHtcbiAgICAgICAgYXN0SW5kZXggPSBydWxlcy5sZW5ndGggKyBvcC5pbmRleDtcbiAgICAgICAgYXN0TGVuZ3RoID0gdGhpc1RoaXMuYXN0LmdldExlbmd0aCgpO1xuICAgICAgICB0aGlzVGhpcy5hc3QuZG93bihhc3RJbmRleCwgdWR0Lm5hbWUpO1xuICAgICAgfVxuICAgICAgLyogTk9URTogcHVzaCBhbmQgcG9wIG9mIHRoZSBiYWNrIHJlZmVyZW5jZSBmcmFtZSBpcyBub3JtYWxseSBub3QgbmVjZXNzYXJ5ICovXG4gICAgICAvKiBvbmx5IGluIHRoZSBjYXNlIHRoYXQgdGhlIFVEVCBjYWxscyBldmFsdWF0ZVJ1bGUoKSBvciBldmFsdWF0ZVVkdCgpICovXG4gICAgICB1bGVuID0gc3lzRGF0YS51RnJhbWUubGVuZ3RoKCk7XG4gICAgICBwbGVuID0gc3lzRGF0YS5wRnJhbWUubGVuZ3RoKCk7XG4gICAgICBzeXNEYXRhLnVGcmFtZS5wdXNoKCk7XG4gICAgICBzeXNEYXRhLnBGcmFtZS5wdXNoKCk7XG4gICAgICBzYXZlRnJhbWUgPSBzeXNEYXRhLnBGcmFtZTtcbiAgICAgIHN5c0RhdGEucEZyYW1lID0gbmV3IGJhY2tSZWYoKTtcbiAgICB9XG4gICAgLyogY2FsbCB0aGUgVURUICovXG4gICAgY29uc3QgY2hhcnNMZWZ0ID0gY2hhcnNFbmQgLSBwaHJhc2VJbmRleDtcbiAgICB1ZHRDYWxsYmFja3Nbb3AuaW5kZXhdKHN5c0RhdGEsIGNoYXJzLCBwaHJhc2VJbmRleCwgc3ludGF4RGF0YSk7XG4gICAgdmFsaWRhdGVVZHRDYWxsYmFja1Jlc3VsdCh1ZHQsIHN5c0RhdGEsIGNoYXJzTGVmdCk7XG4gICAgaWYgKG5vdExvb2tBcm91bmQpIHtcbiAgICAgIC8qIGVuZCBBU1QgKi9cbiAgICAgIGlmIChhc3REZWZpbmVkKSB7XG4gICAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNUaGlzLmFzdC51cChhc3RJbmRleCwgdWR0Lm5hbWUsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIGVuZCBiYWNrIHJlZmVyZW5jZSAqL1xuICAgICAgc3lzRGF0YS5wRnJhbWUgPSBzYXZlRnJhbWU7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICBzeXNEYXRhLnVGcmFtZS5wb3AodWxlbik7XG4gICAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIH0gZWxzZSBpZiAodWR0LmlzQmtyKSB7XG4gICAgICAgIC8qIHNhdmUgcGhyYXNlIG9uIGJvdGggdGhlIHBhcmVudCBhbmQgdW5pdmVyc2FsIGZyYW1lcyAqL1xuICAgICAgICAvKiBCS1Igb3BlcmF0b3Igd2lsbCBkZWNpZGUgd2hpY2ggdG8gdXNlIGxhdGVyICovXG4gICAgICAgIHN5c0RhdGEucEZyYW1lLnNhdmVQaHJhc2UodWR0Lmxvd2VyLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgpO1xuICAgICAgICBzeXNEYXRhLnVGcmFtZS5zYXZlUGhyYXNlKHVkdC5sb3dlciwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgQU5EYCBvcGVyYXRvci48YnI+XG4gIC8vIFRoaXMgaXMgdGhlIHBvc2l0aXZlIGBsb29rIGFoZWFkYCBvcGVyYXRvci5cbiAgLy8gRXhlY3V0ZXMgaXRzIHNpbmdsZSBjaGlsZCBub2RlLCByZXR1cm5pbmcgdGhlIEVNUFRZIHN0YXRlXG4gIC8vIGlmIGl0IHN1Y2NlZWRzYW5kIE5PTUFUQ0ggaWYgaXQgZmFpbHMuXG4gIC8vICpBbHdheXMqIGJhY2t0cmFja3Mgb24gYW55IG1hdGNoZWQgcGhyYXNlIGFuZCByZXR1cm5zIEVNUFRZIG9uIHN1Y2Nlc3MuXG4gIGNvbnN0IG9wQU5EID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbG9va0Fyb3VuZC5wdXNoKHtcbiAgICAgIGxvb2tBcm91bmQ6IGlkLkxPT0tBUk9VTkRfQUhFQUQsXG4gICAgICBhbmNob3I6IHBocmFzZUluZGV4LFxuICAgICAgY2hhcnNFbmQsXG4gICAgICBjaGFyc0xlbmd0aCxcbiAgICB9KTtcbiAgICBjaGFyc0VuZCA9IGNoYXJzLmxlbmd0aDtcbiAgICBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aCAtIGNoYXJzQmVnaW47XG4gICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgY29uc3QgcG9wID0gbG9va0Fyb3VuZC5wb3AoKTtcbiAgICBjaGFyc0VuZCA9IHBvcC5jaGFyc0VuZDtcbiAgICBjaGFyc0xlbmd0aCA9IHBvcC5jaGFyc0xlbmd0aDtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcEFORDogaW52YWxpZCBzdGF0ZSAke3N5c0RhdGEuc3RhdGV9YCk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYE5PVGAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIGlzIHRoZSBuZWdhdGl2ZSBgbG9vayBhaGVhZGAgb3BlcmF0b3IuXG4gIC8vIEV4ZWN1dGVzIGl0cyBzaW5nbGUgY2hpbGQgbm9kZSwgcmV0dXJuaW5nIHRoZSBFTVBUWSBzdGF0ZVxuICAvLyBpZiBpdCAqZmFpbHMqIGFuZCBOT01BVENIIGlmIGl0IHN1Y2NlZWRzLlxuICAvLyAqQWx3YXlzKiBiYWNrdHJhY2tzIG9uIGFueSBtYXRjaGVkIHBocmFzZSBhbmQgcmV0dXJucyBFTVBUWVxuICAvLyBvbiBzdWNjZXNzIChmYWlsdXJlIG9mIGl0cyBjaGlsZCBub2RlKS5cbiAgY29uc3Qgb3BOT1QgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsb29rQXJvdW5kLnB1c2goe1xuICAgICAgbG9va0Fyb3VuZDogaWQuTE9PS0FST1VORF9BSEVBRCxcbiAgICAgIGFuY2hvcjogcGhyYXNlSW5kZXgsXG4gICAgICBjaGFyc0VuZCxcbiAgICAgIGNoYXJzTGVuZ3RoLFxuICAgIH0pO1xuICAgIGNoYXJzRW5kID0gY2hhcnMubGVuZ3RoO1xuICAgIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoIC0gY2hhcnNCZWdpbjtcbiAgICBvcEV4ZWN1dGUob3BJbmRleCArIDEsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICBjb25zdCBwb3AgPSBsb29rQXJvdW5kLnBvcCgpO1xuICAgIGNoYXJzRW5kID0gcG9wLmNoYXJzRW5kO1xuICAgIGNoYXJzTGVuZ3RoID0gcG9wLmNoYXJzTGVuZ3RoO1xuICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICBzd2l0Y2ggKHN5c0RhdGEuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9wTk9UOiBpbnZhbGlkIHN0YXRlICR7c3lzRGF0YS5zdGF0ZX1gKTtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgVFJHYCBvcGVyYXRvci48YnI+XG4gIC8vIFN1Y2NlZWRzIGlmIHRoZSBzaW5nbGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBwaHJhc2UgaXNcbiAgLy8gd2l0aGluIHRoZSBgbWluIC0gbWF4YCByYW5nZS5cbiAgY29uc3Qgb3BUUkcgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgaWYgKHBocmFzZUluZGV4IDwgY2hhcnNFbmQpIHtcbiAgICAgIGlmIChvcC5taW4gPD0gY2hhcnNbcGhyYXNlSW5kZXhdICYmIGNoYXJzW3BocmFzZUluZGV4XSA8PSBvcC5tYXgpIHtcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYFRCU2Agb3BlcmF0b3IuPGJyPlxuICAvLyBNYXRjaGVzIGl0cyBwcmUtZGVmaW5lZCBwaHJhc2UgYWdhaW5zdCB0aGUgaW5wdXQgc3RyaW5nLlxuICAvLyBBbGwgY2hhcmFjdGVycyBtdXN0IG1hdGNoIGV4YWN0bHkuXG4gIC8vIENhc2Utc2Vuc2l0aXZlIGxpdGVyYWwgc3RyaW5ncyAoYCdzdHJpbmcnYCAmIGAlc1wic3RyaW5nXCJgKSBhcmUgdHJhbnNsYXRlZCB0byBgVEJTYFxuICAvLyBvcGVyYXRvcnMgYnkgYGFwZ2AuXG4gIC8vIFBocmFzZSBsZW5ndGggb2YgemVybyBpcyBub3QgYWxsb3dlZC5cbiAgLy8gRW1wdHkgcGhyYXNlcyBjYW4gb25seSBiZSBkZWZpbmVkIHdpdGggYFRMU2Agb3BlcmF0b3JzLlxuICBjb25zdCBvcFRCUyA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBjb25zdCBsZW4gPSBvcC5zdHJpbmcubGVuZ3RoO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIGlmIChwaHJhc2VJbmRleCArIGxlbiA8PSBjaGFyc0VuZCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmIChjaGFyc1twaHJhc2VJbmRleCArIGldICE9PSBvcC5zdHJpbmdbaV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgIH0gLyogaW1wbGllZCBlbHNlIE5PTUFUQ0ggKi9cbiAgfTtcbiAgLy8gVGhlIGBUTFNgIG9wZXJhdG9yLjxicj5cbiAgLy8gTWF0Y2hlcyBpdHMgcHJlLWRlZmluZWQgcGhyYXNlIGFnYWluc3QgdGhlIGlucHV0IHN0cmluZy5cbiAgLy8gQSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGlzIGF0dGVtcHRlZCBmb3IgQVNDSUkgYWxwaGJldGljYWwgY2hhcmFjdGVycy5cbiAgLy8gYFRMU2AgaXMgdGhlIG9ubHkgb3BlcmF0b3IgdGhhdCBleHBsaWNpdGx5IGFsbG93cyBlbXB0eSBwaHJhc2VzLlxuICAvLyBgYXBnYCB3aWxsIGZhaWwgZm9yIGVtcHR5IGBUQlNgLCBjYXNlLXNlbnNpdGl2ZSBzdHJpbmdzIChgJydgKSBvclxuICAvLyB6ZXJvIHJlcGV0aXRpb25zIChgMCowUnVsZU5hbWVgIG9yIGAwUnVsZU5hbWVgKS5cbiAgY29uc3Qgb3BUTFMgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgY29kZTtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgY29uc3QgbGVuID0gb3Auc3RyaW5nLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAvKiBFTVBUWSBtYXRjaCBhbGxvd2VkIGZvciBUTFMgKi9cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBocmFzZUluZGV4ICsgbGVuIDw9IGNoYXJzRW5kKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY29kZSA9IGNoYXJzW3BocmFzZUluZGV4ICsgaV07XG4gICAgICAgIGlmIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHtcbiAgICAgICAgICBjb2RlICs9IDMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlICE9PSBvcC5zdHJpbmdbaV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgIH0gLyogaW1wbGllZCBlbHNlIE5PTUFUQ0ggKi9cbiAgfTtcbiAgLy8gVGhlIGBBQkdgIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBpcyBhbiBcImFuY2hvclwiIGZvciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcsIHNpbWlsYXIgdG8gdGhlIGZhbWlsaWFyIHJlZ2V4IGBeYCBhbmNob3IuXG4gIC8vIEFuIGFuY2hvciBtYXRjaGVzIGEgcG9zaXRpb24gcmF0aGVyIHRoYW4gYSBwaHJhc2UuXG4gIC8vIFJldHVybnMgRU1QVFkgaWYgYHBocmFzZUluZGV4YCBpcyAwLCBOT01BVENIIG90aGVyd2lzZS5cbiAgY29uc3Qgb3BBQkcgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgc3lzRGF0YS5zdGF0ZSA9IHBocmFzZUluZGV4ID09PSAwID8gaWQuRU1QVFkgOiBpZC5OT01BVENIO1xuICB9O1xuICAvLyBUaGUgYEFFTmAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIGlzIGFuIFwiYW5jaG9yXCIgZm9yIHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc2ltaWxhciB0byB0aGUgZmFtaWxpYXIgcmVnZXggYCRgIGFuY2hvci5cbiAgLy8gQW4gYW5jaG9yIG1hdGNoZXMgYSBwb3NpdGlvbiByYXRoZXIgdGhhbiBhIHBocmFzZS5cbiAgLy8gUmV0dXJucyBFTVBUWSBpZiBgcGhyYXNlSW5kZXhgIGVxdWFscyB0aGUgaW5wdXQgc3RyaW5nIGxlbmd0aCwgTk9NQVRDSCBvdGhlcndpc2UuXG4gIGNvbnN0IG9wQUVOID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBwaHJhc2VJbmRleCA9PT0gY2hhcnMubGVuZ3RoID8gaWQuRU1QVFkgOiBpZC5OT01BVENIO1xuICB9O1xuICAvLyBUaGUgYEJLUmAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGUgYmFjayByZWZlcmVuY2Ugb3BlcmF0b3IuXG4gIC8vIE1hdGNoZXMgdGhlIGxhc3QgbWF0Y2hlZCBwaHJhc2Ugb2YgdGhlIG5hbWVkIHJ1bGUgb3IgVURUIGFnYWluc3QgdGhlIGlucHV0IHN0cmluZy5cbiAgLy8gRm9yIEFTQ0lJIGFscGhiZXRpY2FsIGNoYXJhY3RlcnMgdGhlIG1hdGNoIG1heSBiZSBjYXNlIHNlbnNpdGl2ZSAoYCVzYCkgb3IgaW5zZW5zaXRpdmUgKGAlaWApLFxuICAvLyBkZXBlbmRpbmcgb24gdGhlIGJhY2sgcmVmZXJlbmNlIGRlZmluaXRpb24uXG4gIC8vIEZvciBgdW5pdmVyc2FsYCBtb2RlIChgJXVgKSBtYXRjaGVzIHRoZSBsYXN0IHBocmFzZSBmb3VuZCBhbnl3aGVyZSBpbiB0aGUgZ3JhbW1hci5cbiAgLy8gRm9yIGBwYXJlbnQgZnJhbWVgIG1vZGUgKGAlcGApIG1hdGNoZXMgdGhlIGxhc3QgcGhyYXNlIGZvdW5kIGluIHRoZSBwYXJlbnQgcnVsZSBvbmx5LlxuICBjb25zdCBvcEJLUiA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBpO1xuICAgIGxldCBjb2RlO1xuICAgIGxldCBsbWNvZGU7XG4gICAgbGV0IGxvd2VyO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBpZiAob3AuaW5kZXggPCBydWxlcy5sZW5ndGgpIHtcbiAgICAgIGxvd2VyID0gcnVsZXNbb3AuaW5kZXhdLmxvd2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb3dlciA9IHVkdHNbb3AuaW5kZXggLSBydWxlcy5sZW5ndGhdLmxvd2VyO1xuICAgIH1cbiAgICBjb25zdCBmcmFtZSA9IG9wLmJrck1vZGUgPT09IGlkLkJLUl9NT0RFX1BNID8gc3lzRGF0YS5wRnJhbWUuZ2V0UGhyYXNlKGxvd2VyKSA6IHN5c0RhdGEudUZyYW1lLmdldFBocmFzZShsb3dlcik7XG4gICAgY29uc3QgaW5zZW5zaXRpdmUgPSBvcC5ia3JDYXNlID09PSBpZC5CS1JfTU9ERV9DSTtcbiAgICBpZiAoZnJhbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbG1JbmRleCA9IGZyYW1lLnBocmFzZUluZGV4O1xuICAgIGNvbnN0IGxlbiA9IGZyYW1lLnBocmFzZUxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwaHJhc2VJbmRleCArIGxlbiA8PSBjaGFyc0VuZCkge1xuICAgICAgaWYgKGluc2Vuc2l0aXZlKSB7XG4gICAgICAgIC8qIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggKi9cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgY29kZSA9IGNoYXJzW3BocmFzZUluZGV4ICsgaV07XG4gICAgICAgICAgbG1jb2RlID0gY2hhcnNbbG1JbmRleCArIGldO1xuICAgICAgICAgIGlmIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHtcbiAgICAgICAgICAgIGNvZGUgKz0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsbWNvZGUgPj0gNjUgJiYgbG1jb2RlIDw9IDkwKSB7XG4gICAgICAgICAgICBsbWNvZGUgKz0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2RlICE9PSBsbWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGNhc2Utc2Vuc2l0aXZlIG1hdGNoICovXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGNvZGUgPSBjaGFyc1twaHJhc2VJbmRleCArIGldO1xuICAgICAgICAgIGxtY29kZSA9IGNoYXJzW2xtSW5kZXggKyBpXTtcbiAgICAgICAgICBpZiAoY29kZSAhPT0gbG1jb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgQktBYCBvcGVyYXRvci48YnI+XG4gIC8vIFRoaXMgaXMgdGhlIHBvc2l0aXZlIGBsb29rIGJlaGluZGAgb3BlcmF0b3IuXG4gIC8vIEl0J3MgY2hpbGQgbm9kZSBpcyBwYXJzZWQgcmlnaHQtdG8tbGVmdC5cbiAgLy8gUmV0dXJucyB0aGUgRU1QVFkgc3RhdGUgaWYgYSBtYXRjaCBpcyBmb3VuZCwgTk9NQVRDSCBvdGhlcndpc2UuXG4gIC8vIExpa2UgdGhlIGxvb2sgYWhlYWQgb3BlcmF0b3JzLCBpdCBhbHdheXMgYmFja3RyYWNrcyB0byBgcGhyYXNlSW5kZXhgLlxuICBjb25zdCBvcEJLQSA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxvb2tBcm91bmQucHVzaCh7XG4gICAgICBsb29rQXJvdW5kOiBpZC5MT09LQVJPVU5EX0JFSElORCxcbiAgICAgIGFuY2hvcjogcGhyYXNlSW5kZXgsXG4gICAgfSk7XG4gICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgbG9va0Fyb3VuZC5wb3AoKTtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcEJLQTogaW52YWxpZCBzdGF0ZSAke3N5c0RhdGEuc3RhdGV9YCk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYEJLTmAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIGlzIHRoZSBuZWdhdGl2ZSBgbG9vayBiZWhpbmRgIG9wZXJhdG9yLlxuICAvLyBJdCdzIGNoaWxkIG5vZGUgaXMgcGFyc2VkIHJpZ2h0LXRvLWxlZnQuXG4gIC8vIFJldHVybnMgdGhlIEVNUFRZIHN0YXRlIGlmIGEgbWF0Y2ggaXMgKm5vdCogZm91bmQsIE5PTUFUQ0ggb3RoZXJ3aXNlLlxuICAvLyBMaWtlIHRoZSBsb29rIGFoZWFkIG9wZXJhdG9ycywgaXQgYWx3YXlzIGJhY2t0cmFja3MgdG8gYHBocmFzZUluZGV4YC5cbiAgY29uc3Qgb3BCS04gPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICAvLyBsZXQgb3A7XG4gICAgLy8gb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGxvb2tBcm91bmQucHVzaCh7XG4gICAgICBsb29rQXJvdW5kOiBpZC5MT09LQVJPVU5EX0JFSElORCxcbiAgICAgIGFuY2hvcjogcGhyYXNlSW5kZXgsXG4gICAgfSk7XG4gICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgbG9va0Fyb3VuZC5wb3AoKTtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcEJLTjogaW52YWxpZCBzdGF0ZSAke3N5c0RhdGEuc3RhdGV9YCk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgcmlnaHQtdG8tbGVmdCBgQ0FUYCBvcGVyYXRvci48YnI+XG4gIC8vIENhbGxlZCBmb3IgYENBVGAgb3BlcmF0b3JzIHdoZW4gaW4gbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gQ2FsbHMgaXRzIGNoaWxkIG5vZGVzIGZyb20gcmlnaHQgdG8gbGVmdCBjb25jYXRlbmF0aW5nIG1hdGNoZWQgcGhyYXNlcyByaWdodCB0byBsZWZ0LlxuICBjb25zdCBvcENBVEJlaGluZCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBzdWNjZXNzO1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IGNhdENoYXJJbmRleDtcbiAgICBsZXQgY2F0TWF0Y2hlZDtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgY29uc3QgdWxlbiA9IHN5c0RhdGEudUZyYW1lLmxlbmd0aCgpO1xuICAgIGNvbnN0IHBsZW4gPSBzeXNEYXRhLnBGcmFtZS5sZW5ndGgoKTtcbiAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICBhc3RMZW5ndGggPSB0aGlzVGhpcy5hc3QuZ2V0TGVuZ3RoKCk7XG4gICAgfVxuICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgIGNhdENoYXJJbmRleCA9IHBocmFzZUluZGV4O1xuICAgIGNhdE1hdGNoZWQgPSAwO1xuICAgIC8vIGNhdFBocmFzZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IG9wLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBvcEV4ZWN1dGUob3AuY2hpbGRyZW5baV0sIGNhdENoYXJJbmRleCwgc3lzRGF0YSk7XG4gICAgICBjYXRDaGFySW5kZXggLT0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICBjYXRNYXRjaGVkICs9IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgLy8gY2F0UGhyYXNlICs9IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBjYXRNYXRjaGVkID09PSAwID8gaWQuRU1QVFkgOiBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gY2F0TWF0Y2hlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICBzeXNEYXRhLnVGcmFtZS5wb3AodWxlbik7XG4gICAgICBzeXNEYXRhLnBGcmFtZS5wb3AocGxlbik7XG4gICAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICAgIHRoaXNUaGlzLmFzdC5zZXRMZW5ndGgoYXN0TGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZSByaWdodC10by1sZWZ0IGBSRVBgIG9wZXJhdG9yLjxicj5cbiAgLy8gQ2FsbGVkIGZvciBgUkVQYCBvcGVyYXRvcnMgaW4gbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gTWFrZXMgcmVwZWF0ZWQgY2FsbHMgdG8gaXRzIGNoaWxkIG5vZGUsIGNvbmNhdGVuYXRpbmcgbWF0Y2hlZCBwaHJhc2VzIHJpZ2h0IHRvIGxlZnQuXG4gIGNvbnN0IG9wUkVQQmVoaW5kID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGFzdExlbmd0aDtcbiAgICBsZXQgcmVwQ2hhckluZGV4O1xuICAgIGxldCByZXBQaHJhc2U7XG4gICAgbGV0IHJlcENvdW50O1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICByZXBDaGFySW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICByZXBQaHJhc2UgPSAwO1xuICAgIHJlcENvdW50ID0gMDtcbiAgICBjb25zdCB1bGVuID0gc3lzRGF0YS51RnJhbWUubGVuZ3RoKCk7XG4gICAgY29uc3QgcGxlbiA9IHN5c0RhdGEucEZyYW1lLmxlbmd0aCgpO1xuICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgIGFzdExlbmd0aCA9IHRoaXNUaGlzLmFzdC5nZXRMZW5ndGgoKTtcbiAgICB9XG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIGlmIChyZXBDaGFySW5kZXggPD0gMCkge1xuICAgICAgICAvKiBleGl0IG9uIGVuZCBvZiBpbnB1dCBzdHJpbmcgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvcEV4ZWN1dGUob3BJbmRleCArIDEsIHJlcENoYXJJbmRleCwgc3lzRGF0YSk7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICAvKiBhbHdheXMgZW5kIGlmIHRoZSBjaGlsZCBub2RlIGZhaWxzICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLkVNUFRZKSB7XG4gICAgICAgIC8qIFJFUCBhbHdheXMgc3VjY2VlZHMgd2hlbiB0aGUgY2hpbGQgbm9kZSByZXR1cm5zIGFuIGVtcHR5IHBocmFzZSAqL1xuICAgICAgICAvKiB0aGlzIG1heSBub3Qgc2VlbSBvYnZpb3VzLCBidXQgdGhhdCdzIHRoZSB3YXkgaXQgd29ya3Mgb3V0ICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVwQ291bnQgKz0gMTtcbiAgICAgIHJlcFBocmFzZSArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIHJlcENoYXJJbmRleCAtPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIGlmIChyZXBDb3VudCA9PT0gb3AubWF4KSB7XG4gICAgICAgIC8qIGVuZCBvbiBtYXhlZCBvdXQgcmVwcyAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLyogZXZhbHVhdGUgdGhlIG1hdGNoIGNvdW50IGFjY29yZGluZyB0byB0aGUgbWluLCBtYXggdmFsdWVzICovXG4gICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLkVNUFRZKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gcmVwUGhyYXNlID09PSAwID8gaWQuRU1QVFkgOiBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gcmVwUGhyYXNlO1xuICAgIH0gZWxzZSBpZiAocmVwQ291bnQgPj0gb3AubWluKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gcmVwUGhyYXNlID09PSAwID8gaWQuRU1QVFkgOiBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gcmVwUGhyYXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgIHN5c0RhdGEudUZyYW1lLnBvcCh1bGVuKTtcbiAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIHJpZ2h0LXRvLWxlZnQgYFRSR2Agb3BlcmF0b3IuPGJyPlxuICAvLyBDYWxsZWQgZm9yIGBUUkdgIG9wZXJhdG9ycyBpbiBsb29rIGJlaGluZCBtb2RlLlxuICAvLyBNYXRjaGVzIGEgc2luZ2xlIGNoYXJhY3RlciBhdCBgcGhyYXNlSW5kZXggLSAxYCB0byB0aGUgYG1pbmAgLSBgbWF4YCByYW5nZS5cbiAgY29uc3Qgb3BUUkdCZWhpbmQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIGlmIChwaHJhc2VJbmRleCA+IDApIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBjaGFyc1twaHJhc2VJbmRleCAtIDFdO1xuICAgICAgaWYgKG9wLm1pbiA8PSBjaGFyICYmIGNoYXIgPD0gb3AubWF4KSB7XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIHJpZ2h0LXRvLWxlZnQgYFRCU2Agb3BlcmF0b3IuPGJyPlxuICAvLyBDYWxsZWQgZm9yIGBUQlNgIG9wZXJhdG9ycyBpbiBsb29rIGJlaGluZCBtb2RlLlxuICAvLyBNYXRjaGVzIHRoZSBgVEJTYCBwaHJhc2UgdG8gdGhlIGxlZnQgb2YgYHBocmFzZUluZGV4YC5cbiAgY29uc3Qgb3BUQlNCZWhpbmQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgY29uc3QgbGVuID0gb3Auc3RyaW5nLmxlbmd0aDtcbiAgICBjb25zdCBiZWcgPSBwaHJhc2VJbmRleCAtIGxlbjtcbiAgICBpZiAoYmVnID49IDApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoY2hhcnNbYmVnICsgaV0gIT09IG9wLnN0cmluZ1tpXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgfVxuICB9O1xuICAvLyBUaGUgcmlnaHQtdG8tbGVmdCBgVExTYCBvcGVyYXRvci48YnI+XG4gIC8vIENhbGxlZCBmb3IgYFRMU2Agb3BlcmF0b3JzIGluIGxvb2sgYmVoaW5kIG1vZGUuXG4gIC8vIE1hdGNoZXMgdGhlIGBUTFNgIHBocmFzZSB0byB0aGUgbGVmdCBvZiBgcGhyYXNlSW5kZXhgLlxuICBjb25zdCBvcFRMU0JlaGluZCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBjaGFyO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBjb25zdCBsZW4gPSBvcC5zdHJpbmcubGVuZ3RoO1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIC8qIEVNUFRZIG1hdGNoIGFsbG93ZWQgZm9yIFRMUyAqL1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiZWcgPSBwaHJhc2VJbmRleCAtIGxlbjtcbiAgICBpZiAoYmVnID49IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY2hhciA9IGNoYXJzW2JlZyArIGldO1xuICAgICAgICBpZiAoY2hhciA+PSA2NSAmJiBjaGFyIDw9IDkwKSB7XG4gICAgICAgICAgY2hhciArPSAzMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciAhPT0gb3Auc3RyaW5nW2ldKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSByaWdodC10by1sZWZ0IGJhY2sgcmVmZXJlbmNlIG9wZXJhdG9yLjxicj5cbiAgLy8gTWF0Y2hlcyB0aGUgYmFjayByZWZlcmVuY2VkIHBocmFzZSB0byB0aGUgbGVmdCBvZiBgcGhyYXNlSW5kZXhgLlxuICBjb25zdCBvcEJLUkJlaGluZCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBpO1xuICAgIGxldCBjb2RlO1xuICAgIGxldCBsbWNvZGU7XG4gICAgbGV0IGxvd2VyO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICAvKiBOT01BVENIIGRlZmF1bHQgKi9cbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgaWYgKG9wLmluZGV4IDwgcnVsZXMubGVuZ3RoKSB7XG4gICAgICBsb3dlciA9IHJ1bGVzW29wLmluZGV4XS5sb3dlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbG93ZXIgPSB1ZHRzW29wLmluZGV4IC0gcnVsZXMubGVuZ3RoXS5sb3dlcjtcbiAgICB9XG4gICAgY29uc3QgZnJhbWUgPSBvcC5ia3JNb2RlID09PSBpZC5CS1JfTU9ERV9QTSA/IHN5c0RhdGEucEZyYW1lLmdldFBocmFzZShsb3dlcikgOiBzeXNEYXRhLnVGcmFtZS5nZXRQaHJhc2UobG93ZXIpO1xuICAgIGNvbnN0IGluc2Vuc2l0aXZlID0gb3AuYmtyQ2FzZSA9PT0gaWQuQktSX01PREVfQ0k7XG4gICAgaWYgKGZyYW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxtSW5kZXggPSBmcmFtZS5waHJhc2VJbmRleDtcbiAgICBjb25zdCBsZW4gPSBmcmFtZS5waHJhc2VMZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiZWcgPSBwaHJhc2VJbmRleCAtIGxlbjtcbiAgICBpZiAoYmVnID49IDApIHtcbiAgICAgIGlmIChpbnNlbnNpdGl2ZSkge1xuICAgICAgICAvKiBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoICovXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGNvZGUgPSBjaGFyc1tiZWcgKyBpXTtcbiAgICAgICAgICBsbWNvZGUgPSBjaGFyc1tsbUluZGV4ICsgaV07XG4gICAgICAgICAgaWYgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkge1xuICAgICAgICAgICAgY29kZSArPSAzMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxtY29kZSA+PSA2NSAmJiBsbWNvZGUgPD0gOTApIHtcbiAgICAgICAgICAgIGxtY29kZSArPSAzMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGUgIT09IGxtY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogY2FzZS1zZW5zaXRpdmUgbWF0Y2ggKi9cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgY29kZSA9IGNoYXJzW2JlZyArIGldO1xuICAgICAgICAgIGxtY29kZSA9IGNoYXJzW2xtSW5kZXggKyBpXTtcbiAgICAgICAgICBpZiAoY29kZSAhPT0gbG1jb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH07XG4gIC8vIEdlbmVyYWxpemVkIGV4ZWN1dGlvbiBmdW5jdGlvbi48YnI+XG4gIC8vIEhhdmluZyBhIHNpbmdsZSwgZ2VuZXJhbGl6ZWQgZnVuY3Rpb24sIGFsbG93cyBhIHNpbmdsZSBsb2NhdGlvblxuICAvLyBmb3IgdHJhY2luZyBhbmQgc3RhdGlzdGljcyBnYXRoZXJpbmcgZnVuY3Rpb25zIHRvIGJlIGNhbGxlZC5cbiAgLy8gVHJhY2luZyBhbmQgc3RhdGlzdGljcyBhcmUgaGFuZGxlZCBpbiBzZXBhcmF0ZSBvYmplY3RzLlxuICAvLyBIb3dldmVyLCB0aGUgcGFyc2VyIGNhbGxzIHRoZWlyIEFQSSB0byBidWlsZCB0aGUgb2JqZWN0IGRhdGEgcmVjb3Jkcy5cbiAgLy8gU2VlIFtgdHJhY2UuanNgXSguL3RyYWNlLmh0bWwpIGFuZCBbYHN0YXRzLmpzYF0oLi9zdGF0cy5odG1sKSBmb3IgdGhlaXJcbiAgLy8gdXNhZ2UuXG4gIG9wRXhlY3V0ZSA9IGZ1bmN0aW9uIG9wRXhlY3V0ZUZ1bmMob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgcmV0ID0gdHJ1ZTtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgbm9kZUhpdHMgKz0gMTtcbiAgICBpZiAobm9kZUhpdHMgPiBsaW1pdE5vZGVIaXRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlcjogbWF4aW11bSBudW1iZXIgb2Ygbm9kZSBoaXRzIGV4Y2VlZGVkOiAke2xpbWl0Tm9kZUhpdHN9YCk7XG4gICAgfVxuICAgIHRyZWVEZXB0aCArPSAxO1xuICAgIGlmICh0cmVlRGVwdGggPiBtYXhUcmVlRGVwdGgpIHtcbiAgICAgIG1heFRyZWVEZXB0aCA9IHRyZWVEZXB0aDtcbiAgICAgIGlmIChtYXhUcmVlRGVwdGggPiBsaW1pdFRyZWVEZXB0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlcjogbWF4aW11bSBwYXJzZSB0cmVlIGRlcHRoIGV4Y2VlZGVkOiAke2xpbWl0VHJlZURlcHRofWApO1xuICAgICAgfVxuICAgIH1cbiAgICBzeXNEYXRhLnJlZnJlc2goKTtcbiAgICBpZiAodGhpc1RoaXMudHJhY2UgIT09IG51bGwpIHtcbiAgICAgIC8qIGNvbGxlY3QgdGhlIHRyYWNlIHJlY29yZCBmb3IgZG93biB0aGUgcGFyc2UgdHJlZSAqL1xuICAgICAgY29uc3QgbGsgPSBsb29rQXJvdW5kVmFsdWUoKTtcbiAgICAgIHRoaXNUaGlzLnRyYWNlLmRvd24ob3AsIHN5c0RhdGEuc3RhdGUsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCwgbGsuYW5jaG9yLCBsay5sb29rQXJvdW5kKTtcbiAgICB9XG4gICAgaWYgKGluTG9va0JlaGluZCgpKSB7XG4gICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgY2FzZSBpZC5BTFQ6XG4gICAgICAgICAgb3BBTFQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgICBvcENBVEJlaGluZChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuUkVQOlxuICAgICAgICAgIG9wUkVQQmVoaW5kKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgICAgb3BSTk0ob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlVEVDpcbiAgICAgICAgICBvcFVEVChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQU5EOlxuICAgICAgICAgIG9wQU5EKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5OT1Q6XG4gICAgICAgICAgb3BOT1Qob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlRSRzpcbiAgICAgICAgICBvcFRSR0JlaGluZChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVEJTOlxuICAgICAgICAgIG9wVEJTQmVoaW5kKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgICAgb3BUTFNCZWhpbmQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkJLUjpcbiAgICAgICAgICBvcEJLUkJlaGluZChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQktBOlxuICAgICAgICAgIG9wQktBKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5CS046XG4gICAgICAgICAgb3BCS04ob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkFCRzpcbiAgICAgICAgICBvcEFCRyhvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQUVOOlxuICAgICAgICAgIG9wQUVOKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICAgIG9wQUxUKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5DQVQ6XG4gICAgICAgICAgb3BDQVQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgICBvcFJFUChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuUk5NOlxuICAgICAgICAgIG9wUk5NKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5VRFQ6XG4gICAgICAgICAgb3BVRFQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkFORDpcbiAgICAgICAgICBvcEFORChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuTk9UOlxuICAgICAgICAgIG9wTk9UKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgICAgb3BUUkcob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlRCUzpcbiAgICAgICAgICBvcFRCUyhvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVExTOlxuICAgICAgICAgIG9wVExTKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgICAgb3BCS1Iob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkJLQTpcbiAgICAgICAgICBvcEJLQShvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQktOOlxuICAgICAgICAgIG9wQktOKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5BQkc6XG4gICAgICAgICAgb3BBQkcob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkFFTjpcbiAgICAgICAgICBvcEFFTihvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaW5Mb29rQXJvdW5kKCkgJiYgcGhyYXNlSW5kZXggKyBzeXNEYXRhLnBocmFzZUxlbmd0aCA+IG1heE1hdGNoZWQpIHtcbiAgICAgIG1heE1hdGNoZWQgPSBwaHJhc2VJbmRleCArIHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodGhpc1RoaXMuc3RhdHMgIT09IG51bGwpIHtcbiAgICAgIC8qIGNvbGxlY3QgdGhlIHN0YXRpc3RpY3MgKi9cbiAgICAgIHRoaXNUaGlzLnN0YXRzLmNvbGxlY3Qob3AsIHN5c0RhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpc1RoaXMudHJhY2UgIT09IG51bGwpIHtcbiAgICAgIC8qIGNvbGxlY3QgdGhlIHRyYWNlIHJlY29yZCBmb3IgdXAgdGhlIHBhcnNlIHRyZWUgKi9cbiAgICAgIGNvbnN0IGxrID0gbG9va0Fyb3VuZFZhbHVlKCk7XG4gICAgICB0aGlzVGhpcy50cmFjZS51cChvcCwgc3lzRGF0YS5zdGF0ZSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoLCBsay5hbmNob3IsIGxrLmxvb2tBcm91bmQpO1xuICAgIH1cbiAgICB0cmVlRGVwdGggLT0gMTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2VyIiwiaWQiLCJyZXF1aXJlIiwidXRpbHMiLCJ0aGlzRmlsZU5hbWUiLCJ0aGlzVGhpcyIsIm9wRXhlY3V0ZSIsImFzdCIsInN0YXRzIiwidHJhY2UiLCJjYWxsYmFja3MiLCJvcGNvZGVzIiwiY2hhcnMiLCJjaGFyc0JlZ2luIiwiY2hhcnNMZW5ndGgiLCJjaGFyc0VuZCIsImxvb2tBcm91bmQiLCJ0cmVlRGVwdGgiLCJtYXhUcmVlRGVwdGgiLCJub2RlSGl0cyIsInJ1bGVDYWxsYmFja3MiLCJ1ZHRDYWxsYmFja3MiLCJydWxlcyIsInVkdHMiLCJzeW50YXhEYXRhIiwibWF4TWF0Y2hlZCIsImxpbWl0VHJlZURlcHRoIiwiSW5maW5pdHkiLCJsaW1pdE5vZGVIaXRzIiwiZXZhbHVhdGVSdWxlIiwicnVsZUluZGV4IiwicGhyYXNlSW5kZXgiLCJzeXNEYXRhIiwiZnVuY3Rpb25OYW1lIiwibGVuZ3RoIiwiRXJyb3IiLCJwdXNoIiwidHlwZSIsIlJOTSIsImluZGV4IiwicG9wIiwiZXZhbHVhdGVVZHQiLCJ1ZHRJbmRleCIsIlVEVCIsImVtcHR5IiwiY2xlYXIiLCJMT09LQVJPVU5EX05PTkUiLCJhbmNob3IiLCJiYWNrUmVmIiwic3RhY2siLCJpbml0Iiwib2JqIiwiZm9yRWFjaCIsInJ1bGUiLCJpc0JrciIsImxvd2VyIiwidWR0IiwiY29weSIsInRvcCIsIm5hbWUiLCJsZW5ndGhBcmciLCJzYXZlUGhyYXNlIiwicGhyYXNlTGVuZ3RoIiwiZ2V0UGhyYXNlIiwic3lzdGVtRGF0YSIsInRoaXNEYXRhIiwic3RhdGUiLCJBQ1RJVkUiLCJ1RnJhbWUiLCJwRnJhbWUiLCJyZWZyZXNoIiwibG9va0Fyb3VuZFZhbHVlIiwiaW5Mb29rQXJvdW5kIiwiaW5Mb29rQmVoaW5kIiwiTE9PS0FST1VORF9CRUhJTkQiLCJpbml0aWFsaXplQXN0IiwiVFJVRSIsInVuZGVmaW5lZCIsImFzdE9iamVjdCIsImluaXRpYWxpemVUcmFjZSIsInRyYWNlT2JqZWN0IiwiaW5pdGlhbGl6ZVN0YXRzIiwic3RhdHNPYmplY3QiLCJpbml0aWFsaXplR3JhbW1hciIsImdyYW1tYXIiLCJncmFtbWFyT2JqZWN0IiwiaW5pdGlhbGl6ZVN0YXJ0UnVsZSIsInN0YXJ0UnVsZSIsInN0YXJ0IiwidG9Mb3dlckNhc2UiLCJpIiwiaW5pdGlhbGl6ZUlucHV0Q2hhcnMiLCJpbnB1dEFyZyIsImJlZ0FyZyIsImxlbkFyZyIsImlucHV0IiwiYmVnIiwibGVuIiwic3RyaW5nVG9DaGFycyIsIkFycmF5IiwiaXNBcnJheSIsIk1hdGgiLCJmbG9vciIsImluaXRpYWxpemVDYWxsYmFja3MiLCJmdW5jIiwibGlzdCIsImluZGV4T2YiLCJzZXRNYXhUcmVlRGVwdGgiLCJkZXB0aCIsInNldE1heE5vZGVIaXRzIiwiaGl0cyIsInByaXZhdGVQYXJzZSIsInN0YXJ0UnVsZUFyZyIsImNhbGxiYWNrRGF0YSIsInN1Y2Nlc3MiLCJOT01BVENIIiwiRU1QVFkiLCJNQVRDSCIsIm1hdGNoZWQiLCJpbnB1dExlbmd0aCIsInN1YkJlZ2luIiwic3ViRW5kIiwic3ViTGVuZ3RoIiwicGFyc2VTdWJzdHJpbmciLCJpbnB1dENoYXJzIiwiaW5wdXRJbmRleCIsInBhcnNlIiwib3BBTFQiLCJvcEluZGV4Iiwib3AiLCJjaGlsZHJlbiIsIm9wQ0FUIiwiYXN0TGVuZ3RoIiwiY2F0Q2hhckluZGV4IiwiY2F0UGhyYXNlIiwidWxlbiIsInBsZW4iLCJnZXRMZW5ndGgiLCJzZXRMZW5ndGgiLCJvcFJFUCIsInJlcENoYXJJbmRleCIsInJlcFBocmFzZSIsInJlcENvdW50IiwibWF4IiwibWluIiwidmFsaWRhdGVSbm1DYWxsYmFja1Jlc3VsdCIsImNoYXJzTGVmdCIsImRvd24iLCJzdHIiLCJvcFJOTSIsImFzdERlZmluZWQiLCJzYXZlZE9wY29kZXMiLCJzYXZlRnJhbWUiLCJjYWxsYmFjayIsIm5vdExvb2tBcm91bmQiLCJydWxlRGVmaW5lZCIsInVwIiwidmFsaWRhdGVVZHRDYWxsYmFja1Jlc3VsdCIsIm9wVURUIiwiYXN0SW5kZXgiLCJVZHRJbmRleCIsInVkdERlZmluZWQiLCJvcEFORCIsIkxPT0tBUk9VTkRfQUhFQUQiLCJvcE5PVCIsIm9wVFJHIiwib3BUQlMiLCJzdHJpbmciLCJvcFRMUyIsImNvZGUiLCJvcEFCRyIsIm9wQUVOIiwib3BCS1IiLCJsbWNvZGUiLCJmcmFtZSIsImJrck1vZGUiLCJCS1JfTU9ERV9QTSIsImluc2Vuc2l0aXZlIiwiYmtyQ2FzZSIsIkJLUl9NT0RFX0NJIiwibG1JbmRleCIsIm9wQktBIiwib3BCS04iLCJvcENBVEJlaGluZCIsImNhdE1hdGNoZWQiLCJvcFJFUEJlaGluZCIsIm9wVFJHQmVoaW5kIiwiY2hhciIsIm9wVEJTQmVoaW5kIiwib3BUTFNCZWhpbmQiLCJvcEJLUkJlaGluZCIsIm9wRXhlY3V0ZUZ1bmMiLCJyZXQiLCJsayIsIkFMVCIsIkNBVCIsIlJFUCIsIkFORCIsIk5PVCIsIlRSRyIsIlRCUyIsIlRMUyIsIkJLUiIsIkJLQSIsIkJLTiIsIkFCRyIsIkFFTiIsImNvbGxlY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/parser.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/stats.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/stats.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module is the constructor for the statistics gathering object.\n// The statistics are nothing more than keeping a count of the\n// number of times each node in the parse tree is traversed.\n//\n// Counts are collected for each of the individual types of operators.\n// Additionally, counts are collected for each of the individually named\n// `RNM` and `UDT` operators.\n\nmodule.exports = function statsFunc() {\n    const id = __webpack_require__(/*! ./identifiers */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n    const utils = __webpack_require__(/*! ./utilities */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\");\n    const style = __webpack_require__(/*! ./style */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js\");\n    const thisFileName = \"stats.js: \";\n    let rules = [];\n    let udts = [];\n    const stats = [];\n    let totals;\n    const ruleStats = [];\n    const udtStats = [];\n    this.statsObject = \"statsObject\";\n    const nameId = \"stats\";\n    /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators alphabetically by name. */ const sortAlpha = function sortAlpha(lhs, rhs) {\n        if (lhs.lower < rhs.lower) {\n            return -1;\n        }\n        if (lhs.lower > rhs.lower) {\n            return 1;\n        }\n        return 0;\n    };\n    /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by hit count. */ const sortHits = function sortHits(lhs, rhs) {\n        if (lhs.total < rhs.total) {\n            return 1;\n        }\n        if (lhs.total > rhs.total) {\n            return -1;\n        }\n        return sortAlpha(lhs, rhs);\n    };\n    /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by index */ /* (in the order in which they appear in the SABNF grammar). */ const sortIndex = function sortIndex(lhs, rhs) {\n        if (lhs.index < rhs.index) {\n            return -1;\n        }\n        if (lhs.index > rhs.index) {\n            return 1;\n        }\n        return 0;\n    };\n    const EmptyStat = function EmptyStat() {\n        this.empty = 0;\n        this.match = 0;\n        this.nomatch = 0;\n        this.total = 0;\n    };\n    /* Zero out all stats */ const clear = function clear() {\n        stats.length = 0;\n        totals = new EmptyStat();\n        stats[id.ALT] = new EmptyStat();\n        stats[id.CAT] = new EmptyStat();\n        stats[id.REP] = new EmptyStat();\n        stats[id.RNM] = new EmptyStat();\n        stats[id.TRG] = new EmptyStat();\n        stats[id.TBS] = new EmptyStat();\n        stats[id.TLS] = new EmptyStat();\n        stats[id.UDT] = new EmptyStat();\n        stats[id.AND] = new EmptyStat();\n        stats[id.NOT] = new EmptyStat();\n        stats[id.BKR] = new EmptyStat();\n        stats[id.BKA] = new EmptyStat();\n        stats[id.BKN] = new EmptyStat();\n        stats[id.ABG] = new EmptyStat();\n        stats[id.AEN] = new EmptyStat();\n        ruleStats.length = 0;\n        for(let i = 0; i < rules.length; i += 1){\n            ruleStats.push({\n                empty: 0,\n                match: 0,\n                nomatch: 0,\n                total: 0,\n                name: rules[i].name,\n                lower: rules[i].lower,\n                index: rules[i].index\n            });\n        }\n        if (udts.length > 0) {\n            udtStats.length = 0;\n            for(let i = 0; i < udts.length; i += 1){\n                udtStats.push({\n                    empty: 0,\n                    match: 0,\n                    nomatch: 0,\n                    total: 0,\n                    name: udts[i].name,\n                    lower: udts[i].lower,\n                    index: udts[i].index\n                });\n            }\n        }\n    };\n    /* increment the designated operator hit count by one */ const incStat = function incStat(stat, state) {\n        stat.total += 1;\n        switch(state){\n            case id.EMPTY:\n                stat.empty += 1;\n                break;\n            case id.MATCH:\n                stat.match += 1;\n                break;\n            case id.NOMATCH:\n                stat.nomatch += 1;\n                break;\n            default:\n                throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);\n        }\n    };\n    /* helper for toHtml() */ const displayRow = function displayRow(name, stat) {\n        let html = \"\";\n        html += \"<tr>\";\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${name}</td>`;\n        html += `<td class=\"${style.CLASS_EMPTY}\">${stat.empty}</td>`;\n        html += `<td class=\"${style.CLASS_MATCH}\">${stat.match}</td>`;\n        html += `<td class=\"${style.CLASS_NOMATCH}\">${stat.nomatch}</td>`;\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${stat.total}</td>`;\n        html += \"</tr>\\n\";\n        return html;\n    };\n    const displayOpsOnly = function displayOpsOnly() {\n        let html = \"\";\n        html += displayRow(\"ALT\", stats[id.ALT]);\n        html += displayRow(\"CAT\", stats[id.CAT]);\n        html += displayRow(\"REP\", stats[id.REP]);\n        html += displayRow(\"RNM\", stats[id.RNM]);\n        html += displayRow(\"TRG\", stats[id.TRG]);\n        html += displayRow(\"TBS\", stats[id.TBS]);\n        html += displayRow(\"TLS\", stats[id.TLS]);\n        html += displayRow(\"UDT\", stats[id.UDT]);\n        html += displayRow(\"AND\", stats[id.AND]);\n        html += displayRow(\"NOT\", stats[id.NOT]);\n        html += displayRow(\"BKR\", stats[id.BKR]);\n        html += displayRow(\"BKA\", stats[id.BKA]);\n        html += displayRow(\"BKN\", stats[id.BKN]);\n        html += displayRow(\"ABG\", stats[id.ABG]);\n        html += displayRow(\"AEN\", stats[id.AEN]);\n        html += displayRow(\"totals\", totals);\n        return html;\n    };\n    /* helper for toHtml() */ const displayRules = function displayRules() {\n        let html = \"\";\n        html += \"<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n\";\n        html += \"<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\\n\";\n        for(let i = 0; i < rules.length; i += 1){\n            if (ruleStats[i].total > 0) {\n                html += \"<tr>\";\n                html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].name}</td>`;\n                html += `<td class=\"${style.CLASS_EMPTY}\">${ruleStats[i].empty}</td>`;\n                html += `<td class=\"${style.CLASS_MATCH}\">${ruleStats[i].match}</td>`;\n                html += `<td class=\"${style.CLASS_NOMATCH}\">${ruleStats[i].nomatch}</td>`;\n                html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].total}</td>`;\n                html += \"</tr>\\n\";\n            }\n        }\n        if (udts.length > 0) {\n            html += \"<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n\";\n            html += \"<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\\n\";\n            for(let i = 0; i < udts.length; i += 1){\n                if (udtStats[i].total > 0) {\n                    html += \"<tr>\";\n                    html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].name}</td>`;\n                    html += `<td class=\"${style.CLASS_EMPTY}\">${udtStats[i].empty}</td>`;\n                    html += `<td class=\"${style.CLASS_MATCH}\">${udtStats[i].match}</td>`;\n                    html += `<td class=\"${style.CLASS_NOMATCH}\">${udtStats[i].nomatch}</td>`;\n                    html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].total}</td>`;\n                    html += \"</tr>\\n\";\n                }\n            }\n        }\n        return html;\n    };\n    /* called only by the parser to validate a stats object */ this.validate = function validate(name) {\n        let ret = false;\n        if (typeof name === \"string\" && nameId === name) {\n            ret = true;\n        }\n        return ret;\n    };\n    /* no verification of input - only called by parser() */ this.init = function init(inputRules, inputUdts) {\n        rules = inputRules;\n        udts = inputUdts;\n        clear();\n    };\n    /* This function is the main interaction with the parser. */ /* The parser calls it after each node has been traversed. */ this.collect = function collect(op, result) {\n        incStat(totals, result.state, result.phraseLength);\n        incStat(stats[op.type], result.state, result.phraseLength);\n        if (op.type === id.RNM) {\n            incStat(ruleStats[op.index], result.state, result.phraseLength);\n        }\n        if (op.type === id.UDT) {\n            incStat(udtStats[op.index], result.state, result.phraseLength);\n        }\n    };\n    // Display the statistics as an HTML table.\n    // - *type*\n    //   - \"ops\" - (default) display only the total hit counts for all operator types.\n    //   - \"index\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators ordered by index.\n    //   - \"hits\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by hit count.\n    //   - \"alpha\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by name alphabetically.\n    // - *caption* - optional caption for the table\n    this.toHtml = function toHtml(type, caption) {\n        let html = \"\";\n        html += `<table class=\"${style.CLASS_STATS}\">\\n`;\n        if (typeof caption === \"string\") {\n            html += `<caption>${caption}</caption>\\n`;\n        }\n        html += `<tr><th class=\"${style.CLASS_ACTIVE}\">ops</th>\\n`;\n        html += `<th class=\"${style.CLASS_EMPTY}\">EMPTY</th>\\n`;\n        html += `<th class=\"${style.CLASS_MATCH}\">MATCH</th>\\n`;\n        html += `<th class=\"${style.CLASS_NOMATCH}\">NOMATCH</th>\\n`;\n        html += `<th class=\"${style.CLASS_ACTIVE}\">totals</th></tr>\\n`;\n        const test = true;\n        while(test){\n            if (type === undefined) {\n                html += displayOpsOnly();\n                break;\n            }\n            if (type === null) {\n                html += displayOpsOnly();\n                break;\n            }\n            if (type === \"ops\") {\n                html += displayOpsOnly();\n                break;\n            }\n            if (type === \"index\") {\n                ruleStats.sort(sortIndex);\n                if (udtStats.length > 0) {\n                    udtStats.sort(sortIndex);\n                }\n                html += displayOpsOnly();\n                html += displayRules();\n                break;\n            }\n            if (type === \"hits\") {\n                ruleStats.sort(sortHits);\n                if (udtStats.length > 0) {\n                    udtStats.sort(sortIndex);\n                }\n                html += displayOpsOnly();\n                html += displayRules();\n                break;\n            }\n            if (type === \"alpha\") {\n                ruleStats.sort(sortAlpha);\n                if (udtStats.length > 0) {\n                    udtStats.sort(sortAlpha);\n                }\n                html += displayOpsOnly();\n                html += displayRules();\n                break;\n            }\n            break;\n        }\n        html += \"</table>\\n\";\n        return html;\n    };\n    // Display the stats table in a complete HTML5 page.\n    this.toHtmlPage = function toHtmlPage(type, caption, title) {\n        return utils.htmlToPage(this.toHtml(type, caption), title);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0YXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7dUZBR3VGLEdBQ3ZGLHNFQUFzRTtBQUN0RSw4REFBOEQ7QUFDOUQsNERBQTREO0FBQzVELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsd0VBQXdFO0FBQ3hFLDZCQUE2Qjs7QUFDN0JBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQztJQUN4QixNQUFNQyxLQUFLQyxtQkFBT0EsQ0FBQztJQUNuQixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQztJQUN0QixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQztJQUV0QixNQUFNRyxlQUFlO0lBQ3JCLElBQUlDLFFBQVEsRUFBRTtJQUNkLElBQUlDLE9BQU8sRUFBRTtJQUNiLE1BQU1DLFFBQVEsRUFBRTtJQUNoQixJQUFJQztJQUNKLE1BQU1DLFlBQVksRUFBRTtJQUNwQixNQUFNQyxXQUFXLEVBQUU7SUFDbkIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7SUFDbkIsTUFBTUMsU0FBUztJQUNmLGtHQUFrRyxHQUNsRyxNQUFNQyxZQUFZLFNBQVNBLFVBQVVDLEdBQUcsRUFBRUMsR0FBRztRQUMzQyxJQUFJRCxJQUFJRSxLQUFLLEdBQUdELElBQUlDLEtBQUssRUFBRTtZQUN6QixPQUFPLENBQUM7UUFDVjtRQUNBLElBQUlGLElBQUlFLEtBQUssR0FBR0QsSUFBSUMsS0FBSyxFQUFFO1lBQ3pCLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUNBLHdGQUF3RixHQUN4RixNQUFNQyxXQUFXLFNBQVNBLFNBQVNILEdBQUcsRUFBRUMsR0FBRztRQUN6QyxJQUFJRCxJQUFJSSxLQUFLLEdBQUdILElBQUlHLEtBQUssRUFBRTtZQUN6QixPQUFPO1FBQ1Q7UUFDQSxJQUFJSixJQUFJSSxLQUFLLEdBQUdILElBQUlHLEtBQUssRUFBRTtZQUN6QixPQUFPLENBQUM7UUFD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cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvc3RhdHMuanM/N2Y2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBpcyB0aGUgY29uc3RydWN0b3IgZm9yIHRoZSBzdGF0aXN0aWNzIGdhdGhlcmluZyBvYmplY3QuXG4vLyBUaGUgc3RhdGlzdGljcyBhcmUgbm90aGluZyBtb3JlIHRoYW4ga2VlcGluZyBhIGNvdW50IG9mIHRoZVxuLy8gbnVtYmVyIG9mIHRpbWVzIGVhY2ggbm9kZSBpbiB0aGUgcGFyc2UgdHJlZSBpcyB0cmF2ZXJzZWQuXG4vL1xuLy8gQ291bnRzIGFyZSBjb2xsZWN0ZWQgZm9yIGVhY2ggb2YgdGhlIGluZGl2aWR1YWwgdHlwZXMgb2Ygb3BlcmF0b3JzLlxuLy8gQWRkaXRpb25hbGx5LCBjb3VudHMgYXJlIGNvbGxlY3RlZCBmb3IgZWFjaCBvZiB0aGUgaW5kaXZpZHVhbGx5IG5hbWVkXG4vLyBgUk5NYCBhbmQgYFVEVGAgb3BlcmF0b3JzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdGF0c0Z1bmMoKSB7XG4gIGNvbnN0IGlkID0gcmVxdWlyZSgnLi9pZGVudGlmaWVycycpO1xuICBjb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzJyk7XG4gIGNvbnN0IHN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuXG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdzdGF0cy5qczogJztcbiAgbGV0IHJ1bGVzID0gW107XG4gIGxldCB1ZHRzID0gW107XG4gIGNvbnN0IHN0YXRzID0gW107XG4gIGxldCB0b3RhbHM7XG4gIGNvbnN0IHJ1bGVTdGF0cyA9IFtdO1xuICBjb25zdCB1ZHRTdGF0cyA9IFtdO1xuICB0aGlzLnN0YXRzT2JqZWN0ID0gJ3N0YXRzT2JqZWN0JztcbiAgY29uc3QgbmFtZUlkID0gJ3N0YXRzJztcbiAgLyogYEFycmF5LnNvcnQoKWAgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNvcnRpbmcgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBhbHBoYWJldGljYWxseSBieSBuYW1lLiAqL1xuICBjb25zdCBzb3J0QWxwaGEgPSBmdW5jdGlvbiBzb3J0QWxwaGEobGhzLCByaHMpIHtcbiAgICBpZiAobGhzLmxvd2VyIDwgcmhzLmxvd2VyKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChsaHMubG93ZXIgPiByaHMubG93ZXIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgLyogYEFycmF5LnNvcnQoKWAgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNvcnRpbmcgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBieSBoaXQgY291bnQuICovXG4gIGNvbnN0IHNvcnRIaXRzID0gZnVuY3Rpb24gc29ydEhpdHMobGhzLCByaHMpIHtcbiAgICBpZiAobGhzLnRvdGFsIDwgcmhzLnRvdGFsKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGxocy50b3RhbCA+IHJocy50b3RhbCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gc29ydEFscGhhKGxocywgcmhzKTtcbiAgfTtcbiAgLyogYEFycmF5LnNvcnQoKWAgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNvcnRpbmcgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBieSBpbmRleCAqL1xuICAvKiAoaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyIGluIHRoZSBTQUJORiBncmFtbWFyKS4gKi9cbiAgY29uc3Qgc29ydEluZGV4ID0gZnVuY3Rpb24gc29ydEluZGV4KGxocywgcmhzKSB7XG4gICAgaWYgKGxocy5pbmRleCA8IHJocy5pbmRleCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAobGhzLmluZGV4ID4gcmhzLmluZGV4KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIGNvbnN0IEVtcHR5U3RhdCA9IGZ1bmN0aW9uIEVtcHR5U3RhdCgpIHtcbiAgICB0aGlzLmVtcHR5ID0gMDtcbiAgICB0aGlzLm1hdGNoID0gMDtcbiAgICB0aGlzLm5vbWF0Y2ggPSAwO1xuICAgIHRoaXMudG90YWwgPSAwO1xuICB9O1xuICAvKiBaZXJvIG91dCBhbGwgc3RhdHMgKi9cbiAgY29uc3QgY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBzdGF0cy5sZW5ndGggPSAwO1xuICAgIHRvdGFscyA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5BTFRdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkNBVF0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuUkVQXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5STk1dID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLlRSR10gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuVEJTXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5UTFNdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLlVEVF0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQU5EXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5OT1RdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkJLUl0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQktBXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5CS05dID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkFCR10gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQUVOXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBydWxlU3RhdHMubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBydWxlU3RhdHMucHVzaCh7XG4gICAgICAgIGVtcHR5OiAwLFxuICAgICAgICBtYXRjaDogMCxcbiAgICAgICAgbm9tYXRjaDogMCxcbiAgICAgICAgdG90YWw6IDAsXG4gICAgICAgIG5hbWU6IHJ1bGVzW2ldLm5hbWUsXG4gICAgICAgIGxvd2VyOiBydWxlc1tpXS5sb3dlcixcbiAgICAgICAgaW5kZXg6IHJ1bGVzW2ldLmluZGV4LFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVkdFN0YXRzLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdWR0U3RhdHMucHVzaCh7XG4gICAgICAgICAgZW1wdHk6IDAsXG4gICAgICAgICAgbWF0Y2g6IDAsXG4gICAgICAgICAgbm9tYXRjaDogMCxcbiAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICBuYW1lOiB1ZHRzW2ldLm5hbWUsXG4gICAgICAgICAgbG93ZXI6IHVkdHNbaV0ubG93ZXIsXG4gICAgICAgICAgaW5kZXg6IHVkdHNbaV0uaW5kZXgsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogaW5jcmVtZW50IHRoZSBkZXNpZ25hdGVkIG9wZXJhdG9yIGhpdCBjb3VudCBieSBvbmUgKi9cbiAgY29uc3QgaW5jU3RhdCA9IGZ1bmN0aW9uIGluY1N0YXQoc3RhdCwgc3RhdGUpIHtcbiAgICBzdGF0LnRvdGFsICs9IDE7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgc3RhdC5lbXB0eSArPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHN0YXQubWF0Y2ggKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN0YXQubm9tYXRjaCArPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y29sbGVjdCgpOiBpbmNTdGF0KCk6IHVucmVjb2duaXplZCBzdGF0ZTogJHtzdGF0ZX1gKTtcbiAgICB9XG4gIH07XG4gIC8qIGhlbHBlciBmb3IgdG9IdG1sKCkgKi9cbiAgY29uc3QgZGlzcGxheVJvdyA9IGZ1bmN0aW9uIGRpc3BsYXlSb3cobmFtZSwgc3RhdCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaHRtbCArPSAnPHRyPic7XG4gICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHtuYW1lfTwvdGQ+YDtcbiAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiR7c3RhdC5lbXB0eX08L3RkPmA7XG4gICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj4ke3N0YXQubWF0Y2h9PC90ZD5gO1xuICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4ke3N0YXQubm9tYXRjaH08L3RkPmA7XG4gICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHtzdGF0LnRvdGFsfTwvdGQ+YDtcbiAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIGNvbnN0IGRpc3BsYXlPcHNPbmx5ID0gZnVuY3Rpb24gZGlzcGxheU9wc09ubHkoKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0FMVCcsIHN0YXRzW2lkLkFMVF0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQ0FUJywgc3RhdHNbaWQuQ0FUXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdSRVAnLCBzdGF0c1tpZC5SRVBdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ1JOTScsIHN0YXRzW2lkLlJOTV0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnVFJHJywgc3RhdHNbaWQuVFJHXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdUQlMnLCBzdGF0c1tpZC5UQlNdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ1RMUycsIHN0YXRzW2lkLlRMU10pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnVURUJywgc3RhdHNbaWQuVURUXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdBTkQnLCBzdGF0c1tpZC5BTkRdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ05PVCcsIHN0YXRzW2lkLk5PVF0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQktSJywgc3RhdHNbaWQuQktSXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdCS0EnLCBzdGF0c1tpZC5CS0FdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0JLTicsIHN0YXRzW2lkLkJLTl0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQUJHJywgc3RhdHNbaWQuQUJHXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdBRU4nLCBzdGF0c1tpZC5BRU5dKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ3RvdGFscycsIHRvdGFscyk7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGhlbHBlciBmb3IgdG9IdG1sKCkgKi9cbiAgY29uc3QgZGlzcGxheVJ1bGVzID0gZnVuY3Rpb24gZGlzcGxheVJ1bGVzKCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaHRtbCArPSAnPHRyPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjwvdHI+XFxuJztcbiAgICBodG1sICs9ICc8dHI+PHRoPnJ1bGVzPC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48L3RyPlxcbic7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHJ1bGVTdGF0c1tpXS50b3RhbCA+IDApIHtcbiAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiR7cnVsZVN0YXRzW2ldLm5hbWV9PC90ZD5gO1xuICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiR7cnVsZVN0YXRzW2ldLmVtcHR5fTwvdGQ+YDtcbiAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj4ke3J1bGVTdGF0c1tpXS5tYXRjaH08L3RkPmA7XG4gICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4ke3J1bGVTdGF0c1tpXS5ub21hdGNofTwvdGQ+YDtcbiAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHtydWxlU3RhdHNbaV0udG90YWx9PC90ZD5gO1xuICAgICAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1ZHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGh0bWwgKz0gJzx0cj48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48L3RyPlxcbic7XG4gICAgICBodG1sICs9ICc8dHI+PHRoPnVkdHM8L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjx0aD48L3RoPjwvdHI+XFxuJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWR0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodWR0U3RhdHNbaV0udG90YWwgPiAwKSB7XG4gICAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHt1ZHRTdGF0c1tpXS5uYW1lfTwvdGQ+YDtcbiAgICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiR7dWR0U3RhdHNbaV0uZW1wdHl9PC90ZD5gO1xuICAgICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+JHt1ZHRTdGF0c1tpXS5tYXRjaH08L3RkPmA7XG4gICAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPiR7dWR0U3RhdHNbaV0ubm9tYXRjaH08L3RkPmA7XG4gICAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+JHt1ZHRTdGF0c1tpXS50b3RhbH08L3RkPmA7XG4gICAgICAgICAgaHRtbCArPSAnPC90cj5cXG4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBjYWxsZWQgb25seSBieSB0aGUgcGFyc2VyIHRvIHZhbGlkYXRlIGEgc3RhdHMgb2JqZWN0ICovXG4gIHRoaXMudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShuYW1lKSB7XG4gICAgbGV0IHJldCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgbmFtZUlkID09PSBuYW1lKSB7XG4gICAgICByZXQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICAvKiBubyB2ZXJpZmljYXRpb24gb2YgaW5wdXQgLSBvbmx5IGNhbGxlZCBieSBwYXJzZXIoKSAqL1xuICB0aGlzLmluaXQgPSBmdW5jdGlvbiBpbml0KGlucHV0UnVsZXMsIGlucHV0VWR0cykge1xuICAgIHJ1bGVzID0gaW5wdXRSdWxlcztcbiAgICB1ZHRzID0gaW5wdXRVZHRzO1xuICAgIGNsZWFyKCk7XG4gIH07XG4gIC8qIFRoaXMgZnVuY3Rpb24gaXMgdGhlIG1haW4gaW50ZXJhY3Rpb24gd2l0aCB0aGUgcGFyc2VyLiAqL1xuICAvKiBUaGUgcGFyc2VyIGNhbGxzIGl0IGFmdGVyIGVhY2ggbm9kZSBoYXMgYmVlbiB0cmF2ZXJzZWQuICovXG4gIHRoaXMuY29sbGVjdCA9IGZ1bmN0aW9uIGNvbGxlY3Qob3AsIHJlc3VsdCkge1xuICAgIGluY1N0YXQodG90YWxzLCByZXN1bHQuc3RhdGUsIHJlc3VsdC5waHJhc2VMZW5ndGgpO1xuICAgIGluY1N0YXQoc3RhdHNbb3AudHlwZV0sIHJlc3VsdC5zdGF0ZSwgcmVzdWx0LnBocmFzZUxlbmd0aCk7XG4gICAgaWYgKG9wLnR5cGUgPT09IGlkLlJOTSkge1xuICAgICAgaW5jU3RhdChydWxlU3RhdHNbb3AuaW5kZXhdLCByZXN1bHQuc3RhdGUsIHJlc3VsdC5waHJhc2VMZW5ndGgpO1xuICAgIH1cbiAgICBpZiAob3AudHlwZSA9PT0gaWQuVURUKSB7XG4gICAgICBpbmNTdGF0KHVkdFN0YXRzW29wLmluZGV4XSwgcmVzdWx0LnN0YXRlLCByZXN1bHQucGhyYXNlTGVuZ3RoKTtcbiAgICB9XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHN0YXRpc3RpY3MgYXMgYW4gSFRNTCB0YWJsZS5cbiAgLy8gLSAqdHlwZSpcbiAgLy8gICAtIFwib3BzXCIgLSAoZGVmYXVsdCkgZGlzcGxheSBvbmx5IHRoZSB0b3RhbCBoaXQgY291bnRzIGZvciBhbGwgb3BlcmF0b3IgdHlwZXMuXG4gIC8vICAgLSBcImluZGV4XCIgLSBhZGRpdGlvbmFsbHksIGRpc3BsYXkgdGhlIGhpdCBjb3VudHMgZm9yIHRoZSBpbmRpdmlkdWFsIGBSTk1gIGFuZCBgVURUYCBvcGVyYXRvcnMgb3JkZXJlZCBieSBpbmRleC5cbiAgLy8gICAtIFwiaGl0c1wiIC0gYWRkaXRpb25hbGx5LCBkaXNwbGF5IHRoZSBoaXQgY291bnRzIGZvciB0aGUgaW5kaXZpZHVhbCBgUk5NYCBhbmQgYFVEVGAgb3BlcmF0b3JzIGJ5IGhpdCBjb3VudC5cbiAgLy8gICAtIFwiYWxwaGFcIiAtIGFkZGl0aW9uYWxseSwgZGlzcGxheSB0aGUgaGl0IGNvdW50cyBmb3IgdGhlIGluZGl2aWR1YWwgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBieSBuYW1lIGFscGhhYmV0aWNhbGx5LlxuICAvLyAtICpjYXB0aW9uKiAtIG9wdGlvbmFsIGNhcHRpb24gZm9yIHRoZSB0YWJsZVxuICB0aGlzLnRvSHRtbCA9IGZ1bmN0aW9uIHRvSHRtbCh0eXBlLCBjYXB0aW9uKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9IGA8dGFibGUgY2xhc3M9XCIke3N0eWxlLkNMQVNTX1NUQVRTfVwiPlxcbmA7XG4gICAgaWYgKHR5cGVvZiBjYXB0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgaHRtbCArPSBgPGNhcHRpb24+JHtjYXB0aW9ufTwvY2FwdGlvbj5cXG5gO1xuICAgIH1cbiAgICBodG1sICs9IGA8dHI+PHRoIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+b3BzPC90aD5cXG5gO1xuICAgIGh0bWwgKz0gYDx0aCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+RU1QVFk8L3RoPlxcbmA7XG4gICAgaHRtbCArPSBgPHRoIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj5NQVRDSDwvdGg+XFxuYDtcbiAgICBodG1sICs9IGA8dGggY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+Tk9NQVRDSDwvdGg+XFxuYDtcbiAgICBodG1sICs9IGA8dGggY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj50b3RhbHM8L3RoPjwvdHI+XFxuYDtcbiAgICBjb25zdCB0ZXN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAodGVzdCkge1xuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnb3BzJykge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdpbmRleCcpIHtcbiAgICAgICAgcnVsZVN0YXRzLnNvcnQoc29ydEluZGV4KTtcbiAgICAgICAgaWYgKHVkdFN0YXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1ZHRTdGF0cy5zb3J0KHNvcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBodG1sICs9IGRpc3BsYXlSdWxlcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnaGl0cycpIHtcbiAgICAgICAgcnVsZVN0YXRzLnNvcnQoc29ydEhpdHMpO1xuICAgICAgICBpZiAodWR0U3RhdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVkdFN0YXRzLnNvcnQoc29ydEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9IGRpc3BsYXlPcHNPbmx5KCk7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheVJ1bGVzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdhbHBoYScpIHtcbiAgICAgICAgcnVsZVN0YXRzLnNvcnQoc29ydEFscGhhKTtcbiAgICAgICAgaWYgKHVkdFN0YXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1ZHRTdGF0cy5zb3J0KHNvcnRBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBodG1sICs9IGRpc3BsYXlSdWxlcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBodG1sICs9ICc8L3RhYmxlPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHN0YXRzIHRhYmxlIGluIGEgY29tcGxldGUgSFRNTDUgcGFnZS5cbiAgdGhpcy50b0h0bWxQYWdlID0gZnVuY3Rpb24gdG9IdG1sUGFnZSh0eXBlLCBjYXB0aW9uLCB0aXRsZSkge1xuICAgIHJldHVybiB1dGlscy5odG1sVG9QYWdlKHRoaXMudG9IdG1sKHR5cGUsIGNhcHRpb24pLCB0aXRsZSk7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJzdGF0c0Z1bmMiLCJpZCIsInJlcXVpcmUiLCJ1dGlscyIsInN0eWxlIiwidGhpc0ZpbGVOYW1lIiwicnVsZXMiLCJ1ZHRzIiwic3RhdHMiLCJ0b3RhbHMiLCJydWxlU3RhdHMiLCJ1ZHRTdGF0cyIsInN0YXRzT2JqZWN0IiwibmFtZUlkIiwic29ydEFscGhhIiwibGhzIiwicmhzIiwibG93ZXIiLCJzb3J0SGl0cyIsInRvdGFsIiwic29ydEluZGV4IiwiaW5kZXgiLCJFbXB0eVN0YXQiLCJlbXB0eSIsIm1hdGNoIiwibm9tYXRjaCIsImNsZWFyIiwibGVuZ3RoIiwiQUxUIiwiQ0FUIiwiUkVQIiwiUk5NIiwiVFJHIiwiVEJTIiwiVExTIiwiVURUIiwiQU5EIiwiTk9UIiwiQktSIiwiQktBIiwiQktOIiwiQUJHIiwiQUVOIiwiaSIsInB1c2giLCJuYW1lIiwiaW5jU3RhdCIsInN0YXQiLCJzdGF0ZSIsIkVNUFRZIiwiTUFUQ0giLCJOT01BVENIIiwiRXJyb3IiLCJkaXNwbGF5Um93IiwiaHRtbCIsIkNMQVNTX0FDVElWRSIsIkNMQVNTX0VNUFRZIiwiQ0xBU1NfTUFUQ0giLCJDTEFTU19OT01BVENIIiwiZGlzcGxheU9wc09ubHkiLCJkaXNwbGF5UnVsZXMiLCJ2YWxpZGF0ZSIsInJldCIsImluaXQiLCJpbnB1dFJ1bGVzIiwiaW5wdXRVZHRzIiwiY29sbGVjdCIsIm9wIiwicmVzdWx0IiwicGhyYXNlTGVuZ3RoIiwidHlwZSIsInRvSHRtbCIsImNhcHRpb24iLCJDTEFTU19TVEFUUyIsInRlc3QiLCJ1bmRlZmluZWQiLCJzb3J0IiwidG9IdG1sUGFnZSIsInRpdGxlIiwiaHRtbFRvUGFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/stats.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    // Generated by apglib/style.js \n    CLASS_MONOSPACE: \"apg-mono\",\n    CLASS_ACTIVE: \"apg-active\",\n    CLASS_EMPTY: \"apg-empty\",\n    CLASS_MATCH: \"apg-match\",\n    CLASS_NOMATCH: \"apg-nomatch\",\n    CLASS_LOOKAHEAD: \"apg-lh-match\",\n    CLASS_LOOKBEHIND: \"apg-lb-match\",\n    CLASS_REMAINDER: \"apg-remainder\",\n    CLASS_CTRLCHAR: \"apg-ctrl-char\",\n    CLASS_LINEEND: \"apg-line-end\",\n    CLASS_ERROR: \"apg-error\",\n    CLASS_PHRASE: \"apg-phrase\",\n    CLASS_EMPTYPHRASE: \"apg-empty-phrase\",\n    CLASS_STATE: \"apg-state\",\n    CLASS_STATS: \"apg-stats\",\n    CLASS_TRACE: \"apg-trace\",\n    CLASS_GRAMMAR: \"apg-grammar\",\n    CLASS_RULES: \"apg-rules\",\n    CLASS_RULESLINK: \"apg-rules-link\",\n    CLASS_ATTRIBUTES: \"apg-attrs\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0eWxlLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsT0FBT0MsT0FBTyxHQUFHO0lBRWYsZ0NBQWdDO0lBQ2hDQyxpQkFBaUI7SUFDakJDLGNBQWM7SUFDZEMsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLGVBQWU7SUFDZkMsaUJBQWlCO0lBQ2pCQyxrQkFBa0I7SUFDbEJDLGlCQUFpQjtJQUNqQkMsZ0JBQWdCO0lBQ2hCQyxlQUFlO0lBQ2ZDLGFBQWE7SUFDYkMsY0FBYztJQUNkQyxtQkFBbUI7SUFDbkJDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLGVBQWU7SUFDZkMsYUFBYTtJQUNiQyxpQkFBaUI7SUFDakJDLGtCQUFrQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0B0b2tlbnN0cmVhbS93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0eWxlLmpzP2ZkNDQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLy8gR2VuZXJhdGVkIGJ5IGFwZ2xpYi9zdHlsZS5qcyBcbiAgQ0xBU1NfTU9OT1NQQUNFOiAnYXBnLW1vbm8nLFxuICBDTEFTU19BQ1RJVkU6ICdhcGctYWN0aXZlJyxcbiAgQ0xBU1NfRU1QVFk6ICdhcGctZW1wdHknLFxuICBDTEFTU19NQVRDSDogJ2FwZy1tYXRjaCcsXG4gIENMQVNTX05PTUFUQ0g6ICdhcGctbm9tYXRjaCcsXG4gIENMQVNTX0xPT0tBSEVBRDogJ2FwZy1saC1tYXRjaCcsXG4gIENMQVNTX0xPT0tCRUhJTkQ6ICdhcGctbGItbWF0Y2gnLFxuICBDTEFTU19SRU1BSU5ERVI6ICdhcGctcmVtYWluZGVyJyxcbiAgQ0xBU1NfQ1RSTENIQVI6ICdhcGctY3RybC1jaGFyJyxcbiAgQ0xBU1NfTElORUVORDogJ2FwZy1saW5lLWVuZCcsXG4gIENMQVNTX0VSUk9SOiAnYXBnLWVycm9yJyxcbiAgQ0xBU1NfUEhSQVNFOiAnYXBnLXBocmFzZScsXG4gIENMQVNTX0VNUFRZUEhSQVNFOiAnYXBnLWVtcHR5LXBocmFzZScsXG4gIENMQVNTX1NUQVRFOiAnYXBnLXN0YXRlJyxcbiAgQ0xBU1NfU1RBVFM6ICdhcGctc3RhdHMnLFxuICBDTEFTU19UUkFDRTogJ2FwZy10cmFjZScsXG4gIENMQVNTX0dSQU1NQVI6ICdhcGctZ3JhbW1hcicsXG4gIENMQVNTX1JVTEVTOiAnYXBnLXJ1bGVzJyxcbiAgQ0xBU1NfUlVMRVNMSU5LOiAnYXBnLXJ1bGVzLWxpbmsnLFxuICBDTEFTU19BVFRSSUJVVEVTOiAnYXBnLWF0dHJzJyxcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiQ0xBU1NfTU9OT1NQQUNFIiwiQ0xBU1NfQUNUSVZFIiwiQ0xBU1NfRU1QVFkiLCJDTEFTU19NQVRDSCIsIkNMQVNTX05PTUFUQ0giLCJDTEFTU19MT09LQUhFQUQiLCJDTEFTU19MT09LQkVISU5EIiwiQ0xBU1NfUkVNQUlOREVSIiwiQ0xBU1NfQ1RSTENIQVIiLCJDTEFTU19MSU5FRU5EIiwiQ0xBU1NfRVJST1IiLCJDTEFTU19QSFJBU0UiLCJDTEFTU19FTVBUWVBIUkFTRSIsIkNMQVNTX1NUQVRFIiwiQ0xBU1NfU1RBVFMiLCJDTEFTU19UUkFDRSIsIkNMQVNTX0dSQU1NQVIiLCJDTEFTU19SVUxFUyIsIkNMQVNTX1JVTEVTTElOSyIsIkNMQVNTX0FUVFJJQlVURVMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/trace.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/trace.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint-disable func-names */ /* eslint-disable prefer-destructuring */ /* eslint-disable no-restricted-syntax */ /* eslint-disable guard-for-in */ /*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module provides a means of tracing the parser through the parse tree as it goes.\n// It is the primary debugging facility for debugging both the SABNF grammar syntax\n// and the input strings that are supposed to be valid grammar sentences.\n// It is also a very informative and educational tool for understanding\n// how a parser actually operates for a given language.\n//\n// Tracing is the process of generating and saving a record of information for each passage\n// of the parser through a parse tree node. And since it traverses each node twice, once down the tree\n// and once coming back up, there are two records for each node.\n// This, obviously, has the potential of generating lots of records.\n// And since these records are normally displayed on a web page\n// it is important to have a means to limit the actual number of records generated to\n// probably no more that a few thousand. This is almost always enough to find any errors.\n// The problem is to get the *right* few thousand records.\n// Therefore, this module has a number of ways of limiting and/or filtering, the number and type of records.\n// Considerable effort has been made to make this filtering of the trace output as simple\n// and intuitive as possible.\n//\n// However, the ability to filter the trace records, or for that matter even understand what they are\n// and the information they contain, does require a minimum amount of understanding of the APG parsing\n// method. The parse tree nodes are all represented by APG operators. They break down into two natural groups.\n// - The `RNM` operators and `UDT` operators are named phrases.\n// These are names chosen by the writer of the SABNF grammar to represent special phrases of interest.\n// - All others collect, concatenate and otherwise manipulate various intermediate phrases along the way.\n//\n// There are separate means of filtering which of these operators in each of these two groups get traced.\n// Let `trace` be an instantiated `trace.js` object.\n// Prior to parsing the string, filtering the rules and UDTs can be defined as follows:\n// ```\n// trace.filter.rules[\"rulename\"] = true;\n//     /* trace rule name \"rulename\" */\n// trace.filter.rules[\"udtname\"]  = true;\n//     /* trace UDT name \"udtname\" */\n// trace.filter.rules[\"<ALL>\"]    = true;\n//     /* trace all rules and UDTs (the default) */\n// trace.filter.rules[\"<NONE>\"]   = true;\n//     /* trace no rules or UDTS */\n// ```\n// If any rule or UDT name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of rule names, a filter statement is required for each rule/UDT name desired.\n//\n// Filtering of the other operators follows a similar procedure.\n// ```\n// trace.filter.operators[\"TRG\"] = true;\n//     /* trace the terminal range, TRG, operators */\n// trace.filter.operators[\"CAT\"]  = true;\n//     /* trace the concatenations, CAT, operators */\n// trace.filter.operators[\"<ALL>\"]    = true;\n//     /* trace all operators */\n// trace.filter.operators[\"<NONE>\"]   = true;\n//     /* trace no operators (the default) */\n// ```\n// If any operator name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of operator names, a filter statement is required for each name desired.\n//\n// There is, additionally, a means for limiting the total number of filtered or saved trace records.\n// See the function, `setMaxRecords(max)` below. This will result in only the last `max` records being saved.\n//\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js-examples) for examples of using `trace.js`.)\n\nmodule.exports = function exportTrace() {\n    const utils = __webpack_require__(/*! ./utilities */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\");\n    const style = __webpack_require__(/*! ./style */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js\");\n    const circular = new (__webpack_require__(/*! ./circular-buffer */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/circular-buffer.js\"))();\n    const id = __webpack_require__(/*! ./identifiers */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\n    const thisFileName = \"trace.js: \";\n    const that = this;\n    const MODE_HEX = 16;\n    const MODE_DEC = 10;\n    const MODE_ASCII = 8;\n    const MODE_UNICODE = 32;\n    const MAX_PHRASE = 80;\n    const MAX_TLS = 5;\n    const records = [];\n    let maxRecords = 5000;\n    let lastRecord = -1;\n    let filteredRecords = 0;\n    let treeDepth = 0;\n    const recordStack = [];\n    let chars = null;\n    let rules = null;\n    let udts = null;\n    const operatorFilter = [];\n    const ruleFilter = [];\n    /* special trace table phrases */ const PHRASE_END = `<span class=\"${style.CLASS_LINEEND}\">&bull;</span>`;\n    const PHRASE_CONTINUE = `<span class=\"${style.CLASS_LINEEND}\">&hellip;</span>`;\n    const PHRASE_EMPTY = `<span class=\"${style.CLASS_EMPTY}\">&#120634;</span>`;\n    /* filter the non-RNM & non-UDT operators */ const initOperatorFilter = function() {\n        const setOperators = function(set) {\n            operatorFilter[id.ALT] = set;\n            operatorFilter[id.CAT] = set;\n            operatorFilter[id.REP] = set;\n            operatorFilter[id.TLS] = set;\n            operatorFilter[id.TBS] = set;\n            operatorFilter[id.TRG] = set;\n            operatorFilter[id.AND] = set;\n            operatorFilter[id.NOT] = set;\n            operatorFilter[id.BKR] = set;\n            operatorFilter[id.BKA] = set;\n            operatorFilter[id.BKN] = set;\n            operatorFilter[id.ABG] = set;\n            operatorFilter[id.AEN] = set;\n        };\n        let items = 0;\n        // eslint-disable-next-line no-unused-vars\n        for(const name in that.filter.operators){\n            items += 1;\n        }\n        if (items === 0) {\n            /* case 1: no operators specified: default: do not trace any operators */ setOperators(false);\n            return;\n        }\n        for(const name in that.filter.operators){\n            const upper = name.toUpperCase();\n            if (upper === \"<ALL>\") {\n                /* case 2: <all> operators specified: trace all operators ignore all other operator commands */ setOperators(true);\n                return;\n            }\n            if (upper === \"<NONE>\") {\n                /* case 3: <none> operators specified: trace NO operators ignore all other operator commands */ setOperators(false);\n                return;\n            }\n        }\n        setOperators(false);\n        for(const name in that.filter.operators){\n            const upper = name.toUpperCase();\n            /* case 4: one or more individual operators specified: trace 'true' operators only */ if (upper === \"ALT\") {\n                operatorFilter[id.ALT] = that.filter.operators[name] === true;\n            } else if (upper === \"CAT\") {\n                operatorFilter[id.CAT] = that.filter.operators[name] === true;\n            } else if (upper === \"REP\") {\n                operatorFilter[id.REP] = that.filter.operators[name] === true;\n            } else if (upper === \"AND\") {\n                operatorFilter[id.AND] = that.filter.operators[name] === true;\n            } else if (upper === \"NOT\") {\n                operatorFilter[id.NOT] = that.filter.operators[name] === true;\n            } else if (upper === \"TLS\") {\n                operatorFilter[id.TLS] = that.filter.operators[name] === true;\n            } else if (upper === \"TBS\") {\n                operatorFilter[id.TBS] = that.filter.operators[name] === true;\n            } else if (upper === \"TRG\") {\n                operatorFilter[id.TRG] = that.filter.operators[name] === true;\n            } else if (upper === \"BKR\") {\n                operatorFilter[id.BKR] = that.filter.operators[name] === true;\n            } else if (upper === \"BKA\") {\n                operatorFilter[id.BKA] = that.filter.operators[name] === true;\n            } else if (upper === \"BKN\") {\n                operatorFilter[id.BKN] = that.filter.operators[name] === true;\n            } else if (upper === \"ABG\") {\n                operatorFilter[id.ABG] = that.filter.operators[name] === true;\n            } else if (upper === \"AEN\") {\n                operatorFilter[id.AEN] = that.filter.operators[name] === true;\n            } else {\n                throw new Error(`${thisFileName}initOpratorFilter: '${name}' not a valid operator name.` + ` Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`);\n            }\n        }\n    };\n    /* filter the rule and `UDT` named operators */ const initRuleFilter = function() {\n        const setRules = function(set) {\n            operatorFilter[id.RNM] = set;\n            operatorFilter[id.UDT] = set;\n            const count = rules.length + udts.length;\n            ruleFilter.length = 0;\n            for(let i = 0; i < count; i += 1){\n                ruleFilter.push(set);\n            }\n        };\n        let items;\n        let i;\n        const list = [];\n        for(i = 0; i < rules.length; i += 1){\n            list.push(rules[i].lower);\n        }\n        for(i = 0; i < udts.length; i += 1){\n            list.push(udts[i].lower);\n        }\n        ruleFilter.length = 0;\n        items = 0;\n        // eslint-disable-next-line no-unused-vars\n        for(const name in that.filter.rules){\n            items += 1;\n        }\n        if (items === 0) {\n            /* case 1: default to all rules & udts */ setRules(true);\n            return;\n        }\n        for(const name in that.filter.rules){\n            const lower = name.toLowerCase();\n            if (lower === \"<all>\") {\n                /* case 2: trace all rules ignore all other rule commands */ setRules(true);\n                return;\n            }\n            if (lower === \"<none>\") {\n                /* case 3: trace no rules */ setRules(false);\n                return;\n            }\n        }\n        /* case 4: trace only individually specified rules */ setRules(false);\n        operatorFilter[id.RNM] = true;\n        operatorFilter[id.UDT] = true;\n        for(const name in that.filter.rules){\n            const lower = name.toLowerCase();\n            i = list.indexOf(lower);\n            if (i < 0) {\n                throw new Error(`${thisFileName}initRuleFilter: '${name}' not a valid rule or udt name`);\n            }\n            ruleFilter[i] = that.filter.rules[name] === true;\n        }\n    };\n    /* used by other APG components to verify that they have a valid trace object */ this.traceObject = \"traceObject\";\n    this.filter = {\n        operators: [],\n        rules: []\n    };\n    // Set the maximum number of records to keep (default = 5000).\n    // Each record number larger than `maxRecords`\n    // will result in deleting the previously oldest record.\n    // - `max`: maximum number of records to retain (default = 5000)\n    // - `last`: last record number to retain, (default = -1 for (unknown) actual last record)\n    this.setMaxRecords = function(max, last) {\n        lastRecord = -1;\n        if (typeof max === \"number\" && max > 0) {\n            maxRecords = Math.ceil(max);\n        } else {\n            maxRecords = 0;\n            return;\n        }\n        if (typeof last === \"number\") {\n            lastRecord = Math.floor(last);\n            if (lastRecord < 0) {\n                lastRecord = -1;\n            }\n        }\n    };\n    // Returns `maxRecords` to the caller.\n    this.getMaxRecords = function() {\n        return maxRecords;\n    };\n    // Returns `lastRecord` to the caller.\n    this.getLastRecord = function() {\n        return lastRecord;\n    };\n    /* Called only by the `parser.js` object. No verification of input. */ this.init = function(rulesIn, udtsIn, charsIn) {\n        records.length = 0;\n        recordStack.length = 0;\n        filteredRecords = 0;\n        treeDepth = 0;\n        chars = charsIn;\n        rules = rulesIn;\n        udts = udtsIn;\n        initOperatorFilter();\n        initRuleFilter();\n        circular.init(maxRecords);\n    };\n    /* returns true if this records passes through the designated filter, false if the record is to be skipped */ const filterOps = function(op) {\n        let ret = false;\n        if (op.type === id.RNM) {\n            if (operatorFilter[op.type] && ruleFilter[op.index]) {\n                ret = true;\n            } else {\n                ret = false;\n            }\n        } else if (op.type === id.UDT) {\n            if (operatorFilter[op.type] && ruleFilter[rules.length + op.index]) {\n                ret = true;\n            } else {\n                ret = false;\n            }\n        } else {\n            ret = operatorFilter[op.type];\n        }\n        return ret;\n    };\n    const filterRecords = function(record) {\n        if (lastRecord === -1) {\n            return true;\n        }\n        if (record <= lastRecord) {\n            return true;\n        }\n        return false;\n    };\n    /* Collect the \"down\" record. */ this.down = function(op, state, offset, length, anchor, lookAround) {\n        if (filterRecords(filteredRecords) && filterOps(op)) {\n            recordStack.push(filteredRecords);\n            records[circular.increment()] = {\n                dirUp: false,\n                depth: treeDepth,\n                thisLine: filteredRecords,\n                thatLine: undefined,\n                opcode: op,\n                state,\n                phraseIndex: offset,\n                phraseLength: length,\n                lookAnchor: anchor,\n                lookAround\n            };\n            filteredRecords += 1;\n            treeDepth += 1;\n        }\n    };\n    /* Collect the \"up\" record. */ this.up = function(op, state, offset, length, anchor, lookAround) {\n        if (filterRecords(filteredRecords) && filterOps(op)) {\n            const thisLine = filteredRecords;\n            const thatLine = recordStack.pop();\n            const thatRecord = circular.getListIndex(thatLine);\n            if (thatRecord !== -1) {\n                records[thatRecord].thatLine = thisLine;\n            }\n            treeDepth -= 1;\n            records[circular.increment()] = {\n                dirUp: true,\n                depth: treeDepth,\n                thisLine,\n                thatLine,\n                opcode: op,\n                state,\n                phraseIndex: offset,\n                phraseLength: length,\n                lookAnchor: anchor,\n                lookAround\n            };\n            filteredRecords += 1;\n        }\n    };\n    /* convert the trace records to a tree of nodes */ const toTreeObj = function() {\n        /* private helper functions */ function nodeOpcode(node, opcode) {\n            let name;\n            let casetype;\n            let modetype;\n            if (opcode) {\n                node.op = {\n                    id: opcode.type,\n                    name: utils.opcodeToString(opcode.type)\n                };\n                node.opData = undefined;\n                switch(opcode.type){\n                    case id.RNM:\n                        node.opData = rules[opcode.index].name;\n                        break;\n                    case id.UDT:\n                        node.opData = udts[opcode.index].name;\n                        break;\n                    case id.BKR:\n                        if (opcode.index < rules.length) {\n                            name = rules[opcode.index].name;\n                        } else {\n                            name = udts[opcode.index - rules.length].name;\n                        }\n                        casetype = opcode.bkrCase === id.BKR_MODE_CI ? \"%i\" : \"%s\";\n                        modetype = opcode.bkrMode === id.BKR_MODE_UM ? \"%u\" : \"%p\";\n                        node.opData = `\\\\\\\\${casetype}${modetype}${name}`;\n                        break;\n                    case id.TLS:\n                        node.opData = [];\n                        for(let i = 0; i < opcode.string.length; i += 1){\n                            node.opData.push(opcode.string[i]);\n                        }\n                        break;\n                    case id.TBS:\n                        node.opData = [];\n                        for(let i = 0; i < opcode.string.length; i += 1){\n                            node.opData.push(opcode.string[i]);\n                        }\n                        break;\n                    case id.TRG:\n                        node.opData = [\n                            opcode.min,\n                            opcode.max\n                        ];\n                        break;\n                    case id.REP:\n                        node.opData = [\n                            opcode.min,\n                            opcode.max\n                        ];\n                        break;\n                    default:\n                        throw new Error(\"unrecognized opcode\");\n                }\n            } else {\n                node.op = {\n                    id: undefined,\n                    name: undefined\n                };\n                node.opData = undefined;\n            }\n        }\n        function nodePhrase(state, index, length) {\n            if (state === id.MATCH) {\n                return {\n                    index,\n                    length\n                };\n            }\n            if (state === id.NOMATCH) {\n                return {\n                    index,\n                    length: 0\n                };\n            }\n            if (state === id.EMPTY) {\n                return {\n                    index,\n                    length: 0\n                };\n            }\n            return null;\n        }\n        let nodeId = -1;\n        function nodeDown(parent, record, depth) {\n            const node = {\n                // eslint-disable-next-line no-plusplus\n                id: nodeId++,\n                branch: -1,\n                parent,\n                up: false,\n                down: false,\n                depth,\n                children: []\n            };\n            if (record) {\n                node.down = true;\n                node.state = {\n                    id: record.state,\n                    name: utils.stateToString(record.state)\n                };\n                node.phrase = null;\n                nodeOpcode(node, record.opcode);\n            } else {\n                node.state = {\n                    id: undefined,\n                    name: undefined\n                };\n                node.phrase = nodePhrase();\n                nodeOpcode(node, undefined);\n            }\n            return node;\n        }\n        function nodeUp(node, record) {\n            if (record) {\n                node.up = true;\n                node.state = {\n                    id: record.state,\n                    name: utils.stateToString(record.state)\n                };\n                node.phrase = nodePhrase(record.state, record.phraseIndex, record.phraseLength);\n                if (!node.down) {\n                    nodeOpcode(node, record.opcode);\n                }\n            }\n        }\n        /* walk the final tree: label branches and count leaf nodes */ let leafNodes = 0;\n        let depth = -1;\n        let branchCount = 1;\n        function walk(node) {\n            depth += 1;\n            node.branch = branchCount;\n            if (depth > treeDepth) {\n                treeDepth = depth;\n            }\n            if (node.children.length === 0) {\n                leafNodes += 1;\n            } else {\n                for(let i = 0; i < node.children.length; i += 1){\n                    if (i > 0) {\n                        branchCount += 1;\n                    }\n                    node.children[i].leftMost = false;\n                    node.children[i].rightMost = false;\n                    if (node.leftMost) {\n                        node.children[i].leftMost = i === 0;\n                    }\n                    if (node.rightMost) {\n                        node.children[i].rightMost = i === node.children.length - 1;\n                    }\n                    walk(node.children[i]);\n                }\n            }\n            depth -= 1;\n        }\n        function display(node, offset) {\n            let name;\n            const obj = {};\n            obj.id = node.id;\n            obj.branch = node.branch;\n            obj.leftMost = node.leftMost;\n            obj.rightMost = node.rightMost;\n            name = node.state.name ? node.state.name : \"ACTIVE\";\n            obj.state = {\n                id: node.state.id,\n                name\n            };\n            name = node.op.name ? node.op.name : \"?\";\n            obj.op = {\n                id: node.op.id,\n                name\n            };\n            if (typeof node.opData === \"string\") {\n                obj.opData = node.opData;\n            } else if (Array.isArray(node.opData)) {\n                obj.opData = [];\n                for(let i = 0; i < node.opData.length; i += 1){\n                    obj.opData[i] = node.opData[i];\n                }\n            } else {\n                obj.opData = undefined;\n            }\n            if (node.phrase) {\n                obj.phrase = {\n                    index: node.phrase.index,\n                    length: node.phrase.length\n                };\n            } else {\n                obj.phrase = null;\n            }\n            obj.depth = node.depth;\n            obj.children = [];\n            for(let i = 0; i < node.children.length; i += 1){\n                const c = i !== node.children.length - 1;\n                obj.children[i] = display(node.children[i], offset, c);\n            }\n            return obj;\n        }\n        /* construct the tree beginning here */ const branch = [];\n        let root;\n        let node;\n        let parent;\n        let record;\n        let firstRecord = true;\n        /* push a dummy node so the root node will have a non-null parent */ const dummy = nodeDown(null, null, -1);\n        branch.push(dummy);\n        node = dummy;\n        circular.forEach((lineIndex)=>{\n            record = records[lineIndex];\n            if (firstRecord) {\n                firstRecord = false;\n                if (record.depth > 0) {\n                    /* push some dummy nodes to fill in for missing records */ const num = record.dirUp ? record.depth + 1 : record.depth;\n                    for(let i = 0; i < num; i += 1){\n                        parent = node;\n                        node = nodeDown(node, null, i);\n                        branch.push(node);\n                        parent.children.push(node);\n                    }\n                }\n            }\n            if (record.dirUp) {\n                /* handle the next record up */ node = branch.pop();\n                nodeUp(node, record);\n                node = branch[branch.length - 1];\n            } else {\n                /* handle the next record down */ parent = node;\n                node = nodeDown(node, record, record.depth);\n                branch.push(node);\n                parent.children.push(node);\n            }\n        });\n        /* if not at root, walk it up to root */ while(branch.length > 1){\n            node = branch.pop();\n            nodeUp(node, null);\n        }\n        /* maybe redundant or paranoid tests: these should never happen */ if (dummy.children.length === 0) {\n            throw new Error(\"trace.toTree(): parse tree has no nodes\");\n        }\n        if (branch.length === 0) {\n            throw new Error(\"trace.toTree(): integrity check: dummy root node disappeared?\");\n        }\n        /* if no record for start rule: find the pseudo root node (first dummy node above a real node) */ root = dummy.children[0];\n        let prev = root;\n        while(root && !root.down && !root.up){\n            prev = root;\n            root = root.children[0];\n        }\n        root = prev;\n        /* walk the tree of nodes: label brances and count leaves */ root.leftMost = true;\n        root.rightMost = true;\n        walk(root);\n        root.branch = 0;\n        /* generate the exported object */ const obj = {};\n        obj.string = [];\n        for(let i = 0; i < chars.length; i += 1){\n            obj.string[i] = chars[i];\n        }\n        /* generate the exported rule names */ obj.rules = [];\n        for(let i = 0; i < rules.length; i += 1){\n            obj.rules[i] = rules[i].name;\n        }\n        /* generate the exported UDT names */ obj.udts = [];\n        for(let i = 0; i < udts.length; i += 1){\n            obj.udts[i] = udts[i].name;\n        }\n        /* generate the ids */ obj.id = {};\n        obj.id.ALT = {\n            id: id.ALT,\n            name: \"ALT\"\n        };\n        obj.id.CAT = {\n            id: id.CAT,\n            name: \"CAT\"\n        };\n        obj.id.REP = {\n            id: id.REP,\n            name: \"REP\"\n        };\n        obj.id.RNM = {\n            id: id.RNM,\n            name: \"RNM\"\n        };\n        obj.id.TLS = {\n            id: id.TLS,\n            name: \"TLS\"\n        };\n        obj.id.TBS = {\n            id: id.TBS,\n            name: \"TBS\"\n        };\n        obj.id.TRG = {\n            id: id.TRG,\n            name: \"TRG\"\n        };\n        obj.id.UDT = {\n            id: id.UDT,\n            name: \"UDT\"\n        };\n        obj.id.AND = {\n            id: id.AND,\n            name: \"AND\"\n        };\n        obj.id.NOT = {\n            id: id.NOT,\n            name: \"NOT\"\n        };\n        obj.id.BKR = {\n            id: id.BKR,\n            name: \"BKR\"\n        };\n        obj.id.BKA = {\n            id: id.BKA,\n            name: \"BKA\"\n        };\n        obj.id.BKN = {\n            id: id.BKN,\n            name: \"BKN\"\n        };\n        obj.id.ABG = {\n            id: id.ABG,\n            name: \"ABG\"\n        };\n        obj.id.AEN = {\n            id: id.AEN,\n            name: \"AEN\"\n        };\n        obj.id.ACTIVE = {\n            id: id.ACTIVE,\n            name: \"ACTIVE\"\n        };\n        obj.id.MATCH = {\n            id: id.MATCH,\n            name: \"MATCH\"\n        };\n        obj.id.EMPTY = {\n            id: id.EMPTY,\n            name: \"EMPTY\"\n        };\n        obj.id.NOMATCH = {\n            id: id.NOMATCH,\n            name: \"NOMATCH\"\n        };\n        /* generate the max tree depth */ obj.treeDepth = treeDepth;\n        /* generate the number of leaf nodes (branches) */ obj.leafNodes = leafNodes;\n        /* generate the types of the left- and right-most branches */ let branchesIncomplete;\n        if (root.down) {\n            if (root.up) {\n                branchesIncomplete = \"none\";\n            } else {\n                branchesIncomplete = \"right\";\n            }\n        } else if (root.up) {\n            branchesIncomplete = \"left\";\n        } else {\n            branchesIncomplete = \"both\";\n        }\n        obj.branchesIncomplete = branchesIncomplete;\n        obj.tree = display(root, root.depth, false);\n        return obj;\n    };\n    // Returns the trace records as JSON parse tree object.\n    // - stringify: if `true`, the object is 'stringified' before returning, otherwise, the object itself is returned.\n    this.toTree = function(stringify) {\n        const obj = toTreeObj();\n        if (stringify) {\n            return JSON.stringify(obj);\n        }\n        return obj;\n    };\n    // Translate the trace records to HTML format and create a complete HTML page for browser display.\n    this.toHtmlPage = function(mode, caption, title) {\n        return utils.htmlToPage(this.toHtml(mode, caption), title);\n    };\n    /* From here on down, these are just helper functions for `toHtml()`. */ const htmlHeader = function(mode, caption) {\n        /* open the page */ /* write the HTML5 header with table style */ /* open the <table> tag */ let modeName;\n        switch(mode){\n            case MODE_HEX:\n                modeName = \"hexadecimal\";\n                break;\n            case MODE_DEC:\n                modeName = \"decimal\";\n                break;\n            case MODE_ASCII:\n                modeName = \"ASCII\";\n                break;\n            case MODE_UNICODE:\n                modeName = \"UNICODE\";\n                break;\n            default:\n                throw new Error(`${thisFileName}htmlHeader: unrecognized mode: ${mode}`);\n        }\n        let header = \"\";\n        header += `<p>display mode: ${modeName}</p>\\n`;\n        header += `<table class=\"${style.CLASS_TRACE}\">\\n`;\n        if (typeof caption === \"string\") {\n            header += `<caption>${caption}</caption>`;\n        }\n        return header;\n    };\n    const htmlFooter = function() {\n        let footer = \"\";\n        /* close the </table> tag */ footer += \"</table>\\n\";\n        /* display a table legend */ footer += `<p class=\"${style.CLASS_MONOSPACE}\">legend:<br>\\n`;\n        footer += \"(a)&nbsp;-&nbsp;line number<br>\\n\";\n        footer += \"(b)&nbsp;-&nbsp;matching line number<br>\\n\";\n        footer += \"(c)&nbsp;-&nbsp;phrase offset<br>\\n\";\n        footer += \"(d)&nbsp;-&nbsp;phrase length<br>\\n\";\n        footer += \"(e)&nbsp;-&nbsp;tree depth<br>\\n\";\n        footer += \"(f)&nbsp;-&nbsp;operator state<br>\\n\";\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_ACTIVE}\">&darr;</span>&nbsp;&nbsp;phrase opened<br>\\n`;\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">&uarr;M</span> phrase matched<br>\\n`;\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span> empty phrase matched<br>\\n`;\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span> phrase not matched<br>\\n`;\n        footer += \"operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>\\n\";\n        footer += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${MAX_PHRASE} characters of the phrase being matched<br>\\n`;\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">matched characters</span><br>\\n`;\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKAHEAD}\">matched characters in look ahead mode</span><br>\\n`;\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKBEHIND}\">matched characters in look behind mode</span><br>\\n`;\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_REMAINDER}\">remainder characters(not yet examined by parser)</span><br>\\n`;\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_CTRLCHAR}\">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>\\n`;\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_EMPTY} empty string<br>\\n`;\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_END} end of input string<br>\\n`;\n        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_CONTINUE} input string display truncated<br>\\n`;\n        footer += \"</p>\\n\";\n        footer += `<p class=\"${style.CLASS_MONOSPACE}\">\\n`;\n        footer += \"<sup>&dagger;</sup>original ABNF operators:<br>\\n\";\n        footer += \"ALT - alternation<br>\\n\";\n        footer += \"CAT - concatenation<br>\\n\";\n        footer += \"REP - repetition<br>\\n\";\n        footer += \"RNM - rule name<br>\\n\";\n        footer += \"TRG - terminal range<br>\\n\";\n        footer += \"TLS - terminal literal string (case insensitive)<br>\\n\";\n        footer += \"TBS - terminal binary string (case sensitive)<br>\\n\";\n        footer += \"<br>\\n\";\n        footer += \"<sup>&Dagger;</sup>super set SABNF operators:<br>\\n\";\n        footer += \"UDT - user-defined terminal<br>\\n\";\n        footer += \"AND - positive look ahead<br>\\n\";\n        footer += \"NOT - negative look ahead<br>\\n\";\n        footer += \"BKA - positive look behind<br>\\n\";\n        footer += \"BKN - negative look behind<br>\\n\";\n        footer += \"BKR - back reference<br>\\n\";\n        footer += \"ABG - anchor - begin of input string<br>\\n\";\n        footer += \"AEN - anchor - end of input string<br>\\n\";\n        footer += \"</p>\\n\";\n        return footer;\n    };\n    this.indent = function(depth) {\n        let html = \"\";\n        for(let i = 0; i < depth; i += 1){\n            html += \".\";\n        }\n        return html;\n    };\n    /* format the TRG operator */ const displayTrg = function(mode, op) {\n        let html = \"\";\n        if (op.type === id.TRG) {\n            if (mode === MODE_HEX || mode === MODE_UNICODE) {\n                let hex = op.min.toString(16).toUpperCase();\n                if (hex.length % 2 !== 0) {\n                    hex = `0${hex}`;\n                }\n                html += mode === MODE_HEX ? \"%x\" : \"U+\";\n                html += hex;\n                hex = op.max.toString(16).toUpperCase();\n                if (hex.length % 2 !== 0) {\n                    hex = `0${hex}`;\n                }\n                html += `&ndash;${hex}`;\n            } else {\n                html = `%d${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n            }\n        }\n        return html;\n    };\n    /* format the REP operator */ const displayRep = function(mode, op) {\n        let html = \"\";\n        if (op.type === id.REP) {\n            if (mode === MODE_HEX) {\n                let hex = op.min.toString(16).toUpperCase();\n                if (hex.length % 2 !== 0) {\n                    hex = `0${hex}`;\n                }\n                html = `x${hex}`;\n                if (op.max < Infinity) {\n                    hex = op.max.toString(16).toUpperCase();\n                    if (hex.length % 2 !== 0) {\n                        hex = `0${hex}`;\n                    }\n                } else {\n                    hex = \"inf\";\n                }\n                html += `&ndash;${hex}`;\n            } else if (op.max < Infinity) {\n                html = `${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n            } else {\n                html = `${op.min.toString(10)}&ndash;inf`;\n            }\n        }\n        return html;\n    };\n    /* format the TBS operator */ const displayTbs = function(mode, op) {\n        let html = \"\";\n        if (op.type === id.TBS) {\n            const len = Math.min(op.string.length, MAX_TLS * 2);\n            if (mode === MODE_HEX || mode === MODE_UNICODE) {\n                html += mode === MODE_HEX ? \"%x\" : \"U+\";\n                for(let i = 0; i < len; i += 1){\n                    let hex;\n                    if (i > 0) {\n                        html += \".\";\n                    }\n                    hex = op.string[i].toString(16).toUpperCase();\n                    if (hex.length % 2 !== 0) {\n                        hex = `0${hex}`;\n                    }\n                    html += hex;\n                }\n            } else {\n                html = \"%d\";\n                for(let i = 0; i < len; i += 1){\n                    if (i > 0) {\n                        html += \".\";\n                    }\n                    html += op.string[i].toString(10);\n                }\n            }\n            if (len < op.string.length) {\n                html += PHRASE_CONTINUE;\n            }\n        }\n        return html;\n    };\n    /* format the TLS operator */ const displayTls = function(mode, op) {\n        let html = \"\";\n        if (op.type === id.TLS) {\n            const len = Math.min(op.string.length, MAX_TLS);\n            if (mode === MODE_HEX || mode === MODE_DEC) {\n                let charu;\n                let charl;\n                let base;\n                if (mode === MODE_HEX) {\n                    html = \"%x\";\n                    base = 16;\n                } else {\n                    html = \"%d\";\n                    base = 10;\n                }\n                for(let i = 0; i < len; i += 1){\n                    if (i > 0) {\n                        html += \".\";\n                    }\n                    charl = op.string[i];\n                    if (charl >= 97 && charl <= 122) {\n                        charu = charl - 32;\n                        html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n                    } else if (charl >= 65 && charl <= 90) {\n                        charu = charl;\n                        charl += 32;\n                        html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n                    } else {\n                        html += charl.toString(base).toUpperCase();\n                    }\n                }\n                if (len < op.string.length) {\n                    html += PHRASE_CONTINUE;\n                }\n            } else {\n                html = '\"';\n                for(let i = 0; i < len; i += 1){\n                    html += utils.asciiChars[op.string[i]];\n                }\n                if (len < op.string.length) {\n                    html += PHRASE_CONTINUE;\n                }\n                html += '\"';\n            }\n        }\n        return html;\n    };\n    const subPhrase = function(mode, charsArg, index, length, prev) {\n        if (length === 0) {\n            return \"\";\n        }\n        let phrase = \"\";\n        const comma = prev ? \",\" : \"\";\n        switch(mode){\n            case MODE_HEX:\n                phrase = comma + utils.charsToHex(charsArg, index, length);\n                break;\n            case MODE_DEC:\n                if (prev) {\n                    return `,${utils.charsToDec(charsArg, index, length)}`;\n                }\n                phrase = comma + utils.charsToDec(charsArg, index, length);\n                break;\n            case MODE_UNICODE:\n                phrase = utils.charsToUnicode(charsArg, index, length);\n                break;\n            case MODE_ASCII:\n            default:\n                phrase = utils.charsToAsciiHtml(charsArg, index, length);\n                break;\n        }\n        return phrase;\n    };\n    /* display phrases matched in look-behind mode */ const displayBehind = function(mode, charsArg, state, index, length, anchor) {\n        let html = \"\";\n        let beg1;\n        let len1;\n        let beg2;\n        let len2;\n        let lastchar = PHRASE_END;\n        const spanBehind = `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n        const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n        const spanend = \"</span>\";\n        let prev = false;\n        switch(state){\n            case id.EMPTY:\n                html += PHRASE_EMPTY;\n            /* // eslint-disable-next-line no-fallthrough */ case id.NOMATCH:\n            case id.MATCH:\n            case id.ACTIVE:\n                beg1 = index - length;\n                len1 = anchor - beg1;\n                beg2 = anchor;\n                len2 = charsArg.length - beg2;\n                break;\n            default:\n                throw new Error(\"unrecognized state\");\n        }\n        lastchar = PHRASE_END;\n        if (len1 > MAX_PHRASE) {\n            len1 = MAX_PHRASE;\n            lastchar = PHRASE_CONTINUE;\n            len2 = 0;\n        } else if (len1 + len2 > MAX_PHRASE) {\n            lastchar = PHRASE_CONTINUE;\n            len2 = MAX_PHRASE - len1;\n        }\n        if (len1 > 0) {\n            html += spanBehind;\n            html += subPhrase(mode, charsArg, beg1, len1, prev);\n            html += spanend;\n            prev = true;\n        }\n        if (len2 > 0) {\n            html += spanRemainder;\n            html += subPhrase(mode, charsArg, beg2, len2, prev);\n            html += spanend;\n        }\n        return html + lastchar;\n    };\n    const displayForward = function(mode, charsArg, state, index, length, spanAhead) {\n        let html = \"\";\n        let beg1;\n        let len1;\n        let beg2;\n        let len2;\n        let lastchar = PHRASE_END;\n        const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n        const spanend = \"</span>\";\n        let prev = false;\n        switch(state){\n            case id.EMPTY:\n                html += PHRASE_EMPTY;\n            /* // eslint-disable-next-line no-fallthrough */ case id.NOMATCH:\n            case id.ACTIVE:\n                beg1 = index;\n                len1 = 0;\n                beg2 = index;\n                len2 = charsArg.length - beg2;\n                break;\n            case id.MATCH:\n                beg1 = index;\n                len1 = length;\n                beg2 = index + len1;\n                len2 = charsArg.length - beg2;\n                break;\n            default:\n                throw new Error(\"unrecognized state\");\n        }\n        lastchar = PHRASE_END;\n        if (len1 > MAX_PHRASE) {\n            len1 = MAX_PHRASE;\n            lastchar = PHRASE_CONTINUE;\n            len2 = 0;\n        } else if (len1 + len2 > MAX_PHRASE) {\n            lastchar = PHRASE_CONTINUE;\n            len2 = MAX_PHRASE - len1;\n        }\n        if (len1 > 0) {\n            html += spanAhead;\n            html += subPhrase(mode, charsArg, beg1, len1, prev);\n            html += spanend;\n            prev = true;\n        }\n        if (len2 > 0) {\n            html += spanRemainder;\n            html += subPhrase(mode, charsArg, beg2, len2, prev);\n            html += spanend;\n        }\n        return html + lastchar;\n    };\n    /* display phrases matched in look-ahead mode */ const displayAhead = function(mode, charsArg, state, index, length) {\n        const spanAhead = `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n        return displayForward(mode, charsArg, state, index, length, spanAhead);\n    };\n    /* display phrases matched in normal parsing mode */ const displayNone = function(mode, charsArg, state, index, length) {\n        const spanAhead = `<span class=\"${style.CLASS_MATCH}\">`;\n        return displayForward(mode, charsArg, state, index, length, spanAhead);\n    };\n    /* Returns the filtered records, formatted as an HTML table. */ const htmlTable = function(mode) {\n        if (rules === null) {\n            return \"\";\n        }\n        let html = \"\";\n        let thisLine;\n        let thatLine;\n        let lookAhead;\n        let lookBehind;\n        let lookAround;\n        let anchor;\n        html += \"<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>\";\n        html += \"<th>operator</th><th>phrase</th></tr>\\n\";\n        circular.forEach((lineIndex)=>{\n            const line = records[lineIndex];\n            thisLine = line.thisLine;\n            thatLine = line.thatLine !== undefined ? line.thatLine : \"--\";\n            lookAhead = false;\n            lookBehind = false;\n            lookAround = false;\n            if (line.lookAround === id.LOOKAROUND_AHEAD) {\n                lookAhead = true;\n                lookAround = true;\n                anchor = line.lookAnchor;\n            }\n            if (line.opcode.type === id.AND || line.opcode.type === id.NOT) {\n                lookAhead = true;\n                lookAround = true;\n                anchor = line.phraseIndex;\n            }\n            if (line.lookAround === id.LOOKAROUND_BEHIND) {\n                lookBehind = true;\n                lookAround = true;\n                anchor = line.lookAnchor;\n            }\n            if (line.opcode.type === id.BKA || line.opcode.type === id.BKN) {\n                lookBehind = true;\n                lookAround = true;\n                anchor = line.phraseIndex;\n            }\n            html += \"<tr>\";\n            html += `<td>${thisLine}</td><td>${thatLine}</td>`;\n            html += `<td>${line.phraseIndex}</td>`;\n            html += `<td>${line.phraseLength}</td>`;\n            html += `<td>${line.depth}</td>`;\n            html += \"<td>\";\n            switch(line.state){\n                case id.ACTIVE:\n                    html += `<span class=\"${style.CLASS_ACTIVE}\">&darr;&nbsp;</span>`;\n                    break;\n                case id.MATCH:\n                    html += `<span class=\"${style.CLASS_MATCH}\">&uarr;M</span>`;\n                    break;\n                case id.NOMATCH:\n                    html += `<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span>`;\n                    break;\n                case id.EMPTY:\n                    html += `<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span>`;\n                    break;\n                default:\n                    html += `<span class=\"${style.CLASS_ACTIVE}\">--</span>`;\n                    break;\n            }\n            html += \"</td>\";\n            html += \"<td>\";\n            html += that.indent(line.depth);\n            if (lookAhead) {\n                html += `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n            } else if (lookBehind) {\n                html += `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n            }\n            html += utils.opcodeToString(line.opcode.type);\n            if (line.opcode.type === id.RNM) {\n                html += `(${rules[line.opcode.index].name}) `;\n            }\n            if (line.opcode.type === id.BKR) {\n                const casetype = line.opcode.bkrCase === id.BKR_MODE_CI ? \"%i\" : \"%s\";\n                const modetype = line.opcode.bkrMode === id.BKR_MODE_UM ? \"%u\" : \"%p\";\n                html += `(\\\\${casetype}${modetype}${rules[line.opcode.index].name}) `;\n            }\n            if (line.opcode.type === id.UDT) {\n                html += `(${udts[line.opcode.index].name}) `;\n            }\n            if (line.opcode.type === id.TRG) {\n                html += `(${displayTrg(mode, line.opcode)}) `;\n            }\n            if (line.opcode.type === id.TBS) {\n                html += `(${displayTbs(mode, line.opcode)}) `;\n            }\n            if (line.opcode.type === id.TLS) {\n                html += `(${displayTls(mode, line.opcode)}) `;\n            }\n            if (line.opcode.type === id.REP) {\n                html += `(${displayRep(mode, line.opcode)}) `;\n            }\n            if (lookAround) {\n                html += \"</span>\";\n            }\n            html += \"</td>\";\n            html += \"<td>\";\n            if (lookBehind) {\n                html += displayBehind(mode, chars, line.state, line.phraseIndex, line.phraseLength, anchor);\n            } else if (lookAhead) {\n                html += displayAhead(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n            } else {\n                html += displayNone(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n            }\n            html += \"</td></tr>\\n\";\n        });\n        html += \"<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>\";\n        html += \"<th>operator</th><th>phrase</th></tr>\\n\";\n        html += \"</table>\\n\";\n        return html;\n    };\n    // Translate the trace records to HTML format.\n    // - *modearg* - can be `\"ascii\"`, `\"decimal\"`, `\"hexadecimal\"` or `\"unicode\"`.\n    // Determines the format of the string character code display.\n    // - *caption* - optional caption for the HTML table.\n    this.toHtml = function(modearg, caption) {\n        /* writes the trace records as a table in a complete html page */ let mode = MODE_ASCII;\n        if (typeof modearg === \"string\" && modearg.length >= 3) {\n            const modein = modearg.toLowerCase().slice(0, 3);\n            if (modein === \"hex\") {\n                mode = MODE_HEX;\n            } else if (modein === \"dec\") {\n                mode = MODE_DEC;\n            } else if (modein === \"uni\") {\n                mode = MODE_UNICODE;\n            }\n        }\n        let html = \"\";\n        html += htmlHeader(mode, caption);\n        html += htmlTable(mode);\n        html += htmlFooter();\n        return html;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3RyYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLDZCQUE2QixHQUM3Qix1Q0FBdUMsR0FDdkMsdUNBQXVDLEdBQ3ZDLCtCQUErQixHQUMvQjs7O3VGQUd1RixHQUN2Rix3RkFBd0Y7QUFDeEYsbUZBQW1GO0FBQ25GLHlFQUF5RTtBQUN6RSx1RUFBdUU7QUFDdkUsdURBQXVEO0FBQ3ZELEVBQUU7QUFDRiwyRkFBMkY7QUFDM0Ysc0dBQXNHO0FBQ3RHLGdFQUFnRTtBQUNoRSxvRUFBb0U7QUFDcEUsK0RBQStEO0FBQy9ELHFGQUFxRjtBQUNyRix5RkFBeUY7QUFDekYsMERBQTBEO0FBQzFELDRHQUE0RztBQUM1Ryx5RkFBeUY7QUFDekYsNkJBQTZCO0FBQzdCLEVBQUU7QUFDRixxR0FBcUc7QUFDckcsc0dBQXNHO0FBQ3RHLDhHQUE4RztBQUM5RywrREFBK0Q7QUFDL0Qsc0dBQXNHO0FBQ3RHLHlHQUF5RztBQUN6RyxFQUFFO0FBQ0YseUdBQXlHO0FBQ3pHLG9EQUFvRDtBQUNwRCx1RkFBdUY7QUFDdkYsTUFBTTtBQUNOLHlDQUF5QztBQUN6Qyx1Q0FBdUM7QUFDdkMseUNBQXlDO0FBQ3pDLHFDQUFxQztBQUNyQyx5Q0FBeUM7QUFDekMsbURBQW1EO0FBQ25ELHlDQUF5QztBQUN6QyxtQ0FBbUM7QUFDbkMsTUFBTTtBQUNOLDZHQUE2RztBQUM3RywyR0FBMkc7QUFDM0csRUFBRTtBQUNGLGdFQUFnRTtBQUNoRSxNQUFNO0FBQ04sd0NBQXdDO0FBQ3hDLHFEQUFxRDtBQUNyRCx5Q0FBeUM7QUFDekMscURBQXFEO0FBQ3JELDZDQUE2QztBQUM3QyxnQ0FBZ0M7QUFDaEMsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3QyxNQUFNO0FBQ04sMEdBQTBHO0FBQzFHLHNHQUFzRztBQUN0RyxFQUFFO0FBQ0Ysb0dBQW9HO0FBQ3BHLDZHQUE2RztB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QUNwQmxDLFFBQVErQixhQUFhbkQsTUFBTXJJLE9BQU82TCxLQUFLM0gsS0FBSyxFQUFFMkgsS0FBS2hILFdBQVcsRUFBRWdILEtBQUsvRyxZQUFZO1lBQ25GLE9BQU87Z0JBQ0wyRSxRQUFRZ0MsWUFBWXBELE1BQU1ySSxPQUFPNkwsS0FBSzNILEtBQUssRUFBRTJILEtBQUtoSCxXQUFXLEVBQUVnSCxLQUFLL0csWUFBWTtZQUNsRjtZQUNBMkUsUUFBUTtRQUNWO1FBQ0FBLFFBQVE7UUFDUkEsUUFBUTtRQUNSQSxRQUFRO1FBQ1IsT0FBT0E7SUFDVDtJQUNBLDhDQUE4QztJQUM5QywrRUFBK0U7SUFDL0UsOERBQThEO0lBQzlELHFEQUFxRDtJQUNyRCxJQUFJLENBQUNoQixNQUFNLEdBQUcsU0FBVXVELE9BQU8sRUFBRTFELE9BQU87UUFDdEMsK0RBQStELEdBQy9ELElBQUlELE9BQU8vSTtRQUNYLElBQUksT0FBTzBNLFlBQVksWUFBWUEsUUFBUTFKLE1BQU0sSUFBSSxHQUFHO1lBQ3RELE1BQU0ySixTQUFTRCxRQUFRckosV0FBVyxHQUFHdUosS0FBSyxDQUFDLEdBQUc7WUFDOUMsSUFBSUQsV0FBVyxPQUFPO2dCQUNwQjVELE9BQU9qSjtZQUNULE9BQU8sSUFBSTZNLFdBQVcsT0FBTztnQkFDM0I1RCxPQUFPaEo7WUFDVCxPQUFPLElBQUk0TSxXQUFXLE9BQU87Z0JBQzNCNUQsT0FBTzlJO1lBQ1Q7UUFDRjtRQUNBLElBQUlrSyxPQUFPO1FBQ1hBLFFBQVFmLFdBQVdMLE1BQU1DO1FBQ3pCbUIsUUFBUWlDLFVBQVVyRDtRQUNsQm9CLFFBQVFYO1FBQ1IsT0FBT1c7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRva2Vuc3RyZWFtL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXBnLWpzQDQuMi4xL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvdHJhY2UuanM/ZDNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cbi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBtZWFucyBvZiB0cmFjaW5nIHRoZSBwYXJzZXIgdGhyb3VnaCB0aGUgcGFyc2UgdHJlZSBhcyBpdCBnb2VzLlxuLy8gSXQgaXMgdGhlIHByaW1hcnkgZGVidWdnaW5nIGZhY2lsaXR5IGZvciBkZWJ1Z2dpbmcgYm90aCB0aGUgU0FCTkYgZ3JhbW1hciBzeW50YXhcbi8vIGFuZCB0aGUgaW5wdXQgc3RyaW5ncyB0aGF0IGFyZSBzdXBwb3NlZCB0byBiZSB2YWxpZCBncmFtbWFyIHNlbnRlbmNlcy5cbi8vIEl0IGlzIGFsc28gYSB2ZXJ5IGluZm9ybWF0aXZlIGFuZCBlZHVjYXRpb25hbCB0b29sIGZvciB1bmRlcnN0YW5kaW5nXG4vLyBob3cgYSBwYXJzZXIgYWN0dWFsbHkgb3BlcmF0ZXMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UuXG4vL1xuLy8gVHJhY2luZyBpcyB0aGUgcHJvY2VzcyBvZiBnZW5lcmF0aW5nIGFuZCBzYXZpbmcgYSByZWNvcmQgb2YgaW5mb3JtYXRpb24gZm9yIGVhY2ggcGFzc2FnZVxuLy8gb2YgdGhlIHBhcnNlciB0aHJvdWdoIGEgcGFyc2UgdHJlZSBub2RlLiBBbmQgc2luY2UgaXQgdHJhdmVyc2VzIGVhY2ggbm9kZSB0d2ljZSwgb25jZSBkb3duIHRoZSB0cmVlXG4vLyBhbmQgb25jZSBjb21pbmcgYmFjayB1cCwgdGhlcmUgYXJlIHR3byByZWNvcmRzIGZvciBlYWNoIG5vZGUuXG4vLyBUaGlzLCBvYnZpb3VzbHksIGhhcyB0aGUgcG90ZW50aWFsIG9mIGdlbmVyYXRpbmcgbG90cyBvZiByZWNvcmRzLlxuLy8gQW5kIHNpbmNlIHRoZXNlIHJlY29yZHMgYXJlIG5vcm1hbGx5IGRpc3BsYXllZCBvbiBhIHdlYiBwYWdlXG4vLyBpdCBpcyBpbXBvcnRhbnQgdG8gaGF2ZSBhIG1lYW5zIHRvIGxpbWl0IHRoZSBhY3R1YWwgbnVtYmVyIG9mIHJlY29yZHMgZ2VuZXJhdGVkIHRvXG4vLyBwcm9iYWJseSBubyBtb3JlIHRoYXQgYSBmZXcgdGhvdXNhbmQuIFRoaXMgaXMgYWxtb3N0IGFsd2F5cyBlbm91Z2ggdG8gZmluZCBhbnkgZXJyb3JzLlxuLy8gVGhlIHByb2JsZW0gaXMgdG8gZ2V0IHRoZSAqcmlnaHQqIGZldyB0aG91c2FuZCByZWNvcmRzLlxuLy8gVGhlcmVmb3JlLCB0aGlzIG1vZHVsZSBoYXMgYSBudW1iZXIgb2Ygd2F5cyBvZiBsaW1pdGluZyBhbmQvb3IgZmlsdGVyaW5nLCB0aGUgbnVtYmVyIGFuZCB0eXBlIG9mIHJlY29yZHMuXG4vLyBDb25zaWRlcmFibGUgZWZmb3J0IGhhcyBiZWVuIG1hZGUgdG8gbWFrZSB0aGlzIGZpbHRlcmluZyBvZiB0aGUgdHJhY2Ugb3V0cHV0IGFzIHNpbXBsZVxuLy8gYW5kIGludHVpdGl2ZSBhcyBwb3NzaWJsZS5cbi8vXG4vLyBIb3dldmVyLCB0aGUgYWJpbGl0eSB0byBmaWx0ZXIgdGhlIHRyYWNlIHJlY29yZHMsIG9yIGZvciB0aGF0IG1hdHRlciBldmVuIHVuZGVyc3RhbmQgd2hhdCB0aGV5IGFyZVxuLy8gYW5kIHRoZSBpbmZvcm1hdGlvbiB0aGV5IGNvbnRhaW4sIGRvZXMgcmVxdWlyZSBhIG1pbmltdW0gYW1vdW50IG9mIHVuZGVyc3RhbmRpbmcgb2YgdGhlIEFQRyBwYXJzaW5nXG4vLyBtZXRob2QuIFRoZSBwYXJzZSB0cmVlIG5vZGVzIGFyZSBhbGwgcmVwcmVzZW50ZWQgYnkgQVBHIG9wZXJhdG9ycy4gVGhleSBicmVhayBkb3duIGludG8gdHdvIG5hdHVyYWwgZ3JvdXBzLlxuLy8gLSBUaGUgYFJOTWAgb3BlcmF0b3JzIGFuZCBgVURUYCBvcGVyYXRvcnMgYXJlIG5hbWVkIHBocmFzZXMuXG4vLyBUaGVzZSBhcmUgbmFtZXMgY2hvc2VuIGJ5IHRoZSB3cml0ZXIgb2YgdGhlIFNBQk5GIGdyYW1tYXIgdG8gcmVwcmVzZW50IHNwZWNpYWwgcGhyYXNlcyBvZiBpbnRlcmVzdC5cbi8vIC0gQWxsIG90aGVycyBjb2xsZWN0LCBjb25jYXRlbmF0ZSBhbmQgb3RoZXJ3aXNlIG1hbmlwdWxhdGUgdmFyaW91cyBpbnRlcm1lZGlhdGUgcGhyYXNlcyBhbG9uZyB0aGUgd2F5LlxuLy9cbi8vIFRoZXJlIGFyZSBzZXBhcmF0ZSBtZWFucyBvZiBmaWx0ZXJpbmcgd2hpY2ggb2YgdGhlc2Ugb3BlcmF0b3JzIGluIGVhY2ggb2YgdGhlc2UgdHdvIGdyb3VwcyBnZXQgdHJhY2VkLlxuLy8gTGV0IGB0cmFjZWAgYmUgYW4gaW5zdGFudGlhdGVkIGB0cmFjZS5qc2Agb2JqZWN0LlxuLy8gUHJpb3IgdG8gcGFyc2luZyB0aGUgc3RyaW5nLCBmaWx0ZXJpbmcgdGhlIHJ1bGVzIGFuZCBVRFRzIGNhbiBiZSBkZWZpbmVkIGFzIGZvbGxvd3M6XG4vLyBgYGBcbi8vIHRyYWNlLmZpbHRlci5ydWxlc1tcInJ1bGVuYW1lXCJdID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBydWxlIG5hbWUgXCJydWxlbmFtZVwiICovXG4vLyB0cmFjZS5maWx0ZXIucnVsZXNbXCJ1ZHRuYW1lXCJdICA9IHRydWU7XG4vLyAgICAgLyogdHJhY2UgVURUIG5hbWUgXCJ1ZHRuYW1lXCIgKi9cbi8vIHRyYWNlLmZpbHRlci5ydWxlc1tcIjxBTEw+XCJdICAgID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBhbGwgcnVsZXMgYW5kIFVEVHMgKHRoZSBkZWZhdWx0KSAqL1xuLy8gdHJhY2UuZmlsdGVyLnJ1bGVzW1wiPE5PTkU+XCJdICAgPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIG5vIHJ1bGVzIG9yIFVEVFMgKi9cbi8vIGBgYFxuLy8gSWYgYW55IHJ1bGUgb3IgVURUIG5hbWUgb3RoZXIgdGhhbiBcIiZsdDtBTEw+XCIgb3IgXCImbHQ7Tk9ORT5cIiBpcyBzcGVjaWZpZWQsIGFsbCBvdGhlciBuYW1lcyBhcmUgdHVybmVkIG9mZi5cbi8vIFRoZXJlZm9yZSwgdG8gYmUgc2VsZWN0aXZlIG9mIHJ1bGUgbmFtZXMsIGEgZmlsdGVyIHN0YXRlbWVudCBpcyByZXF1aXJlZCBmb3IgZWFjaCBydWxlL1VEVCBuYW1lIGRlc2lyZWQuXG4vL1xuLy8gRmlsdGVyaW5nIG9mIHRoZSBvdGhlciBvcGVyYXRvcnMgZm9sbG93cyBhIHNpbWlsYXIgcHJvY2VkdXJlLlxuLy8gYGBgXG4vLyB0cmFjZS5maWx0ZXIub3BlcmF0b3JzW1wiVFJHXCJdID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSB0aGUgdGVybWluYWwgcmFuZ2UsIFRSRywgb3BlcmF0b3JzICovXG4vLyB0cmFjZS5maWx0ZXIub3BlcmF0b3JzW1wiQ0FUXCJdICA9IHRydWU7XG4vLyAgICAgLyogdHJhY2UgdGhlIGNvbmNhdGVuYXRpb25zLCBDQVQsIG9wZXJhdG9ycyAqL1xuLy8gdHJhY2UuZmlsdGVyLm9wZXJhdG9yc1tcIjxBTEw+XCJdICAgID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBhbGwgb3BlcmF0b3JzICovXG4vLyB0cmFjZS5maWx0ZXIub3BlcmF0b3JzW1wiPE5PTkU+XCJdICAgPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIG5vIG9wZXJhdG9ycyAodGhlIGRlZmF1bHQpICovXG4vLyBgYGBcbi8vIElmIGFueSBvcGVyYXRvciBuYW1lIG90aGVyIHRoYW4gXCImbHQ7QUxMPlwiIG9yIFwiJmx0O05PTkU+XCIgaXMgc3BlY2lmaWVkLCBhbGwgb3RoZXIgbmFtZXMgYXJlIHR1cm5lZCBvZmYuXG4vLyBUaGVyZWZvcmUsIHRvIGJlIHNlbGVjdGl2ZSBvZiBvcGVyYXRvciBuYW1lcywgYSBmaWx0ZXIgc3RhdGVtZW50IGlzIHJlcXVpcmVkIGZvciBlYWNoIG5hbWUgZGVzaXJlZC5cbi8vXG4vLyBUaGVyZSBpcywgYWRkaXRpb25hbGx5LCBhIG1lYW5zIGZvciBsaW1pdGluZyB0aGUgdG90YWwgbnVtYmVyIG9mIGZpbHRlcmVkIG9yIHNhdmVkIHRyYWNlIHJlY29yZHMuXG4vLyBTZWUgdGhlIGZ1bmN0aW9uLCBgc2V0TWF4UmVjb3JkcyhtYXgpYCBiZWxvdy4gVGhpcyB3aWxsIHJlc3VsdCBpbiBvbmx5IHRoZSBsYXN0IGBtYXhgIHJlY29yZHMgYmVpbmcgc2F2ZWQuXG4vL1xuLy8gKFNlZSBbYGFwZy1leGFtcGxlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMtZXhhbXBsZXMpIGZvciBleGFtcGxlcyBvZiB1c2luZyBgdHJhY2UuanNgLilcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwb3J0VHJhY2UoKSB7XG4gIGNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcbiAgY29uc3Qgc3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlJyk7XG4gIGNvbnN0IGNpcmN1bGFyID0gbmV3IChyZXF1aXJlKCcuL2NpcmN1bGFyLWJ1ZmZlcicpKSgpO1xuICBjb25zdCBpZCA9IHJlcXVpcmUoJy4vaWRlbnRpZmllcnMnKTtcblxuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAndHJhY2UuanM6ICc7XG4gIGNvbnN0IHRoYXQgPSB0aGlzO1xuICBjb25zdCBNT0RFX0hFWCA9IDE2O1xuICBjb25zdCBNT0RFX0RFQyA9IDEwO1xuICBjb25zdCBNT0RFX0FTQ0lJID0gODtcbiAgY29uc3QgTU9ERV9VTklDT0RFID0gMzI7XG4gIGNvbnN0IE1BWF9QSFJBU0UgPSA4MDtcbiAgY29uc3QgTUFYX1RMUyA9IDU7XG4gIGNvbnN0IHJlY29yZHMgPSBbXTtcbiAgbGV0IG1heFJlY29yZHMgPSA1MDAwO1xuICBsZXQgbGFzdFJlY29yZCA9IC0xO1xuICBsZXQgZmlsdGVyZWRSZWNvcmRzID0gMDtcbiAgbGV0IHRyZWVEZXB0aCA9IDA7XG4gIGNvbnN0IHJlY29yZFN0YWNrID0gW107XG4gIGxldCBjaGFycyA9IG51bGw7XG4gIGxldCBydWxlcyA9IG51bGw7XG4gIGxldCB1ZHRzID0gbnVsbDtcbiAgY29uc3Qgb3BlcmF0b3JGaWx0ZXIgPSBbXTtcbiAgY29uc3QgcnVsZUZpbHRlciA9IFtdO1xuICAvKiBzcGVjaWFsIHRyYWNlIHRhYmxlIHBocmFzZXMgKi9cbiAgY29uc3QgUEhSQVNFX0VORCA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTElORUVORH1cIj4mYnVsbDs8L3NwYW4+YDtcbiAgY29uc3QgUEhSQVNFX0NPTlRJTlVFID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MSU5FRU5EfVwiPiZoZWxsaXA7PC9zcGFuPmA7XG4gIGNvbnN0IFBIUkFTRV9FTVBUWSA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+JiMxMjA2MzQ7PC9zcGFuPmA7XG4gIC8qIGZpbHRlciB0aGUgbm9uLVJOTSAmIG5vbi1VRFQgb3BlcmF0b3JzICovXG4gIGNvbnN0IGluaXRPcGVyYXRvckZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzZXRPcGVyYXRvcnMgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5BTFRdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQ0FUXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlJFUF0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5UTFNdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVEJTXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlRSR10gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5BTkRdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuTk9UXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkJLUl0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5CS0FdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQktOXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFCR10gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5BRU5dID0gc2V0O1xuICAgIH07XG4gICAgbGV0IGl0ZW1zID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIub3BlcmF0b3JzKSB7XG4gICAgICBpdGVtcyArPSAxO1xuICAgIH1cbiAgICBpZiAoaXRlbXMgPT09IDApIHtcbiAgICAgIC8qIGNhc2UgMTogbm8gb3BlcmF0b3JzIHNwZWNpZmllZDogZGVmYXVsdDogZG8gbm90IHRyYWNlIGFueSBvcGVyYXRvcnMgKi9cbiAgICAgIHNldE9wZXJhdG9ycyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGF0LmZpbHRlci5vcGVyYXRvcnMpIHtcbiAgICAgIGNvbnN0IHVwcGVyID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKHVwcGVyID09PSAnPEFMTD4nKSB7XG4gICAgICAgIC8qIGNhc2UgMjogPGFsbD4gb3BlcmF0b3JzIHNwZWNpZmllZDogdHJhY2UgYWxsIG9wZXJhdG9ycyBpZ25vcmUgYWxsIG90aGVyIG9wZXJhdG9yIGNvbW1hbmRzICovXG4gICAgICAgIHNldE9wZXJhdG9ycyh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHVwcGVyID09PSAnPE5PTkU+Jykge1xuICAgICAgICAvKiBjYXNlIDM6IDxub25lPiBvcGVyYXRvcnMgc3BlY2lmaWVkOiB0cmFjZSBOTyBvcGVyYXRvcnMgaWdub3JlIGFsbCBvdGhlciBvcGVyYXRvciBjb21tYW5kcyAqL1xuICAgICAgICBzZXRPcGVyYXRvcnMoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHNldE9wZXJhdG9ycyhmYWxzZSk7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoYXQuZmlsdGVyLm9wZXJhdG9ycykge1xuICAgICAgY29uc3QgdXBwZXIgPSBuYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAvKiBjYXNlIDQ6IG9uZSBvciBtb3JlIGluZGl2aWR1YWwgb3BlcmF0b3JzIHNwZWNpZmllZDogdHJhY2UgJ3RydWUnIG9wZXJhdG9ycyBvbmx5ICovXG4gICAgICBpZiAodXBwZXIgPT09ICdBTFQnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFMVF0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnQ0FUJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5DQVRdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ1JFUCcpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuUkVQXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdBTkQnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFORF0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnTk9UJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5OT1RdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ1RMUycpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVExTXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdUQlMnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlRCU10gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnVFJHJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5UUkddID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ0JLUicpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQktSXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdCS0EnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkJLQV0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnQktOJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5CS05dID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ0FCRycpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQUJHXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdBRU4nKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFFTl0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7dGhpc0ZpbGVOYW1lfWluaXRPcHJhdG9yRmlsdGVyOiAnJHtuYW1lfScgbm90IGEgdmFsaWQgb3BlcmF0b3IgbmFtZS5gICtcbiAgICAgICAgICAgIGAgTXVzdCBiZSA8YWxsPiwgPG5vbmU+LCBhbHQsIGNhdCwgcmVwLCB0bHMsIHRicywgdHJnLCBhbmQsIG5vdCwgYmtyLCBia2Egb3IgYmtuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogZmlsdGVyIHRoZSBydWxlIGFuZCBgVURUYCBuYW1lZCBvcGVyYXRvcnMgKi9cbiAgY29uc3QgaW5pdFJ1bGVGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc2V0UnVsZXMgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5STk1dID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVURUXSA9IHNldDtcbiAgICAgIGNvbnN0IGNvdW50ID0gcnVsZXMubGVuZ3RoICsgdWR0cy5sZW5ndGg7XG4gICAgICBydWxlRmlsdGVyLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgcnVsZUZpbHRlci5wdXNoKHNldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgaXRlbXM7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbGlzdC5wdXNoKHJ1bGVzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaCh1ZHRzW2ldLmxvd2VyKTtcbiAgICB9XG4gICAgcnVsZUZpbHRlci5sZW5ndGggPSAwO1xuICAgIGl0ZW1zID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIucnVsZXMpIHtcbiAgICAgIGl0ZW1zICs9IDE7XG4gICAgfVxuICAgIGlmIChpdGVtcyA9PT0gMCkge1xuICAgICAgLyogY2FzZSAxOiBkZWZhdWx0IHRvIGFsbCBydWxlcyAmIHVkdHMgKi9cbiAgICAgIHNldFJ1bGVzKHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIucnVsZXMpIHtcbiAgICAgIGNvbnN0IGxvd2VyID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyID09PSAnPGFsbD4nKSB7XG4gICAgICAgIC8qIGNhc2UgMjogdHJhY2UgYWxsIHJ1bGVzIGlnbm9yZSBhbGwgb3RoZXIgcnVsZSBjb21tYW5kcyAqL1xuICAgICAgICBzZXRSdWxlcyh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSAnPG5vbmU+Jykge1xuICAgICAgICAvKiBjYXNlIDM6IHRyYWNlIG5vIHJ1bGVzICovXG4gICAgICAgIHNldFJ1bGVzKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBjYXNlIDQ6IHRyYWNlIG9ubHkgaW5kaXZpZHVhbGx5IHNwZWNpZmllZCBydWxlcyAqL1xuICAgIHNldFJ1bGVzKGZhbHNlKTtcbiAgICBvcGVyYXRvckZpbHRlcltpZC5STk1dID0gdHJ1ZTtcbiAgICBvcGVyYXRvckZpbHRlcltpZC5VRFRdID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIucnVsZXMpIHtcbiAgICAgIGNvbnN0IGxvd2VyID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaSA9IGxpc3QuaW5kZXhPZihsb3dlcik7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1pbml0UnVsZUZpbHRlcjogJyR7bmFtZX0nIG5vdCBhIHZhbGlkIHJ1bGUgb3IgdWR0IG5hbWVgKTtcbiAgICAgIH1cbiAgICAgIHJ1bGVGaWx0ZXJbaV0gPSB0aGF0LmZpbHRlci5ydWxlc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8qIHVzZWQgYnkgb3RoZXIgQVBHIGNvbXBvbmVudHMgdG8gdmVyaWZ5IHRoYXQgdGhleSBoYXZlIGEgdmFsaWQgdHJhY2Ugb2JqZWN0ICovXG4gIHRoaXMudHJhY2VPYmplY3QgPSAndHJhY2VPYmplY3QnO1xuICB0aGlzLmZpbHRlciA9IHtcbiAgICBvcGVyYXRvcnM6IFtdLFxuICAgIHJ1bGVzOiBbXSxcbiAgfTtcbiAgLy8gU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvcmRzIHRvIGtlZXAgKGRlZmF1bHQgPSA1MDAwKS5cbiAgLy8gRWFjaCByZWNvcmQgbnVtYmVyIGxhcmdlciB0aGFuIGBtYXhSZWNvcmRzYFxuICAvLyB3aWxsIHJlc3VsdCBpbiBkZWxldGluZyB0aGUgcHJldmlvdXNseSBvbGRlc3QgcmVjb3JkLlxuICAvLyAtIGBtYXhgOiBtYXhpbXVtIG51bWJlciBvZiByZWNvcmRzIHRvIHJldGFpbiAoZGVmYXVsdCA9IDUwMDApXG4gIC8vIC0gYGxhc3RgOiBsYXN0IHJlY29yZCBudW1iZXIgdG8gcmV0YWluLCAoZGVmYXVsdCA9IC0xIGZvciAodW5rbm93bikgYWN0dWFsIGxhc3QgcmVjb3JkKVxuICB0aGlzLnNldE1heFJlY29yZHMgPSBmdW5jdGlvbiAobWF4LCBsYXN0KSB7XG4gICAgbGFzdFJlY29yZCA9IC0xO1xuICAgIGlmICh0eXBlb2YgbWF4ID09PSAnbnVtYmVyJyAmJiBtYXggPiAwKSB7XG4gICAgICBtYXhSZWNvcmRzID0gTWF0aC5jZWlsKG1heCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFJlY29yZHMgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICBsYXN0UmVjb3JkID0gTWF0aC5mbG9vcihsYXN0KTtcbiAgICAgIGlmIChsYXN0UmVjb3JkIDwgMCkge1xuICAgICAgICBsYXN0UmVjb3JkID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBSZXR1cm5zIGBtYXhSZWNvcmRzYCB0byB0aGUgY2FsbGVyLlxuICB0aGlzLmdldE1heFJlY29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1heFJlY29yZHM7XG4gIH07XG4gIC8vIFJldHVybnMgYGxhc3RSZWNvcmRgIHRvIHRoZSBjYWxsZXIuXG4gIHRoaXMuZ2V0TGFzdFJlY29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbGFzdFJlY29yZDtcbiAgfTtcbiAgLyogQ2FsbGVkIG9ubHkgYnkgdGhlIGBwYXJzZXIuanNgIG9iamVjdC4gTm8gdmVyaWZpY2F0aW9uIG9mIGlucHV0LiAqL1xuICB0aGlzLmluaXQgPSBmdW5jdGlvbiAocnVsZXNJbiwgdWR0c0luLCBjaGFyc0luKSB7XG4gICAgcmVjb3Jkcy5sZW5ndGggPSAwO1xuICAgIHJlY29yZFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgZmlsdGVyZWRSZWNvcmRzID0gMDtcbiAgICB0cmVlRGVwdGggPSAwO1xuICAgIGNoYXJzID0gY2hhcnNJbjtcbiAgICBydWxlcyA9IHJ1bGVzSW47XG4gICAgdWR0cyA9IHVkdHNJbjtcbiAgICBpbml0T3BlcmF0b3JGaWx0ZXIoKTtcbiAgICBpbml0UnVsZUZpbHRlcigpO1xuICAgIGNpcmN1bGFyLmluaXQobWF4UmVjb3Jkcyk7XG4gIH07XG4gIC8qIHJldHVybnMgdHJ1ZSBpZiB0aGlzIHJlY29yZHMgcGFzc2VzIHRocm91Z2ggdGhlIGRlc2lnbmF0ZWQgZmlsdGVyLCBmYWxzZSBpZiB0aGUgcmVjb3JkIGlzIHRvIGJlIHNraXBwZWQgKi9cbiAgY29uc3QgZmlsdGVyT3BzID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgbGV0IHJldCA9IGZhbHNlO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5STk0pIHtcbiAgICAgIGlmIChvcGVyYXRvckZpbHRlcltvcC50eXBlXSAmJiBydWxlRmlsdGVyW29wLmluZGV4XSkge1xuICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcC50eXBlID09PSBpZC5VRFQpIHtcbiAgICAgIGlmIChvcGVyYXRvckZpbHRlcltvcC50eXBlXSAmJiBydWxlRmlsdGVyW3J1bGVzLmxlbmd0aCArIG9wLmluZGV4XSkge1xuICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCA9IG9wZXJhdG9yRmlsdGVyW29wLnR5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICBjb25zdCBmaWx0ZXJSZWNvcmRzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgIGlmIChsYXN0UmVjb3JkID09PSAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZWNvcmQgPD0gbGFzdFJlY29yZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyogQ29sbGVjdCB0aGUgXCJkb3duXCIgcmVjb3JkLiAqL1xuICB0aGlzLmRvd24gPSBmdW5jdGlvbiAob3AsIHN0YXRlLCBvZmZzZXQsIGxlbmd0aCwgYW5jaG9yLCBsb29rQXJvdW5kKSB7XG4gICAgaWYgKGZpbHRlclJlY29yZHMoZmlsdGVyZWRSZWNvcmRzKSAmJiBmaWx0ZXJPcHMob3ApKSB7XG4gICAgICByZWNvcmRTdGFjay5wdXNoKGZpbHRlcmVkUmVjb3Jkcyk7XG4gICAgICByZWNvcmRzW2NpcmN1bGFyLmluY3JlbWVudCgpXSA9IHtcbiAgICAgICAgZGlyVXA6IGZhbHNlLFxuICAgICAgICBkZXB0aDogdHJlZURlcHRoLFxuICAgICAgICB0aGlzTGluZTogZmlsdGVyZWRSZWNvcmRzLFxuICAgICAgICB0aGF0TGluZTogdW5kZWZpbmVkLFxuICAgICAgICBvcGNvZGU6IG9wLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcGhyYXNlSW5kZXg6IG9mZnNldCxcbiAgICAgICAgcGhyYXNlTGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIGxvb2tBbmNob3I6IGFuY2hvcixcbiAgICAgICAgbG9va0Fyb3VuZCxcbiAgICAgIH07XG4gICAgICBmaWx0ZXJlZFJlY29yZHMgKz0gMTtcbiAgICAgIHRyZWVEZXB0aCArPSAxO1xuICAgIH1cbiAgfTtcbiAgLyogQ29sbGVjdCB0aGUgXCJ1cFwiIHJlY29yZC4gKi9cbiAgdGhpcy51cCA9IGZ1bmN0aW9uIChvcCwgc3RhdGUsIG9mZnNldCwgbGVuZ3RoLCBhbmNob3IsIGxvb2tBcm91bmQpIHtcbiAgICBpZiAoZmlsdGVyUmVjb3JkcyhmaWx0ZXJlZFJlY29yZHMpICYmIGZpbHRlck9wcyhvcCkpIHtcbiAgICAgIGNvbnN0IHRoaXNMaW5lID0gZmlsdGVyZWRSZWNvcmRzO1xuICAgICAgY29uc3QgdGhhdExpbmUgPSByZWNvcmRTdGFjay5wb3AoKTtcbiAgICAgIGNvbnN0IHRoYXRSZWNvcmQgPSBjaXJjdWxhci5nZXRMaXN0SW5kZXgodGhhdExpbmUpO1xuICAgICAgaWYgKHRoYXRSZWNvcmQgIT09IC0xKSB7XG4gICAgICAgIHJlY29yZHNbdGhhdFJlY29yZF0udGhhdExpbmUgPSB0aGlzTGluZTtcbiAgICAgIH1cbiAgICAgIHRyZWVEZXB0aCAtPSAxO1xuICAgICAgcmVjb3Jkc1tjaXJjdWxhci5pbmNyZW1lbnQoKV0gPSB7XG4gICAgICAgIGRpclVwOiB0cnVlLFxuICAgICAgICBkZXB0aDogdHJlZURlcHRoLFxuICAgICAgICB0aGlzTGluZSxcbiAgICAgICAgdGhhdExpbmUsXG4gICAgICAgIG9wY29kZTogb3AsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwaHJhc2VJbmRleDogb2Zmc2V0LFxuICAgICAgICBwaHJhc2VMZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgbG9va0FuY2hvcjogYW5jaG9yLFxuICAgICAgICBsb29rQXJvdW5kLFxuICAgICAgfTtcbiAgICAgIGZpbHRlcmVkUmVjb3JkcyArPSAxO1xuICAgIH1cbiAgfTtcbiAgLyogY29udmVydCB0aGUgdHJhY2UgcmVjb3JkcyB0byBhIHRyZWUgb2Ygbm9kZXMgKi9cbiAgY29uc3QgdG9UcmVlT2JqID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIHByaXZhdGUgaGVscGVyIGZ1bmN0aW9ucyAqL1xuICAgIGZ1bmN0aW9uIG5vZGVPcGNvZGUobm9kZSwgb3Bjb2RlKSB7XG4gICAgICBsZXQgbmFtZTtcbiAgICAgIGxldCBjYXNldHlwZTtcbiAgICAgIGxldCBtb2RldHlwZTtcbiAgICAgIGlmIChvcGNvZGUpIHtcbiAgICAgICAgbm9kZS5vcCA9IHsgaWQ6IG9wY29kZS50eXBlLCBuYW1lOiB1dGlscy5vcGNvZGVUb1N0cmluZyhvcGNvZGUudHlwZSkgfTtcbiAgICAgICAgbm9kZS5vcERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN3aXRjaCAob3Bjb2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIGlkLlJOTTpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gcnVsZXNbb3Bjb2RlLmluZGV4XS5uYW1lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5VRFQ6XG4gICAgICAgICAgICBub2RlLm9wRGF0YSA9IHVkdHNbb3Bjb2RlLmluZGV4XS5uYW1lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgICAgICBpZiAob3Bjb2RlLmluZGV4IDwgcnVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBydWxlc1tvcGNvZGUuaW5kZXhdLm5hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lID0gdWR0c1tvcGNvZGUuaW5kZXggLSBydWxlcy5sZW5ndGhdLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNldHlwZSA9IG9wY29kZS5ia3JDYXNlID09PSBpZC5CS1JfTU9ERV9DSSA/ICclaScgOiAnJXMnO1xuICAgICAgICAgICAgbW9kZXR5cGUgPSBvcGNvZGUuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfVU0gPyAnJXUnIDogJyVwJztcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gYFxcXFxcXFxcJHtjYXNldHlwZX0ke21vZGV0eXBlfSR7bmFtZX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgICAgICBub2RlLm9wRGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcGNvZGUuc3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIG5vZGUub3BEYXRhLnB1c2gob3Bjb2RlLnN0cmluZ1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRCUzpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wY29kZS5zdHJpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgbm9kZS5vcERhdGEucHVzaChvcGNvZGUuc3RyaW5nW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVFJHOlxuICAgICAgICAgICAgbm9kZS5vcERhdGEgPSBbb3Bjb2RlLm1pbiwgb3Bjb2RlLm1heF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gW29wY29kZS5taW4sIG9wY29kZS5tYXhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIG9wY29kZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLm9wID0geyBpZDogdW5kZWZpbmVkLCBuYW1lOiB1bmRlZmluZWQgfTtcbiAgICAgICAgbm9kZS5vcERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVQaHJhc2Uoc3RhdGUsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gaWQuTUFUQ0gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsZW5ndGgsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IGlkLkVNUFRZKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBub2RlSWQgPSAtMTtcbiAgICBmdW5jdGlvbiBub2RlRG93bihwYXJlbnQsIHJlY29yZCwgZGVwdGgpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wbHVzcGx1c1xuICAgICAgICBpZDogbm9kZUlkKyssXG4gICAgICAgIGJyYW5jaDogLTEsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgdXA6IGZhbHNlLFxuICAgICAgICBkb3duOiBmYWxzZSxcbiAgICAgICAgZGVwdGgsXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIH07XG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIG5vZGUuZG93biA9IHRydWU7XG4gICAgICAgIG5vZGUuc3RhdGUgPSB7IGlkOiByZWNvcmQuc3RhdGUsIG5hbWU6IHV0aWxzLnN0YXRlVG9TdHJpbmcocmVjb3JkLnN0YXRlKSB9O1xuICAgICAgICBub2RlLnBocmFzZSA9IG51bGw7XG4gICAgICAgIG5vZGVPcGNvZGUobm9kZSwgcmVjb3JkLm9wY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnN0YXRlID0geyBpZDogdW5kZWZpbmVkLCBuYW1lOiB1bmRlZmluZWQgfTtcbiAgICAgICAgbm9kZS5waHJhc2UgPSBub2RlUGhyYXNlKCk7XG4gICAgICAgIG5vZGVPcGNvZGUobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlVXAobm9kZSwgcmVjb3JkKSB7XG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIG5vZGUudXAgPSB0cnVlO1xuICAgICAgICBub2RlLnN0YXRlID0geyBpZDogcmVjb3JkLnN0YXRlLCBuYW1lOiB1dGlscy5zdGF0ZVRvU3RyaW5nKHJlY29yZC5zdGF0ZSkgfTtcbiAgICAgICAgbm9kZS5waHJhc2UgPSBub2RlUGhyYXNlKHJlY29yZC5zdGF0ZSwgcmVjb3JkLnBocmFzZUluZGV4LCByZWNvcmQucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgaWYgKCFub2RlLmRvd24pIHtcbiAgICAgICAgICBub2RlT3Bjb2RlKG5vZGUsIHJlY29yZC5vcGNvZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIHdhbGsgdGhlIGZpbmFsIHRyZWU6IGxhYmVsIGJyYW5jaGVzIGFuZCBjb3VudCBsZWFmIG5vZGVzICovXG4gICAgbGV0IGxlYWZOb2RlcyA9IDA7XG4gICAgbGV0IGRlcHRoID0gLTE7XG4gICAgbGV0IGJyYW5jaENvdW50ID0gMTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGRlcHRoICs9IDE7XG4gICAgICBub2RlLmJyYW5jaCA9IGJyYW5jaENvdW50O1xuICAgICAgaWYgKGRlcHRoID4gdHJlZURlcHRoKSB7XG4gICAgICAgIHRyZWVEZXB0aCA9IGRlcHRoO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGxlYWZOb2RlcyArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBicmFuY2hDb3VudCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmxlZnRNb3N0ID0gZmFsc2U7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5yaWdodE1vc3QgPSBmYWxzZTtcbiAgICAgICAgICBpZiAobm9kZS5sZWZ0TW9zdCkge1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5sZWZ0TW9zdCA9IGkgPT09IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlLnJpZ2h0TW9zdCkge1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5yaWdodE1vc3QgPSBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhbGsobm9kZS5jaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlcHRoIC09IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BsYXkobm9kZSwgb2Zmc2V0KSB7XG4gICAgICBsZXQgbmFtZTtcbiAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgb2JqLmlkID0gbm9kZS5pZDtcbiAgICAgIG9iai5icmFuY2ggPSBub2RlLmJyYW5jaDtcbiAgICAgIG9iai5sZWZ0TW9zdCA9IG5vZGUubGVmdE1vc3Q7XG4gICAgICBvYmoucmlnaHRNb3N0ID0gbm9kZS5yaWdodE1vc3Q7XG4gICAgICBuYW1lID0gbm9kZS5zdGF0ZS5uYW1lID8gbm9kZS5zdGF0ZS5uYW1lIDogJ0FDVElWRSc7XG4gICAgICBvYmouc3RhdGUgPSB7IGlkOiBub2RlLnN0YXRlLmlkLCBuYW1lIH07XG4gICAgICBuYW1lID0gbm9kZS5vcC5uYW1lID8gbm9kZS5vcC5uYW1lIDogJz8nO1xuICAgICAgb2JqLm9wID0geyBpZDogbm9kZS5vcC5pZCwgbmFtZSB9O1xuICAgICAgaWYgKHR5cGVvZiBub2RlLm9wRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqLm9wRGF0YSA9IG5vZGUub3BEYXRhO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGUub3BEYXRhKSkge1xuICAgICAgICBvYmoub3BEYXRhID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5vcERhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBvYmoub3BEYXRhW2ldID0gbm9kZS5vcERhdGFbaV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai5vcERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5waHJhc2UpIHtcbiAgICAgICAgb2JqLnBocmFzZSA9IHsgaW5kZXg6IG5vZGUucGhyYXNlLmluZGV4LCBsZW5ndGg6IG5vZGUucGhyYXNlLmxlbmd0aCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqLnBocmFzZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBvYmouZGVwdGggPSBub2RlLmRlcHRoO1xuICAgICAgb2JqLmNoaWxkcmVuID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgYyA9IGkgIT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgb2JqLmNoaWxkcmVuW2ldID0gZGlzcGxheShub2RlLmNoaWxkcmVuW2ldLCBvZmZzZXQsIGMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAvKiBjb25zdHJ1Y3QgdGhlIHRyZWUgYmVnaW5uaW5nIGhlcmUgKi9cbiAgICBjb25zdCBicmFuY2ggPSBbXTtcbiAgICBsZXQgcm9vdDtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgcGFyZW50O1xuICAgIGxldCByZWNvcmQ7XG4gICAgbGV0IGZpcnN0UmVjb3JkID0gdHJ1ZTtcbiAgICAvKiBwdXNoIGEgZHVtbXkgbm9kZSBzbyB0aGUgcm9vdCBub2RlIHdpbGwgaGF2ZSBhIG5vbi1udWxsIHBhcmVudCAqL1xuICAgIGNvbnN0IGR1bW15ID0gbm9kZURvd24obnVsbCwgbnVsbCwgLTEpO1xuICAgIGJyYW5jaC5wdXNoKGR1bW15KTtcbiAgICBub2RlID0gZHVtbXk7XG4gICAgY2lyY3VsYXIuZm9yRWFjaCgobGluZUluZGV4KSA9PiB7XG4gICAgICByZWNvcmQgPSByZWNvcmRzW2xpbmVJbmRleF07XG4gICAgICBpZiAoZmlyc3RSZWNvcmQpIHtcbiAgICAgICAgZmlyc3RSZWNvcmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJlY29yZC5kZXB0aCA+IDApIHtcbiAgICAgICAgICAvKiBwdXNoIHNvbWUgZHVtbXkgbm9kZXMgdG8gZmlsbCBpbiBmb3IgbWlzc2luZyByZWNvcmRzICovXG4gICAgICAgICAgY29uc3QgbnVtID0gcmVjb3JkLmRpclVwID8gcmVjb3JkLmRlcHRoICsgMSA6IHJlY29yZC5kZXB0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bTsgaSArPSAxKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVEb3duKG5vZGUsIG51bGwsIGkpO1xuICAgICAgICAgICAgYnJhbmNoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWNvcmQuZGlyVXApIHtcbiAgICAgICAgLyogaGFuZGxlIHRoZSBuZXh0IHJlY29yZCB1cCAqL1xuICAgICAgICBub2RlID0gYnJhbmNoLnBvcCgpO1xuICAgICAgICBub2RlVXAobm9kZSwgcmVjb3JkKTtcbiAgICAgICAgbm9kZSA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBoYW5kbGUgdGhlIG5leHQgcmVjb3JkIGRvd24gKi9cbiAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGVEb3duKG5vZGUsIHJlY29yZCwgcmVjb3JkLmRlcHRoKTtcbiAgICAgICAgYnJhbmNoLnB1c2gobm9kZSk7XG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogaWYgbm90IGF0IHJvb3QsIHdhbGsgaXQgdXAgdG8gcm9vdCAqL1xuICAgIHdoaWxlIChicmFuY2gubGVuZ3RoID4gMSkge1xuICAgICAgbm9kZSA9IGJyYW5jaC5wb3AoKTtcbiAgICAgIG5vZGVVcChub2RlLCBudWxsKTtcbiAgICB9XG4gICAgLyogbWF5YmUgcmVkdW5kYW50IG9yIHBhcmFub2lkIHRlc3RzOiB0aGVzZSBzaG91bGQgbmV2ZXIgaGFwcGVuICovXG4gICAgaWYgKGR1bW15LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFjZS50b1RyZWUoKTogcGFyc2UgdHJlZSBoYXMgbm8gbm9kZXMnKTtcbiAgICB9XG4gICAgaWYgKGJyYW5jaC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhY2UudG9UcmVlKCk6IGludGVncml0eSBjaGVjazogZHVtbXkgcm9vdCBub2RlIGRpc2FwcGVhcmVkPycpO1xuICAgIH1cblxuICAgIC8qIGlmIG5vIHJlY29yZCBmb3Igc3RhcnQgcnVsZTogZmluZCB0aGUgcHNldWRvIHJvb3Qgbm9kZSAoZmlyc3QgZHVtbXkgbm9kZSBhYm92ZSBhIHJlYWwgbm9kZSkgKi9cbiAgICByb290ID0gZHVtbXkuY2hpbGRyZW5bMF07XG4gICAgbGV0IHByZXYgPSByb290O1xuICAgIHdoaWxlIChyb290ICYmICFyb290LmRvd24gJiYgIXJvb3QudXApIHtcbiAgICAgIHByZXYgPSByb290O1xuICAgICAgcm9vdCA9IHJvb3QuY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIHJvb3QgPSBwcmV2O1xuXG4gICAgLyogd2FsayB0aGUgdHJlZSBvZiBub2RlczogbGFiZWwgYnJhbmNlcyBhbmQgY291bnQgbGVhdmVzICovXG4gICAgcm9vdC5sZWZ0TW9zdCA9IHRydWU7XG4gICAgcm9vdC5yaWdodE1vc3QgPSB0cnVlO1xuICAgIHdhbGsocm9vdCk7XG4gICAgcm9vdC5icmFuY2ggPSAwO1xuXG4gICAgLyogZ2VuZXJhdGUgdGhlIGV4cG9ydGVkIG9iamVjdCAqL1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIG9iai5zdHJpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvYmouc3RyaW5nW2ldID0gY2hhcnNbaV07XG4gICAgfVxuICAgIC8qIGdlbmVyYXRlIHRoZSBleHBvcnRlZCBydWxlIG5hbWVzICovXG4gICAgb2JqLnJ1bGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgb2JqLnJ1bGVzW2ldID0gcnVsZXNbaV0ubmFtZTtcbiAgICB9XG4gICAgLyogZ2VuZXJhdGUgdGhlIGV4cG9ydGVkIFVEVCBuYW1lcyAqL1xuICAgIG9iai51ZHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvYmoudWR0c1tpXSA9IHVkdHNbaV0ubmFtZTtcbiAgICB9XG4gICAgLyogZ2VuZXJhdGUgdGhlIGlkcyAqL1xuICAgIG9iai5pZCA9IHt9O1xuICAgIG9iai5pZC5BTFQgPSB7IGlkOiBpZC5BTFQsIG5hbWU6ICdBTFQnIH07XG4gICAgb2JqLmlkLkNBVCA9IHsgaWQ6IGlkLkNBVCwgbmFtZTogJ0NBVCcgfTtcbiAgICBvYmouaWQuUkVQID0geyBpZDogaWQuUkVQLCBuYW1lOiAnUkVQJyB9O1xuICAgIG9iai5pZC5STk0gPSB7IGlkOiBpZC5STk0sIG5hbWU6ICdSTk0nIH07XG4gICAgb2JqLmlkLlRMUyA9IHsgaWQ6IGlkLlRMUywgbmFtZTogJ1RMUycgfTtcbiAgICBvYmouaWQuVEJTID0geyBpZDogaWQuVEJTLCBuYW1lOiAnVEJTJyB9O1xuICAgIG9iai5pZC5UUkcgPSB7IGlkOiBpZC5UUkcsIG5hbWU6ICdUUkcnIH07XG4gICAgb2JqLmlkLlVEVCA9IHsgaWQ6IGlkLlVEVCwgbmFtZTogJ1VEVCcgfTtcbiAgICBvYmouaWQuQU5EID0geyBpZDogaWQuQU5ELCBuYW1lOiAnQU5EJyB9O1xuICAgIG9iai5pZC5OT1QgPSB7IGlkOiBpZC5OT1QsIG5hbWU6ICdOT1QnIH07XG4gICAgb2JqLmlkLkJLUiA9IHsgaWQ6IGlkLkJLUiwgbmFtZTogJ0JLUicgfTtcbiAgICBvYmouaWQuQktBID0geyBpZDogaWQuQktBLCBuYW1lOiAnQktBJyB9O1xuICAgIG9iai5pZC5CS04gPSB7IGlkOiBpZC5CS04sIG5hbWU6ICdCS04nIH07XG4gICAgb2JqLmlkLkFCRyA9IHsgaWQ6IGlkLkFCRywgbmFtZTogJ0FCRycgfTtcbiAgICBvYmouaWQuQUVOID0geyBpZDogaWQuQUVOLCBuYW1lOiAnQUVOJyB9O1xuICAgIG9iai5pZC5BQ1RJVkUgPSB7IGlkOiBpZC5BQ1RJVkUsIG5hbWU6ICdBQ1RJVkUnIH07XG4gICAgb2JqLmlkLk1BVENIID0geyBpZDogaWQuTUFUQ0gsIG5hbWU6ICdNQVRDSCcgfTtcbiAgICBvYmouaWQuRU1QVFkgPSB7IGlkOiBpZC5FTVBUWSwgbmFtZTogJ0VNUFRZJyB9O1xuICAgIG9iai5pZC5OT01BVENIID0geyBpZDogaWQuTk9NQVRDSCwgbmFtZTogJ05PTUFUQ0gnIH07XG4gICAgLyogZ2VuZXJhdGUgdGhlIG1heCB0cmVlIGRlcHRoICovXG4gICAgb2JqLnRyZWVEZXB0aCA9IHRyZWVEZXB0aDtcbiAgICAvKiBnZW5lcmF0ZSB0aGUgbnVtYmVyIG9mIGxlYWYgbm9kZXMgKGJyYW5jaGVzKSAqL1xuICAgIG9iai5sZWFmTm9kZXMgPSBsZWFmTm9kZXM7XG4gICAgLyogZ2VuZXJhdGUgdGhlIHR5cGVzIG9mIHRoZSBsZWZ0LSBhbmQgcmlnaHQtbW9zdCBicmFuY2hlcyAqL1xuICAgIGxldCBicmFuY2hlc0luY29tcGxldGU7XG4gICAgaWYgKHJvb3QuZG93bikge1xuICAgICAgaWYgKHJvb3QudXApIHtcbiAgICAgICAgYnJhbmNoZXNJbmNvbXBsZXRlID0gJ25vbmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJhbmNoZXNJbmNvbXBsZXRlID0gJ3JpZ2h0JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJvb3QudXApIHtcbiAgICAgIGJyYW5jaGVzSW5jb21wbGV0ZSA9ICdsZWZ0JztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJhbmNoZXNJbmNvbXBsZXRlID0gJ2JvdGgnO1xuICAgIH1cbiAgICBvYmouYnJhbmNoZXNJbmNvbXBsZXRlID0gYnJhbmNoZXNJbmNvbXBsZXRlO1xuICAgIG9iai50cmVlID0gZGlzcGxheShyb290LCByb290LmRlcHRoLCBmYWxzZSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbiAgLy8gUmV0dXJucyB0aGUgdHJhY2UgcmVjb3JkcyBhcyBKU09OIHBhcnNlIHRyZWUgb2JqZWN0LlxuICAvLyAtIHN0cmluZ2lmeTogaWYgYHRydWVgLCB0aGUgb2JqZWN0IGlzICdzdHJpbmdpZmllZCcgYmVmb3JlIHJldHVybmluZywgb3RoZXJ3aXNlLCB0aGUgb2JqZWN0IGl0c2VsZiBpcyByZXR1cm5lZC5cbiAgdGhpcy50b1RyZWUgPSBmdW5jdGlvbiAoc3RyaW5naWZ5KSB7XG4gICAgY29uc3Qgb2JqID0gdG9UcmVlT2JqKCk7XG4gICAgaWYgKHN0cmluZ2lmeSkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG4gIC8vIFRyYW5zbGF0ZSB0aGUgdHJhY2UgcmVjb3JkcyB0byBIVE1MIGZvcm1hdCBhbmQgY3JlYXRlIGEgY29tcGxldGUgSFRNTCBwYWdlIGZvciBicm93c2VyIGRpc3BsYXkuXG4gIHRoaXMudG9IdG1sUGFnZSA9IGZ1bmN0aW9uIChtb2RlLCBjYXB0aW9uLCB0aXRsZSkge1xuICAgIHJldHVybiB1dGlscy5odG1sVG9QYWdlKHRoaXMudG9IdG1sKG1vZGUsIGNhcHRpb24pLCB0aXRsZSk7XG4gIH07XG5cbiAgLyogRnJvbSBoZXJlIG9uIGRvd24sIHRoZXNlIGFyZSBqdXN0IGhlbHBlciBmdW5jdGlvbnMgZm9yIGB0b0h0bWwoKWAuICovXG4gIGNvbnN0IGh0bWxIZWFkZXIgPSBmdW5jdGlvbiAobW9kZSwgY2FwdGlvbikge1xuICAgIC8qIG9wZW4gdGhlIHBhZ2UgKi9cbiAgICAvKiB3cml0ZSB0aGUgSFRNTDUgaGVhZGVyIHdpdGggdGFibGUgc3R5bGUgKi9cbiAgICAvKiBvcGVuIHRoZSA8dGFibGU+IHRhZyAqL1xuICAgIGxldCBtb2RlTmFtZTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgTU9ERV9IRVg6XG4gICAgICAgIG1vZGVOYW1lID0gJ2hleGFkZWNpbWFsJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfREVDOlxuICAgICAgICBtb2RlTmFtZSA9ICdkZWNpbWFsJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfQVNDSUk6XG4gICAgICAgIG1vZGVOYW1lID0gJ0FTQ0lJJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfVU5JQ09ERTpcbiAgICAgICAgbW9kZU5hbWUgPSAnVU5JQ09ERSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1odG1sSGVhZGVyOiB1bnJlY29nbml6ZWQgbW9kZTogJHttb2RlfWApO1xuICAgIH1cbiAgICBsZXQgaGVhZGVyID0gJyc7XG4gICAgaGVhZGVyICs9IGA8cD5kaXNwbGF5IG1vZGU6ICR7bW9kZU5hbWV9PC9wPlxcbmA7XG4gICAgaGVhZGVyICs9IGA8dGFibGUgY2xhc3M9XCIke3N0eWxlLkNMQVNTX1RSQUNFfVwiPlxcbmA7XG4gICAgaWYgKHR5cGVvZiBjYXB0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgaGVhZGVyICs9IGA8Y2FwdGlvbj4ke2NhcHRpb259PC9jYXB0aW9uPmA7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXI7XG4gIH07XG4gIGNvbnN0IGh0bWxGb290ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGZvb3RlciA9ICcnO1xuICAgIC8qIGNsb3NlIHRoZSA8L3RhYmxlPiB0YWcgKi9cbiAgICBmb290ZXIgKz0gJzwvdGFibGU+XFxuJztcbiAgICAvKiBkaXNwbGF5IGEgdGFibGUgbGVnZW5kICovXG4gICAgZm9vdGVyICs9IGA8cCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTU9OT1NQQUNFfVwiPmxlZ2VuZDo8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gJyhhKSZuYnNwOy0mbmJzcDtsaW5lIG51bWJlcjxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnKGIpJm5ic3A7LSZuYnNwO21hdGNoaW5nIGxpbmUgbnVtYmVyPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICcoYykmbmJzcDstJm5ic3A7cGhyYXNlIG9mZnNldDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnKGQpJm5ic3A7LSZuYnNwO3BocmFzZSBsZW5ndGg8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJyhlKSZuYnNwOy0mbmJzcDt0cmVlIGRlcHRoPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICcoZikmbmJzcDstJm5ic3A7b3BlcmF0b3Igc3RhdGU8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDs8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiZkYXJyOzwvc3Bhbj4mbmJzcDsmbmJzcDtwaHJhc2Ugb3BlbmVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPiZ1YXJyO008L3NwYW4+IHBocmFzZSBtYXRjaGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiZ1YXJyO0U8L3NwYW4+IGVtcHR5IHBocmFzZSBtYXRjaGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+JnVhcnI7Tjwvc3Bhbj4gcGhyYXNlIG5vdCBtYXRjaGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9XG4gICAgICAnb3BlcmF0b3ImbmJzcDstJm5ic3A7QUxULCBDQVQsIFJFUCwgUk5NLCBUUkcsIFRMUywgVEJTPHN1cD4mZGFnZ2VyOzwvc3VwPiwgVURULCBBTkQsIE5PVCwgQktBLCBCS04sIEJLUiwgQUJHLCBBRU48c3VwPiZEYWdnZXI7PC9zdXA+PGJyPlxcbic7XG4gICAgZm9vdGVyICs9IGBwaHJhc2UmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7dXAgdG8gJHtNQVhfUEhSQVNFfSBjaGFyYWN0ZXJzIG9mIHRoZSBwaHJhc2UgYmVpbmcgbWF0Y2hlZDxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj5tYXRjaGVkIGNoYXJhY3RlcnM8L3NwYW4+PGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0xPT0tBSEVBRH1cIj5tYXRjaGVkIGNoYXJhY3RlcnMgaW4gbG9vayBhaGVhZCBtb2RlPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQkVISU5EfVwiPm1hdGNoZWQgY2hhcmFjdGVycyBpbiBsb29rIGJlaGluZCBtb2RlPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19SRU1BSU5ERVJ9XCI+cmVtYWluZGVyIGNoYXJhY3RlcnMobm90IHlldCBleGFtaW5lZCBieSBwYXJzZXIpPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19DVFJMQ0hBUn1cIj5jb250cm9sIGNoYXJhY3RlcnMsIFRBQiwgTEYsIENSLCBldGMuIChBU0NJSSBtb2RlIG9ubHkpPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOyR7UEhSQVNFX0VNUFRZfSBlbXB0eSBzdHJpbmc8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDske1BIUkFTRV9FTkR9IGVuZCBvZiBpbnB1dCBzdHJpbmc8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDske1BIUkFTRV9DT05USU5VRX0gaW5wdXQgc3RyaW5nIGRpc3BsYXkgdHJ1bmNhdGVkPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9ICc8L3A+XFxuJztcbiAgICBmb290ZXIgKz0gYDxwIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NT05PU1BBQ0V9XCI+XFxuYDtcbiAgICBmb290ZXIgKz0gJzxzdXA+JmRhZ2dlcjs8L3N1cD5vcmlnaW5hbCBBQk5GIG9wZXJhdG9yczo8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0FMVCAtIGFsdGVybmF0aW9uPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdDQVQgLSBjb25jYXRlbmF0aW9uPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdSRVAgLSByZXBldGl0aW9uPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdSTk0gLSBydWxlIG5hbWU8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1RSRyAtIHRlcm1pbmFsIHJhbmdlPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdUTFMgLSB0ZXJtaW5hbCBsaXRlcmFsIHN0cmluZyAoY2FzZSBpbnNlbnNpdGl2ZSk8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1RCUyAtIHRlcm1pbmFsIGJpbmFyeSBzdHJpbmcgKGNhc2Ugc2Vuc2l0aXZlKTxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICc8c3VwPiZEYWdnZXI7PC9zdXA+c3VwZXIgc2V0IFNBQk5GIG9wZXJhdG9yczo8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ1VEVCAtIHVzZXItZGVmaW5lZCB0ZXJtaW5hbDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQU5EIC0gcG9zaXRpdmUgbG9vayBhaGVhZDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnTk9UIC0gbmVnYXRpdmUgbG9vayBhaGVhZDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQktBIC0gcG9zaXRpdmUgbG9vayBiZWhpbmQ8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0JLTiAtIG5lZ2F0aXZlIGxvb2sgYmVoaW5kPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdCS1IgLSBiYWNrIHJlZmVyZW5jZTxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQUJHIC0gYW5jaG9yIC0gYmVnaW4gb2YgaW5wdXQgc3RyaW5nPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdBRU4gLSBhbmNob3IgLSBlbmQgb2YgaW5wdXQgc3RyaW5nPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICc8L3A+XFxuJztcbiAgICByZXR1cm4gZm9vdGVyO1xuICB9O1xuICB0aGlzLmluZGVudCA9IGZ1bmN0aW9uIChkZXB0aCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXB0aDsgaSArPSAxKSB7XG4gICAgICBodG1sICs9ICcuJztcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGZvcm1hdCB0aGUgVFJHIG9wZXJhdG9yICovXG4gIGNvbnN0IGRpc3BsYXlUcmcgPSBmdW5jdGlvbiAobW9kZSwgb3ApIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5UUkcpIHtcbiAgICAgIGlmIChtb2RlID09PSBNT0RFX0hFWCB8fCBtb2RlID09PSBNT0RFX1VOSUNPREUpIHtcbiAgICAgICAgbGV0IGhleCA9IG9wLm1pbi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gbW9kZSA9PT0gTU9ERV9IRVggPyAnJXgnIDogJ1UrJztcbiAgICAgICAgaHRtbCArPSBoZXg7XG4gICAgICAgIGhleCA9IG9wLm1heC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gYCZuZGFzaDske2hleH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9IGAlZCR7b3AubWluLnRvU3RyaW5nKDEwKX0mbmRhc2g7JHtvcC5tYXgudG9TdHJpbmcoMTApfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBmb3JtYXQgdGhlIFJFUCBvcGVyYXRvciAqL1xuICBjb25zdCBkaXNwbGF5UmVwID0gZnVuY3Rpb24gKG1vZGUsIG9wKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBpZiAob3AudHlwZSA9PT0gaWQuUkVQKSB7XG4gICAgICBpZiAobW9kZSA9PT0gTU9ERV9IRVgpIHtcbiAgICAgICAgbGV0IGhleCA9IG9wLm1pbi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgPSBgeCR7aGV4fWA7XG4gICAgICAgIGlmIChvcC5tYXggPCBJbmZpbml0eSkge1xuICAgICAgICAgIGhleCA9IG9wLm1heC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGV4ID0gJ2luZic7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBgJm5kYXNoOyR7aGV4fWA7XG4gICAgICB9IGVsc2UgaWYgKG9wLm1heCA8IEluZmluaXR5KSB7XG4gICAgICAgIGh0bWwgPSBgJHtvcC5taW4udG9TdHJpbmcoMTApfSZuZGFzaDske29wLm1heC50b1N0cmluZygxMCl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSBgJHtvcC5taW4udG9TdHJpbmcoMTApfSZuZGFzaDtpbmZgO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogZm9ybWF0IHRoZSBUQlMgb3BlcmF0b3IgKi9cbiAgY29uc3QgZGlzcGxheVRicyA9IGZ1bmN0aW9uIChtb2RlLCBvcCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaWYgKG9wLnR5cGUgPT09IGlkLlRCUykge1xuICAgICAgY29uc3QgbGVuID0gTWF0aC5taW4ob3Auc3RyaW5nLmxlbmd0aCwgTUFYX1RMUyAqIDIpO1xuICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEVYIHx8IG1vZGUgPT09IE1PREVfVU5JQ09ERSkge1xuICAgICAgICBodG1sICs9IG1vZGUgPT09IE1PREVfSEVYID8gJyV4JyA6ICdVKyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBsZXQgaGV4O1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaHRtbCArPSAnLic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhleCA9IG9wLnN0cmluZ1tpXS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbCArPSBoZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSAnJWQnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBodG1sICs9ICcuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbCArPSBvcC5zdHJpbmdbaV0udG9TdHJpbmcoMTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGVuIDwgb3Auc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICBodG1sICs9IFBIUkFTRV9DT05USU5VRTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGZvcm1hdCB0aGUgVExTIG9wZXJhdG9yICovXG4gIGNvbnN0IGRpc3BsYXlUbHMgPSBmdW5jdGlvbiAobW9kZSwgb3ApIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5UTFMpIHtcbiAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKG9wLnN0cmluZy5sZW5ndGgsIE1BWF9UTFMpO1xuICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEVYIHx8IG1vZGUgPT09IE1PREVfREVDKSB7XG4gICAgICAgIGxldCBjaGFydTtcbiAgICAgICAgbGV0IGNoYXJsO1xuICAgICAgICBsZXQgYmFzZTtcbiAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEVYKSB7XG4gICAgICAgICAgaHRtbCA9ICcleCc7XG4gICAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGh0bWwgPSAnJWQnO1xuICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBodG1sICs9ICcuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhcmwgPSBvcC5zdHJpbmdbaV07XG4gICAgICAgICAgaWYgKGNoYXJsID49IDk3ICYmIGNoYXJsIDw9IDEyMikge1xuICAgICAgICAgICAgY2hhcnUgPSBjaGFybCAtIDMyO1xuICAgICAgICAgICAgaHRtbCArPSBgJHtjaGFydS50b1N0cmluZyhiYXNlKX0vJHtjaGFybC50b1N0cmluZyhiYXNlKX1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFybCA+PSA2NSAmJiBjaGFybCA8PSA5MCkge1xuICAgICAgICAgICAgY2hhcnUgPSBjaGFybDtcbiAgICAgICAgICAgIGNoYXJsICs9IDMyO1xuICAgICAgICAgICAgaHRtbCArPSBgJHtjaGFydS50b1N0cmluZyhiYXNlKX0vJHtjaGFybC50b1N0cmluZyhiYXNlKX1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWwgKz0gY2hhcmwudG9TdHJpbmcoYmFzZSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA8IG9wLnN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICBodG1sICs9IFBIUkFTRV9DT05USU5VRTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9ICdcIic7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBodG1sICs9IHV0aWxzLmFzY2lpQ2hhcnNbb3Auc3RyaW5nW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuIDwgb3Auc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIGh0bWwgKz0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gJ1wiJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIGNvbnN0IHN1YlBocmFzZSA9IGZ1bmN0aW9uIChtb2RlLCBjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCwgcHJldikge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IHBocmFzZSA9ICcnO1xuICAgIGNvbnN0IGNvbW1hID0gcHJldiA/ICcsJyA6ICcnO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBNT0RFX0hFWDpcbiAgICAgICAgcGhyYXNlID0gY29tbWEgKyB1dGlscy5jaGFyc1RvSGV4KGNoYXJzQXJnLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfREVDOlxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIHJldHVybiBgLCR7dXRpbHMuY2hhcnNUb0RlYyhjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCl9YDtcbiAgICAgICAgfVxuICAgICAgICBwaHJhc2UgPSBjb21tYSArIHV0aWxzLmNoYXJzVG9EZWMoY2hhcnNBcmcsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTU9ERV9VTklDT0RFOlxuICAgICAgICBwaHJhc2UgPSB1dGlscy5jaGFyc1RvVW5pY29kZShjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNT0RFX0FTQ0lJOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcGhyYXNlID0gdXRpbHMuY2hhcnNUb0FzY2lpSHRtbChjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcGhyYXNlO1xuICB9O1xuICAvKiBkaXNwbGF5IHBocmFzZXMgbWF0Y2hlZCBpbiBsb29rLWJlaGluZCBtb2RlICovXG4gIGNvbnN0IGRpc3BsYXlCZWhpbmQgPSBmdW5jdGlvbiAobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBhbmNob3IpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGxldCBiZWcxO1xuICAgIGxldCBsZW4xO1xuICAgIGxldCBiZWcyO1xuICAgIGxldCBsZW4yO1xuICAgIGxldCBsYXN0Y2hhciA9IFBIUkFTRV9FTkQ7XG4gICAgY29uc3Qgc3BhbkJlaGluZCA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTE9PS0JFSElORH1cIj5gO1xuICAgIGNvbnN0IHNwYW5SZW1haW5kZXIgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX1JFTUFJTkRFUn1cIj5gO1xuICAgIGNvbnN0IHNwYW5lbmQgPSAnPC9zcGFuPic7XG4gICAgbGV0IHByZXYgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBodG1sICs9IFBIUkFTRV9FTVBUWTtcbiAgICAgIC8qIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBiZWcxID0gaW5kZXggLSBsZW5ndGg7XG4gICAgICAgIGxlbjEgPSBhbmNob3IgLSBiZWcxO1xuICAgICAgICBiZWcyID0gYW5jaG9yO1xuICAgICAgICBsZW4yID0gY2hhcnNBcmcubGVuZ3RoIC0gYmVnMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBzdGF0ZScpO1xuICAgIH1cbiAgICBsYXN0Y2hhciA9IFBIUkFTRV9FTkQ7XG4gICAgaWYgKGxlbjEgPiBNQVhfUEhSQVNFKSB7XG4gICAgICBsZW4xID0gTUFYX1BIUkFTRTtcbiAgICAgIGxhc3RjaGFyID0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgbGVuMiA9IDA7XG4gICAgfSBlbHNlIGlmIChsZW4xICsgbGVuMiA+IE1BWF9QSFJBU0UpIHtcbiAgICAgIGxhc3RjaGFyID0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgbGVuMiA9IE1BWF9QSFJBU0UgLSBsZW4xO1xuICAgIH1cbiAgICBpZiAobGVuMSA+IDApIHtcbiAgICAgIGh0bWwgKz0gc3BhbkJlaGluZDtcbiAgICAgIGh0bWwgKz0gc3ViUGhyYXNlKG1vZGUsIGNoYXJzQXJnLCBiZWcxLCBsZW4xLCBwcmV2KTtcbiAgICAgIGh0bWwgKz0gc3BhbmVuZDtcbiAgICAgIHByZXYgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobGVuMiA+IDApIHtcbiAgICAgIGh0bWwgKz0gc3BhblJlbWFpbmRlcjtcbiAgICAgIGh0bWwgKz0gc3ViUGhyYXNlKG1vZGUsIGNoYXJzQXJnLCBiZWcyLCBsZW4yLCBwcmV2KTtcbiAgICAgIGh0bWwgKz0gc3BhbmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWwgKyBsYXN0Y2hhcjtcbiAgfTtcbiAgY29uc3QgZGlzcGxheUZvcndhcmQgPSBmdW5jdGlvbiAobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBzcGFuQWhlYWQpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGxldCBiZWcxO1xuICAgIGxldCBsZW4xO1xuICAgIGxldCBiZWcyO1xuICAgIGxldCBsZW4yO1xuICAgIGxldCBsYXN0Y2hhciA9IFBIUkFTRV9FTkQ7XG4gICAgY29uc3Qgc3BhblJlbWFpbmRlciA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfUkVNQUlOREVSfVwiPmA7XG4gICAgY29uc3Qgc3BhbmVuZCA9ICc8L3NwYW4+JztcbiAgICBsZXQgcHJldiA9IGZhbHNlO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGh0bWwgKz0gUEhSQVNFX0VNUFRZO1xuICAgICAgLyogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYmVnMSA9IGluZGV4O1xuICAgICAgICBsZW4xID0gMDtcbiAgICAgICAgYmVnMiA9IGluZGV4O1xuICAgICAgICBsZW4yID0gY2hhcnNBcmcubGVuZ3RoIC0gYmVnMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBiZWcxID0gaW5kZXg7XG4gICAgICAgIGxlbjEgPSBsZW5ndGg7XG4gICAgICAgIGJlZzIgPSBpbmRleCArIGxlbjE7XG4gICAgICAgIGxlbjIgPSBjaGFyc0FyZy5sZW5ndGggLSBiZWcyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHN0YXRlJyk7XG4gICAgfVxuICAgIGxhc3RjaGFyID0gUEhSQVNFX0VORDtcbiAgICBpZiAobGVuMSA+IE1BWF9QSFJBU0UpIHtcbiAgICAgIGxlbjEgPSBNQVhfUEhSQVNFO1xuICAgICAgbGFzdGNoYXIgPSBQSFJBU0VfQ09OVElOVUU7XG4gICAgICBsZW4yID0gMDtcbiAgICB9IGVsc2UgaWYgKGxlbjEgKyBsZW4yID4gTUFYX1BIUkFTRSkge1xuICAgICAgbGFzdGNoYXIgPSBQSFJBU0VfQ09OVElOVUU7XG4gICAgICBsZW4yID0gTUFYX1BIUkFTRSAtIGxlbjE7XG4gICAgfVxuICAgIGlmIChsZW4xID4gMCkge1xuICAgICAgaHRtbCArPSBzcGFuQWhlYWQ7XG4gICAgICBodG1sICs9IHN1YlBocmFzZShtb2RlLCBjaGFyc0FyZywgYmVnMSwgbGVuMSwgcHJldik7XG4gICAgICBodG1sICs9IHNwYW5lbmQ7XG4gICAgICBwcmV2ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxlbjIgPiAwKSB7XG4gICAgICBodG1sICs9IHNwYW5SZW1haW5kZXI7XG4gICAgICBodG1sICs9IHN1YlBocmFzZShtb2RlLCBjaGFyc0FyZywgYmVnMiwgbGVuMiwgcHJldik7XG4gICAgICBodG1sICs9IHNwYW5lbmQ7XG4gICAgfVxuICAgIHJldHVybiBodG1sICsgbGFzdGNoYXI7XG4gIH07XG4gIC8qIGRpc3BsYXkgcGhyYXNlcyBtYXRjaGVkIGluIGxvb2stYWhlYWQgbW9kZSAqL1xuICBjb25zdCBkaXNwbGF5QWhlYWQgPSBmdW5jdGlvbiAobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgY29uc3Qgc3BhbkFoZWFkID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQUhFQUR9XCI+YDtcbiAgICByZXR1cm4gZGlzcGxheUZvcndhcmQobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBzcGFuQWhlYWQpO1xuICB9O1xuICAvKiBkaXNwbGF5IHBocmFzZXMgbWF0Y2hlZCBpbiBub3JtYWwgcGFyc2luZyBtb2RlICovXG4gIGNvbnN0IGRpc3BsYXlOb25lID0gZnVuY3Rpb24gKG1vZGUsIGNoYXJzQXJnLCBzdGF0ZSwgaW5kZXgsIGxlbmd0aCkge1xuICAgIGNvbnN0IHNwYW5BaGVhZCA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+YDtcbiAgICByZXR1cm4gZGlzcGxheUZvcndhcmQobW9kZSwgY2hhcnNBcmcsIHN0YXRlLCBpbmRleCwgbGVuZ3RoLCBzcGFuQWhlYWQpO1xuICB9O1xuICAvKiBSZXR1cm5zIHRoZSBmaWx0ZXJlZCByZWNvcmRzLCBmb3JtYXR0ZWQgYXMgYW4gSFRNTCB0YWJsZS4gKi9cbiAgY29uc3QgaHRtbFRhYmxlID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICBpZiAocnVsZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBsZXQgdGhpc0xpbmU7XG4gICAgbGV0IHRoYXRMaW5lO1xuICAgIGxldCBsb29rQWhlYWQ7XG4gICAgbGV0IGxvb2tCZWhpbmQ7XG4gICAgbGV0IGxvb2tBcm91bmQ7XG4gICAgbGV0IGFuY2hvcjtcbiAgICBodG1sICs9ICc8dHI+PHRoPihhKTwvdGg+PHRoPihiKTwvdGg+PHRoPihjKTwvdGg+PHRoPihkKTwvdGg+PHRoPihlKTwvdGg+PHRoPihmKTwvdGg+JztcbiAgICBodG1sICs9ICc8dGg+b3BlcmF0b3I8L3RoPjx0aD5waHJhc2U8L3RoPjwvdHI+XFxuJztcbiAgICBjaXJjdWxhci5mb3JFYWNoKChsaW5lSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGxpbmUgPSByZWNvcmRzW2xpbmVJbmRleF07XG4gICAgICB0aGlzTGluZSA9IGxpbmUudGhpc0xpbmU7XG4gICAgICB0aGF0TGluZSA9IGxpbmUudGhhdExpbmUgIT09IHVuZGVmaW5lZCA/IGxpbmUudGhhdExpbmUgOiAnLS0nO1xuICAgICAgbG9va0FoZWFkID0gZmFsc2U7XG4gICAgICBsb29rQmVoaW5kID0gZmFsc2U7XG4gICAgICBsb29rQXJvdW5kID0gZmFsc2U7XG4gICAgICBpZiAobGluZS5sb29rQXJvdW5kID09PSBpZC5MT09LQVJPVU5EX0FIRUFEKSB7XG4gICAgICAgIGxvb2tBaGVhZCA9IHRydWU7XG4gICAgICAgIGxvb2tBcm91bmQgPSB0cnVlO1xuICAgICAgICBhbmNob3IgPSBsaW5lLmxvb2tBbmNob3I7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuQU5EIHx8IGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLk5PVCkge1xuICAgICAgICBsb29rQWhlYWQgPSB0cnVlO1xuICAgICAgICBsb29rQXJvdW5kID0gdHJ1ZTtcbiAgICAgICAgYW5jaG9yID0gbGluZS5waHJhc2VJbmRleDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLmxvb2tBcm91bmQgPT09IGlkLkxPT0tBUk9VTkRfQkVISU5EKSB7XG4gICAgICAgIGxvb2tCZWhpbmQgPSB0cnVlO1xuICAgICAgICBsb29rQXJvdW5kID0gdHJ1ZTtcbiAgICAgICAgYW5jaG9yID0gbGluZS5sb29rQW5jaG9yO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLkJLQSB8fCBsaW5lLm9wY29kZS50eXBlID09PSBpZC5CS04pIHtcbiAgICAgICAgbG9va0JlaGluZCA9IHRydWU7XG4gICAgICAgIGxvb2tBcm91bmQgPSB0cnVlO1xuICAgICAgICBhbmNob3IgPSBsaW5lLnBocmFzZUluZGV4O1xuICAgICAgfVxuICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICBodG1sICs9IGA8dGQ+JHt0aGlzTGluZX08L3RkPjx0ZD4ke3RoYXRMaW5lfTwvdGQ+YDtcbiAgICAgIGh0bWwgKz0gYDx0ZD4ke2xpbmUucGhyYXNlSW5kZXh9PC90ZD5gO1xuICAgICAgaHRtbCArPSBgPHRkPiR7bGluZS5waHJhc2VMZW5ndGh9PC90ZD5gO1xuICAgICAgaHRtbCArPSBgPHRkPiR7bGluZS5kZXB0aH08L3RkPmA7XG4gICAgICBodG1sICs9ICc8dGQ+JztcbiAgICAgIHN3aXRjaCAobGluZS5zdGF0ZSkge1xuICAgICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiZkYXJyOyZuYnNwOzwvc3Bhbj5gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj4mdWFycjtNPC9zcGFuPmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4mdWFycjtOPC9zcGFuPmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiZ1YXJyO0U8L3NwYW4+YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPi0tPC9zcGFuPmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBodG1sICs9ICc8L3RkPic7XG4gICAgICBodG1sICs9ICc8dGQ+JztcbiAgICAgIGh0bWwgKz0gdGhhdC5pbmRlbnQobGluZS5kZXB0aCk7XG4gICAgICBpZiAobG9va0FoZWFkKSB7XG4gICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQUhFQUR9XCI+YDtcbiAgICAgIH0gZWxzZSBpZiAobG9va0JlaGluZCkge1xuICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTE9PS0JFSElORH1cIj5gO1xuICAgICAgfVxuICAgICAgaHRtbCArPSB1dGlscy5vcGNvZGVUb1N0cmluZyhsaW5lLm9wY29kZS50eXBlKTtcbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5STk0pIHtcbiAgICAgICAgaHRtbCArPSBgKCR7cnVsZXNbbGluZS5vcGNvZGUuaW5kZXhdLm5hbWV9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLkJLUikge1xuICAgICAgICBjb25zdCBjYXNldHlwZSA9IGxpbmUub3Bjb2RlLmJrckNhc2UgPT09IGlkLkJLUl9NT0RFX0NJID8gJyVpJyA6ICclcyc7XG4gICAgICAgIGNvbnN0IG1vZGV0eXBlID0gbGluZS5vcGNvZGUuYmtyTW9kZSA9PT0gaWQuQktSX01PREVfVU0gPyAnJXUnIDogJyVwJztcbiAgICAgICAgaHRtbCArPSBgKFxcXFwke2Nhc2V0eXBlfSR7bW9kZXR5cGV9JHtydWxlc1tsaW5lLm9wY29kZS5pbmRleF0ubmFtZX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuVURUKSB7XG4gICAgICAgIGh0bWwgKz0gYCgke3VkdHNbbGluZS5vcGNvZGUuaW5kZXhdLm5hbWV9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLlRSRykge1xuICAgICAgICBodG1sICs9IGAoJHtkaXNwbGF5VHJnKG1vZGUsIGxpbmUub3Bjb2RlKX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuVEJTKSB7XG4gICAgICAgIGh0bWwgKz0gYCgke2Rpc3BsYXlUYnMobW9kZSwgbGluZS5vcGNvZGUpfSkgYDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5UTFMpIHtcbiAgICAgICAgaHRtbCArPSBgKCR7ZGlzcGxheVRscyhtb2RlLCBsaW5lLm9wY29kZSl9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLlJFUCkge1xuICAgICAgICBodG1sICs9IGAoJHtkaXNwbGF5UmVwKG1vZGUsIGxpbmUub3Bjb2RlKX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobG9va0Fyb3VuZCkge1xuICAgICAgICBodG1sICs9ICc8L3NwYW4+JztcbiAgICAgIH1cbiAgICAgIGh0bWwgKz0gJzwvdGQ+JztcbiAgICAgIGh0bWwgKz0gJzx0ZD4nO1xuICAgICAgaWYgKGxvb2tCZWhpbmQpIHtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5QmVoaW5kKG1vZGUsIGNoYXJzLCBsaW5lLnN0YXRlLCBsaW5lLnBocmFzZUluZGV4LCBsaW5lLnBocmFzZUxlbmd0aCwgYW5jaG9yKTtcbiAgICAgIH0gZWxzZSBpZiAobG9va0FoZWFkKSB7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheUFoZWFkKG1vZGUsIGNoYXJzLCBsaW5lLnN0YXRlLCBsaW5lLnBocmFzZUluZGV4LCBsaW5lLnBocmFzZUxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlOb25lKG1vZGUsIGNoYXJzLCBsaW5lLnN0YXRlLCBsaW5lLnBocmFzZUluZGV4LCBsaW5lLnBocmFzZUxlbmd0aCk7XG4gICAgICB9XG4gICAgICBodG1sICs9ICc8L3RkPjwvdHI+XFxuJztcbiAgICB9KTtcbiAgICBodG1sICs9ICc8dHI+PHRoPihhKTwvdGg+PHRoPihiKTwvdGg+PHRoPihjKTwvdGg+PHRoPihkKTwvdGg+PHRoPihlKTwvdGg+PHRoPihmKTwvdGg+JztcbiAgICBodG1sICs9ICc8dGg+b3BlcmF0b3I8L3RoPjx0aD5waHJhc2U8L3RoPjwvdHI+XFxuJztcbiAgICBodG1sICs9ICc8L3RhYmxlPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8vIFRyYW5zbGF0ZSB0aGUgdHJhY2UgcmVjb3JkcyB0byBIVE1MIGZvcm1hdC5cbiAgLy8gLSAqbW9kZWFyZyogLSBjYW4gYmUgYFwiYXNjaWlcImAsIGBcImRlY2ltYWxcImAsIGBcImhleGFkZWNpbWFsXCJgIG9yIGBcInVuaWNvZGVcImAuXG4gIC8vIERldGVybWluZXMgdGhlIGZvcm1hdCBvZiB0aGUgc3RyaW5nIGNoYXJhY3RlciBjb2RlIGRpc3BsYXkuXG4gIC8vIC0gKmNhcHRpb24qIC0gb3B0aW9uYWwgY2FwdGlvbiBmb3IgdGhlIEhUTUwgdGFibGUuXG4gIHRoaXMudG9IdG1sID0gZnVuY3Rpb24gKG1vZGVhcmcsIGNhcHRpb24pIHtcbiAgICAvKiB3cml0ZXMgdGhlIHRyYWNlIHJlY29yZHMgYXMgYSB0YWJsZSBpbiBhIGNvbXBsZXRlIGh0bWwgcGFnZSAqL1xuICAgIGxldCBtb2RlID0gTU9ERV9BU0NJSTtcbiAgICBpZiAodHlwZW9mIG1vZGVhcmcgPT09ICdzdHJpbmcnICYmIG1vZGVhcmcubGVuZ3RoID49IDMpIHtcbiAgICAgIGNvbnN0IG1vZGVpbiA9IG1vZGVhcmcudG9Mb3dlckNhc2UoKS5zbGljZSgwLCAzKTtcbiAgICAgIGlmIChtb2RlaW4gPT09ICdoZXgnKSB7XG4gICAgICAgIG1vZGUgPSBNT0RFX0hFWDtcbiAgICAgIH0gZWxzZSBpZiAobW9kZWluID09PSAnZGVjJykge1xuICAgICAgICBtb2RlID0gTU9ERV9ERUM7XG4gICAgICB9IGVsc2UgaWYgKG1vZGVpbiA9PT0gJ3VuaScpIHtcbiAgICAgICAgbW9kZSA9IE1PREVfVU5JQ09ERTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBodG1sICs9IGh0bWxIZWFkZXIobW9kZSwgY2FwdGlvbik7XG4gICAgaHRtbCArPSBodG1sVGFibGUobW9kZSk7XG4gICAgaHRtbCArPSBodG1sRm9vdGVyKCk7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJleHBvcnRUcmFjZSIsInV0aWxzIiwicmVxdWlyZSIsInN0eWxlIiwiY2lyY3VsYXIiLCJpZCIsInRoaXNGaWxlTmFtZSIsInRoYXQiLCJNT0RFX0hFWCIsIk1PREVfREVDIiwiTU9ERV9BU0NJSSIsIk1PREVfVU5JQ09ERSIsIk1BWF9QSFJBU0UiLCJNQVhfVExTIiwicmVjb3JkcyIsIm1heFJlY29yZHMiLCJsYXN0UmVjb3JkIiwiZmlsdGVyZWRSZWNvcmRzIiwidHJlZURlcHRoIiwicmVjb3JkU3RhY2siLCJjaGFycyIsInJ1bGVzIiwidWR0cyIsIm9wZXJhdG9yRmlsdGVyIiwicnVsZUZpbHRlciIsIlBIUkFTRV9FTkQiLCJDTEFTU19MSU5FRU5EIiwiUEhSQVNFX0NPTlRJTlVFIiwiUEhSQVNFX0VNUFRZIiwiQ0xBU1NfRU1QVFkiLCJpbml0T3BlcmF0b3JGaWx0ZXIiLCJzZXRPcGVyYXRvcnMiLCJzZXQiLCJBTFQiLCJDQVQiLCJSRVAiLCJUTFMiLCJUQlMiLCJUUkciLCJBTkQiLCJOT1QiLCJCS1IiLCJCS0EiLCJCS04iLCJBQkciLCJBRU4iLCJpdGVtcyIsIm5hbWUiLCJmaWx0ZXIiLCJvcGVyYXRvcnMiLCJ1cHBlciIsInRvVXBwZXJDYXNlIiwiRXJyb3IiLCJpbml0UnVsZUZpbHRlciIsInNldFJ1bGVzIiwiUk5NIiwiVURUIiwiY291bnQiLCJsZW5ndGgiLCJpIiwicHVzaCIsImxpc3QiLCJsb3dlciIsInRvTG93ZXJDYXNlIiwiaW5kZXhPZiIsInRyYWNlT2JqZWN0Iiwic2V0TWF4UmVjb3JkcyIsIm1heCIsImxhc3QiLCJNYXRoIiwiY2VpbCIsImZsb29yIiwiZ2V0TWF4UmVjb3JkcyIsImdldExhc3RSZWNvcmQiLCJpbml0IiwicnVsZXNJbiIsInVkdHNJbiIsImNoYXJzSW4iLCJmaWx0ZXJPcHMiLCJvcCIsInJldCIsInR5cGUiLCJpbmRleCIsImZpbHRlclJlY29yZHMiLCJyZWNvcmQiLCJkb3duIiwic3RhdGUiLCJvZmZzZXQiLCJhbmNob3IiLCJsb29rQXJvdW5kIiwiaW5jcmVtZW50IiwiZGlyVXAiLCJkZXB0aCIsInRoaXNMaW5lIiwidGhhdExpbmUiLCJ1bmRlZmluZWQiLCJvcGNvZGUiLCJwaHJhc2VJbmRleCIsInBocmFzZUxlbmd0aCIsImxvb2tBbmNob3IiLCJ1cCIsInBvcCIsInRoYXRSZWNvcmQiLCJnZXRMaXN0SW5kZXgiLCJ0b1RyZWVPYmoiLCJub2RlT3Bjb2RlIiwibm9kZSIsImNhc2V0eXBlIiwibW9kZXR5cGUiLCJvcGNvZGVUb1N0cmluZyIsIm9wRGF0YSIsImJrckNhc2UiLCJCS1JfTU9ERV9DSSIsImJrck1vZGUiLCJCS1JfTU9ERV9VTSIsInN0cmluZyIsIm1pbiIsIm5vZGVQaHJhc2UiLCJNQVRDSCIsIk5PTUFUQ0giLCJFTVBUWSIsIm5vZGVJZCIsIm5vZGVEb3duIiwicGFyZW50IiwiYnJhbmNoIiwiY2hpbGRyZW4iLCJzdGF0ZVRvU3RyaW5nIiwicGhyYXNlIiwibm9kZVVwIiwibGVhZk5vZGVzIiwiYnJhbmNoQ291bnQiLCJ3YWxrIiwibGVmdE1vc3QiLCJyaWdodE1vc3QiLCJkaXNwbGF5Iiwib2JqIiwiQXJyYXkiLCJpc0FycmF5IiwiYyIsInJvb3QiLCJmaXJzdFJlY29yZCIsImR1bW15IiwiZm9yRWFjaCIsImxpbmVJbmRleCIsIm51bSIsInByZXYiLCJBQ1RJVkUiLCJicmFuY2hlc0luY29tcGxldGUiLCJ0cmVlIiwidG9UcmVlIiwic3RyaW5naWZ5IiwiSlNPTiIsInRvSHRtbFBhZ2UiLCJtb2RlIiwiY2FwdGlvbiIsInRpdGxlIiwiaHRtbFRvUGFnZSIsInRvSHRtbCIsImh0bWxIZWFkZXIiLCJtb2RlTmFtZSIsImhlYWRlciIsIkNMQVNTX1RSQUNFIiwiaHRtbEZvb3RlciIsImZvb3RlciIsIkNMQVNTX01PTk9TUEFDRSIsIkNMQVNTX0FDVElWRSIsIkNMQVNTX01BVENIIiwiQ0xBU1NfTk9NQVRDSCIsIkNMQVNTX0xPT0tBSEVBRCIsIkNMQVNTX0xPT0tCRUhJTkQiLCJDTEFTU19SRU1BSU5ERVIiLCJDTEFTU19DVFJMQ0hBUiIsImluZGVudCIsImh0bWwiLCJkaXNwbGF5VHJnIiwiaGV4IiwidG9TdHJpbmciLCJkaXNwbGF5UmVwIiwiSW5maW5pdHkiLCJkaXNwbGF5VGJzIiwibGVuIiwiZGlzcGxheVRscyIsImNoYXJ1IiwiY2hhcmwiLCJiYXNlIiwiYXNjaWlDaGFycyIsInN1YlBocmFzZSIsImNoYXJzQXJnIiwiY29tbWEiLCJjaGFyc1RvSGV4IiwiY2hhcnNUb0RlYyIsImNoYXJzVG9Vbmljb2RlIiwiY2hhcnNUb0FzY2lpSHRtbCIsImRpc3BsYXlCZWhpbmQiLCJiZWcxIiwibGVuMSIsImJlZzIiLCJsZW4yIiwibGFzdGNoYXIiLCJzcGFuQmVoaW5kIiwic3BhblJlbWFpbmRlciIsInNwYW5lbmQiLCJkaXNwbGF5Rm9yd2FyZCIsInNwYW5BaGVhZCIsImRpc3BsYXlBaGVhZCIsImRpc3BsYXlOb25lIiwiaHRtbFRhYmxlIiwibG9va0FoZWFkIiwibG9va0JlaGluZCIsImxpbmUiLCJMT09LQVJPVU5EX0FIRUFEIiwiTE9PS0FST1VORF9CRUhJTkQiLCJtb2RlYXJnIiwibW9kZWluIiwic2xpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/trace.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* eslint-disable func-names */ /*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */ // This module exports a variety of utility functions that support\n// [`apg`](https://github.com/ldthomas/apg-js2), [`apg-lib`](https://github.com/ldthomas/apg-js2-lib)\n// and the generated parser applications.\nconst style = __webpack_require__(/*! ./style */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/style.js\");\nconst converter = __webpack_require__(/*! ../apg-conv-api/converter */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-conv-api/converter.js\");\nconst emitCss = __webpack_require__(/*! ./emitcss */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/emitcss.js\");\nconst id = __webpack_require__(/*! ./identifiers */ \"(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/identifiers.js\");\nconst thisFileName = \"utilities.js: \";\n/* translate (implied) phrase beginning character and length to actual first and last character indexes */ /* used by multiple phrase handling functions */ const getBounds = function(length, begArg, len) {\n    let end;\n    let beg = begArg;\n    const TRUE = true;\n    while(TRUE){\n        if (length <= 0) {\n            beg = 0;\n            end = 0;\n            break;\n        }\n        if (typeof beg !== \"number\") {\n            beg = 0;\n            end = length;\n            break;\n        }\n        if (beg >= length) {\n            beg = length;\n            end = length;\n            break;\n        }\n        if (typeof len !== \"number\") {\n            end = length;\n            break;\n        }\n        end = beg + len;\n        if (end > length) {\n            end = length;\n            break;\n        }\n        break;\n    }\n    return {\n        beg,\n        end\n    };\n};\n// Generates a complete, minimal HTML5 page, inserting the user's HTML text on the page.\n// - *html* - the page text in HTML format\n// - *title* - the HTML page `<title>` - defaults to `htmlToPage`.\nexports.htmlToPage = function(html, titleArg) {\n    let title;\n    if (typeof html !== \"string\") {\n        throw new Error(`${thisFileName}htmlToPage: input HTML is not a string`);\n    }\n    if (typeof titleArg !== \"string\") {\n        title = \"htmlToPage\";\n    } else {\n        title = titleArg;\n    }\n    let page = \"\";\n    page += \"<!DOCTYPE html>\\n\";\n    page += '<html lang=\"en\">\\n';\n    page += \"<head>\\n\";\n    page += '<meta charset=\"utf-8\">\\n';\n    page += `<title>${title}</title>\\n`;\n    page += \"<style>\\n\";\n    page += emitCss();\n    page += \"</style>\\n\";\n    page += \"</head>\\n<body>\\n\";\n    page += `<p>${new Date()}</p>\\n`;\n    page += html;\n    page += \"</body>\\n</html>\\n\";\n    return page;\n};\n// Formats the returned object from `parser.parse()`\n// into an HTML table.\n// ```\n// return {\n//   success : sysData.success,\n//   state : sysData.state,\n//   length : charsLength,\n//   matched : sysData.phraseLength,\n//   maxMatched : maxMatched,\n//   maxTreeDepth : maxTreeDepth,\n//   nodeHits : nodeHits,\n//   inputLength : chars.length,\n//   subBegin : charsBegin,\n//   subEnd : charsEnd,\n//   subLength : charsLength\n// };\n// ```\nexports.parserResultToHtml = function(result, caption) {\n    let cap = null;\n    if (typeof caption === \"string\" && caption !== \"\") {\n        cap = caption;\n    }\n    let success;\n    let state;\n    if (result.success === true) {\n        success = `<span class=\"${style.CLASS_MATCH}\">true</span>`;\n    } else {\n        success = `<span class=\"${style.CLASS_NOMATCH}\">false</span>`;\n    }\n    if (result.state === id.EMPTY) {\n        state = `<span class=\"${style.CLASS_EMPTY}\">EMPTY</span>`;\n    } else if (result.state === id.MATCH) {\n        state = `<span class=\"${style.CLASS_MATCH}\">MATCH</span>`;\n    } else if (result.state === id.NOMATCH) {\n        state = `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span>`;\n    } else {\n        state = `<span class=\"${style.CLASS_NOMATCH}\">unrecognized</span>`;\n    }\n    let html = \"\";\n    html += `<table class=\"${style.CLASS_STATE}\">\\n`;\n    if (cap) {\n        html += `<caption>${cap}</caption>\\n`;\n    }\n    html += \"<tr><th>state item</th><th>value</th><th>description</th></tr>\\n\";\n    html += `<tr><td>parser success</td><td>${success}</td>\\n`;\n    html += `<td><span class=\"${style.CLASS_MATCH}\">true</span> if the parse succeeded,\\n`;\n    html += ` <span class=\"${style.CLASS_NOMATCH}\">false</span> otherwise`;\n    html += \"<br><i>NOTE: for success, entire string must be matched</i></td></tr>\\n\";\n    html += `<tr><td>parser state</td><td>${state}</td>\\n`;\n    html += `<td><span class=\"${style.CLASS_EMPTY}\">EMPTY</span>, `;\n    html += `<span class=\"${style.CLASS_MATCH}\">MATCH</span> or \\n`;\n    html += `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span></td></tr>\\n`;\n    html += `<tr><td>string length</td><td>${result.length}</td><td>length of the input (sub)string</td></tr>\\n`;\n    html += `<tr><td>matched length</td><td>${result.matched}</td><td>number of input string characters matched</td></tr>\\n`;\n    html += `<tr><td>max matched</td><td>${result.maxMatched}</td><td>maximum number of input string characters matched</td></tr>\\n`;\n    html += `<tr><td>max tree depth</td><td>${result.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>\\n`;\n    html += `<tr><td>node hits</td><td>${result.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>\\n`;\n    html += `<tr><td>input length</td><td>${result.inputLength}</td><td>length of full input string</td></tr>\\n`;\n    html += `<tr><td>sub-string begin</td><td>${result.subBegin}</td><td>sub-string first character index</td></tr>\\n`;\n    html += `<tr><td>sub-string end</td><td>${result.subEnd}</td><td>sub-string end-of-string index</td></tr>\\n`;\n    html += `<tr><td>sub-string length</td><td>${result.subLength}</td><td>sub-string length</td></tr>\\n`;\n    html += \"</table>\\n\";\n    return html;\n};\n// Translates a sub-array of integer character codes into a string.\n// Very useful in callback functions to translate the matched phrases into strings.\nexports.charsToString = function(chars, phraseIndex, phraseLength) {\n    let beg;\n    let end;\n    if (typeof phraseIndex === \"number\") {\n        if (phraseIndex >= chars.length) {\n            return \"\";\n        }\n        beg = phraseIndex < 0 ? 0 : phraseIndex;\n    } else {\n        beg = 0;\n    }\n    if (typeof phraseLength === \"number\") {\n        if (phraseLength <= 0) {\n            return \"\";\n        }\n        end = phraseLength > chars.length - beg ? chars.length : beg + phraseLength;\n    } else {\n        end = chars.length;\n    }\n    if (beg < end) {\n        return converter.encode(\"UTF16LE\", chars.slice(beg, end)).toString(\"utf16le\");\n    }\n    return \"\";\n};\n// Translates a string into an array of integer character codes.\nexports.stringToChars = function(string) {\n    return converter.decode(\"STRING\", string);\n};\n// Translates an opcode identifier into a human-readable string.\nexports.opcodeToString = function(type) {\n    let ret = \"unknown\";\n    switch(type){\n        case id.ALT:\n            ret = \"ALT\";\n            break;\n        case id.CAT:\n            ret = \"CAT\";\n            break;\n        case id.RNM:\n            ret = \"RNM\";\n            break;\n        case id.UDT:\n            ret = \"UDT\";\n            break;\n        case id.AND:\n            ret = \"AND\";\n            break;\n        case id.NOT:\n            ret = \"NOT\";\n            break;\n        case id.REP:\n            ret = \"REP\";\n            break;\n        case id.TRG:\n            ret = \"TRG\";\n            break;\n        case id.TBS:\n            ret = \"TBS\";\n            break;\n        case id.TLS:\n            ret = \"TLS\";\n            break;\n        case id.BKR:\n            ret = \"BKR\";\n            break;\n        case id.BKA:\n            ret = \"BKA\";\n            break;\n        case id.BKN:\n            ret = \"BKN\";\n            break;\n        case id.ABG:\n            ret = \"ABG\";\n            break;\n        case id.AEN:\n            ret = \"AEN\";\n            break;\n        default:\n            throw new Error(\"unrecognized opcode\");\n    }\n    return ret;\n};\n// Translates an state identifier into a human-readable string.\nexports.stateToString = function(state) {\n    let ret = \"unknown\";\n    switch(state){\n        case id.ACTIVE:\n            ret = \"ACTIVE\";\n            break;\n        case id.MATCH:\n            ret = \"MATCH\";\n            break;\n        case id.EMPTY:\n            ret = \"EMPTY\";\n            break;\n        case id.NOMATCH:\n            ret = \"NOMATCH\";\n            break;\n        default:\n            throw new Error(\"unrecognized state\");\n    }\n    return ret;\n};\n// Array which translates all 128, 7-bit ASCII character codes to their respective HTML format.\nexports.asciiChars = [\n    \"NUL\",\n    \"SOH\",\n    \"STX\",\n    \"ETX\",\n    \"EOT\",\n    \"ENQ\",\n    \"ACK\",\n    \"BEL\",\n    \"BS\",\n    \"TAB\",\n    \"LF\",\n    \"VT\",\n    \"FF\",\n    \"CR\",\n    \"SO\",\n    \"SI\",\n    \"DLE\",\n    \"DC1\",\n    \"DC2\",\n    \"DC3\",\n    \"DC4\",\n    \"NAK\",\n    \"SYN\",\n    \"ETB\",\n    \"CAN\",\n    \"EM\",\n    \"SUB\",\n    \"ESC\",\n    \"FS\",\n    \"GS\",\n    \"RS\",\n    \"US\",\n    \"&nbsp;\",\n    \"!\",\n    \"&#34;\",\n    \"#\",\n    \"$\",\n    \"%\",\n    \"&#38;\",\n    \"&#39;\",\n    \"(\",\n    \")\",\n    \"*\",\n    \"+\",\n    \",\",\n    \"-\",\n    \".\",\n    \"/\",\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \":\",\n    \";\",\n    \"&#60;\",\n    \"=\",\n    \"&#62;\",\n    \"?\",\n    \"@\",\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\",\n    \"G\",\n    \"H\",\n    \"I\",\n    \"J\",\n    \"K\",\n    \"L\",\n    \"M\",\n    \"N\",\n    \"O\",\n    \"P\",\n    \"Q\",\n    \"R\",\n    \"S\",\n    \"T\",\n    \"U\",\n    \"V\",\n    \"W\",\n    \"X\",\n    \"Y\",\n    \"Z\",\n    \"[\",\n    \"&#92;\",\n    \"]\",\n    \"^\",\n    \"_\",\n    \"`\",\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"q\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"{\",\n    \"|\",\n    \"}\",\n    \"~\",\n    \"DEL\"\n];\n// Translates a single character to hexadecimal with leading zeros for 2, 4, or 8 digit display.\nexports.charToHex = function(char) {\n    let ch = char.toString(16).toUpperCase();\n    switch(ch.length){\n        case 1:\n        case 3:\n        case 7:\n            ch = `0${ch}`;\n            break;\n        case 2:\n        case 6:\n            ch = `00${ch}`;\n            break;\n        case 4:\n            break;\n        case 5:\n            ch = `000${ch}`;\n            break;\n        default:\n            throw new Error(\"unrecognized option\");\n    }\n    return ch;\n};\n// Translates a sub-array of character codes to decimal display format.\nexports.charsToDec = function(chars, beg, len) {\n    let ret = \"\";\n    if (!Array.isArray(chars)) {\n        throw new Error(`${thisFileName}charsToDec: input must be an array of integers`);\n    }\n    const bounds = getBounds(chars.length, beg, len);\n    if (bounds.end > bounds.beg) {\n        ret += chars[bounds.beg];\n        for(let i = bounds.beg + 1; i < bounds.end; i += 1){\n            ret += `,${chars[i]}`;\n        }\n    }\n    return ret;\n};\n// Translates a sub-array of character codes to hexadecimal display format.\nexports.charsToHex = function(chars, beg, len) {\n    let ret = \"\";\n    if (!Array.isArray(chars)) {\n        throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n    }\n    const bounds = getBounds(chars.length, beg, len);\n    if (bounds.end > bounds.beg) {\n        ret += `\\\\x${exports.charToHex(chars[bounds.beg])}`;\n        for(let i = bounds.beg + 1; i < bounds.end; i += 1){\n            ret += `,\\\\x${exports.charToHex(chars[i])}`;\n        }\n    }\n    return ret;\n};\nexports.charsToHtmlEntities = function(chars, beg, len) {\n    let ret = \"\";\n    if (!Array.isArray(chars)) {\n        throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n    }\n    const bounds = getBounds(chars.length, beg, len);\n    if (bounds.end > bounds.beg) {\n        for(let i = bounds.beg; i < bounds.end; i += 1){\n            ret += `&#x${chars[i].toString(16)};`;\n        }\n    }\n    return ret;\n};\n// Translates a sub-array of character codes to Unicode display format.\nfunction isUnicode(char) {\n    if (char >= 0xd800 && char <= 0xdfff) {\n        return false;\n    }\n    if (char > 0x10ffff) {\n        return false;\n    }\n    return true;\n}\nexports.charsToUnicode = function(chars, beg, len) {\n    let ret = \"\";\n    if (!Array.isArray(chars)) {\n        throw new Error(`${thisFileName}charsToUnicode: input must be an array of integers`);\n    }\n    const bounds = getBounds(chars.length, beg, len);\n    if (bounds.end > bounds.beg) {\n        for(let i = bounds.beg; i < bounds.end; i += 1){\n            if (isUnicode(chars[i])) {\n                ret += `&#${chars[i]};`;\n            } else {\n                ret += ` U+${exports.charToHex(chars[i])}`;\n            }\n        }\n    }\n    return ret;\n};\n// Translates a sub-array of character codes to JavaScript Unicode display format (`\\uXXXX`).\nexports.charsToJsUnicode = function(chars, beg, len) {\n    let ret = \"\";\n    if (!Array.isArray(chars)) {\n        throw new Error(`${thisFileName}charsToJsUnicode: input must be an array of integers`);\n    }\n    const bounds = getBounds(chars.length, beg, len);\n    if (bounds.end > bounds.beg) {\n        ret += `\\\\u${exports.charToHex(chars[bounds.beg])}`;\n        for(let i = bounds.beg + 1; i < bounds.end; i += 1){\n            ret += `,\\\\u${exports.charToHex(chars[i])}`;\n        }\n    }\n    return ret;\n};\n// Translates a sub-array of character codes to printing ASCII character display format.\nexports.charsToAscii = function(chars, beg, len) {\n    let ret = \"\";\n    if (!Array.isArray(chars)) {\n        throw new Error(`${thisFileName}charsToAscii: input must be an array of integers`);\n    }\n    const bounds = getBounds(chars.length, beg, len);\n    for(let i = bounds.beg; i < bounds.end; i += 1){\n        const char = chars[i];\n        if (char >= 32 && char <= 126) {\n            ret += String.fromCharCode(char);\n        } else {\n            ret += `\\\\x${exports.charToHex(char)}`;\n        }\n    }\n    return ret;\n};\n// Translates a sub-array of character codes to HTML display format.\nexports.charsToAsciiHtml = function(chars, beg, len) {\n    if (!Array.isArray(chars)) {\n        throw new Error(`${thisFileName}charsToAsciiHtml: input must be an array of integers`);\n    }\n    let html = \"\";\n    let char;\n    const bounds = getBounds(chars.length, beg, len);\n    for(let i = bounds.beg; i < bounds.end; i += 1){\n        char = chars[i];\n        if (char < 32 || char === 127) {\n            /* control characters */ html += `<span class=\"${style.CLASS_CTRLCHAR}\">${exports.asciiChars[char]}</span>`;\n        } else if (char > 127) {\n            /* non-ASCII */ html += `<span class=\"${style.CLASS_CTRLCHAR}\">U+${exports.charToHex(char)}</span>`;\n        } else {\n            /* printing ASCII, 32 <= char <= 126 */ html += exports.asciiChars[char];\n        }\n    }\n    return html;\n};\n// Translates a JavaScript string to HTML display format.\nexports.stringToAsciiHtml = function(str) {\n    const chars = converter.decode(\"STRING\", str);\n    return this.charsToAsciiHtml(chars);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2FwZy1qc0A0LjIuMS9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3V0aWxpdGllcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSw2QkFBNkIsR0FDN0I7Ozt1RkFHdUYsR0FDdkYsa0VBQWtFO0FBQ2xFLHFHQUFxRztBQUNyRyx5Q0FBeUM7QUFFekMsTUFBTUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDdEIsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUM7QUFDMUIsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUM7QUFDeEIsTUFBTUcsS0FBS0gsbUJBQU9BLENBQUM7QUFFbkIsTUFBTUksZUFBZTtBQUVyQix3R0FBd0csR0FDeEcsOENBQThDLEdBQzlDLE1BQU1DLFlBQVksU0FBVUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEdBQUc7SUFDN0MsSUFBSUM7SUFDSixJQUFJQyxNQUFNSDtJQUNWLE1BQU1JLE9BQU87SUFDYixNQUFPQSxLQUFNO1FBQ1gsSUFBSUwsVUFBVSxHQUFHO1lBQ2ZJLE1BQU07WUFDTkQsTUFBTTtZQUNOO1FBQ0Y7UUFDQSxJQUFJLE9BQU9DLFFBQVEsVUFBVTtZQUMzQkEsTUFBTTtZQUNORCxNQUFNSDtZQUNOO1FBQ0Y7UUFDQSxJQUFJSSxPQUFPSixRQUFRO1lBQ2pCSSxNQUFNSjtZQUNORyxNQUFNSDtZQUNOO1FBQ0Y7UUFDQSxJQUFJLE9BQU9FLFFBQVEsVUFBVTtZQUMzQkMsTUFBTUg7WUFDTjtRQUNGO1FBQ0FHLE1BQU1DLE1BQU1GO1FBQ1osSUFBSUMsTUFBTUgsUUFBUTtZQUNoQkcsTUFBTUg7WUFDTjtRQUNGO1FBQ0E7SUFDRjtJQUNBLE9BQU87UUFDTEk7UUFDQUQ7SUFDRjtBQUNGO0FBQ0Esd0ZBQXdGO0FBQ3hGLDBDQUEwQztBQUMxQyxrRUFBa0U7QUFDbEVHLGtCQUFrQixHQUFHLFNBQVVFLElBQUksRUFBRUMsUUFBUTtJQUMzQyxJQUFJQztJQUNKLElBQUksT0FBT0YsU0FBUyxV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TzNEO0FBQ1Q7QUFDQSx5REFBeUQ7QUFDekRGLHlCQUF5QixHQUFHLFNBQVVnRixHQUFHO0lBQ3ZDLE1BQU1sRCxRQUFRekMsVUFBVWlELE1BQU0sQ0FBQyxVQUFVMEM7SUFDekMsT0FBTyxJQUFJLENBQUNILGdCQUFnQixDQUFDL0M7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG9rZW5zdHJlYW0vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hcGctanNANC4yLjEvbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi91dGlsaXRpZXMuanM/ZmIwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzICovXG4vKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBleHBvcnRzIGEgdmFyaWV0eSBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IHN1cHBvcnRcbi8vIFtgYXBnYF0oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qczIpLCBbYGFwZy1saWJgXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzMi1saWIpXG4vLyBhbmQgdGhlIGdlbmVyYXRlZCBwYXJzZXIgYXBwbGljYXRpb25zLlxuXG5jb25zdCBzdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGUnKTtcbmNvbnN0IGNvbnZlcnRlciA9IHJlcXVpcmUoJy4uL2FwZy1jb252LWFwaS9jb252ZXJ0ZXInKTtcbmNvbnN0IGVtaXRDc3MgPSByZXF1aXJlKCcuL2VtaXRjc3MnKTtcbmNvbnN0IGlkID0gcmVxdWlyZSgnLi9pZGVudGlmaWVycycpO1xuXG5jb25zdCB0aGlzRmlsZU5hbWUgPSAndXRpbGl0aWVzLmpzOiAnO1xuXG4vKiB0cmFuc2xhdGUgKGltcGxpZWQpIHBocmFzZSBiZWdpbm5pbmcgY2hhcmFjdGVyIGFuZCBsZW5ndGggdG8gYWN0dWFsIGZpcnN0IGFuZCBsYXN0IGNoYXJhY3RlciBpbmRleGVzICovXG4vKiB1c2VkIGJ5IG11bHRpcGxlIHBocmFzZSBoYW5kbGluZyBmdW5jdGlvbnMgKi9cbmNvbnN0IGdldEJvdW5kcyA9IGZ1bmN0aW9uIChsZW5ndGgsIGJlZ0FyZywgbGVuKSB7XG4gIGxldCBlbmQ7XG4gIGxldCBiZWcgPSBiZWdBcmc7XG4gIGNvbnN0IFRSVUUgPSB0cnVlO1xuICB3aGlsZSAoVFJVRSkge1xuICAgIGlmIChsZW5ndGggPD0gMCkge1xuICAgICAgYmVnID0gMDtcbiAgICAgIGVuZCA9IDA7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiZWcgIT09ICdudW1iZXInKSB7XG4gICAgICBiZWcgPSAwO1xuICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChiZWcgPj0gbGVuZ3RoKSB7XG4gICAgICBiZWcgPSBsZW5ndGg7XG4gICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsZW4gIT09ICdudW1iZXInKSB7XG4gICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZW5kID0gYmVnICsgbGVuO1xuICAgIGlmIChlbmQgPiBsZW5ndGgpIHtcbiAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4ge1xuICAgIGJlZyxcbiAgICBlbmQsXG4gIH07XG59O1xuLy8gR2VuZXJhdGVzIGEgY29tcGxldGUsIG1pbmltYWwgSFRNTDUgcGFnZSwgaW5zZXJ0aW5nIHRoZSB1c2VyJ3MgSFRNTCB0ZXh0IG9uIHRoZSBwYWdlLlxuLy8gLSAqaHRtbCogLSB0aGUgcGFnZSB0ZXh0IGluIEhUTUwgZm9ybWF0XG4vLyAtICp0aXRsZSogLSB0aGUgSFRNTCBwYWdlIGA8dGl0bGU+YCAtIGRlZmF1bHRzIHRvIGBodG1sVG9QYWdlYC5cbmV4cG9ydHMuaHRtbFRvUGFnZSA9IGZ1bmN0aW9uIChodG1sLCB0aXRsZUFyZykge1xuICBsZXQgdGl0bGU7XG4gIGlmICh0eXBlb2YgaHRtbCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWh0bWxUb1BhZ2U6IGlucHV0IEhUTUwgaXMgbm90IGEgc3RyaW5nYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0aXRsZUFyZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aXRsZSA9ICdodG1sVG9QYWdlJztcbiAgfSBlbHNlIHtcbiAgICB0aXRsZSA9IHRpdGxlQXJnO1xuICB9XG4gIGxldCBwYWdlID0gJyc7XG4gIHBhZ2UgKz0gJzwhRE9DVFlQRSBodG1sPlxcbic7XG4gIHBhZ2UgKz0gJzxodG1sIGxhbmc9XCJlblwiPlxcbic7XG4gIHBhZ2UgKz0gJzxoZWFkPlxcbic7XG4gIHBhZ2UgKz0gJzxtZXRhIGNoYXJzZXQ9XCJ1dGYtOFwiPlxcbic7XG4gIHBhZ2UgKz0gYDx0aXRsZT4ke3RpdGxlfTwvdGl0bGU+XFxuYDtcbiAgcGFnZSArPSAnPHN0eWxlPlxcbic7XG4gIHBhZ2UgKz0gZW1pdENzcygpO1xuICBwYWdlICs9ICc8L3N0eWxlPlxcbic7XG4gIHBhZ2UgKz0gJzwvaGVhZD5cXG48Ym9keT5cXG4nO1xuICBwYWdlICs9IGA8cD4ke25ldyBEYXRlKCl9PC9wPlxcbmA7XG4gIHBhZ2UgKz0gaHRtbDtcbiAgcGFnZSArPSAnPC9ib2R5PlxcbjwvaHRtbD5cXG4nO1xuICByZXR1cm4gcGFnZTtcbn07XG4vLyBGb3JtYXRzIHRoZSByZXR1cm5lZCBvYmplY3QgZnJvbSBgcGFyc2VyLnBhcnNlKClgXG4vLyBpbnRvIGFuIEhUTUwgdGFibGUuXG4vLyBgYGBcbi8vIHJldHVybiB7XG4vLyAgIHN1Y2Nlc3MgOiBzeXNEYXRhLnN1Y2Nlc3MsXG4vLyAgIHN0YXRlIDogc3lzRGF0YS5zdGF0ZSxcbi8vICAgbGVuZ3RoIDogY2hhcnNMZW5ndGgsXG4vLyAgIG1hdGNoZWQgOiBzeXNEYXRhLnBocmFzZUxlbmd0aCxcbi8vICAgbWF4TWF0Y2hlZCA6IG1heE1hdGNoZWQsXG4vLyAgIG1heFRyZWVEZXB0aCA6IG1heFRyZWVEZXB0aCxcbi8vICAgbm9kZUhpdHMgOiBub2RlSGl0cyxcbi8vICAgaW5wdXRMZW5ndGggOiBjaGFycy5sZW5ndGgsXG4vLyAgIHN1YkJlZ2luIDogY2hhcnNCZWdpbixcbi8vICAgc3ViRW5kIDogY2hhcnNFbmQsXG4vLyAgIHN1Ykxlbmd0aCA6IGNoYXJzTGVuZ3RoXG4vLyB9O1xuLy8gYGBgXG5leHBvcnRzLnBhcnNlclJlc3VsdFRvSHRtbCA9IGZ1bmN0aW9uIChyZXN1bHQsIGNhcHRpb24pIHtcbiAgbGV0IGNhcCA9IG51bGw7XG4gIGlmICh0eXBlb2YgY2FwdGlvbiA9PT0gJ3N0cmluZycgJiYgY2FwdGlvbiAhPT0gJycpIHtcbiAgICBjYXAgPSBjYXB0aW9uO1xuICB9XG4gIGxldCBzdWNjZXNzO1xuICBsZXQgc3RhdGU7XG4gIGlmIChyZXN1bHQuc3VjY2VzcyA9PT0gdHJ1ZSkge1xuICAgIHN1Y2Nlc3MgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPnRydWU8L3NwYW4+YDtcbiAgfSBlbHNlIHtcbiAgICBzdWNjZXNzID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPmZhbHNlPC9zcGFuPmA7XG4gIH1cbiAgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gaWQuRU1QVFkpIHtcbiAgICBzdGF0ZSA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+RU1QVFk8L3NwYW4+YDtcbiAgfSBlbHNlIGlmIChyZXN1bHQuc3RhdGUgPT09IGlkLk1BVENIKSB7XG4gICAgc3RhdGUgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPk1BVENIPC9zcGFuPmA7XG4gIH0gZWxzZSBpZiAocmVzdWx0LnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgc3RhdGUgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+Tk9NQVRDSDwvc3Bhbj5gO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPnVucmVjb2duaXplZDwvc3Bhbj5gO1xuICB9XG4gIGxldCBodG1sID0gJyc7XG4gIGh0bWwgKz0gYDx0YWJsZSBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfU1RBVEV9XCI+XFxuYDtcbiAgaWYgKGNhcCkge1xuICAgIGh0bWwgKz0gYDxjYXB0aW9uPiR7Y2FwfTwvY2FwdGlvbj5cXG5gO1xuICB9XG4gIGh0bWwgKz0gJzx0cj48dGg+c3RhdGUgaXRlbTwvdGg+PHRoPnZhbHVlPC90aD48dGg+ZGVzY3JpcHRpb248L3RoPjwvdHI+XFxuJztcbiAgaHRtbCArPSBgPHRyPjx0ZD5wYXJzZXIgc3VjY2VzczwvdGQ+PHRkPiR7c3VjY2Vzc308L3RkPlxcbmA7XG4gIGh0bWwgKz0gYDx0ZD48c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+dHJ1ZTwvc3Bhbj4gaWYgdGhlIHBhcnNlIHN1Y2NlZWRlZCxcXG5gO1xuICBodG1sICs9IGAgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+ZmFsc2U8L3NwYW4+IG90aGVyd2lzZWA7XG4gIGh0bWwgKz0gJzxicj48aT5OT1RFOiBmb3Igc3VjY2VzcywgZW50aXJlIHN0cmluZyBtdXN0IGJlIG1hdGNoZWQ8L2k+PC90ZD48L3RyPlxcbic7XG4gIGh0bWwgKz0gYDx0cj48dGQ+cGFyc2VyIHN0YXRlPC90ZD48dGQ+JHtzdGF0ZX08L3RkPlxcbmA7XG4gIGh0bWwgKz0gYDx0ZD48c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfRU1QVFl9XCI+RU1QVFk8L3NwYW4+LCBgO1xuICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+TUFUQ0g8L3NwYW4+IG9yIFxcbmA7XG4gIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPk5PTUFUQ0g8L3NwYW4+PC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+c3RyaW5nIGxlbmd0aDwvdGQ+PHRkPiR7cmVzdWx0Lmxlbmd0aH08L3RkPjx0ZD5sZW5ndGggb2YgdGhlIGlucHV0IChzdWIpc3RyaW5nPC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+bWF0Y2hlZCBsZW5ndGg8L3RkPjx0ZD4ke3Jlc3VsdC5tYXRjaGVkfTwvdGQ+PHRkPm51bWJlciBvZiBpbnB1dCBzdHJpbmcgY2hhcmFjdGVycyBtYXRjaGVkPC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+bWF4IG1hdGNoZWQ8L3RkPjx0ZD4ke3Jlc3VsdC5tYXhNYXRjaGVkfTwvdGQ+PHRkPm1heGltdW0gbnVtYmVyIG9mIGlucHV0IHN0cmluZyBjaGFyYWN0ZXJzIG1hdGNoZWQ8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5tYXggdHJlZSBkZXB0aDwvdGQ+PHRkPiR7cmVzdWx0Lm1heFRyZWVEZXB0aH08L3RkPjx0ZD5tYXhpbXVtIGRlcHRoIG9mIHRoZSBwYXJzZSB0cmVlIHJlYWNoZWQ8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5ub2RlIGhpdHM8L3RkPjx0ZD4ke3Jlc3VsdC5ub2RlSGl0c308L3RkPjx0ZD5udW1iZXIgb2YgcGFyc2UgdHJlZSBub2RlIGhpdHMgKG9wY29kZSBmdW5jdGlvbiBjYWxscyk8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5pbnB1dCBsZW5ndGg8L3RkPjx0ZD4ke3Jlc3VsdC5pbnB1dExlbmd0aH08L3RkPjx0ZD5sZW5ndGggb2YgZnVsbCBpbnB1dCBzdHJpbmc8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5zdWItc3RyaW5nIGJlZ2luPC90ZD48dGQ+JHtyZXN1bHQuc3ViQmVnaW59PC90ZD48dGQ+c3ViLXN0cmluZyBmaXJzdCBjaGFyYWN0ZXIgaW5kZXg8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5zdWItc3RyaW5nIGVuZDwvdGQ+PHRkPiR7cmVzdWx0LnN1YkVuZH08L3RkPjx0ZD5zdWItc3RyaW5nIGVuZC1vZi1zdHJpbmcgaW5kZXg8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSBgPHRyPjx0ZD5zdWItc3RyaW5nIGxlbmd0aDwvdGQ+PHRkPiR7cmVzdWx0LnN1Ykxlbmd0aH08L3RkPjx0ZD5zdWItc3RyaW5nIGxlbmd0aDwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9ICc8L3RhYmxlPlxcbic7XG4gIHJldHVybiBodG1sO1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdWItYXJyYXkgb2YgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMgaW50byBhIHN0cmluZy5cbi8vIFZlcnkgdXNlZnVsIGluIGNhbGxiYWNrIGZ1bmN0aW9ucyB0byB0cmFuc2xhdGUgdGhlIG1hdGNoZWQgcGhyYXNlcyBpbnRvIHN0cmluZ3MuXG5leHBvcnRzLmNoYXJzVG9TdHJpbmcgPSBmdW5jdGlvbiAoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VMZW5ndGgpIHtcbiAgbGV0IGJlZztcbiAgbGV0IGVuZDtcbiAgaWYgKHR5cGVvZiBwaHJhc2VJbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAocGhyYXNlSW5kZXggPj0gY2hhcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGJlZyA9IHBocmFzZUluZGV4IDwgMCA/IDAgOiBwaHJhc2VJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBiZWcgPSAwO1xuICB9XG4gIGlmICh0eXBlb2YgcGhyYXNlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIGlmIChwaHJhc2VMZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBlbmQgPSBwaHJhc2VMZW5ndGggPiBjaGFycy5sZW5ndGggLSBiZWcgPyBjaGFycy5sZW5ndGggOiBiZWcgKyBwaHJhc2VMZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgZW5kID0gY2hhcnMubGVuZ3RoO1xuICB9XG4gIGlmIChiZWcgPCBlbmQpIHtcbiAgICByZXR1cm4gY29udmVydGVyLmVuY29kZSgnVVRGMTZMRScsIGNoYXJzLnNsaWNlKGJlZywgZW5kKSkudG9TdHJpbmcoJ3V0ZjE2bGUnKTtcbiAgfVxuICByZXR1cm4gJyc7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGludGVnZXIgY2hhcmFjdGVyIGNvZGVzLlxuZXhwb3J0cy5zdHJpbmdUb0NoYXJzID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gY29udmVydGVyLmRlY29kZSgnU1RSSU5HJywgc3RyaW5nKTtcbn07XG4vLyBUcmFuc2xhdGVzIGFuIG9wY29kZSBpZGVudGlmaWVyIGludG8gYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcuXG5leHBvcnRzLm9wY29kZVRvU3RyaW5nID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgbGV0IHJldCA9ICd1bmtub3duJztcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBpZC5BTFQ6XG4gICAgICByZXQgPSAnQUxUJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQ0FUOlxuICAgICAgcmV0ID0gJ0NBVCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLlJOTTpcbiAgICAgIHJldCA9ICdSTk0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5VRFQ6XG4gICAgICByZXQgPSAnVURUJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQU5EOlxuICAgICAgcmV0ID0gJ0FORCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLk5PVDpcbiAgICAgIHJldCA9ICdOT1QnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5SRVA6XG4gICAgICByZXQgPSAnUkVQJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuVFJHOlxuICAgICAgcmV0ID0gJ1RSRyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLlRCUzpcbiAgICAgIHJldCA9ICdUQlMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5UTFM6XG4gICAgICByZXQgPSAnVExTJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQktSOlxuICAgICAgcmV0ID0gJ0JLUic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLkJLQTpcbiAgICAgIHJldCA9ICdCS0EnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5CS046XG4gICAgICByZXQgPSAnQktOJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQUJHOlxuICAgICAgcmV0ID0gJ0FCRyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLkFFTjpcbiAgICAgIHJldCA9ICdBRU4nO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIG9wY29kZScpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gVHJhbnNsYXRlcyBhbiBzdGF0ZSBpZGVudGlmaWVyIGludG8gYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcuXG5leHBvcnRzLnN0YXRlVG9TdHJpbmcgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgbGV0IHJldCA9ICd1bmtub3duJztcbiAgc3dpdGNoIChzdGF0ZSkge1xuICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgcmV0ID0gJ0FDVElWRSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgcmV0ID0gJ01BVENIJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICByZXQgPSAnRU1QVFknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgcmV0ID0gJ05PTUFUQ0gnO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHN0YXRlJyk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBBcnJheSB3aGljaCB0cmFuc2xhdGVzIGFsbCAxMjgsIDctYml0IEFTQ0lJIGNoYXJhY3RlciBjb2RlcyB0byB0aGVpciByZXNwZWN0aXZlIEhUTUwgZm9ybWF0LlxuZXhwb3J0cy5hc2NpaUNoYXJzID0gW1xuICAnTlVMJyxcbiAgJ1NPSCcsXG4gICdTVFgnLFxuICAnRVRYJyxcbiAgJ0VPVCcsXG4gICdFTlEnLFxuICAnQUNLJyxcbiAgJ0JFTCcsXG4gICdCUycsXG4gICdUQUInLFxuICAnTEYnLFxuICAnVlQnLFxuICAnRkYnLFxuICAnQ1InLFxuICAnU08nLFxuICAnU0knLFxuICAnRExFJyxcbiAgJ0RDMScsXG4gICdEQzInLFxuICAnREMzJyxcbiAgJ0RDNCcsXG4gICdOQUsnLFxuICAnU1lOJyxcbiAgJ0VUQicsXG4gICdDQU4nLFxuICAnRU0nLFxuICAnU1VCJyxcbiAgJ0VTQycsXG4gICdGUycsXG4gICdHUycsXG4gICdSUycsXG4gICdVUycsXG4gICcmbmJzcDsnLFxuICAnIScsXG4gICcmIzM0OycsXG4gICcjJyxcbiAgJyQnLFxuICAnJScsXG4gICcmIzM4OycsXG4gICcmIzM5OycsXG4gICcoJyxcbiAgJyknLFxuICAnKicsXG4gICcrJyxcbiAgJywnLFxuICAnLScsXG4gICcuJyxcbiAgJy8nLFxuICAnMCcsXG4gICcxJyxcbiAgJzInLFxuICAnMycsXG4gICc0JyxcbiAgJzUnLFxuICAnNicsXG4gICc3JyxcbiAgJzgnLFxuICAnOScsXG4gICc6JyxcbiAgJzsnLFxuICAnJiM2MDsnLFxuICAnPScsXG4gICcmIzYyOycsXG4gICc/JyxcbiAgJ0AnLFxuICAnQScsXG4gICdCJyxcbiAgJ0MnLFxuICAnRCcsXG4gICdFJyxcbiAgJ0YnLFxuICAnRycsXG4gICdIJyxcbiAgJ0knLFxuICAnSicsXG4gICdLJyxcbiAgJ0wnLFxuICAnTScsXG4gICdOJyxcbiAgJ08nLFxuICAnUCcsXG4gICdRJyxcbiAgJ1InLFxuICAnUycsXG4gICdUJyxcbiAgJ1UnLFxuICAnVicsXG4gICdXJyxcbiAgJ1gnLFxuICAnWScsXG4gICdaJyxcbiAgJ1snLFxuICAnJiM5MjsnLFxuICAnXScsXG4gICdeJyxcbiAgJ18nLFxuICAnYCcsXG4gICdhJyxcbiAgJ2InLFxuICAnYycsXG4gICdkJyxcbiAgJ2UnLFxuICAnZicsXG4gICdnJyxcbiAgJ2gnLFxuICAnaScsXG4gICdqJyxcbiAgJ2snLFxuICAnbCcsXG4gICdtJyxcbiAgJ24nLFxuICAnbycsXG4gICdwJyxcbiAgJ3EnLFxuICAncicsXG4gICdzJyxcbiAgJ3QnLFxuICAndScsXG4gICd2JyxcbiAgJ3cnLFxuICAneCcsXG4gICd5JyxcbiAgJ3onLFxuICAneycsXG4gICd8JyxcbiAgJ30nLFxuICAnficsXG4gICdERUwnLFxuXTtcbi8vIFRyYW5zbGF0ZXMgYSBzaW5nbGUgY2hhcmFjdGVyIHRvIGhleGFkZWNpbWFsIHdpdGggbGVhZGluZyB6ZXJvcyBmb3IgMiwgNCwgb3IgOCBkaWdpdCBkaXNwbGF5LlxuZXhwb3J0cy5jaGFyVG9IZXggPSBmdW5jdGlvbiAoY2hhcikge1xuICBsZXQgY2ggPSBjaGFyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICBzd2l0Y2ggKGNoLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICBjYXNlIDM6XG4gICAgY2FzZSA3OlxuICAgICAgY2ggPSBgMCR7Y2h9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICBjYXNlIDY6XG4gICAgICBjaCA9IGAwMCR7Y2h9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIGNoID0gYDAwMCR7Y2h9YDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBvcHRpb24nKTtcbiAgfVxuICByZXR1cm4gY2g7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgdG8gZGVjaW1hbCBkaXNwbGF5IGZvcm1hdC5cbmV4cG9ydHMuY2hhcnNUb0RlYyA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgbGV0IHJldCA9ICcnO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvRGVjOiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBpZiAoYm91bmRzLmVuZCA+IGJvdW5kcy5iZWcpIHtcbiAgICByZXQgKz0gY2hhcnNbYm91bmRzLmJlZ107XG4gICAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWcgKyAxOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICByZXQgKz0gYCwke2NoYXJzW2ldfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgdG8gaGV4YWRlY2ltYWwgZGlzcGxheSBmb3JtYXQuXG5leHBvcnRzLmNoYXJzVG9IZXggPSBmdW5jdGlvbiAoY2hhcnMsIGJlZywgbGVuKSB7XG4gIGxldCByZXQgPSAnJztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb0hleDogaW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhjaGFycy5sZW5ndGgsIGJlZywgbGVuKTtcbiAgaWYgKGJvdW5kcy5lbmQgPiBib3VuZHMuYmVnKSB7XG4gICAgcmV0ICs9IGBcXFxceCR7ZXhwb3J0cy5jaGFyVG9IZXgoY2hhcnNbYm91bmRzLmJlZ10pfWA7XG4gICAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWcgKyAxOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICByZXQgKz0gYCxcXFxceCR7ZXhwb3J0cy5jaGFyVG9IZXgoY2hhcnNbaV0pfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy5jaGFyc1RvSHRtbEVudGl0aWVzID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBsZXQgcmV0ID0gJyc7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNoYXJzVG9IZXg6IGlucHV0IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgfVxuICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMoY2hhcnMubGVuZ3RoLCBiZWcsIGxlbik7XG4gIGlmIChib3VuZHMuZW5kID4gYm91bmRzLmJlZykge1xuICAgIGZvciAobGV0IGkgPSBib3VuZHMuYmVnOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICByZXQgKz0gYCYjeCR7Y2hhcnNbaV0udG9TdHJpbmcoMTYpfTtgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdWItYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzIHRvIFVuaWNvZGUgZGlzcGxheSBmb3JtYXQuXG5mdW5jdGlvbiBpc1VuaWNvZGUoY2hhcikge1xuICBpZiAoY2hhciA+PSAweGQ4MDAgJiYgY2hhciA8PSAweGRmZmYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNoYXIgPiAweDEwZmZmZikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY2hhcnNUb1VuaWNvZGUgPSBmdW5jdGlvbiAoY2hhcnMsIGJlZywgbGVuKSB7XG4gIGxldCByZXQgPSAnJztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb1VuaWNvZGU6IGlucHV0IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgfVxuICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMoY2hhcnMubGVuZ3RoLCBiZWcsIGxlbik7XG4gIGlmIChib3VuZHMuZW5kID4gYm91bmRzLmJlZykge1xuICAgIGZvciAobGV0IGkgPSBib3VuZHMuYmVnOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICBpZiAoaXNVbmljb2RlKGNoYXJzW2ldKSkge1xuICAgICAgICByZXQgKz0gYCYjJHtjaGFyc1tpXX07YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCArPSBgIFUrJHtleHBvcnRzLmNoYXJUb0hleChjaGFyc1tpXSl9YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyB0byBKYXZhU2NyaXB0IFVuaWNvZGUgZGlzcGxheSBmb3JtYXQgKGBcXHVYWFhYYCkuXG5leHBvcnRzLmNoYXJzVG9Kc1VuaWNvZGUgPSBmdW5jdGlvbiAoY2hhcnMsIGJlZywgbGVuKSB7XG4gIGxldCByZXQgPSAnJztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb0pzVW5pY29kZTogaW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhjaGFycy5sZW5ndGgsIGJlZywgbGVuKTtcbiAgaWYgKGJvdW5kcy5lbmQgPiBib3VuZHMuYmVnKSB7XG4gICAgcmV0ICs9IGBcXFxcdSR7ZXhwb3J0cy5jaGFyVG9IZXgoY2hhcnNbYm91bmRzLmJlZ10pfWA7XG4gICAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWcgKyAxOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgICByZXQgKz0gYCxcXFxcdSR7ZXhwb3J0cy5jaGFyVG9IZXgoY2hhcnNbaV0pfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgdG8gcHJpbnRpbmcgQVNDSUkgY2hhcmFjdGVyIGRpc3BsYXkgZm9ybWF0LlxuZXhwb3J0cy5jaGFyc1RvQXNjaWkgPSBmdW5jdGlvbiAoY2hhcnMsIGJlZywgbGVuKSB7XG4gIGxldCByZXQgPSAnJztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb0FzY2lpOiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBmb3IgKGxldCBpID0gYm91bmRzLmJlZzsgaSA8IGJvdW5kcy5lbmQ7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXIgPSBjaGFyc1tpXTtcbiAgICBpZiAoY2hhciA+PSAzMiAmJiBjaGFyIDw9IDEyNikge1xuICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCArPSBgXFxcXHgke2V4cG9ydHMuY2hhclRvSGV4KGNoYXIpfWA7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgdG8gSFRNTCBkaXNwbGF5IGZvcm1hdC5cbmV4cG9ydHMuY2hhcnNUb0FzY2lpSHRtbCA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb0FzY2lpSHRtbDogaW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICB9XG4gIGxldCBodG1sID0gJyc7XG4gIGxldCBjaGFyO1xuICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMoY2hhcnMubGVuZ3RoLCBiZWcsIGxlbik7XG4gIGZvciAobGV0IGkgPSBib3VuZHMuYmVnOyBpIDwgYm91bmRzLmVuZDsgaSArPSAxKSB7XG4gICAgY2hhciA9IGNoYXJzW2ldO1xuICAgIGlmIChjaGFyIDwgMzIgfHwgY2hhciA9PT0gMTI3KSB7XG4gICAgICAvKiBjb250cm9sIGNoYXJhY3RlcnMgKi9cbiAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19DVFJMQ0hBUn1cIj4ke2V4cG9ydHMuYXNjaWlDaGFyc1tjaGFyXX08L3NwYW4+YDtcbiAgICB9IGVsc2UgaWYgKGNoYXIgPiAxMjcpIHtcbiAgICAgIC8qIG5vbi1BU0NJSSAqL1xuICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0NUUkxDSEFSfVwiPlUrJHtleHBvcnRzLmNoYXJUb0hleChjaGFyKX08L3NwYW4+YDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogcHJpbnRpbmcgQVNDSUksIDMyIDw9IGNoYXIgPD0gMTI2ICovXG4gICAgICBodG1sICs9IGV4cG9ydHMuYXNjaWlDaGFyc1tjaGFyXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGh0bWw7XG59O1xuLy8gVHJhbnNsYXRlcyBhIEphdmFTY3JpcHQgc3RyaW5nIHRvIEhUTUwgZGlzcGxheSBmb3JtYXQuXG5leHBvcnRzLnN0cmluZ1RvQXNjaWlIdG1sID0gZnVuY3Rpb24gKHN0cikge1xuICBjb25zdCBjaGFycyA9IGNvbnZlcnRlci5kZWNvZGUoJ1NUUklORycsIHN0cik7XG4gIHJldHVybiB0aGlzLmNoYXJzVG9Bc2NpaUh0bWwoY2hhcnMpO1xufTtcbiJdLCJuYW1lcyI6WyJzdHlsZSIsInJlcXVpcmUiLCJjb252ZXJ0ZXIiLCJlbWl0Q3NzIiwiaWQiLCJ0aGlzRmlsZU5hbWUiLCJnZXRCb3VuZHMiLCJsZW5ndGgiLCJiZWdBcmciLCJsZW4iLCJlbmQiLCJiZWciLCJUUlVFIiwiZXhwb3J0cyIsImh0bWxUb1BhZ2UiLCJodG1sIiwidGl0bGVBcmciLCJ0aXRsZSIsIkVycm9yIiwicGFnZSIsIkRhdGUiLCJwYXJzZXJSZXN1bHRUb0h0bWwiLCJyZXN1bHQiLCJjYXB0aW9uIiwiY2FwIiwic3VjY2VzcyIsInN0YXRlIiwiQ0xBU1NfTUFUQ0giLCJDTEFTU19OT01BVENIIiwiRU1QVFkiLCJDTEFTU19FTVBUWSIsIk1BVENIIiwiTk9NQVRDSCIsIkNMQVNTX1NUQVRFIiwibWF0Y2hlZCIsIm1heE1hdGNoZWQiLCJtYXhUcmVlRGVwdGgiLCJub2RlSGl0cyIsImlucHV0TGVuZ3RoIiwic3ViQmVnaW4iLCJzdWJFbmQiLCJzdWJMZW5ndGgiLCJjaGFyc1RvU3RyaW5nIiwiY2hhcnMiLCJwaHJhc2VJbmRleCIsInBocmFzZUxlbmd0aCIsImVuY29kZSIsInNsaWNlIiwidG9TdHJpbmciLCJzdHJpbmdUb0NoYXJzIiwic3RyaW5nIiwiZGVjb2RlIiwib3Bjb2RlVG9TdHJpbmciLCJ0eXBlIiwicmV0IiwiQUxUIiwiQ0FUIiwiUk5NIiwiVURUIiwiQU5EIiwiTk9UIiwiUkVQIiwiVFJHIiwiVEJTIiwiVExTIiwiQktSIiwiQktBIiwiQktOIiwiQUJHIiwiQUVOIiwic3RhdGVUb1N0cmluZyIsIkFDVElWRSIsImFzY2lpQ2hhcnMiLCJjaGFyVG9IZXgiLCJjaGFyIiwiY2giLCJ0b1VwcGVyQ2FzZSIsImNoYXJzVG9EZWMiLCJBcnJheSIsImlzQXJyYXkiLCJib3VuZHMiLCJpIiwiY2hhcnNUb0hleCIsImNoYXJzVG9IdG1sRW50aXRpZXMiLCJpc1VuaWNvZGUiLCJjaGFyc1RvVW5pY29kZSIsImNoYXJzVG9Kc1VuaWNvZGUiLCJjaGFyc1RvQXNjaWkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjaGFyc1RvQXNjaWlIdG1sIiwiQ0xBU1NfQ1RSTENIQVIiLCJzdHJpbmdUb0FzY2lpSHRtbCIsInN0ciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/apg-js@4.2.1/node_modules/apg-js/src/apg-lib/utilities.js\n");

/***/ })

};
;